{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "Android Guide",
  "home_page_url": "https://zengkaiqiang562.github.io/",
  "feed_url": "https://zengkaiqiang562.github.io/feed.json",
  "description": "Android 学习 && 面试指南",
  "items": [
    {
      "title": "面试问题",
      "url": "https://zengkaiqiang562.github.io/zkq/hnap/interview_faq.html",
      "id": "https://zengkaiqiang562.github.io/zkq/hnap/interview_faq.html",
      "content_html": "<h2 id=\"_1-ui-篇\" tabindex=\"-1\"> 1. <code>UI</code> 篇</h2>\n<h3 id=\"_1-1-中级\" tabindex=\"-1\"> 1.1 中级</h3>\n<h4 id=\"_1-1-1-简述-ui-绘制流程\" tabindex=\"-1\"> 1.1.1 简述 <code>UI</code> 绘制流程？</h4>\n<h4 id=\"_1-1-2-简述事件传递机制\" tabindex=\"-1\"> 1.1.2 简述事件传递机制？</h4>\n<h4 id=\"_1-1-2-view-补间动画有哪些-什么是插值器\" tabindex=\"-1\"> 1.1.2 <code>View</code> 补间动画有哪些？什么是插值器？</h4>\n<h4 id=\"_1-1-3-lottie-动画的基本使用-有哪些优缺点\" tabindex=\"-1\"> 1.1.3 <code>Lottie</code> 动画的基本使用？有哪些优缺点？</h4>\n<p><strong>缺点：</strong> 客户端不可以实现 <code>3D</code> 效果（如绕 <code>Y</code> 轴旋转），用什么代替？（<code>SVGA</code> 动画）</p>\n<h4 id=\"_1-1-4-简述-constraintlayout-约束布局的优点\" tabindex=\"-1\"> 1.1.4 简述 <code>ConstraintLayout</code> 约束布局的优点？</h4>\n<ol>\n<li>\n<p>减少布局层级；</p>\n</li>\n<li>\n<p>实现屏幕适配。</p>\n</li>\n</ol>\n<h4 id=\"_1-1-5-简述-recyclerview-的基本使用流程\" tabindex=\"-1\"> 1.1.5 简述 <code>RecyclerView</code> 的基本使用流程？</h4>\n<h4 id=\"_1-1-6-activity-的启动模式有哪些-简述下各启动模式的特点。\" tabindex=\"-1\"> 1.1.6 <code>Activity</code> 的启动模式有哪些？简述下各启动模式的特点。</h4>\n<h3 id=\"_1-2-高级\" tabindex=\"-1\"> 1.2 高级</h3>\n<h4 id=\"_1-2-1-滑动冲突是如何产生的-怎样解决\" tabindex=\"-1\"> 1.2.1 滑动冲突是如何产生的？怎样解决？</h4>\n<h4 id=\"_1-2-2-recyclerview-回收复用机制中用到了哪些回收池-它们的作用分别是什么\" tabindex=\"-1\"> 1.2.2 <code>RecyclerView</code> 回收复用机制中用到了哪些回收池，它们的作用分别是什么？</h4>\n<h2 id=\"_2-线程篇\" tabindex=\"-1\"> 2. 线程篇</h2>\n<h3 id=\"_2-1-中级\" tabindex=\"-1\"> 2.1 中级</h3>\n<h4 id=\"_2-1-1-简述-handler-的基本工作机制\" tabindex=\"-1\"> 2.1.1 简述 <code>Handler</code> 的基本工作机制</h4>\n<h4 id=\"_2-1-2-handlderthread-的作用是什么\" tabindex=\"-1\"> 2.1.2 <code>HandlderThread</code> 的作用是什么？</h4>\n<h4 id=\"_2-1-3-new-出来的-thread-线程如何正确停止\" tabindex=\"-1\"> 2.1.3 <code>new</code> 出来的 <code>Thread</code> 线程如何正确停止？</h4>\n<h4 id=\"_2-1-4-一个线程有哪几种状态\" tabindex=\"-1\"> 2.1.4 一个线程有哪几种状态？</h4>\n<h4 id=\"_2-1-5-android-提供的线程池有哪四类\" tabindex=\"-1\"> 2.1.5 <code>Android</code> 提供的线程池有哪四类？</h4>\n<h3 id=\"_2-2-高级\" tabindex=\"-1\"> 2.2 高级</h3>\n<h4 id=\"_2-2-1-一个线程的消息机制内可以有几个-handler-对象、几个-looper-对象\" tabindex=\"-1\"> 2.2.1 一个线程的消息机制内可以有几个 <code>Handler</code> 对象、几个 <code>Looper</code> 对象？</h4>\n<h4 id=\"_2-2-2-handler-对象是否可以持有-activity-对象的强引用\" tabindex=\"-1\"> 2.2.2 <code>Handler</code> 对象是否可以持有 <code>Activity</code> 对象的强引用？</h4>\n<h4 id=\"_2-2-3-什么是死锁-死锁是如何产生的\" tabindex=\"-1\"> 2.2.3 什么是死锁？死锁是如何产生的？</h4>\n<h4 id=\"_2-2-4-线程池-threadpoolexecutor-是如何分配线程的\" tabindex=\"-1\"> 2.2.4 线程池 <code>ThreadPoolExecutor</code> 是如何分配线程的？</h4>\n<h2 id=\"_3-性能篇\" tabindex=\"-1\"> 3. 性能篇</h2>\n<h3 id=\"_3-1-中级\" tabindex=\"-1\"> 3.1 中级</h3>\n<h4 id=\"_3-1-1-什么是内存泄漏-如何产生的-怎样避免\" tabindex=\"-1\"> 3.1.1 什么是内存泄漏？如何产生的？怎样避免？</h4>\n<h4 id=\"_3-1-2-什么是内存抖动-如何产生的-怎样避免\" tabindex=\"-1\"> 3.1.2 什么是内存抖动？如何产生的？怎样避免？</h4>\n<h4 id=\"_3-1-3-什么是-anr-如何产生的-怎样避免\" tabindex=\"-1\"> 3.1.3 什么是 <code>ANR</code>？如何产生的？怎样避免？</h4>\n<h4 id=\"_3-1-4-app-冷启动时的白屏现象是如何产生的-怎样避免\" tabindex=\"-1\"> 3.1.4 <code>App</code> 冷启动时的白屏现象是如何产生的？怎样避免？</h4>\n<h3 id=\"_3-2-高级\" tabindex=\"-1\"> 3.2 高级</h3>\n<h4 id=\"_3-2-1-简述下垃圾回收机制中的根搜索算法\" tabindex=\"-1\"> 3.2.1 简述下垃圾回收机制中的根搜索算法？</h4>\n<h4 id=\"_3-2-2-可作为-gc-roots-根节点的对象有哪些\" tabindex=\"-1\"> 3.2.2 可作为 <code>GC Roots</code> 根节点的对象有哪些？</h4>\n<h4 id=\"_3-2-3-主线程消息机制中的-looper-死循环为什么不会导致-anr\" tabindex=\"-1\"> 3.2.3 主线程消息机制中的 <code>Looper</code> 死循环为什么不会导致 <code>ANR</code>？</h4>\n<h2 id=\"_4-架构篇\" tabindex=\"-1\"> 4. 架构篇</h2>\n<h3 id=\"_4-1-中级\" tabindex=\"-1\"> 4.1 中级</h3>\n<h4 id=\"_4-1-1-简述下-mvc、mvp、mvvm-三种架构的特点\" tabindex=\"-1\"> 4.1.1 简述下 <code>MVC</code>、<code>MVP</code>、<code>MVVM</code> 三种架构的特点</h4>\n<h4 id=\"_4-1-2-用过哪些设计模式-什么场景下会用到这些设计模式\" tabindex=\"-1\"> 4.1.2 用过哪些设计模式？什么场景下会用到这些设计模式？</h4>\n<h4 id=\"_4-1-3-面向对象编程的基本原则有哪些\" tabindex=\"-1\"> 4.1.3 面向对象编程的基本原则有哪些？</h4>\n<h3 id=\"_4-2-高级\" tabindex=\"-1\"> 4.2 高级</h3>\n<h4 id=\"_4-2-1-单例模式的实现方式有哪些\" tabindex=\"-1\"> 4.2.1 单例模式的实现方式有哪些？</h4>\n<p>饿汉式、懒汉式、双重检查、静态内部类、枚举</p>\n<h4 id=\"_4-2-2-单例模式的双重检查方式中的外层-if-和-内存-if-的作用分别是什么\" tabindex=\"-1\"> 4.2.2 单例模式的双重检查方式中的外层 <code>if</code> 和 内存 <code>if</code> 的作用分别是什么？</h4>\n<h4 id=\"_4-2-3-依赖倒置原则中的-倒置-是什么倒置了\" tabindex=\"-1\"> 4.2.3 依赖倒置原则中的 “倒置” 是什么倒置了？</h4>\n<h2 id=\"_5-开源框架篇\" tabindex=\"-1\"> 5. 开源框架篇</h2>\n<h3 id=\"_5-1-中级\" tabindex=\"-1\"> 5.1 中级</h3>\n<h4 id=\"_5-1-1-okhttp-的请求过程中主要涉及到了哪些类-它们的作用分别是什么\" tabindex=\"-1\"> 5.1.1 <code>OKHttp</code> 的请求过程中主要涉及到了哪些类？它们的作用分别是什么？</h4>\n<h4 id=\"_5-1-2-retrofit-在实例化网络请求接口时用到了哪种设计模式\" tabindex=\"-1\"> 5.1.2 <code>Retrofit</code> 在实例化网络请求接口时用到了哪种设计模式？</h4>\n<h4 id=\"_5-1-3-glide-是如何将加载图片的过程跟-activity-的生命周期绑定的\" tabindex=\"-1\"> 5.1.3 <code>Glide</code> 是如何将加载图片的过程跟 <code>Activity</code> 的生命周期绑定的？</h4>\n<p><code>Glide</code> 内部会在加载图片前，创建一个没有界面的 <code>Fragment</code> 对象并添加到传入的 <code>Activity</code> 对象的 <code>FragmentManager</code> 中。</p>\n<p>通过监听这个 <code>Fragment</code> 对象的生命周期来与 <code>Activity</code> 的生命周期进行绑定</p>\n<h4 id=\"_5-1-4-用过哪些数据库框架-简单介绍其特点-什么是对象关系映射-orm\" tabindex=\"-1\"> 5.1.4 用过哪些数据库框架？简单介绍其特点？什么是对象关系映射（<code>ORM</code>）</h4>\n<h3 id=\"_5-2-高级\" tabindex=\"-1\"> 5.2 高级</h3>\n",
      "date_published": "2023-05-10T15:47:41.000Z",
      "date_modified": "2023-05-10T15:47:41.000Z",
      "authors": [],
      "tags": [
        "HNAP"
      ]
    },
    {
      "title": "Adjust接入",
      "url": "https://zengkaiqiang562.github.io/zkq/hnap/sdk/adjust.html",
      "id": "https://zengkaiqiang562.github.io/zkq/hnap/sdk/adjust.html",
      "content_html": "<h2 id=\"_1-接入步骤\" tabindex=\"-1\"> 1. 接入步骤</h2>\n<blockquote>\n<p>参考：<a href=\"https://help.adjust.com/zh/article/get-started-android-sdk#set-up-environment\" target=\"_blank\" rel=\"noopener noreferrer\">Adjust 开发文档<ExternalLinkIcon/></a></p>\n</blockquote>\n<h3 id=\"step-1-添加依赖包\" tabindex=\"-1\"> Step 1. 添加依赖包</h3>\n<div><pre><code><span>/* 在 Module 的 build.gradle 中添加依赖 */</span>\n\ndependencies <span>{</span>\n    implementation <span>'com.adjust.sdk:adjust-android:4.33.0'</span>\n\n    <span>// Install Referrer 是一种唯一标识符，可用来将应用安装归因至来源</span>\n    implementation <span>'com.android.installreferrer:installreferrer:2.2'</span>\n\n    <span>// Add the following if you are using the Adjust SDK inside web views on your app</span>\n    implementation <span>'com.adjust.sdk:adjust-android-webbridge:4.33.0'</span>\n\n    <span>// 为了让 Adjust SDK 能使用 Google 广告 ID，需要集成 Google Play 服务</span>\n    implementation <span>'com.google.android.gms:play-services-ads-identifier:17.0.1'</span>\n<span>}</span>\n</code></pre></div><h3 id=\"step-2-添加权限\" tabindex=\"-1\"> Step 2. 添加权限</h3>\n<div><pre><code>/* AndroidManifest.xml */\n\n<span><span><span>&lt;</span>uses-permission</span> <span><span>android:</span>name</span><span><span>=</span><span>\"</span>android.permission.INTERNET<span>\"</span></span> <span>/></span></span>\n<span><span><span>&lt;</span>uses-permission</span> <span><span>android:</span>name</span><span><span>=</span><span>\"</span>android.permission.ACCESS_NETWORK_STATE<span>\"</span></span> <span>/></span></span>\n<span><span><span>&lt;</span>uses-permission</span> <span><span>android:</span>name</span><span><span>=</span><span>\"</span>android.permission.ACCESS_WIFI_STATE<span>\"</span></span> <span>/></span></span>\n</code></pre></div><h3 id=\"step-3-设置-proguard-混淆\" tabindex=\"-1\"> Step 3. 设置 <code>Proguard</code> 混淆</h3>\n<div><pre><code>/* proguard-rules.pro */\n\n-keep class com.adjust.sdk.**{ *; }\n-keep class com.google.android.gms.common.ConnectionResult {\n    int SUCCESS;\n}\n-keep class com.google.android.gms.ads.identifier.AdvertisingIdClient {\n    com.google.android.gms.ads.identifier.AdvertisingIdClient$Info getAdvertisingIdInfo(android.content.Context);\n}\n-keep class com.google.android.gms.ads.identifier.AdvertisingIdClient$Info {\n    java.lang.String getId();\n    boolean isLimitAdTrackingEnabled();\n}\n-keep public class com.android.installreferrer.**{ *; }\n</code></pre></div><h3 id=\"step-4-在-application-中进行配置和初始化\" tabindex=\"-1\"> Step 4. 在 <code>Application</code> 中进行配置和初始化</h3>\n<div><pre><code><span>import</span> <span><span>com<span>.</span>adjust<span>.</span>sdk<span>.</span></span><span>Adjust</span></span><span>;</span>\n<span>import</span> <span><span>com<span>.</span>adjust<span>.</span>sdk<span>.</span></span><span>AdjustConfig</span></span><span>;</span>\n\n<span>public</span> <span>class</span> <span>MyApplication</span> <span>extends</span> <span>Application</span> <span>{</span>\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>onCreate</span><span>(</span><span>)</span> <span>{</span>\n        <span>super</span><span>.</span><span>onCreate</span><span>(</span><span>)</span><span>;</span>\n        <span>initAdjust</span><span>(</span><span>this</span><span>)</span><span>;</span>\n        <span>registerActivityLifecycleCallbacks</span><span>(</span><span>new</span> <span>MyLifecycleCallbacks</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>initAdjust</span><span>(</span><span>Application</span> application<span>)</span> <span>{</span>\n        <span>// TODO 正式环境改为实际的 appToken</span>\n        <span>String</span> appToken <span>=</span> <span>\"{YourAppToken}\"</span><span>;</span>\n        <span>/*\n        Debug 时 environment 设置为 AdjustConfig.ENVIRONMENT_SANDBOX 。\n        Release 时 environment 设置为 AdjustConfig.ENVIRONMENT_PRODUCTION。\n         */</span>\n        <span>String</span> environment <span>=</span> <span>BuildConfig</span><span>.</span><span>DEBUG</span> <span>?</span> <span>AdjustConfig</span><span>.</span><span>ENVIRONMENT_SANDBOX</span> <span>:</span> <span>AdjustConfig</span><span>.</span><span>ENVIRONMENT_PRODUCTION</span><span>;</span>\n        <span>AdjustConfig</span> config <span>=</span> <span>new</span> <span>AdjustConfig</span><span>(</span>application<span>,</span> appToken<span>,</span> environment<span>)</span><span>;</span>\n        <span>// LogLevel.SUPRESS 禁用所有日志</span>\n        config<span>.</span><span>setLogLevel</span><span>(</span><span>BuildConfig</span><span>.</span><span>DEBUG</span> <span>?</span> <span>LogLevel</span><span>.</span><span>WARN</span> <span>:</span> <span>LogLevel</span><span>.</span><span>SUPRESS</span><span>)</span><span>;</span>\n        <span>Adjust</span><span>.</span><span>onCreate</span><span>(</span>config<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>// 跟踪 Activity 的生命周期</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>class</span> <span>MyLifecycleCallbacks</span> <span>implements</span> <span>ActivityLifecycleCallbacks</span> <span>{</span>\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onActivityResumed</span><span>(</span><span>Activity</span> activity<span>)</span> <span>{</span>\n            <span>Adjust</span><span>.</span><span>onResume</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onActivityPaused</span><span>(</span><span>Activity</span> activity<span>)</span> <span>{</span>\n            <span>Adjust</span><span>.</span><span>onPause</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>//...</span>\n    <span>}</span>\n<span>}</span>\n</code></pre></div><h2 id=\"_2-事件跟踪-即-埋点\" tabindex=\"-1\"> 2. 事件跟踪（即：埋点）</h2>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>trackEvent</span><span>(</span><span>String</span> event<span>,</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> params<span>,</span> <span>boolean</span> unique<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>unique <span>&amp;&amp;</span> <span>SPUtils</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>.</span><span>getBoolean</span><span>(</span>event<span>)</span><span>)</span> <span>{</span>\n        <span>Log</span><span>.</span><span>e</span><span>(</span><span>TAG</span><span>,</span> <span>\"trackEvent() -->  unique event \"</span> <span>+</span> event <span>+</span> <span>\"  has been REPORT !!!\"</span><span>)</span><span>;</span>\n        <span>return</span><span>;</span> <span>// 去重事件已经上报过，不再上报</span>\n    <span>}</span>\n\n    <span>AdjustEvent</span> adjustEvent <span>=</span> <span>new</span> <span>AdjustEvent</span><span>(</span>event<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>unique<span>)</span> <span>{</span>\n        adjustEvent<span>.</span><span>setOrderId</span><span>(</span>event<span>)</span><span>;</span> <span>// Adjust 内部的去重（最多只能支持10个事件，所以自己再套了层 SP 保证去重）</span>\n    <span>}</span>\n\n    <span>if</span> <span>(</span>params <span>!=</span> <span>null</span> <span>&amp;&amp;</span> <span>!</span>params<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n        <span>for</span> <span>(</span><span>Map<span>.</span>Entry</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> entry <span>:</span> params<span>.</span><span>entrySet</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            adjustEvent<span>.</span><span>addCallbackParameter</span><span>(</span>entry<span>.</span><span>getKey</span><span>(</span><span>)</span><span>,</span> entry<span>.</span><span>getValue</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>Adjust</span><span>.</span><span>trackEvent</span><span>(</span>adjustEvent<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>unique<span>)</span> <span>{</span>\n        <span>SPUtils</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>.</span><span>put</span><span>(</span>event<span>,</span> <span>true</span><span>)</span><span>;</span> <span>// 自己通过 SP 保证去重</span>\n    <span>}</span>\n<span>}</span>\n</code></pre></div><h2 id=\"_3-bi-系统接入\" tabindex=\"-1\"> 3. <code>BI</code> 系统接入</h2>\n<p><code>BI</code> 系统接入就是 <code>Adjust</code> 将客户端上报的信息再转发给 <code>BI</code> 系统。客户端只需关心要上报哪些信息给 <code>Adjust</code> 即可。</p>\n<p>目前，需要上报三类信息：</p>\n<ol>\n<li>\n<p>通过 <code>Adjust</code> 上报归因（上报 <code>FB</code> 安装事件）</p>\n</li>\n<li>\n<p>通过 <code>Adjust</code> 上报广告价值</p>\n</li>\n<li>\n<p>通过 <code>Adjust</code> 上报广告的请求事件、匹配事件、点击事件</p>\n</li>\n</ol>\n<h3 id=\"_3-1-通过-adjust-上报归因-上报-fb-安装事件\" tabindex=\"-1\"> 3.1 通过 <code>Adjust</code> 上报归因（上报 <code>FB</code> 安装事件）</h3>\n<h4 id=\"_3-1-1-产品需提供的信息\" tabindex=\"-1\"> 3.1.1 产品需提供的信息</h4>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>事件名称</strong></th>\n<th style=\"text-align:left\"><strong><code>Adjust</code> 识别码</strong></th>\n<th style=\"text-align:left\"><strong>备注</strong></th>\n<th style=\"text-align:left\"><strong>触发条件</strong></th>\n<th style=\"text-align:left\"><strong>参数</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>cfinstalla</code></td>\n<td style=\"text-align:left\"><code>xm2kgc</code></td>\n<td style=\"text-align:left\"><code>FB</code> <code>install</code> 事件</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">加密数据参数：<code>cfurla</code></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"_3-1-2-示例代码\" tabindex=\"-1\"> 3.1.2 示例代码</h4>\n<div><pre><code><span>public</span> <span>class</span> <span>MyApplication</span> <span>extends</span> <span>Application</span> <span>{</span>\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>onCreate</span><span>(</span><span>)</span> <span>{</span>\n        <span>super</span><span>.</span><span>onCreate</span><span>(</span><span>)</span><span>;</span>\n        <span>initAdjust</span><span>(</span><span>this</span><span>)</span><span>;</span>\n        <span>registerActivityLifecycleCallbacks</span><span>(</span><span>new</span> <span>MyLifecycleCallbacks</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>.</span><span>.</span><span>.</span>\n        <span>// 上报归因的初始化</span>\n        <span>setupReferrer</span><span>(</span><span>this</span><span>)</span><span>;</span>\n        <span>.</span><span>.</span><span>.</span>\n    <span>}</span>\n<span>}</span>\n</code></pre></div><div><pre><code><span>private</span> <span>void</span> <span>setupReferrer</span><span>(</span><span>Application</span> application<span>)</span> <span>{</span>\n    <span>InstallReferrerClient</span> referrerClient<span>;</span>\n    referrerClient <span>=</span> <span>InstallReferrerClient</span><span>.</span><span>newBuilder</span><span>(</span>application<span>)</span><span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>\n    referrerClient<span>.</span><span>startConnection</span><span>(</span><span>new</span> <span>InstallReferrerStateListener</span><span>(</span><span>)</span> <span>{</span>\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onInstallReferrerSetupFinished</span><span>(</span><span>int</span> responseCode<span>)</span> <span>{</span>\n            <span>try</span> <span>{</span>\n                <span>switch</span> <span>(</span>responseCode<span>)</span> <span>{</span>\n                    <span>case</span> <span>InstallReferrerClient<span>.</span>InstallReferrerResponse</span><span>.</span><span>OK</span><span>:</span>\n                        <span>// Connection established.</span>\n                        <span>boolean</span> traced <span>=</span> <span>SPUtils</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>.</span><span>getBoolean</span><span>(</span><span>IConstants</span><span>.</span><span>SP_REFERRER_TRACE</span><span>)</span><span>;</span>\n                        <span>if</span> <span>(</span><span>!</span>traced<span>)</span> <span>{</span>\n                            <span>String</span> referrerUrl <span>=</span> referrerClient<span>.</span><span>getInstallReferrer</span><span>(</span><span>)</span><span>.</span><span>getInstallReferrer</span><span>(</span><span>)</span><span>;</span>\n                            <span>AdjustEvent</span> event <span>=</span> <span>new</span> <span>AdjustEvent</span><span>(</span><span>\"xm2kgc\"</span><span>)</span><span>;</span>\n                            event<span>.</span><span>addCallbackParameter</span><span>(</span><span>\"cfurla\"</span><span>,</span> referrerUrl<span>)</span><span>;</span>\n                            <span>Adjust</span><span>.</span><span>trackEvent</span><span>(</span>event<span>)</span><span>;</span>\n                            <span>//注意要做一个上传标记，避免重复上传，文档也说了尽量避免不必要的重复调用</span>\n                            <span>SPUtils</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>.</span><span>put</span><span>(</span><span>IConstants</span><span>.</span><span>SP_REFERRER_TRACE</span><span>,</span> <span>true</span><span>)</span><span>;</span>\n                        <span>}</span>\n                        <span>//获取归因后要及时断开，避免内存泄露</span>\n                        referrerClient<span>.</span><span>endConnection</span><span>(</span><span>)</span><span>;</span>\n                        <span>break</span><span>;</span>\n                    <span>case</span> <span>InstallReferrerClient<span>.</span>InstallReferrerResponse</span><span>.</span><span>FEATURE_NOT_SUPPORTED</span><span>:</span>\n                        <span>// API not available on the current Play Store app.</span>\n                        <span>break</span><span>;</span>\n                    <span>case</span> <span>InstallReferrerClient<span>.</span>InstallReferrerResponse</span><span>.</span><span>SERVICE_UNAVAILABLE</span><span>:</span>\n                        <span>// Connection couldn't be established.</span>\n                        <span>break</span><span>;</span>\n                <span>}</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onInstallReferrerServiceDisconnected</span><span>(</span><span>)</span> <span>{</span>\n            <span>// Try to restart the connection on the next request to</span>\n            <span>// Google Play by calling the startConnection() method.</span>\n        <span>}</span>\n    <span>}</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre></div><h3 id=\"_3-2-通过-adjust-上报广告价值\" tabindex=\"-1\"> 3.2 通过 <code>Adjust</code> 上报广告价值</h3>\n<h4 id=\"_3-2-1-step1-adjust-上报广告价值的方法封装\" tabindex=\"-1\"> 3.2.1 Step1. <code>Adjust</code> 上报广告价值的方法封装</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>reportRevenue</span><span>(</span><span>long</span> valueMicros<span>,</span> <span>String</span> currencyCode<span>,</span> <span>String</span> network<span>,</span> <span>String</span> adId<span>,</span> <span>String</span> adPlace<span>)</span> <span>{</span>\n    <span>double</span> revenue <span>=</span> valueMicros <span>/</span> <span>1000000.0</span><span>;</span> <span>//把原来的千分值转换成0.001</span>\n    <span>AdjustAdRevenue</span> adRevenue <span>=</span> <span>new</span> <span>AdjustAdRevenue</span><span>(</span><span>AdjustConfig</span><span>.</span><span>AD_REVENUE_ADMOB</span><span>)</span><span>;</span>\n    adRevenue<span>.</span><span>setRevenue</span><span>(</span>revenue<span>,</span> currencyCode<span>)</span><span>;</span>\n    adRevenue<span>.</span><span>setAdRevenueNetwork</span><span>(</span>network<span>)</span><span>;</span> <span>//广告源渠道</span>\n    adRevenue<span>.</span><span>setAdRevenuePlacement</span><span>(</span>adPlace<span>)</span><span>;</span> <span>//广告位名称</span>\n    adRevenue<span>.</span><span>setAdRevenueUnit</span><span>(</span>adId<span>)</span><span>;</span> <span>//广告ID</span>\n    <span>Adjust</span><span>.</span><span>trackAdRevenue</span><span>(</span>adRevenue<span>)</span><span>;</span> <span>//调用Adjust上报广告价值的方法</span>\n<span>}</span>\n</code></pre></div><h4 id=\"_3-2-2-step2-获取广告源渠道的方法封装\" tabindex=\"-1\"> 3.2.2 Step2. 获取广告源渠道的方法封装</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>String</span> <span>getAdChannel</span><span>(</span><span>String</span> adapter<span>)</span> <span>{</span> <span>// 参数 adapter 通过广告 SDK 提供的 API 获取</span>\n    <span>String</span> channel <span>=</span> <span>\"\"</span><span>;</span> <span>// 广告源渠道</span>\n\n    <span>if</span> <span>(</span><span>TextUtils</span><span>.</span><span>isEmpty</span><span>(</span>adapter<span>)</span><span>)</span> <span>{</span>\n        <span>return</span> channel<span>;</span>\n    <span>}</span>\n\n    <span>if</span> <span>(</span>adapter<span>.</span><span>contains</span><span>(</span><span>\"AdMobAdapter\"</span><span>)</span><span>)</span> <span>{</span>\n        channel <span>=</span> <span>\"admob\"</span><span>;</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span>adapter<span>.</span><span>contains</span><span>(</span><span>\"adcolony\"</span><span>)</span><span>)</span> <span>{</span>\n        channel <span>=</span> <span>\"adcolony\"</span><span>;</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span>adapter<span>.</span><span>contains</span><span>(</span><span>\"chartboost\"</span><span>)</span><span>)</span> <span>{</span>\n        channel <span>=</span> <span>\"chartboost\"</span><span>;</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span>adapter<span>.</span><span>contains</span><span>(</span><span>\"inmobi\"</span><span>)</span><span>)</span> <span>{</span>\n        channel <span>=</span> <span>\"inmobi\"</span><span>;</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span>adapter<span>.</span><span>contains</span><span>(</span><span>\"ironsource\"</span><span>)</span><span>)</span> <span>{</span>\n        channel <span>=</span> <span>\"ironsource\"</span><span>;</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span>adapter<span>.</span><span>contains</span><span>(</span><span>\"pangle\"</span><span>)</span><span>)</span> <span>{</span>\n        channel <span>=</span> <span>\"pangle\"</span><span>;</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span>adapter<span>.</span><span>contains</span><span>(</span><span>\"unity\"</span><span>)</span><span>)</span> <span>{</span>\n        channel <span>=</span> <span>\"unity\"</span><span>;</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span>adapter<span>.</span><span>contains</span><span>(</span><span>\"vungle\"</span><span>)</span><span>)</span> <span>{</span>\n        channel <span>=</span> <span>\"vungle\"</span><span>;</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span>adapter<span>.</span><span>contains</span><span>(</span><span>\".mtg\"</span><span>)</span><span>)</span> <span>{</span>\n        channel <span>=</span> <span>\"mintegral\"</span><span>;</span>\n    <span>}</span>\n\n    <span>return</span> channel<span>;</span>\n<span>}</span>\n</code></pre></div><h4 id=\"_3-2-3-step3-实现-onpaideventlistener-接口\" tabindex=\"-1\"> 3.2.3 Step3. 实现 <code>OnPaidEventListener</code> 接口</h4>\n<div><pre><code><span>public</span> <span>class</span> <span>MyOnPaidEventListener</span> <span>implements</span> <span>OnPaidEventListener</span> <span>{</span>\n\n    <span>private</span> <span>final</span> <span>PlaceBean</span> placeBean<span>;</span> <span>// placeBean 实体类的作用是提供广告位名称</span>\n    <span>private</span> <span>final</span> <span>UnitBean</span> unitBean<span>;</span> <span>// unitBean 实体类的作用是提供广告单元 id</span>\n    <span>private</span> <span>final</span> <span>String</span> adapter<span>;</span> <span>// // 参数 adapter 通过广告 SDK 提供的 API 获取</span>\n\n    <span>public</span> <span>MyOnPaidEventListener</span><span>(</span><span>PlaceBean</span> placeBean<span>,</span> <span>UnitBean</span> unitBean<span>,</span> <span>String</span> adapter<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>placeBean <span>=</span> placeBean<span>;</span>\n        <span>this</span><span>.</span>unitBean <span>=</span> unitBean<span>;</span>\n        <span>this</span><span>.</span>adapter <span>=</span> adapter <span>==</span> <span>null</span> <span>?</span> <span>\"\"</span> <span>:</span> adapter<span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>onPaidEvent</span><span>(</span><span>@NonNull</span> <span>AdValue</span> adValue<span>)</span> <span>{</span>\n        <span>String</span> network <span>=</span> <span>getAdChannel</span><span>(</span>adapter<span>)</span><span>;</span> <span>// 广告源渠道</span>\n\n        <span>if</span> <span>(</span>placeBean <span>==</span> <span>null</span> <span>||</span> unitBean <span>==</span> <span>null</span><span>)</span> <span>{</span>\n            <span>return</span><span>;</span>\n        <span>}</span>\n\n        <span>reportRevenue</span><span>(</span>adValue<span>.</span><span>getValueMicros</span><span>(</span><span>)</span><span>,</span> adValue<span>.</span><span>getCurrencyCode</span><span>(</span><span>)</span><span>,</span> network<span>,</span> unitBean<span>.</span><span>getId</span><span>(</span><span>)</span><span>,</span> placeBean<span>.</span><span>getPlace</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre></div><h4 id=\"_3-2-4-step4-在请求成功的回调中为广告对象设置-onpaideventlistener\" tabindex=\"-1\"> 3.2.4 Step4. 在请求成功的回调中为广告对象设置 <code>OnPaidEventListener</code></h4>\n<div><pre><code><span>/* 示例：开屏广告设置监听器的方法。（插页广告与之类似） */</span>\n<span>@Override</span>\n<span>public</span> <span>void</span> <span>onAdLoaded</span><span>(</span><span>@NonNull</span> <span>AppOpenAd</span> appOpenAd<span>)</span> <span>{</span>\n    <span>.</span><span>.</span><span>.</span>\n    <span>String</span> adapterName <span>=</span> appOpenAd<span>.</span><span>getResponseInfo</span><span>(</span><span>)</span><span>.</span><span>getMediationAdapterClassName</span><span>(</span><span>)</span><span>;</span>\n    <span>/*\n        placeBean 实体类的作用是提供广告位名称\n        unitBean 实体类的作用是提供广告单元 id\n    */</span>\n    appOpenAd<span>.</span><span>setOnPaidEventListener</span><span>(</span><span>new</span> <span>MyOnPaidEventListener</span><span>(</span>placeBean<span>,</span> unitBean<span>,</span> adapterName<span>)</span><span>)</span><span>;</span>\n    ad <span>=</span> <span>(</span><span>T</span><span>)</span> appOpenAd<span>;</span>\n    <span>.</span><span>.</span><span>.</span>\n<span>}</span>\n</code></pre></div><div><pre><code><span>/* 示例：原生广告设置监听器的方法。 */</span>\nadLoadBuilder<span>.</span><span>forNativeAd</span><span>(</span>nativeAd <span>-></span> <span>{</span> <span>// onNativeAdLoaded</span>\n    <span>.</span><span>.</span><span>.</span>\n    <span>String</span> adapterName <span>=</span> nativeAd<span>.</span><span>getResponseInfo</span><span>(</span><span>)</span> <span>==</span> <span>null</span> <span>?</span> <span>\"\"</span> <span>:</span> nativeAd<span>.</span><span>getResponseInfo</span><span>(</span><span>)</span><span>.</span><span>getMediationAdapterClassName</span><span>(</span><span>)</span><span>;</span>\n    nativeAd<span>.</span><span>setOnPaidEventListener</span><span>(</span><span>new</span> <span>MyOnPaidEventListener</span><span>(</span>placeBean<span>,</span> unitBean<span>,</span> adapterName<span>)</span><span>)</span><span>;</span>\n    ad <span>=</span> <span>(</span><span>T</span><span>)</span> nativeAd<span>;</span>\n    <span>.</span><span>.</span><span>.</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre></div><div><pre><code><span>/* 示例：Banner 广告设置监听器的方法。 */</span>\n<span>public</span> <span>void</span> <span>onAdLoaded</span><span>(</span><span>)</span> <span>{</span>\n    <span>.</span><span>.</span><span>.</span>\n    <span>String</span> adapterName <span>=</span> adView<span>.</span><span>getResponseInfo</span><span>(</span><span>)</span> <span>==</span> <span>null</span> <span>?</span> <span>\"\"</span> <span>:</span> adView<span>.</span><span>getResponseInfo</span><span>(</span><span>)</span><span>.</span><span>getMediationAdapterClassName</span><span>(</span><span>)</span><span>;</span>\n    adView<span>.</span><span>setOnPaidEventListener</span><span>(</span><span>new</span> <span>MyOnPaidEventListener</span><span>(</span>placeBean<span>,</span> unitBean<span>,</span> adapterName<span>)</span><span>)</span><span>;</span>\n    <span>.</span><span>.</span><span>.</span>\n<span>}</span>\n</code></pre></div><h3 id=\"_3-3-通过-adjust-上报广告的请求事件、匹配事件、点击事件\" tabindex=\"-1\"> 3.3 通过 <code>Adjust</code> 上报广告的请求事件、匹配事件、点击事件</h3>\n<h4 id=\"_3-3-1-产品需提供的信息\" tabindex=\"-1\"> 3.3.1 产品需提供的信息</h4>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>事件名称</strong></th>\n<th style=\"text-align:left\"><strong><code>Adjust</code> 识别码</strong></th>\n<th style=\"text-align:left\"><strong>备注</strong></th>\n<th style=\"text-align:left\"><strong>触发条件</strong></th>\n<th style=\"text-align:left\"><strong>参数</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>cfaska</code></td>\n<td style=\"text-align:left\"><code>c6j2e7</code></td>\n<td style=\"text-align:left\">请求事件</td>\n<td style=\"text-align:left\">开始请求广告后，回传数据</td>\n<td style=\"text-align:left\">广告单元 <code>unitId</code>、广告位置 <code>place</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>cfmata</code></td>\n<td style=\"text-align:left\"><code>2scofd</code></td>\n<td style=\"text-align:left\">匹配事件</td>\n<td style=\"text-align:left\">广告请求成功后，回传数据</td>\n<td style=\"text-align:left\">广告单元 <code>unitId</code>、收入渠道 <code>channel</code>、广告位置 <code>place</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>cfpota</code></td>\n<td style=\"text-align:left\"><code>g55rtc</code></td>\n<td style=\"text-align:left\">点击事件</td>\n<td style=\"text-align:left\">广告点击后，回传数据</td>\n<td style=\"text-align:left\">广告单元 <code>unitId</code>、收入渠道 <code>channel</code>、广告位置 <code>place</code></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>注意：广告的请求事件触发时，还无法获取到收入渠道，所以此时不需要传（或根据产品需求传 <code>&quot;&quot;</code>，或传一个默认值（如 &quot;<code>admob</code>&quot;））</p>\n</blockquote>\n<h4 id=\"_3-3-2-定义埋点方法-兼容带参数的事件\" tabindex=\"-1\"> 3.3.2 定义埋点方法（兼容带参数的事件）</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>trackEvent</span><span>(</span><span>String</span> event<span>,</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> params<span>,</span> <span>boolean</span> unique<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>unique <span>&amp;&amp;</span> <span>SPUtils</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>.</span><span>getBoolean</span><span>(</span>event<span>)</span><span>)</span> <span>{</span>\n        <span>Log</span><span>.</span><span>e</span><span>(</span><span>TAG</span><span>,</span> <span>\"trackEvent() -->  unique event \"</span> <span>+</span> event <span>+</span> <span>\"  has been REPORT !!!\"</span><span>)</span><span>;</span>\n        <span>return</span><span>;</span> <span>// 去重事件已经上报过，不再上报</span>\n    <span>}</span>\n\n    <span>AdjustEvent</span> adjustEvent <span>=</span> <span>new</span> <span>AdjustEvent</span><span>(</span>event<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>unique<span>)</span> <span>{</span>\n        adjustEvent<span>.</span><span>setOrderId</span><span>(</span>event<span>)</span><span>;</span> <span>// Adjust 内部的去重（最多只能支持10个事件，所以自己再套了层 SP 保证去重）</span>\n    <span>}</span>\n\n    <span>if</span> <span>(</span>params <span>!=</span> <span>null</span> <span>&amp;&amp;</span> <span>!</span>params<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n        <span>for</span> <span>(</span><span>Map<span>.</span>Entry</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> entry <span>:</span> params<span>.</span><span>entrySet</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            adjustEvent<span>.</span><span>addCallbackParameter</span><span>(</span>entry<span>.</span><span>getKey</span><span>(</span><span>)</span><span>,</span> entry<span>.</span><span>getValue</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>Adjust</span><span>.</span><span>trackEvent</span><span>(</span>adjustEvent<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>unique<span>)</span> <span>{</span>\n        <span>SPUtils</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>.</span><span>put</span><span>(</span>event<span>,</span> <span>true</span><span>)</span><span>;</span> <span>// 自己通过 SP 保证去重</span>\n    <span>}</span>\n<span>}</span>\n</code></pre></div><h4 id=\"_3-3-3-上报各个广告的请求事件\" tabindex=\"-1\"> 3.3.3 上报各个广告的请求事件</h4>\n<div><pre><code><span>/* 1. 广告请求事件的埋点方法封装 */</span>\n<span>/**\n * 事件: 开始请求广告后，回传数据\n * 事件识别码: xxx\n * 广告单元参数 unitId, 广告位置参数 place\n */</span>\n<span>public</span> <span>static</span> <span>void</span> <span>traceAdPreload</span><span>(</span><span>String</span> unitId<span>,</span> <span>String</span> place<span>)</span> <span>{</span>\n    <span>LogUtils</span><span>.</span><span>e</span><span>(</span><span>TAG</span><span>,</span> <span>\"--> traceAdPreload()  unitId=\"</span> <span>+</span> unitId <span>+</span> <span>\"  place=\"</span> <span>+</span> place<span>)</span><span>;</span>\n    <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> map <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    map<span>.</span><span>put</span><span>(</span><span>\"unitId\"</span><span>,</span> unitId<span>)</span><span>;</span>\n    map<span>.</span><span>put</span><span>(</span><span>\"place\"</span><span>,</span> place<span>)</span><span>;</span>\n    <span>trackEvent</span><span>(</span><span>\"xxx\"</span><span>,</span> map<span>,</span> <span>false</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre></div><div><pre><code><span>/* 2. 在各个广告请求前调用 traceAdPreload 方法 */</span>\n\n<span>// 示例：在开屏广告请求前调用（其他广告类似处理）</span>\n<span>traceAdPreload</span><span>(</span>unitBean<span>.</span><span>getId</span><span>(</span><span>)</span><span>,</span> placeBean<span>.</span><span>getPlace</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>AdRequest</span> request <span>=</span> <span>new</span> <span>AdRequest<span>.</span>Builder</span><span>(</span><span>)</span><span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>\n<span>AppOpenAd</span><span>.</span><span>load</span><span>(</span>context<span>,</span> unitBean<span>.</span><span>getId</span><span>(</span><span>)</span><span>,</span> request<span>,</span> <span>AppOpenAd</span><span>.</span><span>APP_OPEN_AD_ORIENTATION_PORTRAIT</span><span>,</span> appOpenAdLoadCallback<span>)</span><span>;</span>\n</code></pre></div><h4 id=\"_3-3-4-上报各个广告的匹配事件-请求成功\" tabindex=\"-1\"> 3.3.4 上报各个广告的匹配事件（请求成功）</h4>\n<div><pre><code><span>/* 1. 广告匹配事件（请求成功）的埋点方法封装 */</span>\n<span>/**\n * 事件: 广告请求成功后，回传数据\n * 事件识别码: xxx\n * 广告单元参数 unitId, 广告位置参数 place, 收入渠道参数 channel\n */</span>\n<span>public</span> <span>static</span> <span>void</span> <span>traceAdLoadSuccess</span><span>(</span><span>String</span> unitId<span>,</span> <span>String</span> place<span>,</span> <span>String</span> channel<span>)</span> <span>{</span>\n    <span>LogUtils</span><span>.</span><span>e</span><span>(</span><span>TAG</span><span>,</span> <span>\"--> traceAdLoadSuccess()  unitId=\"</span> <span>+</span> unitId <span>+</span> <span>\"  place=\"</span> <span>+</span> place <span>+</span> <span>\"  channel=\"</span> <span>+</span> channel<span>)</span><span>;</span>\n    <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> map <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    map<span>.</span><span>put</span><span>(</span><span>\"unitId\"</span><span>,</span> unitId<span>)</span><span>;</span>\n    map<span>.</span><span>put</span><span>(</span><span>\"place\"</span><span>,</span> place<span>)</span><span>;</span>\n    map<span>.</span><span>put</span><span>(</span><span>\"channel\"</span><span>,</span> channel<span>)</span><span>;</span>\n    <span>trackEvent</span><span>(</span><span>\"xxx\"</span><span>,</span> map<span>,</span> <span>false</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre></div><div><pre><code><span>/* 2. 在各个广告请求成功的回调中调用 traceAdLoadSuccess 方法 */</span>\n\n<span>// 示例：在开屏广告请求成功时调用 traceAdLoadSuccess 方法（其他广告类似处理）</span>\n<span>@Override</span>\n<span>public</span> <span>void</span> <span>onAdLoaded</span><span>(</span><span>@NonNull</span> <span>AppOpenAd</span> appOpenAd<span>)</span> <span>{</span>\n    <span>LogUtils</span><span>.</span><span>e</span><span>(</span><span>TAG</span><span>,</span> <span>\"--> onAdLoaded() appOpenAd=\"</span> <span>+</span> appOpenAd<span>)</span><span>;</span>\n    <span>.</span><span>.</span><span>.</span>\n    <span>String</span> adapterName <span>=</span> appOpenAd<span>.</span><span>getResponseInfo</span><span>(</span><span>)</span><span>.</span><span>getMediationAdapterClassName</span><span>(</span><span>)</span><span>;</span>\n    appOpenAd<span>.</span><span>setOnPaidEventListener</span><span>(</span><span>new</span> <span>MyOnPaidEventListener</span><span>(</span>placeBean<span>,</span> unitBean<span>,</span> adapterName<span>)</span><span>)</span><span>;</span>\n    <span>traceAdLoadSuccess</span><span>(</span>unitBean<span>.</span><span>getId</span><span>(</span><span>)</span><span>,</span> placeBean<span>.</span><span>getPlace</span><span>(</span><span>)</span><span>,</span> <span>AdConfig</span><span>.</span><span>getAdChannel</span><span>(</span>adapterName<span>)</span><span>)</span><span>;</span>\n    ad <span>=</span> <span>(</span><span>T</span><span>)</span> appOpenAd<span>;</span>\n    <span>.</span><span>.</span><span>.</span>\n<span>}</span>\n</code></pre></div><blockquote>\n<p>注意：就是在  调用 <code>traceAdLoadSuccess</code> 方法</p>\n</blockquote>\n<h4 id=\"_3-3-5-上报各个广告的点击事件\" tabindex=\"-1\"> 3.3.5 上报各个广告的点击事件</h4>\n<div><pre><code><span>/* 2. 广告点击事件的埋点方法封装 */</span>\n<span>/**\n * 事件: 广告点击后，回传数据\n * 事件识别码: xxx\n * 广告单元参数 unitId, 广告位置参数 place, 收入渠道参数 channel\n */</span>\n<span>public</span> <span>static</span> <span>void</span> <span>traceAdClick</span><span>(</span><span>String</span> unitId<span>,</span> <span>String</span> place<span>,</span> <span>String</span> channel<span>)</span> <span>{</span>\n    <span>LogUtils</span><span>.</span><span>e</span><span>(</span><span>TAG</span><span>,</span> <span>\"--> traceAdClick()  unitId=\"</span> <span>+</span> unitId <span>+</span> <span>\"  place=\"</span> <span>+</span> place <span>+</span> <span>\"  channel=\"</span> <span>+</span> channel<span>)</span><span>;</span>\n    <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> map <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    map<span>.</span><span>put</span><span>(</span><span>\"unitId\"</span><span>,</span> unitId<span>)</span><span>;</span>\n    map<span>.</span><span>put</span><span>(</span><span>\"place\"</span><span>,</span> place<span>)</span><span>;</span>\n    map<span>.</span><span>put</span><span>(</span><span>\"channel\"</span><span>,</span> channel<span>)</span><span>;</span>\n    <span>trackEvent</span><span>(</span><span>\"xxx\"</span><span>,</span> map<span>,</span> <span>false</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre></div><div><pre><code><span>/* 2. 在各个广告点击事件的回调中调用 traceAdClick 方法 */</span>\n\n<span>// 示例：在开屏广告的点击事件中调用 traceAdClick 方法（插页广告类似处理）</span>\n<span>@Override</span>\n<span>public</span> <span>void</span> <span>onAdClicked</span><span>(</span><span>)</span> <span>{</span>\n    <span>String</span> adapterName <span>=</span> <span>(</span><span>(</span><span>AppOpenAd</span><span>)</span> ad<span>)</span><span>.</span><span>getResponseInfo</span><span>(</span><span>)</span><span>.</span><span>getMediationAdapterClassName</span><span>(</span><span>)</span><span>;</span>\n    <span>traceAdClick</span><span>(</span>unitBean<span>.</span><span>getId</span><span>(</span><span>)</span><span>,</span> placeBean<span>.</span><span>getPlace</span><span>(</span><span>)</span><span>,</span> <span>AdConfig</span><span>.</span><span>getAdChannel</span><span>(</span>adapterName<span>)</span><span>)</span><span>;</span>\n    <span>.</span><span>.</span><span>.</span>\n<span>}</span>\n\n<span>// 示例：在原生广告的点击事件中调用 traceAdClick 方法</span>\n<span>@Override</span>\n<span>public</span> <span>void</span> <span>onAdClicked</span><span>(</span><span>)</span> <span>{</span>\n    <span>String</span> adapterName <span>=</span> <span>(</span><span>(</span><span>NativeAd</span><span>)</span> ad<span>)</span><span>.</span><span>getResponseInfo</span><span>(</span><span>)</span> <span>==</span> <span>null</span> <span>?</span> \n            <span>\"\"</span> <span>:</span> <span>(</span><span>(</span><span>NativeAd</span><span>)</span> ad<span>)</span><span>.</span><span>getResponseInfo</span><span>(</span><span>)</span><span>.</span><span>getMediationAdapterClassName</span><span>(</span><span>)</span><span>;</span>\n    <span>traceAdClick</span><span>(</span>unitBean<span>.</span><span>getId</span><span>(</span><span>)</span><span>,</span> placeBean<span>.</span><span>getPlace</span><span>(</span><span>)</span><span>,</span> <span>AdConfig</span><span>.</span><span>getAdChannel</span><span>(</span>adapterName<span>)</span><span>)</span><span>;</span>\n    <span>.</span><span>.</span><span>.</span>\n<span>}</span>\n\n<span>// 示例：在Banner 广告的点击事件中调用 traceAdClick 方法</span>\n<span>@Override</span>\n<span>public</span> <span>void</span> <span>onAdClicked</span><span>(</span><span>)</span> <span>{</span>\n    <span>String</span> adapterName <span>=</span> adView<span>.</span><span>getResponseInfo</span><span>(</span><span>)</span> <span>==</span> <span>null</span> <span>?</span> <span>\"\"</span> <span>:</span> adView<span>.</span><span>getResponseInfo</span><span>(</span><span>)</span><span>.</span><span>getMediationAdapterClassName</span><span>(</span><span>)</span><span>;</span>\n    <span>traceAdClick</span><span>(</span>unitBean<span>.</span><span>getId</span><span>(</span><span>)</span><span>,</span> placeBean<span>.</span><span>getPlace</span><span>(</span><span>)</span><span>,</span> <span>AdConfig</span><span>.</span><span>getAdChannel</span><span>(</span>adapterName<span>)</span><span>)</span><span>;</span>\n    <span>.</span><span>.</span><span>.</span>\n<span>}</span>\n</code></pre></div>",
      "date_published": "2023-05-04T15:57:35.000Z",
      "date_modified": "2023-05-28T07:27:11.000Z",
      "authors": [],
      "tags": [
        "HNAP"
      ]
    },
    {
      "title": "Admob广告接入",
      "url": "https://zengkaiqiang562.github.io/zkq/hnap/sdk/admob.html",
      "id": "https://zengkaiqiang562.github.io/zkq/hnap/sdk/admob.html",
      "content_html": "<blockquote>\n<p>参考：<a href=\"https://developers.google.cn/admob/android/quick-start\" target=\"_blank\" rel=\"noopener noreferrer\">入门指南<ExternalLinkIcon/></a></p>\n</blockquote>\n<h2 id=\"_1-接入步骤\" tabindex=\"-1\"> 1. 接入步骤</h2>\n<h3 id=\"step-1-添加依赖仓库\" tabindex=\"-1\"> Step 1. 添加依赖仓库</h3>\n<p>在根 <code>build.gradle</code> 文件中添加：</p>\n<div><pre><code>buildscript <span>{</span>\n    repositories <span>{</span>\n        <span>google</span><span>(</span><span>)</span>\n        <span>mavenCentral</span><span>(</span><span>)</span>\n    <span>}</span>\n<span>}</span>\n\nallprojects <span>{</span>\n    repositories <span>{</span>\n        <span>google</span><span>(</span><span>)</span>\n        <span>mavenCentral</span><span>(</span><span>)</span>\n    <span>}</span>\n<span>}</span>\n</code></pre></div><p><code>Android Gradle Plugin 7.0+</code> 在 <code>settings.gradle</code> 中添加：</p>\n<div><pre><code>pluginManagement <span>{</span>\n    repositories <span>{</span>\n        <span>gradlePluginPortal</span><span>(</span><span>)</span>\n        <span>google</span><span>(</span><span>)</span>\n        <span>mavenCentral</span><span>(</span><span>)</span>\n    <span>}</span>\n<span>}</span>\ndependencyResolutionManagement <span>{</span>\n    repositoriesMode<span>.</span><span>set</span><span>(</span>RepositoriesMode<span>.</span>FAIL_ON_PROJECT_REPOS<span>)</span>\n    repositories <span>{</span>\n        <span>google</span><span>(</span><span>)</span>\n        <span>mavenCentral</span><span>(</span><span>)</span>\n        maven <span>{</span> url <span>'https://jitpack.io'</span> <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre></div><h3 id=\"step-2-添加依赖包\" tabindex=\"-1\"> Step 2. 添加依赖包</h3>\n<p>在模块 <code>build.gradle</code> 文件中添加：</p>\n<div><pre><code>dependencies <span>{</span>\n    implementation <span>'com.google.android.gms:play-services-ads:21.0.0'</span>\n<span>}</span>\n</code></pre></div><h3 id=\"step-3-在-androidmanifest-xml-中配置-app-id\" tabindex=\"-1\"> Step 3. 在 <code>AndroidManifest.xml</code> 中配置 <code>App Id</code></h3>\n<div><pre><code><span><span><span>&lt;</span>manifest</span><span>></span></span>\n    <span><span><span>&lt;</span>application</span><span>></span></span>\n        <span>&lt;!-- Sample AdMob app ID: ca-app-pub-3940256099942544~3347511713 --></span>\n        <span>&lt;!-- 注意：实际开发时要替换成自己的 App Id --></span>\n        <span><span><span>&lt;</span>meta-data</span>\n            <span><span>android:</span>name</span><span><span>=</span><span>\"</span>com.google.android.gms.ads.APPLICATION_ID<span>\"</span></span>\n            <span><span>android:</span>value</span><span><span>=</span><span>\"</span>ca-app-pub-xxxxxxxxxxxxxxxx~yyyyyyyyyy<span>\"</span></span><span>/></span></span>\n    <span><span><span>&lt;/</span>application</span><span>></span></span>\n<span><span><span>&lt;/</span>manifest</span><span>></span></span>\n</code></pre></div><h3 id=\"step-4-在-application-中初始化\" tabindex=\"-1\"> Step 4. 在 <code>Application</code> 中初始化</h3>\n<div><pre><code><span>public</span> <span>class</span> <span>MyApplication</span> <span>extends</span> <span>Application</span> <span>{</span>\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>onCreate</span><span>(</span><span>)</span> <span>{</span>\n        <span>super</span><span>.</span><span>onCreate</span><span>(</span><span>)</span><span>;</span>\n\n        <span>initMobileAds</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>private</span> <span>void</span> <span>initMobileAds</span><span>(</span><span>)</span> <span>{</span>\n\n        <span>// if (BuildConfig.DEBUG) {</span>\n        <span>//     // TODO 添写测试机的 DeviceId</span>\n        <span>//     // 参考：https://developers.google.cn/admob/android/test-ads#add_your_test_device_programmatically</span>\n        <span>//       List&lt;String> testDeviceIds = Arrays.asList(\"2B290798B3C52E15FF6CACDAAA57C910\", \"F9180FB4550B86775EB93370CFB3BCA8\");</span>\n        <span>//       RequestConfiguration configuration =</span>\n        <span>//               new RequestConfiguration.Builder().setTestDeviceIds(testDeviceIds).build();</span>\n        <span>//       MobileAds.setRequestConfiguration(configuration);</span>\n        <span>// }</span>\n\n        <span>MobileAds</span><span>.</span><span>initialize</span><span>(</span><span>this</span><span>,</span> initializationStatus <span>-></span> <span>{</span>\n            <span>for</span> <span>(</span><span>Map<span>.</span>Entry</span><span><span>&lt;</span><span>String</span><span>,</span> <span>AdapterStatus</span><span>></span></span> entry <span>:</span> initializationStatus<span>.</span><span>getAdapterStatusMap</span><span>(</span><span>)</span><span>.</span><span>entrySet</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                <span>Printer</span><span>.</span><span>e</span><span>(</span><span>TAG</span><span>,</span> <span>\"==> initMobileAds() onCompleted  entry.key=\"</span> <span>+</span> entry<span>.</span><span>getKey</span><span>(</span><span>)</span>\n                        <span>+</span> <span>\"  entry.AdapterStatus.desc=\"</span> <span>+</span> entry<span>.</span><span>getValue</span><span>(</span><span>)</span><span>.</span><span>getDescription</span><span>(</span><span>)</span> \n                        <span>+</span> <span>\"  entry.AdapterStatus.state=\"</span> <span>+</span> entry<span>.</span><span>getValue</span><span>(</span><span>)</span><span>.</span><span>getInitializationState</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre></div><blockquote>\n<p>加载广告之前，请先调用 <code>MobileAds.initialize()</code>，以便让应用初始化 <code>Google</code> 移动广告 <code>SDK</code>。</p>\n<p>该方法将初始化相应 <code>SDK</code>，并在初始化完成后或 <code>30</code> 秒超时后回调完成监听器。此操作仅需执行一次，最好是在应用启动时执行。</p>\n</blockquote>\n<h3 id=\"step-5-测试广告\" tabindex=\"-1\"> Step 5. 测试广告</h3>\n<p>在开发过程中启用测试广告非常重要，这样您就可以在不向 <code>Google</code> 广告客户收费的情况下点击广告。</p>\n<p><strong>在非测试模式下，如果您点击过多广告，可能会导致您的帐号因为无效活动而被举报。</strong></p>\n<p>有以下两种获得测试广告的方法：</p>\n<ol>\n<li>\n<p>使用 <code>Google</code> 提供的任一示例广告单元 <code>ID</code>。</p>\n</li>\n<li>\n<p>使用自己的广告单元 <code>ID</code> 并 <a href=\"https://developers.google.cn/admob/android/test-ads#enable_test_devices\" target=\"_blank\" rel=\"noopener noreferrer\">启用测试设备<ExternalLinkIcon/></a>。</p>\n</li>\n</ol>\n<p><strong>如下所示，为 <code>Google</code> 提供的示例广告单元 <code>ID</code>：</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">广告格式</th>\n<th style=\"text-align:left\">示例广告单元 <code>ID</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">开屏广告</td>\n<td style=\"text-align:left\"><code>ca-app-pub-3940256099942544/3419835294</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">横幅广告</td>\n<td style=\"text-align:left\"><code>ca-app-pub-3940256099942544/6300978111</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">插页式广告</td>\n<td style=\"text-align:left\"><code>ca-app-pub-3940256099942544/1033173712</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">插页式视频广告</td>\n<td style=\"text-align:left\"><code>ca-app-pub-3940256099942544/8691691433</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">激励广告</td>\n<td style=\"text-align:left\"><code>ca-app-pub-3940256099942544/5224354917</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">插页式激励广告</td>\n<td style=\"text-align:left\"><code>ca-app-pub-3940256099942544/5354046379</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">原生高级广告</td>\n<td style=\"text-align:left\"><code>ca-app-pub-3940256099942544/2247696110</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">原生高级视频广告</td>\n<td style=\"text-align:left\"><code>ca-app-pub-3940256099942544/1044960115</code></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"_2-获取-google-的广告-id\" tabindex=\"-1\"> 2. 获取 <code>Google</code> 的广告 <code>ID</code></h2>\n<div><pre><code><span>/* 需要依赖 Admob 广告 SDK */</span>\n<span>// 在子线程中执行</span>\n<span>private</span> <span>void</span> <span>fetchGoogleAdvertID</span><span>(</span><span>)</span> <span>{</span>\n    <span>try</span> <span>{</span>\n        <span>AdvertisingIdClient<span>.</span>Info</span> adInfo <span>=</span> <span>AdvertisingIdClient</span><span>.</span><span>getAdvertisingIdInfo</span><span>(</span><span>this</span><span>)</span><span>;</span>\n        sGoogleAdvertID <span>=</span> adInfo<span>.</span><span>getId</span><span>(</span><span>)</span><span>;</span>\n        <span>Printer</span><span>.</span><span>e</span><span>(</span><span>TAG</span><span>,</span> <span>\"fetchGoogleAdvertID() ==>  sGoogleAdvertID=\"</span> <span>+</span> sGoogleAdvertID<span>)</span><span>;</span>\n    <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n        <span>Printer</span><span>.</span><span>e</span><span>(</span><span>TAG</span><span>,</span> <span>\"fetchGoogleAdvertID() ==>  Exception=\"</span> <span>+</span> e<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre></div>",
      "date_published": "2023-05-04T15:57:35.000Z",
      "date_modified": "2023-05-04T15:57:35.000Z",
      "authors": [],
      "tags": [
        "HNAP"
      ]
    },
    {
      "title": "Facebook接入",
      "url": "https://zengkaiqiang562.github.io/zkq/hnap/sdk/facebook.html",
      "id": "https://zengkaiqiang562.github.io/zkq/hnap/sdk/facebook.html",
      "content_html": "<blockquote>\n<p>参考：<a href=\"https://developers.facebook.com/docs/android/getting-started\" target=\"_blank\" rel=\"noopener noreferrer\">Android 版 Facebook SDK 入门指南<ExternalLinkIcon/></a></p>\n</blockquote>\n<h2 id=\"_1-接入步骤\" tabindex=\"-1\"> 1. 接入步骤</h2>\n<h3 id=\"step-1-添加依赖包\" tabindex=\"-1\"> Step 1. 添加依赖包</h3>\n<div><pre><code><span>/* Module build.gradle */</span>\n\n<span>/* Facebook */</span>\nimplementation <span>'com.facebook.android:facebook-core:12.1.0'</span>\nimplementation <span>'com.facebook.android:facebook-applinks:12.1.0'</span>\n</code></pre></div><h3 id=\"step-2-在-androidmanifest-xml-中配置-app-id\" tabindex=\"-1\"> Step 2. 在 <code>AndroidManifest.xml</code> 中配置 <code>App ID</code></h3>\n<div><pre><code><span>&lt;!-- Facebook --></span>\n<span><span><span>&lt;</span>meta-data</span>\n    <span><span>android:</span>name</span><span><span>=</span><span>\"</span>com.facebook.sdk.ApplicationId<span>\"</span></span>\n    <span><span>android:</span>value</span><span><span>=</span><span>\"</span>000000000000000<span>\"</span></span><span>/></span></span>\n</code></pre></div><h3 id=\"step3-在-application-中进行初始化配置\" tabindex=\"-1\"> Step3. 在 <code>Application</code> 中进行初始化配置</h3>\n<div><pre><code><span>public</span> <span>class</span> <span>MyApplication</span> <span>extends</span> <span>Application</span> <span>{</span>\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>onCreate</span><span>(</span><span>)</span> <span>{</span>\n        <span>super</span><span>.</span><span>onCreate</span><span>(</span><span>)</span><span>;</span>\n\n        <span>initFacebook</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>private</span> <span>void</span> <span>initFacebook</span><span>(</span><span>)</span> <span>{</span>\n        <span>FacebookSdk</span><span>.</span><span>setApplicationId</span><span>(</span><span>\"000000000000000\"</span><span>)</span><span>;</span> <span>// app id（跟 AndroidManifest.xml 中配置的一样）</span>\n        <span>FacebookSdk</span><span>.</span><span>setClientToken</span><span>(</span><span>\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"</span><span>)</span><span>;</span> <span>// token</span>\n        <span>FacebookSdk</span><span>.</span><span>sdkInitialize</span><span>(</span><span>this</span><span>)</span><span>;</span>\n        <span>AppEventsLogger</span><span>.</span><span>activateApp</span><span>(</span><span>this</span><span>)</span><span>;</span>\n        <span>FacebookSdk</span><span>.</span><span>setAutoLogAppEventsEnabled</span><span>(</span><span>true</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre></div>",
      "date_published": "2023-05-04T15:57:35.000Z",
      "date_modified": "2023-05-04T15:57:35.000Z",
      "authors": [],
      "tags": [
        "HNAP"
      ]
    },
    {
      "title": "Firebase接入",
      "url": "https://zengkaiqiang562.github.io/zkq/hnap/sdk/firebase.html",
      "id": "https://zengkaiqiang562.github.io/zkq/hnap/sdk/firebase.html",
      "content_html": "<h2 id=\"_1-接入步骤\" tabindex=\"-1\"> 1. 接入步骤</h2>\n<blockquote>\n<p>参考：<a href=\"https://firebase.google.com/docs/android/setup?authuser=0#prerequisites\" target=\"_blank\" rel=\"noopener noreferrer\">将 Firebase 添加到您的 Android 项目<ExternalLinkIcon/></a></p>\n<p>参考：<a href=\"https://firebase.google.com/docs/analytics/get-started?platform=android&amp;authuser=0\" target=\"_blank\" rel=\"noopener noreferrer\">Google Analytics（分析）使用入门<ExternalLinkIcon/></a></p>\n<p>参考：<a href=\"https://firebase.google.com/docs/crashlytics/get-started?authuser=0&amp;platform=android\" target=\"_blank\" rel=\"noopener noreferrer\">Firebase Crashlytics 使用入门<ExternalLinkIcon/></a></p>\n</blockquote>\n<h3 id=\"step-1-添加依赖仓库\" tabindex=\"-1\"> Step 1. 添加依赖仓库</h3>\n<div><pre><code><span>/* Project build.gradle */</span>\nbuildscript <span>{</span>\n    dependencies <span>{</span>\n        classpath <span>'com.google.gms:google-services:4.3.14'</span>  <span>// Google Services plugin</span>\n        classpath <span>'com.google.firebase:firebase-crashlytics-gradle:2.9.2'</span>\n    <span>}</span>\n<span>}</span>\n</code></pre></div><blockquote>\n<p>注意：<code>Android Gradle Plugin 7.0+</code> 中 <code>buildscript {...}</code> 需要添加在 <code>plugins {...}</code> 之前。</p>\n</blockquote>\n<h3 id=\"step-2-导入-gradle-插件\" tabindex=\"-1\"> Step 2. 导入 <code>Gradle</code> 插件</h3>\n<div><pre><code><span>/* Module build.gradle */</span>\nplugins <span>{</span>\n    id <span>'com.android.application'</span>\n    id <span>'com.google.gms.google-services'</span>  <span>// Google Services plugin</span>\n    id <span>'com.google.firebase.crashlytics'</span> <span>// Apply the Crashlytics Gradle plugin</span>\n<span>}</span>\n</code></pre></div><h3 id=\"step-3-添加依赖包\" tabindex=\"-1\"> Step 3. 添加依赖包</h3>\n<div><pre><code><span>/* Module build.gradle */</span>\n\n<span>/* Firebase */</span>\n<span>// Import the BoM for the Firebase platform</span>\nimplementation <span>platform</span><span>(</span><span>'com.google.firebase:firebase-bom:30.5.0'</span><span>)</span>\n<span>// Declare the dependencies for the Crashlytics and Analytics libraries</span>\n<span>// When using the BoM, you don't specify versions in Firebase library dependencies</span>\nimplementation <span>'com.google.firebase:firebase-crashlytics'</span>\nimplementation <span>'com.google.firebase:firebase-analytics'</span>\n</code></pre></div><h3 id=\"step-4-导入-google-services-json-配置文件\" tabindex=\"-1\"> Step 4. 导入 <code>google-services.json</code> 配置文件</h3>\n<p>将 <code>google-services.json</code> 文件存放在模块目录下（如路径 <code>app/google-services.json</code>）</p>\n<h3 id=\"step-5-androidmanifest-xml-中的配置\" tabindex=\"-1\"> Step 5. AndroidManifest.xml 中的配置</h3>\n<div><pre><code><span>&lt;!-- 在 application 标签下配置 --></span>\n\n<span>&lt;!-- Firebase 的 Crashlytics 启用自选式报告 --></span>\n<span>&lt;!-- 参考：https://firebase.google.com/docs/crashlytics/customize-crash-reports?authuser=0&amp;platform=android#enable-reporting --></span>\n<span>&lt;!-- 此时，当代码中调用 FirebaseCrashlytics.getInstance().setCrashlyticsCollectionEnabled(true); 时才会启动崩溃分析  --></span>\n<span><span><span>&lt;</span>meta-data</span>\n    <span><span>android:</span>name</span><span><span>=</span><span>\"</span>firebase_crashlytics_collection_enabled<span>\"</span></span>\n    <span><span>android:</span>value</span><span><span>=</span><span>\"</span>false<span>\"</span></span> <span>/></span></span>\n</code></pre></div><h3 id=\"step-6-在-application-中进行初始化配置\" tabindex=\"-1\"> Step 6. 在 <code>Application</code> 中进行初始化配置</h3>\n<div><pre><code><span>public</span> <span>class</span> <span>MyApplication</span> <span>extends</span> <span>Application</span> <span>{</span>\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>onCreate</span><span>(</span><span>)</span> <span>{</span>\n        <span>super</span><span>.</span><span>onCreate</span><span>(</span><span>)</span><span>;</span>\n\n        <span>setFirebaseEnable</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>private</span> <span>void</span> <span>setFirebaseEnable</span><span>(</span><span>)</span> <span>{</span>\n        <span>// Analytics</span>\n        <span>obtainAnalytics</span><span>(</span><span>)</span><span>.</span><span>setAnalyticsCollectionEnabled</span><span>(</span><span>true</span><span>)</span><span>;</span>\n        <span>// Crashlytics: release 传 true，debug 传 false</span>\n        <span>FirebaseCrashlytics</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>.</span><span>setCrashlyticsCollectionEnabled</span><span>(</span><span>!</span><span>BuildConfig</span><span>.</span><span>VPN_DEBUG</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>// 埋点时需要用到 FirebaseAnalytics 实例，所以对外提供 FirebaseAnalytics 对象</span>\n    <span>public</span> <span>static</span> <span>FirebaseAnalytics</span> <span>obtainAnalytics</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>FirebaseAnalytics</span><span>.</span><span>getInstance</span><span>(</span>app<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre></div><h2 id=\"_2-fcm-云消息\" tabindex=\"-1\"> 2. <code>FCM</code> 云消息</h2>\n<h2 id=\"_3-remote-config\" tabindex=\"-1\"> 3. <code>Remote Config</code></h2>\n<h2 id=\"_4-a-b-testing\" tabindex=\"-1\"> 4. <code>A/B Testing</code></h2>\n",
      "date_published": "2023-05-04T15:57:35.000Z",
      "date_modified": "2023-05-04T15:57:35.000Z",
      "authors": [],
      "tags": [
        "HNAP"
      ]
    },
    {
      "title": "学习笔记",
      "url": "https://zengkaiqiang562.github.io/zkq/study_note/",
      "id": "https://zengkaiqiang562.github.io/zkq/study_note/",
      "content_html": "<h4 id=\"享学-android-1、2期\" tabindex=\"-1\"> 享学 Android 1、2期</h4>\n<h4 id=\"码牛-android-2期\" tabindex=\"-1\"> 码牛 Android 2期</h4>\n<ol>\n<li>\n<p>kotlin 专题</p>\n</li>\n<li>\n<p>高级音视频专题</p>\n</li>\n</ol>\n<h4 id=\"黑马-c-32期\" tabindex=\"-1\"> 黑马 C++ 32期</h4>\n<h4 id=\"黑马前端-v6-5\" tabindex=\"-1\"> 黑马前端 v6.5</h4>\n<h4 id=\"flutter-开发实战详解\" tabindex=\"-1\"> Flutter 开发实战详解</h4>\n<h5 id=\"玩转-java-并发工具-精通-juc-成为并发多面手\" tabindex=\"-1\"> 玩转 Java 并发工具，精通 JUC，成为并发多面手</h5>\n<h4 id=\"一站式学习-java-网络编程全面理解-bio\" tabindex=\"-1\"> 一站式学习 Java 网络编程全面理解 BIO</h4>\n<h4 id=\"老男孩-linux-云计算-76期-高级-sre-运维课程\" tabindex=\"-1\"> 老男孩 Linux 云计算（76期）高级 SRE 运维课程</h4>\n",
      "date_published": "2023-04-09T15:40:54.000Z",
      "date_modified": "2023-04-09T15:40:54.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "C/C++",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/",
      "content_html": "<p><strong>黑马 <code>C/C++ 32</code> 期</strong></p>\n",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "第01天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day01.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day01.html",
      "content_html": "<h2 id=\"_1-system-函数\" tabindex=\"-1\"> 1. <code>system</code> 函数</h2>\n<p><strong>作用：</strong> 执行系统命令。如：<code>pause</code>、<code>cmd</code>、<code>calc</code>、<code>mspaint</code>、<code>notepad</code> ...</p>\n<p><strong>示例：</strong></p>\n<div><pre><code><span>system</span><span>(</span><span>\"cmd\"</span><span>)</span><span>;</span>  \n<span>system</span><span>(</span><span>\"calc\"</span><span>)</span><span>;</span>\n<span>system</span><span>(</span><span>\"cls\"</span><span>)</span><span>;</span> <span>// 清屏命令：cls;</span>\n</code></pre></div><h2 id=\"_2-gcc-编译步骤-预处理-编译-汇编-链接\" tabindex=\"-1\"> 2. <code>gcc</code> 编译步骤（预处理-编译-汇编-链接）</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day01/01.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>（-o 选项仅用于指定输出文件名, 不使用 -o, 仅执行 gcc hello.c , 则默认生成 a.exe）\ngcc -E hello.c -o hello.i\ngcc -S hello.i -o hello.s\ngcc -c hello.s -o hello.o\ngcc hello.o -o hello.exe\n</code></pre></div><p><strong>1. 预处理</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">命名选项</th>\n<th style=\"text-align:left\">输出文件</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>-E</code></td>\n<td style=\"text-align:left\"><code>xxx.i</code> 预处理文件（纯文本文件）</td>\n</tr>\n</tbody>\n</table>\n<div><pre><code>gcc -E xxx.c -o xxx.i\n\n1）头文件展开（即 生成的预处理文件 xxx.i 中会包括头文件的所有内容）。 \n    --- 不检查语法错误（但会将语法错误提示出来，仍能成预处理文件）。可以展开任意文件。\n2）宏定义替换。\n    --- 将宏名替换为宏值。\n3）替换注释。\n    --- 变成空行\n4）展开条件编译。\n    --- 根据条件来展开指令。\n</code></pre></div><p><strong>2. 编译</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">命名选项</th>\n<th style=\"text-align:left\">输出文件</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>-S</code></td>\n<td style=\"text-align:left\"><code>xxx.s</code> 汇编文件（纯文本文件，即汇编代码文件）</td>\n</tr>\n</tbody>\n</table>\n<div><pre><code>gcc -S hello.i -o hello.s\n\n1）逐行检查语法错误。【重点】    \n    --- 整个编译4步骤中最耗时的过程。\n2）将 C 程序翻译成汇编指令，得到 .s 汇编文件。\n</code></pre></div><p><strong>3. 汇编</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">命名选项</th>\n<th style=\"text-align:left\">输出文件</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>-c</code></td>\n<td style=\"text-align:left\"><code>xxx.o</code> 目标文件（二进制文件）</td>\n</tr>\n</tbody>\n</table>\n<div><pre><code>gcc -c hello.s -o hello.o\n\n1）翻译：将汇编指令翻译成对应的二进制编码。\n</code></pre></div><p><strong>4. 链接</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">命名选项</th>\n<th style=\"text-align:left\">输出文件</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">无</td>\n<td style=\"text-align:left\"><code>xxx.exe</code> 可执行文件（二进制文件）</td>\n</tr>\n</tbody>\n</table>\n<div><pre><code>gcc  hello.o -o hello.exe\n\n1）数据段合并\n2）数据地址回填\n3）库引入\n</code></pre></div><h2 id=\"_3-查找程序所依赖的动态库\" tabindex=\"-1\"> 3. 查找程序所依赖的动态库</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day01/02.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p><code>windows</code> 中 <code>.dll</code> 文件就是库文件。</p>\n</blockquote>\n<h2 id=\"_4-调试程序\" tabindex=\"-1\"> 4. 调试程序</h2>\n<p><strong><code>VS</code> 中添加行号：</strong></p>\n<div><pre><code>工具 -> 选项 -> 文本编辑器 -> C/C++ -> 行号 选中。\n</code></pre></div><p><strong>调试步骤：</strong></p>\n<div><pre><code>1. 设置断点。F5 启动调试\n2. 停止的位置，是尚未执行的指令。\n3. 逐语句执行一下条（F11）：进入函数内部，逐条执行跟踪。\n3. 逐过程执行一下条（F10）：不进入函数内部，逐条执行程序。\n4. 添加监视：调试 -> 窗口 -> 监视：输入监视变量名。自动监视变量值的变化。\n</code></pre></div><p><strong><code>VS</code> 调试过程中查看对应的汇编指令：</strong></p>\n<div><pre><code>调用 -> 窗口 -> 反汇编\n</code></pre></div><h2 id=\"_5-在指定路径下打开-cmd-命令行\" tabindex=\"-1\"> 5. 在指定路径下打开 <code>cmd</code> 命令行</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day01/03.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>如上图，在路径框内输入 <code>cmd</code> ，按回车即可打开 <code>cmd</code>，并定位到当前目录</p>\n</blockquote>\n",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-16T03:14:27.000Z",
      "authors": [],
      "tags": [
        "C语言基础"
      ]
    },
    {
      "title": "第02天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day02.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day02.html",
      "content_html": "<h2 id=\"_1-常量-不会变化的数据-不能被修改\" tabindex=\"-1\"> 1. 常量（不会变化的数据，不能被修改）</h2>\n<p><strong>三种类型的常量：</strong></p>\n<div><pre><code>1. \"hello\"、'A'、-10、3.1415926（浮点常量）\n\n2. #define PI 3.1415\n    【推荐】\n    【强调】：没有分号结束标记。 \n    【定义宏】：#define 宏名 宏值 \n\n3. const int a = 10;\n    定义语法：const 类型名 变量名 = 变量值。【不推荐，通过指针可修改】\n    const 关键字：被该关键字修饰的变量，表示为只读变量。\n</code></pre></div><h2 id=\"_2-变量-会变化的数据-能被修改\" tabindex=\"-1\"> 2. 变量（会变化的数据，能被修改）</h2>\n<p><strong>定义语法：</strong></p>\n<div><pre><code>类型名 变量名 = 变量值。（一般方法）\n</code></pre></div><p><strong>变量三要素：</strong></p>\n<div><pre><code>类型名、变量名、变量值。\n\n示例：\nint r = 3;    \nfloat s = PI*r*r;（变量值是一个表达式）\n</code></pre></div><p><strong>变量的定义 &amp; 变量的声明</strong></p>\n<div><pre><code>变量的定义： \n    int a = 40;\n\n变量的声明： \n    1）int a; // 没有变量值的变量定义叫做声明。\n    2）extern int a; // 添加了关键字 extern。\n\n1. 变量定义会开辟内存空间。变量声明不会开辟内存空间。\n2. 变量要想使用必须有定义。\n    当编译器编译程序时，在变量使用之前，必须要看到变量定义。如果没有看到变量定义，编译器会自动找寻一个变量声明提升成为定义。\n    如果该变量的声明前有 extern 关键字，无法提升。\n</code></pre></div><blockquote>\n<p>【建议】：定义变量时。尽量不要重名。</p>\n</blockquote>\n<h2 id=\"_3-标识符-变量和常量的统称\" tabindex=\"-1\"> 3. 标识符（变量和常量的统称）</h2>\n<p><strong>命名规则：</strong></p>\n<div><pre><code>1. 通常常量使用大写、变量使用小写。大小写严格区分。\n\n2. 只能使用字母、数字、下划线（\"_\"）命名标识符。且数字不能开头。 a-z/A-Z/0-9/_\n    int a5ir = 10; // ok \n    int _34F = 6; // ok\n    float s2_i85c = 5.4;  // ok\n    int 98ti_54 = 4;  // error\n\n3. 禁止使用关键字和系统函数作为标识符名称。 main/system/printf/sleep ...\n</code></pre></div><h2 id=\"_4-sizeof-关键字-sizeof-不是函数-只是一个关键字\" tabindex=\"-1\"> 4. <code>sizeof</code> 关键字（<code>sizeof</code> 不是函数，只是一个关键字）</h2>\n<p><code>sizeof</code> 不是函数，只是一个关键字，所以不需要依赖任何头文件。</p>\n<p><code>sizeof</code> 用来求一个变量、类型的大小。</p>\n<p><code>sizeof</code> 的返回值为 <code>size_t</code>，<code>size_t</code> 类型在 32 位操作系统下是 <code>unsigned int</code>，是一个无符号的整数，使用 <code>%u</code> 接收返回值。</p>\n<p><strong>使用方式：</strong></p>\n<div><pre><code>方式1：sizeof(类型名) -- sizeof(int)\n\n方式2：sizeof(变量名) -- int a = 20； sizeof(a)\n\n【了解】：sizeof 变量名/类型名  （这种去掉括号的方式不推荐使用，因为不方便阅读）\n    举例1： sizeof int \n    举例2： sizeof a\n</code></pre></div><h2 id=\"_5-数据类型\" tabindex=\"-1\"> 5. 数据类型</h2>\n<h3 id=\"_5-1-有符号整型-signed\" tabindex=\"-1\"> 5.1 有符号整型（<code>signed</code>）</h3>\n<p>类型前缀 <code>signed</code> 表示有符号（类型默认为有符号，所以通常省略前缀 <code>signed</code>）</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>整型类型</strong></th>\n<th style=\"text-align:left\"><strong>格式符</strong></th>\n<th style=\"text-align:left\"><strong>所占字节</strong></th>\n<th style=\"text-align:left\"><strong>使用示例</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>int</code></td>\n<td style=\"text-align:left\"><code>%d</code></td>\n<td style=\"text-align:left\"><code>4</code> 字节</td>\n<td style=\"text-align:left\"><code>int 名 = 值;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>short</code></td>\n<td style=\"text-align:left\"><code>%hd</code></td>\n<td style=\"text-align:left\"><code>2</code> 字节</td>\n<td style=\"text-align:left\"><code>short 名 = 值;</code> <code>short s1 = 3;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>long</code></td>\n<td style=\"text-align:left\"><code>%ld</code></td>\n<td style=\"text-align:left\"><code>4</code> 字节（windows 32/64：<code>4B</code> ； Linux 32位：<code>4B</code> ，64位：<code>8B</code> )）</td>\n<td style=\"text-align:left\"><code>long 名 = 值;</code> <code>long len = 6;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>long long</code></td>\n<td style=\"text-align:left\"><code>%lld</code></td>\n<td style=\"text-align:left\"><code>8</code> 字节</td>\n<td style=\"text-align:left\"><code>long long 名= 值;</code> <code>long long llen = 70;</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_5-2-无符号整型-unsigned\" tabindex=\"-1\"> 5.2 无符号整型（<code>unsigned</code>）</h3>\n<p>类型前缀 <code>unsigned</code> 表示无符号。无符号意味着只关心数据量，不关心方向（没有正负）</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>整型类型</strong></th>\n<th style=\"text-align:left\"><strong>格式符</strong></th>\n<th style=\"text-align:left\"><strong>所占字节</strong></th>\n<th style=\"text-align:left\"><strong>使用示例</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>unsigned int</code></td>\n<td style=\"text-align:left\"><code>%u</code></td>\n<td style=\"text-align:left\"><code>4</code> 字节</td>\n<td style=\"text-align:left\"><code>unsigned int 名 = 值;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>unsigned short</code></td>\n<td style=\"text-align:left\"><code>%hu</code></td>\n<td style=\"text-align:left\"><code>2</code> 字节</td>\n<td style=\"text-align:left\"><code>unsigned short 名 = 值;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>unsigned long</code></td>\n<td style=\"text-align:left\"><code>%lu</code></td>\n<td style=\"text-align:left\"><code>4</code> 字节（windows 32/64：<code>4B</code> ； Linux 32位：<code>4B</code> ，64位：<code>8B</code> )）</td>\n<td style=\"text-align:left\"><code>unsigned long 名 = 值;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>unsigned long long</code></td>\n<td style=\"text-align:left\"><code>%llu</code></td>\n<td style=\"text-align:left\"><code>8</code> 字节</td>\n<td style=\"text-align:left\"><code>unsigned long long 名 = 值;</code></td>\n</tr>\n</tbody>\n</table>\n<p><strong>示例：</strong></p>\n<div><pre><code><span>unsigned</span> <span>int</span> a <span>=</span> <span>10u</span><span>;</span>  <span>// 简写成 unsigned int a = 10;</span>\n<span>unsigned</span> <span>short</span> b <span>=</span> <span>20u</span><span>;</span><span>// 简写成 unsigned short b = 20;</span>\n<span>unsigned</span> <span>long</span> c <span>=</span> <span>30Lu</span><span>;</span>\n<span>unsigned</span> <span>long</span> <span>long</span> d <span>=</span> <span>40LLu</span><span>;</span>\n<span>printf</span><span>(</span><span>\"unsigned int 型数据值：%u\\n\"</span><span>,</span> a<span>)</span><span>;</span>\n<span>printf</span><span>(</span><span>\"unsigned short 型数据值：%hu\\n\"</span><span>,</span> b<span>)</span><span>;</span>\n<span>printf</span><span>(</span><span>\"unsigned long 型数据值：%lu\\n\"</span><span>,</span> c<span>)</span><span>;</span>\n<span>printf</span><span>(</span><span>\"unsigned long long 型数据值：%llu\\n\"</span><span>,</span> d<span>)</span><span>;</span>\n</code></pre></div><div><pre><code><span>int</span> a <span>=</span> <span>3</span><span>;</span>\n<span>short</span> b <span>=</span> <span>4</span><span>;</span>\n<span>long</span> c <span>=</span> <span>5</span><span>;</span>                <span>// 5L  5l</span>\n<span>long</span> <span>long</span> d <span>=</span> <span>6</span><span>;</span>  <span>// 6LL  6ll</span>\n<span>printf</span><span>(</span><span>\"sizeof(int) = %d\\n\"</span><span>,</span> <span>sizeof</span><span>(</span><span>int</span><span>)</span><span>)</span><span>;</span>\n<span>printf</span><span>(</span><span>\"sizeof(short) = %d\\n\"</span><span>,</span> <span>sizeof</span><span>(</span><span>short</span><span>)</span><span>)</span><span>;</span>\n<span>printf</span><span>(</span><span>\"sizeof(long) = %d\\n\"</span><span>,</span> <span>sizeof</span><span>(</span><span>long</span><span>)</span><span>)</span><span>;</span>\n<span>printf</span><span>(</span><span>\"sizeof(long long) = %d\\n\"</span><span>,</span> <span>sizeof</span><span>(</span><span>long</span> <span>long</span><span>)</span><span>)</span><span>;</span>\n\n<span>printf</span><span>(</span><span>\"--------------------------------------\\n\"</span><span>)</span><span>;</span>\n\n<span>unsigned</span> <span>int</span> aun <span>=</span> <span>3</span><span>;</span>             <span>// 3u</span>\n<span>unsigned</span> <span>short</span> bun <span>=</span> <span>4</span><span>;</span>           <span>// 4u</span>\n<span>unsigned</span> <span>long</span> cun <span>=</span> <span>5</span><span>;</span>            <span>// 5lu</span>\n<span>unsigned</span> <span>long</span> <span>long</span> dun <span>=</span> <span>6</span><span>;</span><span>// 6llu</span>\n<span>printf</span><span>(</span><span>\"sizeof(unsigned int) = %d\\n\"</span><span>,</span> <span>sizeof</span><span>(</span><span>unsigned</span> <span>int</span><span>)</span><span>)</span><span>;</span> <span>// aun</span>\n<span>printf</span><span>(</span><span>\"sizeof(unsigned short) = %d\\n\"</span><span>,</span> <span>sizeof</span><span>(</span><span>unsigned</span> <span>short</span><span>)</span><span>)</span><span>;</span>\n<span>printf</span><span>(</span><span>\"sizeof(unsigned long) = %d\\n\"</span><span>,</span> <span>sizeof</span><span>(</span><span>unsigned</span> <span>long</span><span>)</span><span>)</span><span>;</span>\n<span>printf</span><span>(</span><span>\"sizeof(unsigned long long) = %d\\n\"</span><span>,</span> <span>sizeof</span><span>(</span><span>unsigned</span> <span>long</span> <span>long</span><span>)</span><span>)</span><span>;</span>\n</code></pre></div><h3 id=\"_5-3-char-字符类型-1-字节\" tabindex=\"-1\"> 5.3 <code>char</code> 字符类型（<code>1</code> 字节）</h3>\n<p>格式匹配符： <code>%c</code>。</p>\n<p>存储一个字符，如 <code>'A'</code>、<code>'a'</code>、<code>'%'</code>、<code>'#'</code>、<code>'0'</code>。本质是 <code>ASCII</code> 码，即：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>字符</strong></th>\n<th style=\"text-align:left\"><strong>对应的 <code>ASCII</code> 码</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>'A'</code></td>\n<td style=\"text-align:left\"><code>65</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>'a'</code></td>\n<td style=\"text-align:left\"><code>97</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>'0'</code></td>\n<td style=\"text-align:left\"><code>48</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>'\\n'</code> （转义字符）</td>\n<td style=\"text-align:left\"><code>10</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>'\\0'</code> （转义字符）</td>\n<td style=\"text-align:left\"><code>0</code></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>转义字符：<code>'\\'</code> 将普通字符转为特殊意。将特殊字符转为本身意。</p>\n</blockquote>\n<h3 id=\"_5-4-浮点型-float、double\" tabindex=\"-1\"> 5.4 浮点型（<code>float</code>、<code>double</code>）</h3>\n<p><strong><code>float</code>（单精度浮点型，<code>4</code> 字节）</strong></p>\n<div><pre><code>使用示例：float v1 = 4.345;\n格式匹配符：%f \n默认保留 6 位小数。\n</code></pre></div><p><strong><code>double</code>（双精度浮点型，<code>8</code> 字节）</strong></p>\n<div><pre><code>使用示例：double v2 = 5.678;\n格式匹配符：%lf \n</code></pre></div><p><strong>无符号的浮点型</strong></p>\n<div><pre><code><span>unsigned</span> <span>float</span> v1 <span>=</span> <span>4.345</span><span>;</span> <span>// 无符号的 float 数据</span>\n<span>unsigned</span> <span>double</span> v2 <span>=</span> <span>5.678</span><span>;</span> <span>// 无符号的 float 数据</span>\n</code></pre></div><p><strong>格式化输出浮点型</strong></p>\n<div><pre><code><span>// 输出的含义为：显示 8 位数（包含小数点），不足 8 位用 0 填充。并且保留 3 位小数。对第4 位做四舍五入。</span>\n<span>printf</span><span>(</span><span>\"n = %08.3f\\n\"</span><span>,</span> n<span>)</span><span>;</span>\n<span>// 不足 8 位用空格填充。</span>\n<span>printf</span><span>(</span><span>\"n = %8.3f\\n\"</span><span>,</span> n<span>)</span><span>;</span>  \n</code></pre></div><h2 id=\"_6-进制\" tabindex=\"-1\"> 6. 进制</h2>\n<h3 id=\"_6-1-八进制\" tabindex=\"-1\"> 6.1 八进制</h3>\n<p><strong>定义八进制数语法：</strong> 零开头，每位数 <code>0~7</code> 之间。</p>\n<p><strong>八进制转十进制：</strong></p>\n<div><pre><code>056 -- 46\n    5x8+6=46\n    \n0124 -- 84\n    0x8x8x8+1x8x8+2x8+4=64+16+4=84\n</code></pre></div><p><strong>八进制转二进制：</strong></p>\n<blockquote>\n<p>原理：按 <code>421</code> 码将每个八进制位展开。</p>\n</blockquote>\n<div><pre><code>056 -- 101110\n    5 -- 101\n    6 -- 110\n\n05326 -- 101011010110\n    5 -- 101\n    3 -- 011 \n    2 -- 010\n    6 -- 110\n</code></pre></div><p><strong>二进制转八进制：</strong></p>\n<blockquote>\n<p>原理：自右向左，每 <code>3</code> 位一组，按 <code>421</code> 码转换。高位不足三位补 <code>0</code></p>\n</blockquote>\n<div><pre><code>1 010 111 010 110 -- 012726\n</code></pre></div><h3 id=\"_6-2-十六进制\" tabindex=\"-1\"> 6.2 十六进制</h3>\n<p><strong>语法：</strong></p>\n<div><pre><code>以 0x 开头，每位取 0-9/A-F/a-f\n\nA -- 10\nB -- 11\nC -- 12\nD -- 13\nE -- 14\nF -- 15\n</code></pre></div><p><strong>十六进制转十进制：</strong></p>\n<div><pre><code>0x1A： 16+10 = 26\n0x13F：15+3x16+256\n</code></pre></div><p><strong>十六进制转二进制：</strong></p>\n<div><pre><code>0x1A： 00011010\n0x13F：000100111111\n</code></pre></div><p><strong>二进制转十六进制：</strong></p>\n<blockquote>\n<p>原理：自右向左，每 <code>4</code> 位一组，按 <code>8421</code> 码转换。高位不足三位补 <code>0</code></p>\n</blockquote>\n<div><pre><code>0001 0011 1111 -- 13F\n</code></pre></div><h3 id=\"_6-3-进制转换技巧-凑数法\" tabindex=\"-1\"> 6.3 进制转换技巧（凑数法）</h3>\n<div><pre><code>321:    256 128 64 32 16 8 4 2 1\n        1   0   1  0  0  0 0 0 1\n\n以上表示十进制数 321 转二进制数 1 0100 0001 的过程。\n\n凑数法：即列举出不超过 321 的所有 2 的幂指数，然后从大到小怼出 321 来\n</code></pre></div><div><pre><code>321:    256 16 1\n        1   4  1\n\n以上表示十进制数 321 转十六进制数 141 的过程。\n\n凑数法：即列举出不超过 321 的所有 16 的幂指数，然后从大到小怼出 321 来\n</code></pre></div><div><pre><code>321:    64 8 1\n        5  0 1\n\n以上表示十进制数 321 转八进制数 501 的过程。\n\n凑数法：即列举出不超过 321 的所有 8 的幂指数，然后从大到小怼出 321 来\n</code></pre></div><h3 id=\"_6-4-注意-不能给变量直接复制二进制数据\" tabindex=\"-1\"> 6.4 注意：不能给变量直接复制二进制数据</h3>\n<div><pre><code><span>int</span> m <span>=</span> <span>0x15F4</span><span>;</span>\n<span>int</span> n <span>=</span> <span>345</span><span>;</span>\n<span>int</span> var <span>=</span> <span>010011</span><span>;</span> <span>// 不允许。</span>\n</code></pre></div><h3 id=\"_6-5-八进制-十六进制的格式化打印\" tabindex=\"-1\"> 6.5 八进制 &amp; 十六进制的格式化打印</h3>\n<div><pre><code><span>int</span> a <span>=</span> <span>0x2C</span><span>;</span>  <span>// 等价 0x2c</span>\n<span>printf</span><span>(</span><span>\"10进制显示 a = %d\\n\"</span><span>,</span> a<span>)</span><span>;</span>\n<span>printf</span><span>(</span><span>\"8进制显示 a = %o\\n\"</span><span>,</span> a<span>)</span><span>;</span>\n<span>printf</span><span>(</span><span>\"16进制显示 a = %x\\n\"</span><span>,</span> a<span>)</span><span>;</span>\n</code></pre></div><h2 id=\"_7-原码-反码-补码\" tabindex=\"-1\"> 7. 原码 &amp; 反码 &amp; 补码</h2>\n<p><strong>原码：</strong></p>\n<div><pre><code> 43 -> 00101011\n-43 -> 10101011\n</code></pre></div><p><strong>反码：</strong></p>\n<div><pre><code> 43 -> 00101011\n-43 -> 10101011  \n       11010100  反码：符号位不变，其它部分取反\n</code></pre></div><p><strong>补码（现今计算机采用的存储形式）：</strong></p>\n<div><pre><code> 43 -> 00101011 ： 正数不变\n-43 -> 11010101 ： 负数，最高位表符号位不变，其余取反+1\n</code></pre></div><p><strong>总结：</strong></p>\n<div><pre><code>对于正数，三码合一\n对于负数，补码 = 原码取反（符号位不变）再加 1\n</code></pre></div><div><pre><code>两数相减 等价于 正负数相加\n43 - 27 &lt;=> 43 + -27\n</code></pre></div><div><pre><code>人为规定： 10000000 => -128 （即 -0 = -128）\n</code></pre></div>",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-16T03:14:27.000Z",
      "authors": [],
      "tags": [
        "C语言基础"
      ]
    },
    {
      "title": "第03天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day03.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day03.html",
      "content_html": "<h2 id=\"_1-类型限定符\" tabindex=\"-1\"> 1. 类型限定符</h2>\n<h3 id=\"_1-1-extern\" tabindex=\"-1\"> 1.1 <code>extern</code></h3>\n<div><pre><code>表示声明；\nextern 声明的变量没有建立存储空间；\n不能提升。\n</code></pre></div><h3 id=\"_1-2-const\" tabindex=\"-1\"> 1.2 <code>const</code></h3>\n<div><pre><code>限定一个变量为只读变量\n</code></pre></div><h3 id=\"_1-3-volatile\" tabindex=\"-1\"> 1.3 <code>volatile</code></h3>\n<div><pre><code>防止编译器优化代码。\n使用：volatile int flg = 0;\n</code></pre></div><h3 id=\"_1-4-register\" tabindex=\"-1\"> 1.4 <code>register</code></h3>\n<div><pre><code>定义一个寄存器变量。没有内存地址，所以不能对寄存器变量使用指针。\nregister 是建议型的指令，而不是命令型的指令，如果 CPU 有空闲寄存器，那么 register 就生效，如果没有空闲寄存器，那么 register 无效。\n使用：register int a = 10;\n</code></pre></div><h2 id=\"_2-字符串\" tabindex=\"-1\"> 2. 字符串</h2>\n<p>C语言中，用双引号引着的一串字符，称之为字符串。一定有一个结束标记 <code>'\\0'</code></p>\n<div><pre><code>char ch = 'A';  占一个字节\n字符串 \"abc\" 包含 4 个字符：'a'、'b'、'c'、'\\0'\n'a' 不等价 \"a\"（字符串 \"a\" 包括 2 个字符：'a'、'\\0'）\n</code></pre></div><h3 id=\"_2-1-打印字符串时-遇到结束标记-0-才会停止打印\" tabindex=\"-1\"> 2.1 打印字符串时，遇到结束标记 <code>'\\0'</code> 才会停止打印</h3>\n<p>如果字符串变量 <code>str</code> 没有以 <code>'\\0'</code> 结束，那么 <code>printf</code> 函数打印时，就会继续打印 <code>str</code> 变量之后的内存地址中的值，直到遇到 <code>'\\0'</code> 为止。</p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day03/01.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_3-printf-函数\" tabindex=\"-1\"> 3. <code>printf</code> 函数</h2>\n<h3 id=\"_3-1-printf-函数支持的格式匹配符\" tabindex=\"-1\"> 3.1 <code>printf</code> 函数支持的格式匹配符</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>格式符</strong></th>\n<th style=\"text-align:left\"><strong>作用</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>%s</code></td>\n<td style=\"text-align:left\">打印字符串，从字符串的第一个字符开始挨个打印，打印到 <code>'\\0'</code> 结束</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>%d</code></td>\n<td style=\"text-align:left\">打印整数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>%c</code></td>\n<td style=\"text-align:left\">打印字符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>%x</code></td>\n<td style=\"text-align:left\">打印十六进制数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>%u</code></td>\n<td style=\"text-align:left\">打印无符号</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>%m.n</code></td>\n<td style=\"text-align:left\">打印浮点数时用到，一共有 <code>m</code> 位（整数、小数、小数点），<code>n</code> 位小数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>%0m.nf</code></td>\n<td style=\"text-align:left\">其中 <code>f</code> 表示打印浮点数，一共有 <code>m</code> 位（整数、小数、小数点），<code>n</code> 位小数。<code>0</code> 表示不足 <code>m</code> 位时用 <code>0</code> 凑够 <code>m</code> 位</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>%%</code></td>\n<td style=\"text-align:left\">显示一个 <code>%</code>。 转义字符 <code>'\\'</code> 对 <code>%</code> 转义无效。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>%Ns</code></td>\n<td style=\"text-align:left\">显示 <code>N</code> 个字符的字符串。不足 <code>N</code> 用空格向左填充</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>%0Ns</code></td>\n<td style=\"text-align:left\">显示 <code>N</code> 个字符的字符串。不足 <code>N</code> 用 <code>0</code> 向左填充</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>%-Ns</code></td>\n<td style=\"text-align:left\">显示 <code>N</code> 个字符的字符串。不足 <code>N</code> 用空格向右填充</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"_4-putchar-函数\" tabindex=\"-1\"> 4. <code>putchar</code> 函数</h2>\n<div><pre><code>输出一个字符到屏幕。\n可以直接传入字符的 ASCII 码。\n不能输出字符串。\n'abc' 既不是一个有效字符，也不是一个有效字符串。\n常用 putchar('\\n'); 来打印换行。使用 printf(\"\\n\"); 也可以打印换行\n</code></pre></div><h2 id=\"_5-scanf-函数\" tabindex=\"-1\"> 5. <code>scanf</code> 函数</h2>\n<p>从键盘接收用户输入。</p>\n<p><strong>1. 接收整数 <code>%d</code></strong></p>\n<div><pre><code><span>int</span> a<span>,</span> b<span>,</span> c<span>;</span>  <span>// 创建变量空间，等待接收用户输入。</span>\n<span>scanf</span><span>(</span><span>\"%d %d %d\"</span><span>,</span> <span>&amp;</span>a<span>,</span> <span>&amp;</span>b<span>,</span> <span>&amp;</span>c<span>)</span><span>;</span>\n</code></pre></div><p><strong>2. 接收字符 <code>%c</code></strong></p>\n<div><pre><code><span>char</span> a<span>,</span> b<span>,</span> c<span>;</span>\n<span>scanf</span><span>(</span><span>\"%c %c %c\"</span><span>,</span> <span>&amp;</span>a<span>,</span> <span>&amp;</span>b<span>,</span> <span>&amp;</span>c<span>)</span><span>;</span>\n</code></pre></div><p><strong>3. 接收字符串 <code>%s</code></strong></p>\n<div><pre><code><span>char</span> str<span>[</span><span>10</span><span>]</span><span>;</span> <span>// 定义一个数组，用来接收用户输入的字符串。</span>\n<span>scanf</span><span>(</span><span>\"%s\"</span><span>,</span> str<span>)</span><span>;</span> <span>// 变量名要取地址传递给 scanf，数组名本身表示地址，不用 &amp; 符。</span>\n</code></pre></div><h3 id=\"_5-1-接收字符串时的注意项\" tabindex=\"-1\"> 5.1 接收字符串时的注意项</h3>\n<div><pre><code>1. scanf 具有安全隐患。如果存储空间不足，数据能存储到内存中，但不被保护（即存储到参数变量内存范围之外的地址中去了）。\n  【因此，空间不足不要使用】\n2. scanf 函数接收字符串时，碰到 空格 和 换行 会自动终止。不能使用 scanf 的 %s 接收带有空格的字符串。\n</code></pre></div><h3 id=\"_5-2-解决-scanf-4996-错误\" tabindex=\"-1\"> 5.2 解决 <code>scanf</code> <code>4996</code> 错误</h3>\n<div><pre><code>将 #define _CRT_SECURE_NO_WARNINGS  添加到程序第一行。\n</code></pre></div><h2 id=\"_6-getchar-函数\" tabindex=\"-1\"> 6. <code>getchar</code> 函数</h2>\n<div><pre><code>从键盘获取用户输入的一个字符。\n返回该获取的字符的 ASCII 码。\n</code></pre></div><h2 id=\"_7-运算符\" tabindex=\"-1\"> 7. 运算符</h2>\n<h3 id=\"_7-1-运算符优先级\" tabindex=\"-1\"> 7.1 运算符优先级</h3>\n<div><pre><code>[] () > ++ -- (强转) sizeof > 算数运算（先乘除取余，后加减）> 比较运算 > 逻辑运算 > 三目运算（条件运算）> 赋值运算 > 逗号运算 \n</code></pre></div><table>\n    <tr>\n        <th>优先级</th>\n        <th>运算符</th>\n        <th>名称或含义</th>\n        <th>使用形式</th>\n        <th>结合方向</th>\n        <th>说明</th>\n    </tr>\n    <tr>\n        <td rowspan=\"4\">1</td>\n        <td>[]</td>\n        <td>数组下标</td>\n        <td>数组名[常量表达式]</td>\n        <td rowspan=\"4\">左到右</td>\n        <td>--</td>\n    </tr>\n    <tr>\n        <td>()</td>\n        <td>圆括号</td>\n        <td>(表达式）/函数名(形参表)</td>\n        <td>--</td>\n    </tr>\n    <tr>\n        <td>.</td>\n        <td>成员选择（对象）</td>\n        <td>对象.成员名</td>\n        <td>--</td>\n    </tr>\n    <tr>\n        <td>-></td>\n        <td>成员选择（指针）</td>\n        <td>对象指针->成员名</td>\n        <td>--</td>\n    </tr>\n    <tr>\n        <td rowspan=\"9\">2</td>\n        <td>-</td>\n        <td>负号运算符</td>\n        <td>-表达式</td>\n        <td rowspan=\"9\">右到左</td>\n        <td rowspan=\"7\">单目运算符</td>\n    </tr>\n    <tr>\n        <td>~</td>\n        <td>按位取反运算符</td>\n        <td>~表达式</td>\n    </tr>\n    <tr>\n        <td>++</td>\n        <td>自增运算符</td>\n        <td>++变量名/变量名++</td>\n    </tr>\n    <tr>\n        <td>--</td>\n        <td>自减运算符</td>\n        <td>--变量名/变量名--</td>\n    </tr>\n    <tr>\n        <td>*</td>\n        <td>取值运算符</td>\n        <td>*指针变量</td>\n    </tr>\n    <tr>\n        <td>&</td>\n        <td>取地址运算符</td>\n        <td>&变量名</td>\n    </tr>\n    <tr>\n        <td>!</td>\n        <td>逻辑非运算符</td>\n        <td>!表达式</td>\n    </tr>\n    <tr>\n        <td>(类型)</td>\n        <td>强制类型转换</td>\n        <td>(数据类型)表达式</td>\n        <td>--</td>\n    </tr>\n    <tr>\n        <td>sizeof</td>\n        <td>长度运算符</td>\n        <td>sizeof(表达式)</td>\n        <td>--</td>\n    </tr>\n    <tr>\n        <td rowspan=\"3\">3</td>\n        <td>/</td>\n        <td>除</td>\n        <td>表达式/表达式</td>\n        <td rowspan=\"3\">左到右</td>\n        <td rowspan=\"3\">双目运算符</td>\n    </tr>\n    <tr>\n        <td>*</td>\n        <td>乘</td>\n        <td>表达式*表达式</td>\n    </tr>\n    <tr>\n        <td>%</td>\n        <td>余数（取模）</td>\n        <td>整型表达式%整型表达式</td>\n    </tr>\n    <tr>\n        <td rowspan=\"2\">4</td>\n        <td>+</td>\n        <td>加</td>\n        <td>表达式+表达式</td>\n        <td rowspan=\"2\">左到右</td>\n        <td rowspan=\"2\">双目运算符</td>\n    </tr>\n    <tr>\n        <td>-</td>\n        <td>减</td>\n        <td>表达式-表达式</td>\n    </tr>\n    <tr>\n        <td rowspan=\"2\">5</td>\n        <td>&lt;&lt;</td>\n        <td>左移</td>\n        <td>变量&lt;&lt;表达式</td>\n        <td rowspan=\"2\">左到右</td>\n        <td rowspan=\"2\">双目运算符</td>\n    </tr>\n    <tr>\n        <td>&gt;&gt;</td>\n        <td>右移</td>\n        <td>变量&gt;&gt;表达式</td>\n    </tr>\n    <tr>\n        <td rowspan=\"4\">6</td>\n        <td>&gt;</td>\n        <td>大于</td>\n        <td>表达式&gt;表达式</td>\n        <td rowspan=\"4\">左到右</td>\n        <td rowspan=\"4\">双目运算符</td>\n    </tr>\n    <tr>\n        <td>&gt;=</td>\n        <td>大于等于</td>\n        <td>表达式&gt;=表达式</td>\n    </tr>\n    <tr>\n        <td>&lt;</td>\n        <td>小于</td>\n        <td>表达式&lt;表达式</td>\n    </tr>\n    <tr>\n        <td>&lt;=</td>\n        <td>小于等于</td>\n        <td>表达式&lt;=表达式</td>\n    </tr>\n    <tr>\n        <td rowspan=\"2\">7</td>\n        <td>==</td>\n        <td>等于</td>\n        <td>表达式==表达式</td>\n        <td rowspan=\"2\">左到右</td>\n        <td rowspan=\"2\">双目运算符</td>\n    </tr>\n    <tr>\n        <td>!=</td>\n        <td>不等于</td>\n        <td>表达式!=表达式</td>\n    </tr>\n    <tr>\n        <td>8</td>\n        <td>&</td>\n        <td>按位与</td>\n        <td>表达式&表达式</td>\n        <td>左到右</td>\n        <td>双目运算符</td>\n    </tr>\n    <tr>\n        <td>9</td>\n        <td>^</td>\n        <td>按位异或</td>\n        <td>表达式^表达式</td>\n        <td>左到右</td>\n        <td>双目运算符</td>\n    </tr>\n    <tr>\n        <td>10</td>\n        <td>|</td>\n        <td>按位或</td>\n        <td>表达式|表达式</td>\n        <td>左到右</td>\n        <td>双目运算符</td>\n    </tr>\n    <tr>\n        <td>11</td>\n        <td>&&</td>\n        <td>逻辑与</td>\n        <td>表达式&&表达式</td>\n        <td>左到右</td>\n        <td>双目运算符</td>\n    </tr>\n    <tr>\n        <td>12</td>\n        <td>||</td>\n        <td>逻辑或</td>\n        <td>表达式||表达式</td>\n        <td>左到右</td>\n        <td>双目运算符</td>\n    </tr>\n    <tr>\n        <td>13</td>\n        <td>?:</td>\n        <td>条件运算符</td>\n        <td>表达式1 ? 表达式2 : 表达式3</td>\n        <td>右到左</td>\n        <td>三目运算符</td>\n    </tr>\n    <tr>\n        <td rowspan=\"11\">14</td>\n        <td>=</td>\n        <td>赋值运算符</td>\n        <td>变量=表达式</td>\n        <td rowspan=\"11\">右到左</td>\n        <td>--</td>\n    </tr>\n    <tr>\n        <td>/=</td>\n        <td>除后赋值</td>\n        <td>变量/=表达式</td>\n        <td>--</td>\n    </tr>\n    <tr>\n        <td>*=</td>\n        <td>乘后赋值</td>\n        <td>变量*/=表达式</td>\n        <td>--</td>\n    </tr>\n    <tr>\n        <td>%=</td>\n        <td>取模后赋值</td>\n        <td>变量%=表达式</td>\n        <td>--</td>\n    </tr>\n    <tr>\n        <td>+=</td>\n        <td>加后赋值</td>\n        <td>变量+=表达式</td>\n        <td>--</td>\n    </tr>\n    <tr>\n        <td>-=</td>\n        <td>减后赋值</td>\n        <td>变量-=表达式</td>\n        <td>--</td>\n    </tr>\n    <tr>\n        <td>&lt;&lt;=</td>\n        <td>左移后赋值</td>\n        <td>变量&lt;&lt;=表达式</td>\n        <td>--</td>\n    </tr>\n    <tr>\n        <td>&gt;&gt;=</td>\n        <td>右移后赋值</td>\n        <td>变量&gt;&gt;=表达式</td>\n        <td>--</td>\n    </tr>\n    <tr>\n        <td>&=</td>\n        <td>按位与后赋值</td>\n        <td>变量&=表达式</td>\n        <td>--</td>\n    </tr>\n    <tr>\n        <td>^=</td>\n        <td>按位异或后赋值</td>\n        <td>变量^=表达式</td>\n        <td>--</td>\n    </tr>\n    <tr>\n        <td>|=</td>\n        <td>按位或后赋值</td>\n        <td>变量|=表达式</td>\n        <td>--</td>\n    </tr>\n    <tr>\n        <td>15</td>\n        <td>,</td>\n        <td>逗号运算符</td>\n        <td>表达式,表达式,...</td>\n        <td>左到右</td>\n        <td>--</td>\n    </tr>\n</table>\n<h3 id=\"_7-2-算数运算符\" tabindex=\"-1\"> 7.2 算数运算符</h3>\n<div><pre><code>不允许对小数取余，即余数不能是小数。 错误示例：35 % 3.4;\n对负数取余，结果为余数的绝对值。示例：10 % -3; // 结果为 1\n</code></pre></div><h3 id=\"_7-3-逗号运算符\" tabindex=\"-1\"> 7.3 逗号运算符</h3>\n<blockquote>\n<p>从左到右，取最后一次运算的结果。</p>\n</blockquote>\n<p><strong>示例：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day03/02.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_8-类型转换\" tabindex=\"-1\"> 8 类型转换</h2>\n<h3 id=\"_8-1-隐式类型转换\" tabindex=\"-1\"> 8.1 隐式类型转换</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day03/03.png\" alt=\"\" loading=\"lazy\"></p>\n<p>隐式类型转换分两种情况：</p>\n<div><pre><code>1. 由编译器自动完成\n    由上图可知，若 float 型数据和 int 型数据进行运算，会分别先转换成 double 型数据后再进行运算。\n\n2. 由赋值产生的类型转换\n    小 -> 大 没问题。 \n        int r = 3;\n        float s = 3.14 * r * r; // 右侧表达式结果为 double 型，赋值转换为 float 型\n    大 -> 小 有可能发生数据丢失。\n        321:    256 128 64 32 16 8 4 2 1\n                1   0   1  0  0  0 0 0 1 // 高位 1 转 char 型时会丢失\n        char ch  = 0   1  0  0  0 0 0 1  // int 型 321 转 char 型，会发生数据丢失\n</code></pre></div><h3 id=\"_8-2-强制类型转换\" tabindex=\"-1\"> 8.2 强制类型转换</h3>\n<p><strong>语法：</strong></p>\n<div><pre><code>（目标类型）带转换变量\n（目标类型）带转换表达式\n</code></pre></div><h2 id=\"_9-vs2013-的-c4996-错误\" tabindex=\"-1\"> 9. <code>VS2013</code> 的 <code>C4996</code> 错误</h2>\n<p>由于微软在 <code>VS2013</code> 中不建议再使用 <code>C</code> 的传统库函数 <code>scanf</code>、<code>strcpy</code>、<code>sprintf</code> 等，所以直接使用这些库函数会提示 <code>C4996</code> 错误：</p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day03/04.png\" alt=\"\" loading=\"lazy\"></p>\n<p><code>VS</code> 建议采用带 <code>_s</code> 的函数，如 <code>scanf_s</code>、<code>strcpy_s</code>，但这些并不是标准 <code>C</code> 函数。要想继续使用此函数，需要在源文件中添加以下指令就可以避免这个错误提示：</p>\n<div><pre><code><span><span>#</span><span>define</span> <span>_CRT_SECURE_NO_WARNINGS</span>   <span>// 这个宏定义最好要放到 .c 文件的第一行</span></span>\n\n<span><span>#</span><span>pragma</span> <span><span>warning</span><span>(</span>disable<span>:</span><span>4996</span><span>)</span>    </span><span>// 或者使用这个</span></span>\n</code></pre></div><h2 id=\"_10-switch-分支语句\" tabindex=\"-1\"> 10. <code>switch</code> 分支语句</h2>\n<div><pre><code>switch(判别表达式)\n{\n    case 1：\n        执行语句1；\n        break; // 防止 case 穿透\n    case 2:\n        执行语句2;\n        break;\n    case 3:\n        执行语句3;\n        break;\n    ...\n    case N:\n        执行语句N;\n        break;\n    default:\n        其他情况的统一处理;\n        break;\n}\n</code></pre></div><h3 id=\"_10-1-什么是-case-穿透\" tabindex=\"-1\"> 10.1 什么是 <code>case</code> 穿透</h3>\n<div><pre><code>在一个 case 分支中如果，没有 break; 那么它会向下继续执行下一个 case 分支。\n</code></pre></div>",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-16T03:14:27.000Z",
      "authors": [],
      "tags": [
        "C语言基础"
      ]
    },
    {
      "title": "第04天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day04.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day04.html",
      "content_html": "<h2 id=\"_1-for-循环\" tabindex=\"-1\"> 1. <code>for</code> 循环</h2>\n<h3 id=\"_1-1-案例\" tabindex=\"-1\"> 1.1 案例</h3>\n<h4 id=\"_1-1-1-案例1-猜数字游戏-rand-随机数函数\" tabindex=\"-1\"> 1.1.1 案例1：猜数字游戏（<code>rand</code> 随机数函数）</h4>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day04/01.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>1. time 函数在 time.h 中声明；返回时间戳\n2. srand 函数在 stdlib.h 中声明；用于产生随机数种子\n3. rand 函数在 stdlib.h 中声明；用于产生随机数\n\n注意：\n如果不执行 srand(time(NULL)); 生成一个随时间变化的随机数种子，\n那么每次编译运行后，第一次执行 rand() 函数得到的随机数都是相同的。\n</code></pre></div><h4 id=\"_1-1-2-案例2-模拟电子表-sleep-休眠函数\" tabindex=\"-1\"> 1.1.2 案例2：模拟电子表（<code>Sleep</code> 休眠函数）</h4>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day04/02.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>Sleep 函数在 Windows.h 中声明\n</code></pre></div><h4 id=\"_1-1-3-案例3-正序99乘法表\" tabindex=\"-1\"> 1.1.3 案例3：正序99乘法表</h4>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day04/03.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>typedef unsigned int    size_t;\n</code></pre></div><h4 id=\"_1-1-4-案例4-倒序99乘法表\" tabindex=\"-1\"> 1.1.4 案例4：倒序99乘法表</h4>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day04/04.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_1-2-跳转语句-break-continue-goto\" tabindex=\"-1\"> 1.2 跳转语句：<code>break</code> &amp; <code>continue</code> &amp; <code>goto</code></h3>\n<p><strong><code>break</code></strong></p>\n<div><pre><code>作用1：跳出一重循环。 for、while、do while\n作用2：防止 case 穿透。 switch   \n</code></pre></div><p><strong><code>continue</code></strong></p>\n<div><pre><code>作用：结束【本次】循环 continue 关键字之后的循环体，让其在本次循环中不执行。\n</code></pre></div><p><strong><code>goto</code></strong></p>\n<div><pre><code>1. 设定一个标签\n2. 使用 \"goto 标签名\" 跳转到标签的位置。（只在函数内部生效）\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day04/05.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>如上代码，由于 <code>goto</code> 语句直接跳转到了第二个 <code>for</code> 循环的循环体中，略过了循环因子 <code>j</code> 赋初值的步骤，所以打印变量 <code>j</code> 时的输出数据是不确定的。</p>\n</blockquote>\n<h2 id=\"_2-格式符-p-打印内存地址\" tabindex=\"-1\"> 2. 格式符 <code>%p</code>（打印内存地址）</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day04/06.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>如上代码，格式符 %p 专门用来打印内存地址\n</code></pre></div><h2 id=\"_3-数组\" tabindex=\"-1\"> 3. 数组</h2>\n<h3 id=\"_3-1-初识数组\" tabindex=\"-1\"> 3.1 初识数组</h3>\n<div><pre><code>- 相同数据类型的有序连续存储。\n- 各个元素的内存地址连续。\n- 数组名为地址，是数组首元素的地址。即：arr == &amp;arr[0];\n</code></pre></div><h3 id=\"_3-2-数组长度-sizeof-arr-sizeof-arr-0\" tabindex=\"-1\"> 3.2 数组长度：<code>sizeof(arr) / sizeof(arr[0])</code></h3>\n<div><pre><code>取数组长度的方式： sizeof(arr) / sizeof(arr[0]) \n(没有 arr.length 这种 java 中的方式)\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day04/07.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_3-3-数组初始化\" tabindex=\"-1\"> 3.3 数组初始化</h3>\n<div><pre><code>int arr[12] = { 1, 2 ,4, 6, 76, 8, 90 ,4, 3, 6, 6, 8 }; 【重点】\n\nint arr[10] = { 1, 2 ,4, 6, 76, 8, 9 };  剩余未初始化的元素，默认 0 值。【重点】\n\nint arr[10] = {0};  初始化一个全为 0 的数组。【重点】\n\nint arr[] = {1, 2, 4, 6, 8};  编译器自动求取元素个数。【重点】\n\nint arr[] = {0};  只有一个元素，值为 0\n\nint arr[10];\narr[0] = 5;\narr[1] = 6;\narr[2] = 7;    \n其余元素未被初始化，默认值 不确定数。\n</code></pre></div><h3 id=\"_3-4-数组倒序\" tabindex=\"-1\"> 3.4 数组倒序</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day04/08.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_3-5-冒泡排序\" tabindex=\"-1\"> 3.5 冒泡排序</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day04/09.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-16T03:14:27.000Z",
      "authors": [],
      "tags": [
        "C语言基础"
      ]
    },
    {
      "title": "第05天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day05.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day05.html",
      "content_html": "<h2 id=\"_1-二维数组\" tabindex=\"-1\"> 1. 二维数组</h2>\n<h3 id=\"_1-1-获取-数组的大小、数组行的大小、元素的大小、行数、列数\" tabindex=\"-1\"> 1.1 获取：数组的大小、数组行的大小、元素的大小、行数、列数</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day05/01.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>如上代码中，打印的大小单位是字节 <code>Byte</code></p>\n</blockquote>\n<h3 id=\"_1-2-二维数组的地址合一-数组首地址-首行地址-首元素地址\" tabindex=\"-1\"> 1.2 二维数组的地址合一：数组首地址 = 首行地址 = 首元素地址</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day05/02.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_1-3-二维数组初始化\" tabindex=\"-1\"> 1.3 二维数组初始化</h3>\n<p><strong>1. 常规初始化：</strong></p>\n<div><pre><code><span>int</span> arr<span>[</span><span>3</span><span>]</span><span>[</span><span>5</span><span>]</span> <span>=</span> <span>{</span><span>{</span><span>2</span><span>,</span> <span>3</span><span>,</span> <span>54</span><span>,</span> <span>56</span><span>,</span> <span>7</span> <span>}</span><span>,</span> <span>{</span><span>2</span><span>,</span> <span>67</span><span>,</span> <span>4</span><span>,</span> <span>35</span><span>,</span> <span>9</span><span>}</span><span>,</span> <span>{</span><span>1</span><span>,</span> <span>4</span><span>,</span> <span>16</span><span>,</span> <span>3</span><span>,</span> <span>78</span><span>}</span><span>}</span><span>;</span>\n</code></pre></div><p><strong>2. 不完全初始化：</strong></p>\n<div><pre><code><span>int</span> arr<span>[</span><span>3</span><span>]</span><span>[</span><span>5</span><span>]</span> <span>=</span> <span>{</span><span>{</span><span>2</span><span>,</span> <span>3</span><span>}</span><span>,</span> <span>{</span><span>2</span><span>,</span> <span>67</span><span>,</span> <span>4</span><span>,</span> <span>}</span><span>,</span> <span>{</span><span>1</span><span>,</span> <span>4</span><span>,</span> <span>16</span><span>,</span> <span>78</span><span>}</span><span>}</span><span>;</span>  <span>// 未被初始化的数值为 0</span>\n\n<span>int</span> arr<span>[</span><span>3</span><span>]</span><span>[</span><span>5</span><span>]</span> <span>=</span> <span>{</span><span>0</span><span>}</span><span>;</span>    <span>// 初始化一个初值全为 0 的二维数组</span>\n\n<span>int</span> arr<span>[</span><span>3</span><span>]</span><span>[</span><span>5</span><span>]</span> <span>=</span> <span>{</span><span>2</span><span>,</span> <span>3</span><span>,</span> <span>2</span><span>,</span> <span>67</span><span>,</span> <span>4</span><span>,</span> <span>1</span><span>,</span> <span>4</span><span>,</span> <span>16</span><span>,</span> <span>78</span><span>}</span><span>;</span>   <span>// 【少见】系统自动分配行列。</span>\n</code></pre></div><p><strong>3. 不完全指定行列初始化：</strong></p>\n<div><pre><code><span>int</span> arr<span>[</span><span>]</span><span>[</span><span>]</span> <span>=</span> <span>{</span><span>1</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>}</span><span>;</span>  <span>// 错误：二维数组定义必须指定列值。</span>\n\n<span>int</span> arr<span>[</span><span>]</span><span>[</span><span>2</span><span>]</span> <span>=</span> <span>{</span> <span>1</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>6</span><span>,</span> <span>7</span> <span>}</span><span>;</span>  <span>// 正确：可以不指定行值。</span>\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day05/03.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_2-vs-代码片段模板的导入\" tabindex=\"-1\"> 2. <code>VS</code> 代码片段模板的导入</h2>\n<div><pre><code>操作步骤：VS -> 工具 -> 代码片段管理器 -> Visual C++\n</code></pre></div><h2 id=\"_3-多维数组\" tabindex=\"-1\"> 3. 多维数组</h2>\n<p><strong>定义语法：</strong></p>\n<div><pre><code>三维数组：[层][行][列]\n\n数组类型 数组名[层][行][列];\n</code></pre></div><p><strong>示例：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day05/04.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_4-字符串\" tabindex=\"-1\"> 4. 字符串</h2>\n<h3 id=\"_4-1-字符数组和字符串的区别\" tabindex=\"-1\"> 4.1 字符数组和字符串的区别</h3>\n<div><pre><code>字符数组：\n    char str[5] = {'h', 'e', 'l', 'l', 'o'};    \n字符串：\n    char str[6] = {'h', 'e', 'l', 'l', 'o', '\\0'};   &lt;=>  char str[6] = \"hello\";\n        \nprintf(\"%s\"); // 使用 printf 打印字符串的时候，必须碰到 '\\0' 结束。\n</code></pre></div><h3 id=\"_4-2-案例-统计字符串中每个字母的出现次数\" tabindex=\"-1\"> 4.2 案例：统计字符串中每个字母的出现次数</h3>\n<p>键盘输入字符串，存至 <code>str[]</code> 中，统计每个字母出现的次数。</p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day05/05.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_4-3-字符串获取函数-scanf\" tabindex=\"-1\"> 4.3 字符串获取函数 <code>scanf</code></h3>\n<h4 id=\"_4-3-1-注意事项-预留足够空间-遇空格或换行终止\" tabindex=\"-1\"> 4.3.1 注意事项（预留足够空间；遇空格或换行终止）</h4>\n<div><pre><code>1. 用于存储字符串的空间必须足够大，防止溢出。\n2. 获取字符串 %s ，遇到 空格 和 \\n 终止。\n</code></pre></div><h4 id=\"_4-3-2-获取带有空格的字符串-scanf-n-s-str\" tabindex=\"-1\"> 4.3.2 获取带有空格的字符串：<code>scanf(&quot;%[^\\n]s&quot;, str)</code></h4>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day05/06.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_4-4-字符串操作函数\" tabindex=\"-1\"> 4.4 字符串操作函数</h3>\n<h4 id=\"_4-4-1-从键盘获取一个字符串-gets\" tabindex=\"-1\"> 4.4.1 从键盘获取一个字符串：<code>gets</code></h4>\n<p><strong>作用：</strong></p>\n<div><pre><code>从键盘获取一个字符串，返回字符串的首地址。可以获取带有空格的字符串。【不安全】\n</code></pre></div><p><strong>说明：</strong></p>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>char</span> <span>*</span><span>gets</span><span>(</span><span>char</span> <span>*</span>s<span>)</span><span>;</span>\n    参数：用来存储字符串的空间地址。\n    返回值：返回实际获取到的字符串首地址，失败返回 <span>NULL</span>。\n</code></pre></div><p><code>gets(str)</code> 与<code> scanf(&quot;%s&quot;,str)</code> 的区别：</p>\n<div><pre><code>gets(str) 允许输入的字符串含有空格\nscanf(\"%s\",str) 不允许含有空格\n</code></pre></div><p><strong>注意：</strong></p>\n<div><pre><code>由于 scanf() 和 gets() 无法知道字符串 s 大小，必须遇到换行符或读到文件结尾为止才接收输入，\n因此容易导致字符数组越界（缓冲区溢出）的情况，即 scanf 和 gets 都是【不安全】的。\n</code></pre></div><p><strong>示例：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day05/07.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>\"hello world\" 算上 '\\0' 有 12 个字符，数组 str 只能存储 10 个字符，\n所以用数组 str 存储 \"hello world\" 会发出缓冲区溢出，最后两个字符 'd' 和 '\\0' 不在 str 内存范围内，可能会被其他数据覆盖，不安全。\n</code></pre></div><h4 id=\"_4-4-2-从指定输入流中获取一个字符串-fgets\" tabindex=\"-1\"> 4.4.2 从指定输入流中获取一个字符串：<code>fgets</code></h4>\n<p><strong>作用：</strong></p>\n<div><pre><code>从指定输入流中获取一个字符串，预留 '\\0' 的存储空间。空间足够读 '\\n'，空间不足舍弃 '\\n'。【安全】\n</code></pre></div><p><strong>说明：</strong></p>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>char</span> <span>*</span><span>fgets</span><span>(</span><span>char</span> <span>*</span>s<span>,</span> <span>int</span> size<span>,</span> FILE <span>*</span>stream<span>)</span><span>;</span>\n    参<span>1</span>：用来存储字符串的空间地址。\n    参<span>2</span>：描述空间的大小。\n    参<span>3</span>：读取字符串的位置。可以从文件中读取，也可以从标准输入中读取。标准输入：<span>stdin</span> <span>-></span> 即：键盘\n    返回值：返回实际获取到的字符串首地址，失败返回 <span>NULL</span>。\n</code></pre></div><p><strong>示例：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day05/08.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>因为 fgets 的参数中指定了存储空间大小，所有不会出现缓冲区溢出的情况；只会出现输入字符串过长时被截断的情况。\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day05/09.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>因为 fgets 函数的参数中传入的存储空间足够大，所以会把输入的换行符 '\\n' 也存储到数组 str 中，作为输入字符串的一部分。\n</code></pre></div><h4 id=\"_4-4-3-将一个字符串写出到屏幕-puts\" tabindex=\"-1\"> 4.4.3 将一个字符串写出到屏幕：<code>puts</code></h4>\n<p><strong>作用：</strong></p>\n<div><pre><code>将一个字符串写出到屏幕。\nprintf(\"%s\", \"hello\");  &lt;=>  printf(\"hello\\n\");  &lt;=>  puts(\"hello\");   \n</code></pre></div><p><strong>说明：</strong></p>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>int</span> <span>puts</span><span>(</span><span>const</span> <span>char</span> <span>*</span>s<span>)</span><span>;</span>    \n    参数<span>1</span>：待写出到屏幕的字符串。\n    返回值：成功：非负数（通常是 <span>0</span>）；失败：<span>-</span><span>1.</span>  \n</code></pre></div><p><strong>示例：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day05/10.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_4-4-4-将一个字符串写出到指定输出流-fputs\" tabindex=\"-1\"> 4.4.4 将一个字符串写出到指定输出流：<code>fputs</code></h4>\n<p><strong>作用：</strong></p>\n<div><pre><code>将一个字符串写出到指定输出流，输出字符串后不添加 '\\n' 换行符。\n</code></pre></div><p><strong>说明：</strong></p>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>int</span> <span>fputs</span><span>(</span><span>const</span> <span>char</span> <span>*</span> str<span>,</span> FILE <span>*</span> stream<span>)</span><span>;</span>    \n    参数<span>1</span>：待写出到屏幕的字符串。        \n    参数<span>2</span>：写出位置，可以输出到指定的文件，也可以输出到标准输出上。标准输出：<span>stdout</span> <span>-></span> 即：显示器\n    返回值：成功：非负数（通常是 <span>0</span>）；失败：<span>-</span><span>1.</span>\n</code></pre></div><p><strong>示例：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day05/11.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>因为 puts 函数仅面向标准输出（即显示器），所以 puts 函数默认打印换行符；\n而 fputs 函数可以面向任意指定的输出位置，所以 fgets 函数默认不打印换行符。\n</code></pre></div><h4 id=\"_4-4-5-获取字符串长度-strlen\" tabindex=\"-1\"> 4.4.5 获取字符串长度：<code>strlen</code></h4>\n<p><strong>作用：</strong></p>\n<div><pre><code>获取字符串长度，碰到 '\\0' 结束。（长度不包括 '\\0'）\n</code></pre></div><p><strong>说明：</strong></p>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;string.h></span></span>\n<span>size_t</span> <span>strlen</span><span>(</span><span>const</span> <span>char</span> <span>*</span>s<span>)</span><span>;</span>\n    参数<span>1</span>：待求长度的字符串首地址\n    返回：有效的字符个数，<span>size_t</span> 为 <span>unsigned</span> <span>int</span> 类型\n</code></pre></div><p><strong>示例：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day05/12.png\" alt=\"\" loading=\"lazy\"></p>\n<h5 id=\"_4-4-5-1-sizeof-str-和-strlen-str-的区别\" tabindex=\"-1\"> 4.4.5.1 <code>sizeof(str)</code> 和 <code>strlen(str)</code> 的区别</h5>\n<div><pre><code>sizeof(str) 求的数组的长度，不管数组中的元素是什么。\nstrlen(str) 求的是字符串的长度，遇字符串结束标记 '\\0' 为止。\n</code></pre></div><h5 id=\"_4-4-5-2-自己实现-strlen-函数\" tabindex=\"-1\"> 4.4.5.2 自己实现 <code>strlen</code> 函数</h5>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day05/13.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>等价于 printf(\"%d\\n\", strlen(str));\n</code></pre></div><h3 id=\"_4-5-案例-字符串拼接\" tabindex=\"-1\"> 4.5 案例：字符串拼接</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day05/14.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_5-函数\" tabindex=\"-1\"> 5. 函数</h2>\n<h3 id=\"_5-1-函数的作用\" tabindex=\"-1\"> 5.1 函数的作用</h3>\n<div><pre><code>1. 提高代码的复用率；\n2. 提高程序模块化组织性。\n</code></pre></div><h3 id=\"_5-2-函数的分类-系统库函数-用户自定义函数\" tabindex=\"-1\"> 5.2 函数的分类（系统库函数 &amp; 用户自定义函数）</h3>\n<div><pre><code>系统库函数： \n    如：标准C库（libc）\n    使用方式：\n        1. 引入头文件 -- 即：声明函数\n        2. 根据函数原型调用。\n\n用户自定义:\n    使用方式：除了需要提供函数原型之外，还需要提供函数实现。\n</code></pre></div><h3 id=\"_5-3-函数定义\" tabindex=\"-1\"> 5.3 函数定义</h3>\n<p>函数定义包含：</p>\n<div><pre><code>1. 函数原型（返回值类型、函数名、形参列表）\n2. 函数体（花括号一对，具体代码实现）\n</code></pre></div><blockquote>\n<p>形参列表即形式参数列表，一定包含：类型名 形参名</p>\n</blockquote>\n<p><strong>定义语法：</strong></p>\n<div><pre><code>返回值类型 函数名(类型名 形参名, 类型名 形参名, ...)\n{\n    具体代码实现\n}\n</code></pre></div><p><strong>示例：</strong></p>\n<div><pre><code><span>int</span> add（<span>int</span> a<span>,</span> <span>int</span> b<span>,</span> <span>int</span> c）\n<span>{</span>\n    <span>return</span> a<span>+</span>b<span>+</span>c<span>;</span>\n<span>}</span>\n</code></pre></div><h3 id=\"_5-4-函数调用\" tabindex=\"-1\"> 5.4 函数调用</h3>\n<p>函数调用包含：</p>\n<div><pre><code>函数名(实参列表);\n</code></pre></div><blockquote>\n<p>实参(实际参数)：在调用时，传参必须严格按照形参填充（参数的个数、类型、顺序）</p>\n</blockquote>\n<p><strong>示例：</strong></p>\n<div><pre><code><span>int</span> ret <span>=</span> <span>add</span><span>(</span><span>10</span><span>,</span> <span>4</span><span>,</span> <span>28</span><span>)</span><span>;</span>\n</code></pre></div><h3 id=\"_5-5-函数声明\" tabindex=\"-1\"> 5.5 函数声明</h3>\n<p>函数声明包含：</p>\n<div><pre><code>函数原型（返回值类型、函数名、形参列表）+ \";\"\n</code></pre></div><p><strong>注意：</strong></p>\n<div><pre><code>1. 在函数调用之前，编译必须见过函数定义。否则，需要函数声明。\n\n2. 函数声明时，形参列表中可以省略形参名，只保留形参类型即可。\n    int add(int a, int b, int c);   &lt;=>   int add(int, int, int);\n\n3. #include &lt;xxx.h>  中包含函数的声明\n</code></pre></div><h4 id=\"_5-5-1-隐式声明-不要依赖这种方式\" tabindex=\"-1\"> 5.5.1 隐式声明（不要依赖这种方式）</h4>\n<div><pre><code>编译器默认做隐式声明函数时，返回都为 int ，根据调用语句 补全 函数名和形参列表。\n</code></pre></div><p><strong>示例1：编译器默认做隐式声明函数时的异常情况</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day05/15.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>如上图，报错 bubble_sort 函数重定义， 是由于编译器的隐式声明导致的。\n因为 main 函数定义之前未对 bubble_sort 函数做函数声明，而 main 函数中又调用了 bubble_sort 函数，\n所以，此时编译器会在 main 函数定义之前对 bubble_sort 函数做隐式声明：int bubble_sort(int arr[])\n从而导致了 bubble_sort 函数声明与其函数定义不同，报出了重定义的错误。\n</code></pre></div><p><strong>示例2：手动做函数声明的情况</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day05/16.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>示例3：编译器默认做隐式声明函数时的正常情况</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day05/17.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>如上图，若函数的函数类型是 int 型，则可以使用编译器默认的隐式声明，但不建议采用隐式声明。\n</code></pre></div><h3 id=\"_5-6-exit-函数-退出当前程序\" tabindex=\"-1\"> 5.6 <code>exit</code> 函数（退出当前程序）</h3>\n<p><strong>说明：</strong></p>\n<div><pre><code>#include &lt;stdlib.h>\n\nreturn 关键字：返回当前函数调用，将返回值返回给调用者。\n\nexit() 函数：退出当前程序。\n</code></pre></div><p><strong>示例：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day05/18.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_6-vs-的使用\" tabindex=\"-1\"> 6. <code>VS</code> 的使用</h2>\n<h3 id=\"_6-1-vs-解决方案中新建项目\" tabindex=\"-1\"> 6.1 <code>VS</code> 解决方案中新建项目</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day05/19.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>如上图所示，“多文件联编” 是当前解决方案中的一个新的项目。\n通过【右键解决方案 -> 添加 —> 新建项目】可以创建一个类似 “多文件联编” 这样的项目。\n</code></pre></div><h3 id=\"_6-2-vs-解决方案中设置启动项目\" tabindex=\"-1\"> 6.2 <code>VS</code> 解决方案中设置启动项目</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day05/20.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>如上图，若解决方案中包含多个项目，可以通过【右键某个项目 —> 设为启动项目】将项目设置为启动项目。\n启动项目中的 main 函数才是入口函数。\n</code></pre></div><h2 id=\"_7-多文件联编\" tabindex=\"-1\"> 7. 多文件联编</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day05/21.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>多文件联编就是指：将多个含有不同函数功能 .c 文件模块，编译到一起，生成一个 .exe 文件。\n</code></pre></div><p><strong>注意：</strong></p>\n<div><pre><code>使用 VS 生成的 exe 文件 在  \"...\\day05\\Debug\" 路径下，（其中 day05 文件夹表示解决方案）\n</code></pre></div><p><strong>使用 <code>gcc</code> 命令实现多文件联编</strong></p>\n<div><pre><code>gcc main.c add.c mul.c sub.c <span>-o</span> xxx.exe\n</code></pre></div><h2 id=\"_8-include-指令\" tabindex=\"-1\"> 8. <code>#include</code> 指令</h2>\n<div><pre><code>&lt;> 包裹的头文件为系统库头文件。\n\"\" 包裹的头文件为用户自定义头文件。\n</code></pre></div><h2 id=\"_9-防止头文件重复包含-即-头文件守卫\" tabindex=\"-1\"> 9. 防止头文件重复包含（即：头文件守卫）</h2>\n<p><strong>方式1：</strong></p>\n<div><pre><code><span><span>#</span><span>pragma</span> <span>once  </span><span>// 仅 windows 中适用</span></span>\n</code></pre></div><p><strong>方式2：</strong></p>\n<div><pre><code><span><span>#</span><span>ifndef</span> <span>__HEAD_H__   </span><span>// __HEAD_H__ 是通过 头文件名 head.h 来定义的，应该跟头文件名一一对应</span></span>\n<span><span>#</span><span>define</span> <span>__HEAD_H__</span></span>\n\n<span>// ... 头文件内容</span>\n\n<span><span>#</span><span>endif</span></span>\n</code></pre></div>",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-16T03:14:27.000Z",
      "authors": [],
      "tags": [
        "C语言基础"
      ]
    },
    {
      "title": "第06天（指针基础）",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day06.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day06.html",
      "content_html": "<h2 id=\"_1-指针和内存单元\" tabindex=\"-1\"> 1. 指针和内存单元</h2>\n<div><pre><code>指针：\n    即地址。\n\n内存单元： \n    计算机中内存最小的存储单位。\n    1 个内存单元的大小是 1 个字节。 \n    每一个内存单元都有一个唯一的编号（数），称这个内存单元的编号为 “地址”。\n\n指针变量：\n    存地址的变量。\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day06/01.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_2-指针定义和使用\" tabindex=\"-1\"> 2. 指针定义和使用</h2>\n<h3 id=\"_2-1-指针的定义\" tabindex=\"-1\"> 2.1 指针的定义</h3>\n<div><pre><code><span>int</span> a <span>=</span> <span>10</span><span>;</span>\n\n<span>// 写法1： int* p; (windows)</span>\n<span>// 写法2： int *p; (Linux)</span>\n<span>// 写法3： int * p; </span>\n<span>int</span> <span>*</span>p <span>=</span> <span>&amp;</span>a<span>;</span>        \n\n<span>int</span> a<span>,</span> <span>*</span>p<span>,</span> <span>*</span>q<span>,</span> b<span>;</span>\n</code></pre></div><h3 id=\"_2-2-指针的解引用-间接引用\" tabindex=\"-1\"> 2.2 指针的解引用（间接引用）</h3>\n<div><pre><code>对于 *p = 250;  其中 *p 称为指针的解引用，或间接引用。即：将 p 变量的内容取出，当成地址看待，找到该地址对应的内存空间。\n\n*p 如果做左值：存入数据到空间中。\n*p 如果做右值：取出空间中的数据。\n</code></pre></div><h2 id=\"_3-任意指针类型所占的内存大小-与指向的数据类型无关\" tabindex=\"-1\"> 3. 任意指针类型所占的内存大小（与指向的数据类型无关）</h2>\n<div><pre><code>指针的大小与所指向地址中的数据类型无关。只与当前使用的平台架构有关：\n- 32 位系统：4 字节。     \n- 64 位系统：8 字节。\n</code></pre></div><p><strong>示例1：32 位系统中指针类型所占的内存大小</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day06/02.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>示例2：64 位系统中指针类型所占的内存大小</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day06/03.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_4-野指针-注意-杜绝野指针\" tabindex=\"-1\"> 4. 野指针（注意：杜绝野指针）</h2>\n<p><strong>情形1：没有一个有效的地址空间的指针</strong></p>\n<div><pre><code><span>int</span> <span>*</span>p<span>;</span>\n<span>*</span>p <span>=</span> <span>1000</span><span>;</span>\n</code></pre></div><p><strong>情形2：<code>p</code> 变量有一个值，但该值不是可访问的内存区域</strong></p>\n<div><pre><code><span>int</span> <span>*</span>p <span>=</span> <span>10</span><span>;</span>\n<span>*</span>p <span>=</span> <span>2000</span><span>;</span>\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day06/04.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>如上图，调式模式下可看到，给指针 <code>p</code> 赋以地址编号 <code>10</code>，会产生访问权限的异常。</p>\n</blockquote>\n<h2 id=\"_5-空指针-null\" tabindex=\"-1\"> 5. 空指针（<code>NULL</code>）</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day06/05.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>如上图，vcruntime.h 文件中，NULL 是一个指针类型（void *）的数据 0，地址编号 0 是系统使用的，无访问权限。\n所以 int *p = NULL; 执行后，p 所对应的存储空间一定是一个无效的访问区域。\n</code></pre></div><h3 id=\"_5-1-判断指针是否有效\" tabindex=\"-1\"> 5.1 判断指针是否有效</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day06/06.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>如上图，常用 if(p != NULL) 判断指针 p 是否有效\n</code></pre></div><h2 id=\"_6-万能指针-又称泛型指针-void\" tabindex=\"-1\"> 6. 万能指针（又称泛型指针，<code>void*</code>）</h2>\n<p><strong>说明：</strong></p>\n<div><pre><code>可以接收任意一种变量地址。但是在使用时，【必须】借助 “强转” 具体化数据类型。\n</code></pre></div><p><strong>示例：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day06/07.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>如上图：\n1. p = &amp;ch; 表示泛型指针 p 可以接收任意一种变量地址\n\n2. *(char *)p 表示泛型指针 p 在使用时，必须借助强转，具体化为特定的数据类型，\n\n3. *(char *)p 还可以写成 *((char *)p)，\n   因为运算符 * 和 (类型) 优先级都为 2，按照从右到左的结合方向，所以写成 *(char *)p 也没问题\n</code></pre></div><h2 id=\"_7-const-关键字\" tabindex=\"-1\"> 7. <code>const</code> 关键字</h2>\n<h3 id=\"_7-1-修饰变量-常变量\" tabindex=\"-1\"> 7.1 修饰变量（常变量）</h3>\n<div><pre><code><span>const</span> <span>int</span> a <span>=</span> <span>20</span><span>;</span>\n<span>int</span> <span>*</span>p <span>=</span> <span>&amp;</span>a<span>;</span>\n<span>*</span>p <span>=</span> <span>650</span><span>;</span>\n<span>printf</span><span>(</span><span>\"%d\\n\"</span><span>,</span> a<span>)</span><span>;</span>\n</code></pre></div><div><pre><code>如上，const 关键字修饰的变量称为常变量，不能通过常变量 a 修改对应内存空间中的数据，\n但是，可以通过指针的方式来访问并修改对应内存空间中的数据。\n</code></pre></div><h3 id=\"_7-2-修饰指针\" tabindex=\"-1\"> 7.2 修饰指针</h3>\n<p><strong>说明：</strong></p>\n<div><pre><code>const 向右修饰，被修饰的部分即为只读。\n</code></pre></div><p><strong>常用于：</strong></p>\n<div><pre><code>在函数形参内，用来限制指针所指向的内存空间为只读。\n</code></pre></div><h4 id=\"_7-2-1-指针常量-const-修饰-指针本身-int-const-p\" tabindex=\"-1\"> 7.2.1 指针常量（<code>const</code> 修饰 指针本身）：<code>int * const p</code></h4>\n<p>指针的指向不可以修改，但指针所指向的内容可以修改。</p>\n<div><pre><code>int * const p;\n\n可以修改 *p\n不可以修改 p。\n</code></pre></div><h4 id=\"_7-2-2-常量指针-const-修饰-所指向的内容-const-int-p\" tabindex=\"-1\"> 7.2.2 常量指针（<code>const</code> 修饰 所指向的内容）：<code>const int *p</code></h4>\n<p>指针的指向可以修改，但指针所指向的内容不可以修改。</p>\n<div><pre><code>const int *p;  &lt;=>  int const *p;\n\n可以修改 p\n不可以修改 *p。\n</code></pre></div><h4 id=\"_7-2-3-const-int-const-p\" tabindex=\"-1\"> 7.2.3 <code>const int * const p</code></h4>\n<div><pre><code>const int *const p;\n\n不可以修改 p。\n不可以修改 *p。\n</code></pre></div><h2 id=\"_8-指针和数组\" tabindex=\"-1\"> 8. 指针和数组</h2>\n<h3 id=\"_8-1-数组名是指针常量\" tabindex=\"-1\"> 8.1 数组名是指针常量</h3>\n<div><pre><code>数组名是指针常量，所以不可以被赋值。  \n\n指针是变量，可以用数组名给指针赋值。 \n</code></pre></div><h4 id=\"_8-1-1-带有副作用的运算符不能作用在数组名\" tabindex=\"-1\"> 8.1.1 带有副作用的运算符不能作用在数组名</h4>\n<p>带有副作用的运算符是指：参与运算的操作数会受到运算结果的影响。</p>\n<div><pre><code>\"++\"、\"--\"、\"+=\"、\"-=\"、\"%=\"、\"/=\" 这些带有副作用的运算符不能作用在数组名上，但可以作用在指针上。\n</code></pre></div><h3 id=\"_8-2-取数组元素-arr-i\" tabindex=\"-1\"> 8.2 取数组元素：<code>*(arr+i)</code></h3>\n<div><pre><code><span>int</span> arr<span>[</span><span>]</span> <span>=</span> <span>{</span><span>1</span><span>,</span><span>3</span><span>,</span> <span>5</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>}</span><span>;</span>\n<span>int</span> <span>*</span>p <span>=</span> arr<span>;</span>  \narr<span>[</span>i<span>]</span>  <span>&lt;=</span><span>></span>  <span>*</span><span>(</span>arr<span>+</span>i<span>)</span>  <span>&lt;=</span><span>></span>  p<span>[</span>i<span>]</span>  <span>&lt;=</span><span>></span>  <span>*</span><span>(</span>p<span>+</span>i<span>)</span>   <span>// 汇编从采用的是 *(arr+i)、 *(p+i) 这种写法，所以这样写更高效</span>\n<span>*</span><span>(</span>p<span>+</span><span>0</span><span>)</span> <span>&lt;=</span><span>></span> <span>*</span>p\n</code></pre></div><h3 id=\"_8-3-指针和数组的区别\" tabindex=\"-1\"> 8.3 指针和数组的区别</h3>\n<div><pre><code>区别一：\n    指针是变量；数组名为常量（即指针常量）。\n\n区别二：\n    sizeof(指针) => 4字节 or 8字节 (指针类型的变量所占内存大小只跟操作系统（32、64位）有关，跟所指向的地址中存储的数据类型无关)\n    sizeof(数组) => 数组的实际字节数。\n</code></pre></div><h3 id=\"_8-4-指针-操作数组\" tabindex=\"-1\"> 8.4 &quot;指针++&quot; 操作数组</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day06/08.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_9-数据类型对指针的作用\" tabindex=\"-1\"> 9. 数据类型对指针的作用</h2>\n<p><strong>作用1：</strong></p>\n<div><pre><code>从间接引用的方面来说：决定了从指针存储的地址开始，向后读取的字节数。\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day06/09.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作用2：</strong></p>\n<div><pre><code>从加减运算的方面来说：决定了指针进行 +1/-1 操作后，向后/向前偏移的字节数。\n</code></pre></div><h2 id=\"_10-指针加减运算\" tabindex=\"-1\"> 10. 指针加减运算</h2>\n<h3 id=\"_10-1-指针变量不支持-、-、-运算\" tabindex=\"-1\"> 10.1 指针变量不支持 <code>*</code>、<code>/</code>、<code>%</code> 运算</h3>\n<div><pre><code>不能对指针变量进行 * 、 / 、 % 的运算\n</code></pre></div><h3 id=\"_10-2-指针-整数\" tabindex=\"-1\"> 10.2 指针 <code>+-</code> 整数</h3>\n<p><strong>1. 普通指针变量 <code>+-</code> 整数</strong></p>\n<div><pre><code>char  *p; 打印  p+1  偏过 1 字节。\nshort *p; 打印  p+1  偏过 2 字节。\nint   *p; 打印  p+1  偏过 4 字节。 \n</code></pre></div><p><strong>2. 在数组中 <code>+-</code> 整数</strong></p>\n<div><pre><code><span>int</span> arr<span>[</span><span>]</span> <span>=</span> <span>{</span><span>1</span><span>,</span> <span>3</span><span>,</span> <span>5</span><span>,</span> <span>8</span><span>}</span><span>;</span>\n<span>int</span> <span>*</span>p <span>=</span> arr<span>;</span>\np<span>+</span><span>3</span><span>;</span>  <span>// 向后（右）偏过 3 个元素，即 3x4=12 个字节</span>\np<span>-</span><span>2</span><span>;</span>  <span>// 向前（左）偏过 2 个元素，即 3x2=6  个字节</span>\n</code></pre></div><p><strong>3. <code>&amp;数组名 + 1</code></strong></p>\n<div><pre><code>加过一个数组的大小：数组元素个数 x sizeof(数组元素类型)\n</code></pre></div><p><strong>示例：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day06/10.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>如上图，<code>&amp;a+1</code> 表示向后偏移一个数组 <code>a</code> 的大小</p>\n</blockquote>\n<h3 id=\"_10-3-指针-指针\" tabindex=\"-1\"> 10.3 指针 <code>+-</code> 指针</h3>\n<div><pre><code>指针 + 指针：不支持，报错。\n指针 - 指针：\n    1. 对普通变量来说，语法允许，但无实际意义。【了解】\n    2. 对数组来说，偏移过的元素个数。\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day06/11.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>上图说明了，在数组中，指针 - 指针 表示偏移过的元素个数。</p>\n</blockquote>\n<h2 id=\"_11-指针实现-strlen-函数\" tabindex=\"-1\"> 11. 指针实现 <code>strlen</code> 函数</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day06/12.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_12-指针比较运算\" tabindex=\"-1\"> 12. 指针比较运算</h2>\n<div><pre><code>1. 对普通变量来说，语法允许，但无实际意义。\n2. 对数组来说：地址之间可以进行比较大小。可以得到元素存储的先后顺序。\n3. 与空指针 NULL 进行比较【常用】\n</code></pre></div><p><strong>示例：与空指针 <code>NULL</code> 进行比较</strong></p>\n<div><pre><code><span>int</span> <span>*</span>p<span>;</span>\np <span>=</span> <span>NULL</span><span>;</span>  <span>// 这两行等价于：int *p = NULL;</span>\n\n<span>if</span> <span>(</span>p <span>!=</span> <span>NULL</span><span>)</span>\n    <span>printf</span><span>(</span><span>\"p is not NULL\"</span><span>)</span><span>;</span>\n<span>else</span>\n    <span>printf</span><span>(</span><span>\"p is NULL\"</span><span>)</span><span>;</span>\n</code></pre></div><h2 id=\"_13-指针数组-存储地址的数组\" tabindex=\"-1\"> 13. 指针数组（存储地址的数组）</h2>\n<p>指针数组就是一个存储地址的数组。数组内部所有元素都是地址。</p>\n<h2 id=\"_14-指针数组和二维数组本质上都是二级指针\" tabindex=\"-1\"> 14. 指针数组和二维数组本质上都是二级指针</h2>\n<p><strong>示例1：指针数组的本质是一个二级指针</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day06/13.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>示例2：二维数组的本质也是一个二级指针</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day06/14.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_15-多级指针\" tabindex=\"-1\"> 15. 多级指针</h2>\n<div><pre><code>int a = 0;\n\nint *p = &amp;a;            一级指针是 变量的地址。\n\nint **pp = &amp;p;          二级指针是 一级指针的地址。\n\nint ***ppp = &amp;pp;       三级指针是 二级指针的地址。（int **p[] 二级指针数组，其本质是一个三级指针）   \n\nint ****pppp = &amp;ppp;    四级指针是 三级指针的地址。【了解】\n\n...\n</code></pre></div><p><strong>注意：</strong></p>\n<div><pre><code>多级指针，不能跳跃定义！\n</code></pre></div><p><strong>示例：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day06/15.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>对应关系：\nppp == &amp;pp;            三级指针\n\n*ppp == pp == &amp;p;             二级指针\n\n**ppp == *pp == p == &amp;a            一级指针\n\n***ppp == **pp == *p == a                普通整型变量\n</code></pre></div>",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-17T07:26:38.000Z",
      "authors": [],
      "tags": [
        "C语言基础"
      ]
    },
    {
      "title": "第07天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day07.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day07.html",
      "content_html": "<h2 id=\"_1-栈帧\" tabindex=\"-1\"> 1. 栈帧</h2>\n<div><pre><code>当函数调用时，系统会在 stack 空间上申请一块内存区域（即：栈帧），\n栈帧用来供函数调用，主要存放形参和局部变量（定义在函数内部）。\n当函数调用结束，这块内存区域（即：栈帧）自动被释放（消失）。\n</code></pre></div><h2 id=\"_2-传值-传址\" tabindex=\"-1\"> 2. 传值 &amp; 传址</h2>\n<p><strong>传值：</strong> 函数调用期间，实参将自己的值拷贝一份给形参。</p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day07/01.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>传址：</strong> 函数调用期间，实参将地址值拷贝一份给形参。</p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day07/02.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>传址即：传递地址值。通过地址在 <code>swap</code> 函数栈帧内部，修改了 <code>main</code> 函数栈帧内部的局部变量值。</p>\n</blockquote>\n<h2 id=\"_3-指针做函数参数\" tabindex=\"-1\"> 3. 指针做函数参数</h2>\n<div><pre><code>int swap2(int *a, int *b);\nint swap2(char *a, char *b);\n\n调用时，传有效的地址值。\n</code></pre></div><h2 id=\"_4-数组做函数参数\" tabindex=\"-1\"> 4. 数组做函数参数</h2>\n<div><pre><code>void BubbleSort(int arr[10])  &lt;=>  void BubbleSort(int arr[])  &lt;=>  void BubbleSort(int *arr)\n\n数组做函数时，传递不再是整个数组，而是数组的首地址（一个指针）。\n所以，当整型数组做函数参数时，我们通常在函数定义中，封装2个参数。一个表示数组首地址，一个表示元素个数。\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day07/03.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_5-指针做函数返回值-注意-不能返回局部变量的地址值\" tabindex=\"-1\"> 5. 指针做函数返回值（注意：不能返回局部变量的地址值）</h2>\n<div><pre><code>int *test_func(int a, int b);\n\n指针做函数返回值，不能返回【局部变量的地址值】，因为被调函数执行完毕后，会销毁对应的栈帧，从而栈帧中保留的局部变量无效。\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day07/04.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>如上图，当指针做函数 test_func2 的返回值，返回局部变量地址值时，\n由于 test_func2 函数调用结束后，其对应的栈帧销毁，从而局部变量 p 无效，无法得到预期的数据 1234。\n\n注意：函数 disturb_func 的作用是保证 test_func2 函数的调用栈帧销毁后，其栈帧空间被 disturb_func 函数复用，\n从而使得局部变量 p 中的数据被覆盖成一个不确定的数据。\n</code></pre></div><h2 id=\"_6-数组做函数返回值-c语言不允许\" tabindex=\"-1\"> 6. 数组做函数返回值（C语言不允许）</h2>\n<div><pre><code>C语言，不允许！！！只能写成指针形式。\n</code></pre></div><h2 id=\"_7-指针和字符串\" tabindex=\"-1\"> 7. 指针和字符串</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day07/05.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>如上图：\nchar str1[] = \"hello\"; 是把字符串常量 \"hello\" 复制到数组 str1 的内存空间\nchar *str2 = \"hello\";  是将指针 str2 指向字符串常量 \"hello\" 所在的内存地址\n\n因此，可以修改数组 str1 中存储的字符串常量的拷贝，但不能通过指针去直接修改字符串常量本身。\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day07/06.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>如上图：\nstr1 和 m 是两个不同的数组，各自存储着一份对字符串常量 \"hello\" 的拷贝\nstr2 和 n 是两个不同的指针，但是都指向同一个字符串常量 \"hello\" 的内存地址\n</code></pre></div><h2 id=\"_8-字符串初始化的方式\" tabindex=\"-1\"> 8. 字符串初始化的方式</h2>\n<div><pre><code><span>// 方式1</span>\n<span>char</span> str1<span>[</span><span>]</span> <span>=</span> <span>{</span><span>'h'</span><span>,</span> <span>'i'</span><span>,</span> <span>'\\0'</span><span>}</span><span>;</span>\n\n<span>// 方式2</span>\n<span>char</span> str2<span>[</span><span>]</span> <span>=</span> <span>\"hi\"</span><span>;</span>\n\n<span>// 方式3</span>\n<span>char</span> <span>*</span>str3 <span>=</span> <span>\"hi\"</span><span>;</span> \n\n<span>// 错误方式</span>\n<span>char</span> <span>*</span>str4 <span>=</span> <span>{</span><span>'h'</span><span>,</span> <span>'i'</span><span>,</span> <span>'\\0'</span><span>}</span><span>;</span>\n</code></pre></div><h2 id=\"_9-字符串-字符数组-字符指针-做函数实参\" tabindex=\"-1\"> 9. 字符串（字符数组/字符指针）做函数实参</h2>\n<div><pre><code>当字符串（字符数组），做函数参数时，不需要提供 2 个参数（1 个表示字符串首地址，1个表示字符串有效元素个数）。 \n因为每个字符串都有 '\\0'，可以借此判断是否遍历到了字符串的结尾\n</code></pre></div><h2 id=\"_10-字符串比较函数-strcmp-的实现\" tabindex=\"-1\"> 10. 字符串比较函数（<code>strcmp</code>）的实现</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day07/07.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_11-字符串拷贝函数-strcpy-的实现\" tabindex=\"-1\"> 11. 字符串拷贝函数（<code>strcpy</code>）的实现</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day07/08.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_12-字符串去空格\" tabindex=\"-1\"> 12. 字符串去空格</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day07/09.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_13-带参数的-main-函数-int-main-int-argc-char-argv\" tabindex=\"-1\"> 13. 带参数的 <code>main</code> 函数：<code>int main(int argc, char *argv[])</code></h2>\n<p><strong>无参 <code>main</code> 函数：</strong></p>\n<div><pre><code>int main(void)  &lt;=>  int main()\n</code></pre></div><p><strong>带参数的 <code>main</code> 函数：</strong></p>\n<div><pre><code>int main(int argc, char *argv[])   &lt;=>   int main(int argc, char **argv)\n\n参1：表示给 main 函数传递的参数的总个数。\n参2：是一个数组。数组的每一个元素都是字符串 char *\n</code></pre></div><p><strong>示例：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day07/10.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>如上图，参数 <code>argv</code> 数组中的第一个元素是 <strong>命令名称</strong>， 第二个元素开始才是 <strong>命令参数</strong>。</p>\n</blockquote>\n<p><strong><code>VS</code> 中设置命名参数的步骤：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day07/11.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_14-字符串操作函数-strstr-查找子串位置\" tabindex=\"-1\"> 14. 字符串操作函数：<code>strstr</code>（查找子串位置）</h2>\n<p><strong>作用：</strong></p>\n<div><pre><code>在 str 中，找 substr 出现的位置。\n</code></pre></div><p><strong>说明：</strong></p>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;string.h></span></span>\n<span>char</span> <span>*</span><span>strstr</span><span>(</span><span>char</span> <span>*</span>str<span>,</span> <span>char</span> <span>*</span>substr<span>)</span>\n    参数<span>1</span>：原串\n    参数<span>2</span>：子串\n    返回值：子串在原串中的位置。如果有，返回第 <span>1</span> 个子串的首地址值；如果没有，返回 <span>NULL</span>\n</code></pre></div><h2 id=\"_15-字符串中统计子串出现的次数\" tabindex=\"-1\"> 15. 字符串中统计子串出现的次数</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day07/12.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-17T07:26:38.000Z",
      "authors": [],
      "tags": [
        "C语言基础"
      ]
    },
    {
      "title": "第08天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day08.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day08.html",
      "content_html": "<h2 id=\"_1-求非空字符串元素个数\" tabindex=\"-1\"> 1. 求非空字符串元素个数</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/01.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_2-字符串逆置\" tabindex=\"-1\"> 2. 字符串逆置</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/02.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_3-回文字符串判断\" tabindex=\"-1\"> 3. 回文字符串判断</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/03.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_4-字符串处理函数\" tabindex=\"-1\"> 4. 字符串处理函数</h2>\n<h3 id=\"_4-1-字符串拷贝-strcpy-strncpy\" tabindex=\"-1\"> 4.1 字符串拷贝：<code>strcpy</code> &amp; <code>strncpy</code></h3>\n<p><strong><code>strcpy</code></strong></p>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;string.h></span></span>\n<span>char</span> <span>*</span><span>strcpy</span><span>(</span><span>char</span> <span>*</span>dest<span>,</span> <span>const</span> <span>char</span> <span>*</span>src<span>)</span><span>;</span>\n\n将 src 的内容，拷贝给 dest。返回 dest。 保证 dest 空间足够大。【不安全】，会发生缓冲区溢出。\n函数调用结束，返回值和 dest 参数结果一致。\n拷贝失败返回 <span>NULL</span>。\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/04.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>如上代码：\n1. 拷贝成功时，strcpy 返回的地址值和参数数组 dest 的地址值是一样的。\n2. 数组 dest 的大小 小于 被拷贝数组 src 的大小，此时会发生缓冲区溢出，\n   即 dest 数组内存范围之后的内存空间上也会存储着没拷贝完的 src 数组中的元素。\n   由于 printf 函数打印字符串时，遇 '\\0' 才结束，所以打印 dest 数组时，\n   dest 数组中没有 '\\0'，会继续打印 dest 数组内存范围之后的内容，从而把溢出的元素打印出来了。\n</code></pre></div><p><strong><code>strncpy</code></strong></p>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;string.h></span></span>\n<span>char</span> <span>*</span><span>strncpy</span><span>(</span><span>char</span> <span>*</span>dest<span>,</span> <span>const</span> <span>char</span> <span>*</span>src<span>,</span> <span>size_t</span> n<span>)</span><span>;</span> \n\n将 src 的内容，拷贝给 dest。只拷贝 n 个字节。 通常 n 与 dest 对应的空间一致。默认不添加 <span>'\\0'</span>\n\n特性：  \n<span>1.</span> n <span>></span> src：只拷贝 src 的大小\n<span>2.</span> n <span>&lt;</span> src：只拷贝 n 字节大小。不添加 <span>'\\0'</span>\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/05.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>如上代码：\nstrncpy(dest, src, 10) 只拷贝 10 个字符，即 \"hello worl\"，所以 dest 数组中也只有这 10 个字符，缺少 'd' 和 '\\0'\nprintf 函数将 dest 数组做字符串打印时，因为 dest 数组中没有 '\\0'，所以一直向后打印，\n从源数组 src 和 dest 数组的内存地址可以看出，printf 向后打印时，遇到 src 数组结尾处的 '\\0' 才停止。\n</code></pre></div><h3 id=\"_4-2-字符串拼接-strcat-strncat\" tabindex=\"-1\"> 4.2 字符串拼接：<code>strcat</code> &amp; <code>strncat</code></h3>\n<p><strong><code>strcat</code></strong></p>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;string.h></span></span>\n<span>char</span> <span>*</span><span>strcat</span><span>(</span><span>char</span> <span>*</span>dest<span>,</span> <span>const</span> <span>char</span> <span>*</span>src<span>)</span><span>;</span>\n\n将 src 的内容，拼接到 dest 后。返回拼接后的字符串。保证 dest 空间足够大。\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/06.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>如上代码：\n1. strcat 函数的返回的地址值就是参数数组 dest 的首地址；\n2. strcat 函数拼接字符串时，是直接往 dest 数组中追加字符，所以要保证 dest 数组的内存空间足够大，否则会导致缓冲区溢出。\n</code></pre></div><p><strong><code>strncat</code></strong></p>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;string.h></span></span>\n<span>char</span> <span>*</span><span>strncat</span><span>(</span><span>char</span> <span>*</span>dest<span>,</span> <span>const</span> <span>char</span> <span>*</span>src<span>,</span> <span>size_t</span> n<span>)</span><span>;</span>\n\n将 src 的前 n 个字符，拼接到 dest 后。返回拼接后的字符串。保证 dest 空间足够大。默认添加 <span>'\\0'</span>\n\n函数调用结束，返回值和 dest 参数结果一致。\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/07.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>如上代码：\n1. strncat 函数的返回的地址值就是参数数组 dest 的首地址；\n2. strncat 函数拼接字符串时，是直接往 dest 数组中追加字符，所以要保证 dest 数组的内存空间足够大，否则会导致缓冲区溢出；\n3. strlen 函数计算字符串长度时，不考虑存储字符串的数组的空间大小，以字符串结束标记 '\\0' 为准。\n</code></pre></div><h3 id=\"_4-3-字符串比较-strcmp-strncmp\" tabindex=\"-1\"> 4.3 字符串比较：<code>strcmp</code> &amp; <code>strncmp</code></h3>\n<blockquote>\n<p>注意：不能使用 <code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>==</code>、<code>!=</code> 比较字符串。</p>\n</blockquote>\n<p><strong><code>strcmp</code></strong></p>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;string.h></span></span>\n<span>int</span> <span>strcmp</span><span>(</span><span>const</span> <span>char</span> <span>*</span>s1<span>,</span> <span>const</span> <span>char</span> <span>*</span>s2<span>)</span><span>;</span>\n\n比较 s1 和 s2 两个字符串，如果相等返回 <span>0</span>；如果不相等，进一步比较 s1 和 s2 对应位的字符的 ASCII 码值。\ns1 <span>==</span> s2 返回  <span>0</span>\ns1 <span>></span> s2  返回  <span>1</span>\ns1 <span>&lt;</span> s2  返回 <span>-</span><span>1</span>\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/08.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>如上代码：\n1. strcmp 函数比较时，不考虑字符串的长短，仅以对应位字符的 ASCII 码作比较。\n</code></pre></div><p><strong><code>strncmp</code></strong></p>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;string.h></span></span>\n<span>int</span> <span>strncmp</span><span>(</span><span>const</span> <span>char</span> <span>*</span>s1<span>,</span> <span>const</span> <span>char</span> <span>*</span>s2<span>,</span> <span>size_t</span> n<span>)</span><span>;</span>\n\n比较 s1 和 s2 两个字符串的前 n 个字符，\n如果相等，返回 <span>0</span>。如果不相等，进一步比较 s1 和 s2 对应位的字符的 ASCII 码值。\ns1 <span>></span> s2 返回  <span>1</span>\ns1 <span>&lt;</span> s2 返回 <span>-</span><span>1</span>\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/09.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_4-4-字符串格式化输入输出-sprintf-sscanf\" tabindex=\"-1\"> 4.4 字符串格式化输入输出：<code>sprintf</code> &amp; <code>sscanf</code></h3>\n<p><strong><code>sprintf</code></strong></p>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>int</span> <span>sprintf</span><span>(</span><span>char</span> <span>*</span>str<span>,</span> <span>const</span> <span>char</span> <span>*</span>format<span>,</span> <span>.</span><span>.</span><span>.</span><span>)</span><span>;</span>\n\n对应 printf，将原来写到屏幕的 “格式化字符串”，写到参数<span>1</span> str 中。\n返回 str 所指向的字符串的长度，不包含 <span>'\\0'</span>\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/10.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong><code>sscanf</code></strong></p>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>int</span> <span>sscanf</span><span>(</span><span>const</span> <span>char</span> <span>*</span>str<span>,</span> <span>const</span> <span>char</span> <span>*</span>format<span>,</span> <span>.</span><span>.</span><span>.</span><span>)</span><span>;</span>\n\n对应 scanf，将原来从屏幕获取的 “格式化字符串”， 从参数<span>1</span> str 中获取。\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/11.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_4-5-字符串查找字符-strchr-strrchr\" tabindex=\"-1\"> 4.5 字符串查找字符：<code>strchr</code> &amp; <code>strrchr</code></h3>\n<p><strong><code>strchr</code></strong></p>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;string.h></span></span>\n<span>char</span> <span>*</span><span>strchr</span><span>(</span><span>const</span> <span>char</span> <span>*</span>s<span>,</span> <span>int</span> c<span>)</span><span>;</span>\n\n自左向右，在字符串 str 中找一个字符出现的位置。返回字符在字符串中的地址。\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/12.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong><code>strrchr</code></strong></p>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;string.h></span></span>\n<span>char</span> <span>*</span><span>strrchr</span><span>(</span><span>const</span> <span>char</span> <span>*</span>s<span>,</span> <span>int</span> c<span>)</span><span>;</span>\n\n自右向左，在字符串 str 中找一个字符出现的位置。返回字符在字符串中的地址。\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/13.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_4-6-字符串查找子串-strstr\" tabindex=\"-1\"> 4.6 字符串查找子串：<code>strstr</code></h3>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;string.h></span></span>\n<span>char</span> <span>*</span><span>strstr</span><span>(</span><span>const</span> <span>char</span> <span>*</span>str<span>,</span> <span>const</span> <span>char</span> <span>*</span>substr<span>)</span><span>;</span>\n\n在字符串 str 中，找子串 substr 第一次出现的位置。返回地址。\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/14.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_4-7-字符串分割-strtok\" tabindex=\"-1\"> 4.7 字符串分割：<code>strtok</code></h3>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;string.h></span></span>\n<span>char</span> <span>*</span><span>strtok</span><span>(</span><span>char</span> <span>*</span>str<span>,</span> <span>const</span> <span>char</span> <span>*</span>delim<span>)</span><span>;</span>\n    参数<span>1</span>：待拆分字符串\n    参数<span>2</span>：分割符组成的 “分割串”\n    返回：字符串拆分后的第 <span>1</span> 个拆分字符串首地址。拆分失败返回 <span>NULL</span>（如被拆分字符串为空字符串 <span>\"\"</span> 时返回 <span>NULL</span>）\n\n按照既定的分割符，来拆分字符串。\n“拆分” 就是：将分割字符用 <span>'\\0'</span> 替换。【重要】\n每调用一次，只拆分一次：<span>\"www.baidu.com\"</span> <span>-></span> <span>\"www\\0baidu.com\"</span>【重要】\n\n特性：\n<span>1.</span> strtok 拆分字符串是直接在原串上操作，所以要求参数<span>1</span>必须可读可写（<span>char</span> <span>*</span>str <span>=</span> <span>\"www.baidu.com\"</span> 不行！！！）\n<span>2.</span> 第一次拆分，参数<span>1</span>传入待拆分的原串。第 <span>1</span><span>+</span>i 次拆分时 <span>[</span>i<span>=</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3.</span><span>.</span><span>.</span><span>]</span>，参数<span>1</span>传入 <span>NULL</span>。\n</code></pre></div><p><strong>示例1：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/15.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>示例2：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/16.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_4-8-字符串转整数或浮点数-atoi-atof-atol\" tabindex=\"-1\"> 4.8 字符串转整数或浮点数：<code>atoi</code>/<code>atof</code>/<code>atol</code></h3>\n<div><pre><code>atoi/atof/atol：a（字符串）  to（转） i（int整数）/ f（浮点数）/ l（long整数）\n使用这类函数进行转换时要求：原串必须是可转换的字符串。\n错误使用：\"abc123\" -> 0;    \"12abc345\" -> 12;  \"123xyz\" -> 123\n</code></pre></div><p><strong><code>atoi</code> 字符串转整数</strong></p>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdlib.h></span></span>\n<span>int</span> <span>atoi</span><span>(</span><span>const</span> <span>char</span> <span>*</span>nptr<span>)</span><span>;</span>\n</code></pre></div><p><strong><code>atof</code> 字符串转浮点数</strong></p>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdlib.h></span></span>\n<span>double</span> <span>atof</span><span>(</span><span>const</span> <span>char</span> <span>*</span>nptr<span>)</span><span>;</span>\n</code></pre></div><p><strong><code>atol</code> 字符串转长整数</strong></p>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdlib.h></span></span>\n<span>long</span> <span>atol</span><span>(</span><span>const</span> <span>char</span> <span>*</span>nptr<span>)</span><span>;</span>\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/17.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_5-局部变量-及其作用域\" tabindex=\"-1\"> 5. 局部变量（及其作用域）</h2>\n<div><pre><code>概念：定义在函数内部的变量。\n作用域：从定义位置开始，到包裹该变量的第一个右大括号结束。\n</code></pre></div><h2 id=\"_6-全局变量-及其作用域\" tabindex=\"-1\"> 6. 全局变量（及其作用域）</h2>\n<div><pre><code>概念：定义在函数外部的变量。\n作用域：从定义位置开始，默认到本文件内部。其他文件如果想使用，可以通过声明方式（extern）将作用域导出。\n</code></pre></div><h2 id=\"_7-static-全局变量-及其作用域\" tabindex=\"-1\"> 7. <code>static</code> 全局变量（及其作用域）</h2>\n<div><pre><code>定义语法：在全局变量定义之前添加 static 关键字。如：static int a = 10；\n作用域：被限制在本文件内部，不允许通过声明导出到其他文件。\n</code></pre></div><h2 id=\"_8-static-局部变量-及其作用域\" tabindex=\"-1\"> 8. <code>static</code> 局部变量（及其作用域）</h2>\n<div><pre><code>定义语法：在局部变量定义之前添加 static 关键字。\n特性：静态局部变量只在全局位置上定义一次。 通常用来做计数器。\n作用域：从定义位置开始，到包裹该变量的第一个右大括号结束。（作用域跟非 static 局部变量一致，但生命周期不同）\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/18.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>如上图，对比可看出，右侧的静态局部变量 <code>a</code> 只定义了一次，即重复调用 <code>test</code> 函数时，不会再重复定义静态局部变量 <code>a</code>，从而达到了递增的目的。</p>\n</blockquote>\n<h2 id=\"_9-全局函数\" tabindex=\"-1\"> 9. 全局函数</h2>\n<div><pre><code>定义语法： 函数原型 + 函数体\n</code></pre></div><h2 id=\"_10-static-函数\" tabindex=\"-1\"> 10. <code>static</code> 函数</h2>\n<div><pre><code>定义语法：static + 函数原型 + 函数体\nstatic 函数只能在本文件内部使用。其他文件即使声明也无效。\n</code></pre></div><h2 id=\"_11-生命周期-生命周期和作用域之间没有关系\" tabindex=\"-1\"> 11. 生命周期（生命周期和作用域之间没有关系）</h2>\n<div><pre><code>局部变量：       从变量定义开始，函数调用完成。 --- 函数内部。\n\n全局变量：       程序启动开始，程序终止结束。  --- 程序执行期间。\n\nstatic局部变量： 程序启动开始，程序终止结束。  --- 程序执行期间。\n\nstatic全局变量： 程序启动开始，程序终止结束。  --- 程序执行期间。\n\n全局函数：       程序启动开始，程序终止结束。  --- 程序执行期间。\n\nstatic函数：     程序启动开始，程序终止结束。  --- 程序执行期间。\n</code></pre></div><h2 id=\"_12-内存四区模型-代码段-数据段-stack-heap\" tabindex=\"-1\"> 12. 内存四区模型：代码段 &amp; 数据段 &amp; <code>stack</code> &amp; <code>heap</code></h2>\n<div><pre><code>代码段：\n    .text段。 程序源代码（二进制形式）。\n\n数据段：\n    只读数据段 .rodata 段。（常量）\n    初始化数据段 .data 段。（初始化为非 0 的全局变量和静态变量【包括静态局部变量和静态全局变量】）\n    未初始化数据段 .bss 段。（初始化为 0 or 未初始化的全局变量和静态变量。程序加载执行前，会将该段整体赋值为 0）\n\nstack：\n    栈。 在其之上开辟栈帧。    \n    windows 1M --- 10M    Linux： 8M --- 16M\n\nheap：\n    堆。 给用户自定义数据提供空间。 约 1.3G+\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/19.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p><code>windows</code> 底层源码未开源，所以 <code>windows</code> 的内存4区模型只是大致的；</p>\n<p><code>Linux</code> 底层源码是开源的，所以上图 <code>Linux</code> 的内存4区模型就是实际的。</p>\n</blockquote>\n<h2 id=\"_13-申请-释放堆空间-heap-空间\" tabindex=\"-1\"> 13. 申请 &amp; 释放堆空间（<code>heap</code> 空间）</h2>\n<h3 id=\"_13-1-申请堆空间-void-malloc-size-t-size\" tabindex=\"-1\"> 13.1 申请堆空间：<code>void *malloc(size_t size)</code></h3>\n<div><pre><code><span>void</span> <span>*</span><span>malloc</span><span>(</span><span>size_t</span> size<span>)</span><span>;</span>  \n\n申请 size 大小的空间。\n返回实际申请到的内存空间首地址。【我们通常拿来当数组用】\n</code></pre></div><h3 id=\"_13-2-释放堆空间-void-free-void-ptr\" tabindex=\"-1\"> 13.2 释放堆空间：<code>void free(void *ptr)</code></h3>\n<div><pre><code><span>void</span> <span>free</span><span>(</span><span>void</span> <span>*</span>ptr<span>)</span><span>;</span>   \n\n参数 ptr：malloc 申请函数返回的地址值。\n</code></pre></div><p><strong>示例：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/20.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>如上代码：\n1. 形如 int arr[1000000] = {10, 20, 40}; 是在栈（stack）上申请内存空间，因为栈空间较小，所以当申请空间过大时，会发生栈溢出。  \n   而调用 malloc 函数，则是在堆（heap）上申请内存空间，因为堆空间远大于栈空间，所以并不会发生内存溢出。\n\n2. malloc 函数的返回值类型为 void * ，是可以隐式转换为 int * 的。 但是，为了使代码更明确，一般通过 (类型) 显示转换为指定类型。\n</code></pre></div><h3 id=\"_13-3-使用堆空间的注意事项\" tabindex=\"-1\"> 13.3 使用堆空间的注意事项</h3>\n<div><pre><code>1. 空间是连续。当成数组使用。\n2. free 后的空间，不会立即失效。通常将 free 后的地址置为 NULL。\n3. free 地址必须是 malloc 申请地址。否则出错。（如果 malloc 之后的地址一定会变化，那么使用临时变量 tmp 保存）\n</code></pre></div><p><strong>示例1：</strong></p>\n<div><pre><code>如下代码，虽然调用 free 函数后，指针 p 所指向的地址空间中的数据被清除了，\n但是指针 p 所指向的地址空间还是可以访问的，即该地址空间仍然有效，可以使用。\n因此，为了避免使用 free 后的地址空间，应该将指针 p 置为 NULL。\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/21.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>示例2：</strong></p>\n<div><pre><code>如下代码，原本指向 malloc 所申请空间首地址的指针 p 的指向发生了改变（p++;）\n此时，再调用 free(p); 所释放的地址就不是 malloc 所申请空间的首地址了，从而程序报错。\n解决方案：使用临时变量 tmp 保存 malloc 申请到的空间首地址。即：\n\n    char *tmp = p;\n    ...\n    p++;\n    ...\n    free(tmp);\n    p = NULL;\n    tmp = NULL;\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/22.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_13-4-二级指针对应的堆空间\" tabindex=\"-1\"> 13.4 二级指针对应的堆空间</h3>\n<div><pre><code>申请外层指针： \n    char **p = (char **)malloc(sizeof(char *) * 5);\n\n申请内层指针： \n    for(i = 0; i &lt; 5; i++)\n    {\n        p[i] = (char *)malloc(sizeof(char) *10);\n    }\n\n使用：不能修改 p 的值。\n    for(i = 0; i &lt; 5; i++)\n    {\n        strcpy(p[i], \"helloheap\");\n    }\n\n释放内层：\n    for(i = 0; i &lt; 5; i++)\n    {\n        free(p[i]);\n    }\n\n释放外层：\n    free(p);\n</code></pre></div><p><strong>示例：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/23.png\" alt=\"\" loading=\"lazy\"></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/24.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_14-内存常见问题\" tabindex=\"-1\"> 14. 内存常见问题</h2>\n<h3 id=\"_14-1-问题1-申请-0-字节空间\" tabindex=\"-1\"> 14.1 问题1：申请 <code>0</code> 字节空间</h3>\n<div><pre><code><span>int</span> <span>*</span>p <span>=</span> <span>(</span><span>int</span> <span>*</span><span>)</span><span>malloc</span><span>(</span><span>0</span><span>)</span><span>;</span> <span>// 此时指针 p 其实就是野指针</span>\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/25.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_14-2-问题2-多次-free-同一个指针\" tabindex=\"-1\"> 14.2 问题2：多次 <code>free</code> 同一个指针</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/26.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_14-3-问题3-free-空指针\" tabindex=\"-1\"> 14.3 问题3：<code>free</code> 空指针</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/27.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_14-4-问题4-越界访问\" tabindex=\"-1\"> 14.4 问题4：越界访问</h3>\n<h3 id=\"_14-5-问题5-free-后的地址\" tabindex=\"-1\"> 14.5 问题5：<code>free</code> ++后的地址</h3>\n<h3 id=\"_14-6-问题6-子函数-malloc-空间-main-中用\" tabindex=\"-1\"> 14.6 问题6：子函数 <code>malloc</code> 空间，<code>main</code> 中用</h3>\n<h2 id=\"_15-内存操作函数\" tabindex=\"-1\"> 15. 内存操作函数</h2>\n<h3 id=\"_15-1-内存填充-memset\" tabindex=\"-1\"> 15.1 内存填充：<code>memset</code></h3>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;string.h></span></span>\n<span>void</span> <span>*</span><span>memset</span><span>(</span><span>void</span> <span>*</span>s<span>,</span> <span>int</span> c<span>,</span> <span>size_t</span> n<span>)</span><span>;</span>\n    功能：将 s 指向的内存区域的前 n 个字节以参数 c 填入\n    参数：\n        s：需要操作内存 s 的首地址\n        c：填充的字符，c 虽然参数为i nt，但必须是 <span>unsigned</span> <span>char</span> <span>,</span> 范围为 <span>0</span><span>~</span><span>255</span>\n        n：指定需要设置的大小，单位：字节\n    返回值：s 的首地址\n</code></pre></div><p><strong>示例1：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/28.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>示例2：通常使用 <code>memset</code> 函数将内存空间重置为 <code>0</code></strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/29.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p><strong>注意：</strong> 如上代码所示，<code>memset</code> 函数还可以用来重置栈上的内存空间。</p>\n</blockquote>\n<h3 id=\"_15-2-内存拷贝-memcpy\" tabindex=\"-1\"> 15.2 内存拷贝：<code>memcpy</code></h3>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;string.h></span></span>\n<span>void</span> <span>*</span><span>memcpy</span><span>(</span><span>void</span> <span>*</span>dest<span>,</span> <span>const</span> <span>void</span> <span>*</span>src<span>,</span> <span>size_t</span> n<span>)</span><span>;</span>\n    功能：拷贝 src 所指的内存内容的前 n 个字节到 dest 所值的内存地址上。\n    参数：\n        dest：目的内存首地址\n        src：源内存首地址，注意：des t和 src 所指的内存空间不可重叠，可能会导致程序报错。\n        n：需要拷贝的字节数\n    返回值：dest 的首地址\n\n    memcpy 的错误用法（内存重叠）：\n    <span>int</span> a<span>[</span><span>10</span><span>]</span> <span>=</span> <span>{</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>,</span> <span>10</span> <span>}</span><span>;</span>\n    <span>memcpy</span><span>(</span><span>&amp;</span>a<span>[</span><span>3</span><span>]</span><span>,</span> a<span>,</span> <span>5</span> <span>*</span> <span>sizeof</span><span>(</span><span>int</span><span>)</span><span>)</span><span>;</span> <span>// err, 内存重叠，即：可能导致对同一个内存单元同时进行读和写的操作</span>\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/30.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_15-3-内存移动-memmove\" tabindex=\"-1\"> 15.3 内存移动：<code>memmove</code></h3>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;string.h></span></span>\n<span>void</span> <span>*</span><span>memcpy</span><span>(</span><span>void</span> <span>*</span>dest<span>,</span> <span>const</span> <span>void</span> <span>*</span>src<span>,</span> <span>size_t</span> n<span>)</span><span>;</span>\n    功能：拷贝 src 所指的内存内容的前 n 个字节到 dest 所值的内存地址上。\n    参数：\n        dest：目的内存首地址\n        src：源内存首地址，注意：dest 和 src 所指的内存空间不可重叠，可能会导致程序报错\n        n：需要拷贝的字节数\n    返回值：dest 的首地址\n\n    <span>memmove</span><span>(</span><span>)</span> 功能用法和 <span>memcpy</span><span>(</span><span>)</span> 一样，区别在于：\n        dest 和 src 所指的内存空间重叠时，<span>memmove</span><span>(</span><span>)</span>仍然能处理，不过执行效率比 <span>memcpy</span><span>(</span><span>)</span> 低些。\n        如果 dest 和 src 所指的内存空间没有重叠，两个函数效率一样\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/31.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_15-4-内存比较-memcmp\" tabindex=\"-1\"> 15.4 内存比较：<code>memcmp</code></h3>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;string.h></span></span>\n<span>int</span> <span>memcmp</span><span>(</span><span>const</span> <span>void</span> <span>*</span>s1<span>,</span> <span>const</span> <span>void</span> <span>*</span>s2<span>,</span> <span>size_t</span> n<span>)</span><span>;</span>\n    功能：比较 s1 和 s2 所指向内存区域的前 n 个字节\n    参数：\n        s1：内存首地址<span>1</span>\n        s2：内存首地址<span>2</span>\n        n：需比较的前 n 个字节\n    返回值：\n        相等：<span>=</span><span>0</span>\n        大于：<span>></span><span>0</span>\n        小于：<span>&lt;</span><span>0</span>\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/32.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-21T05:58:47.000Z",
      "authors": [],
      "tags": [
        "C语言基础"
      ]
    },
    {
      "title": "第09天（结构体&共用体&枚举）",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day09.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day09.html",
      "content_html": "<h2 id=\"_1-结构体的定义和使用\" tabindex=\"-1\"> 1. 结构体的定义和使用</h2>\n<p><strong>定义结构体类型：</strong></p>\n<div><pre><code>struct 结构体名称\n{\n   结构体成员列表\n};\n</code></pre></div><p><strong>定义结构体变量：</strong></p>\n<div><pre><code>struct 结构体名称 结构体变量名\n</code></pre></div><p><strong>为结构体成员变量赋值：</strong></p>\n<div><pre><code>结构体变量名.结构体成员变量 = 值\n</code></pre></div><blockquote>\n<p>如果结构体成员变量是字符串类型，那么需要使用 <code>strcpy</code> 进行赋值。</p>\n</blockquote>\n<p><strong>注意：定义结构体类型的时候不能为成员变量赋值</strong></p>\n<div><pre><code><span>struct</span> <span>student</span>\n<span>{</span>\n    <span>// int age = 18; //错误</span>\n    <span>.</span><span>.</span><span>.</span>\n<span>}</span>\n</code></pre></div><p><strong>示例1：定义结构体变量的同时，按照结构体顺序赋值</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/01.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>示例2：定义结构体变量的同时，为指定的结构体成员赋值</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/02.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>示例3：先定义结构体变量，再为结构体成员赋值</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/03.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>示例4：定义结构体类型的同时，声明结构体变量</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/04.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>示例5：定义结构体类型的同时，声明结构体变量，并初始化赋值</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/05.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>示例6：定义结构体类型的同时，声明多个结构体变量，并初始化赋值</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/06.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_2-结构体大小和在内存中的存储结构\" tabindex=\"-1\"> 2. 结构体大小和在内存中的存储结构</h2>\n<div><pre><code>结构体需要根据数据类型进行内存对齐，\n因此，以所占内存最大的成员变量数据类型的所占字节数，作为结构体变量进行内存对齐时的内存单元。\n</code></pre></div><p><strong>示例1：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/07.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>示例2：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/08.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>对比如上两个示例可以看出：通过调整结构体的成员列表，可以减少结构体所占的内存大小。\n一般地，按照成员变量所占内存从大到小的顺序定义成员列表，可以节省结构体所占的内存空间。但是，这样排列成员列表，可能不方便代码阅读。\n实际开发中，应该按照既方便代码阅读，又能节省内存空间的方式排列成员列表（即：二者之间取其平衡点）\n</code></pre></div><h3 id=\"_2-1-求结构体所占内存空间大小\" tabindex=\"-1\"> 2.1 求结构体所占内存空间大小</h3>\n<div><pre><code>1. 通过结构体变量求： sizeof(stu)\n2. 通过结构体类型求： sizeof(struct stus1)\n</code></pre></div><h2 id=\"_3-结构体数组\" tabindex=\"-1\"> 3. 结构体数组</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/09.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_4-结构体数组排序\" tabindex=\"-1\"> 4. 结构体数组排序</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/10.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_5-结构体中包含指针类型的成员变量\" tabindex=\"-1\"> 5. 结构体中包含指针类型的成员变量</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/11.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_6-指向结构体类型的指针-即结构体指针\" tabindex=\"-1\"> 6. 指向结构体类型的指针（即结构体指针）</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/12.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_7-在堆空间中创建结构体\" tabindex=\"-1\"> 7. 在堆空间中创建结构体</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/13.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_8-结构体案例\" tabindex=\"-1\"> 8. 结构体案例</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/14.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_9-结构体和函数\" tabindex=\"-1\"> 9. 结构体和函数</h2>\n<h3 id=\"_9-1-结构体变量作形参-值传递\" tabindex=\"-1\"> 9.1 结构体变量作形参（值传递）</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/15.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_9-2-结构体指针作形参-地址传递\" tabindex=\"-1\"> 9.2 结构体指针作形参（地址传递）</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/16.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_9-3-函数返回值类型为结构体类型\" tabindex=\"-1\"> 9.3 函数返回值类型为结构体类型</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/17.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_9-4-函数返回值类型为结构体指针类型\" tabindex=\"-1\"> 9.4 函数返回值类型为结构体指针类型</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/18.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_10-结构体嵌套\" tabindex=\"-1\"> 10. 结构体嵌套</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/19.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_11-共用体-联合体\" tabindex=\"-1\"> 11. 共用体（联合体）</h2>\n<div><pre><code>1. 共用体就是在同一个存储空间存储不同类型数据的类型；\n2. 共用体所占的内存长度，等于其最长成员的长度倍数；\n3. 同一内存段可以用来存放几种不同类型的成员，但每一瞬时只有一种起作用；\n4. 共用体变量中起作用的成员是最后一次存放的成员，在存入一个新的成员后原有的成员的值会被覆盖；\n5. 共用体变量的地址和它的各成员的地址都是同一地址。\n</code></pre></div><p><strong>示例1：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/20.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>示例2：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/21.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>示例3：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/22.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_12-枚举\" tabindex=\"-1\"> 12. 枚举</h2>\n<div><pre><code>1. 在枚举值表中应列出所有可用值，也称为枚举元素 or 枚举常量。\n    enum color { 枚举常量 };  =>  enum color { red, green, blue, black, pink, yellow };\n\n2. 枚举值是常量，不能在程序中用赋值语句再对它赋值。\n\n3. 枚举常量是整型常量。不能是浮点数。可以是负值。 \n   默认初值从 0 开始，后续常量较前一个常量 +1。\n   可以给任意一个常量赋任意初值。后续常量较前一个常量 +1\n</code></pre></div><p><strong>示例1：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/23.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>示例2：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/24.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_13-typedef-关键字-为数据类型起别名\" tabindex=\"-1\"> 13. <code>typedef</code> 关键字（为数据类型起别名）</h2>\n<div><pre><code>1. typedef 为C语言的关键字，作用是为一种数据类型（基本类型或自定义数据类型）定义一个新名字，不能创建新类型。\n2. 与 #define 不同，typedef 仅限于数据类型，而不是能是表达式或具体的值\n3. #define 发生在预处理，typedef 发生在编译阶段\n</code></pre></div><p><strong>示例1：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/25.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>示例2：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/26.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-21T05:58:47.000Z",
      "authors": [],
      "tags": [
        "C语言基础"
      ]
    },
    {
      "title": "第10天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day10.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day10.html",
      "content_html": "<h2 id=\"_1-printf-scanf-perror-函数与其对应的系统文件\" tabindex=\"-1\"> 1. <code>printf</code>/<code>scanf</code>/<code>perror</code> 函数与其对应的系统文件</h2>\n<p><code>printf</code>（标准输入）、<code>scanf</code>（标准输出）、<code>perror</code>（标准错误） 这三个函数分别用于向不同的系统文件（<code>stdin</code> 文件、<code>stdout</code> 文件、<code>stderr</code> 文件）中读写数据，然后再通过操作系统，将系统文件和物理设备关联起来。</p>\n<div><pre><code>scanf函数  -- 标准输入 -- stdin文件（编号0）  -- 键盘\n\nprintf函数 -- 标准输出 -- stdout文件（编号1） -- 屏幕\n\nperror函数 -- 标准错误 -- stderr文件（编号2） -- 屏幕\n</code></pre></div><h3 id=\"_1-1-系统文件的隐式回收\" tabindex=\"-1\"> 1.1 系统文件的隐式回收</h3>\n<p>应用程序启动时，自动被打开；程序执行结束时，自动被关闭。</p>\n<h2 id=\"_2-文件指针和普通指针的区别\" tabindex=\"-1\"> 2. 文件指针和普通指针的区别</h2>\n<p>与普通指针不同的是，文件指针的初始化、赋值等操作基本都是借助文件操作函数来实现的，如：</p>\n<ol>\n<li>\n<p>借助文件操作函数来改变 <code>fp</code> 为空、野指针的状况</p>\n<div><pre><code>FILE <span>*</span>fp <span>=</span> <span>NULL</span><span>;</span>\nfp <span>=</span> <span>fopen</span><span>(</span><span>\"test2.txt\"</span><span>,</span> <span>\"w\"</span><span>)</span><span>;</span> <span>// fopen() 函数相当于 fp = malloc();</span>\n</code></pre></div></li>\n<li>\n<p>操作文件，使用文件读写函数来完成。如：</p>\n<div><pre><code>fputc/fgetc\nfputs/fgets\nfwrite/fread\n</code></pre></div></li>\n</ol>\n<h3 id=\"_2-1-file-结构体\" tabindex=\"-1\"> 2.1 <code>FILE</code> 结构体</h3>\n<p><code>FILE</code> 是系统使用 <code>typedef</code> 定义出来的有关文件信息的一种结构体类型，结构中含有文件名、文件状态和文件当前位置等信息:</p>\n<div><pre><code><span>typedef</span> <span>struct</span>\n<span>{</span>\n    <span>short</span>           level<span>;</span>     <span>// 缓冲区\"满\"或者\"空\"的程度</span>\n    <span>unsigned</span>        flags<span>;</span>     <span>// 文件状态标志</span>\n    <span>char</span>            fd<span>;</span>        <span>// 文件描述符</span>\n    <span>unsigned</span> <span>char</span>   hold<span>;</span>      <span>// 如无缓冲区不读取字符</span>\n    <span>short</span>           bsize<span>;</span>     <span>// 缓冲区的大小</span>\n    <span>unsigned</span> <span>char</span>   <span>*</span>buffer<span>;</span>   <span>// 数据缓冲区的位置</span>\n    <span>unsigned</span>        ar<span>;</span>        <span>// 指针，当前的指向</span>\n    <span>unsigned</span>        istemp<span>;</span>    <span>// 临时文件，指示器</span>\n    <span>short</span>           token<span>;</span>     <span>// 用于有效性的检查</span>\n<span>}</span>FILE<span>;</span>\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day10/01.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_3-文件分类-设备文件-磁盘文件\" tabindex=\"-1\"> 3. 文件分类：设备文件 &amp; 磁盘文件</h2>\n<p><strong>设备文件</strong></p>\n<div><pre><code>屏幕、键盘、磁盘、网卡、声卡、显卡、扬声器 ...\n</code></pre></div><p><strong>磁盘文件</strong></p>\n<div><pre><code>文本文件：\n    ASCII\n\n二进制文件： \n    0101 二进制编码\n</code></pre></div><h2 id=\"_4-文件操作一般步骤\" tabindex=\"-1\"> 4. 文件操作一般步骤</h2>\n<div><pre><code>1. 打开文件 fopen() => 返回 FILE *fp 指针;\n\n2. 读写文件 fputc、fgetc、fputs、fgets、fread、fwrite\n\n3. 关闭文件 fclose()  \n</code></pre></div><h2 id=\"_5-打开、关闭文件函数-fopen-fclose\" tabindex=\"-1\"> 5. 打开、关闭文件函数：<code>fopen</code> &amp; <code>fclose</code></h2>\n<p><strong>打开文件</strong></p>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\nFILE <span>*</span> <span>fopen</span><span>(</span><span>const</span> <span>char</span> <span>*</span> filename<span>,</span> <span>const</span> <span>char</span> <span>*</span> mode<span>)</span><span>;</span>\n    参<span>1</span>：待打开文件的文件名（访问路径）\n    参<span>2</span>：文件打开权限：\n        <span>\"r\"</span>：只读方式打开文件，文件不存在，报错。存在，以只读方式打开。\n        <span>\"w\"</span>：只写方式打开文件，文件不存在，创建一个空文件。文件如果存在，清空并打开。\n        <span>\"w+\"</span>：读、写方式打开文件，文件不存在，创建一个空文件。文件如果存在，清空并打开。\n        <span>\"r+\"</span>：读、写方式打开文件<span>,</span> 文件不存在，报错。存在，以读写方式打开。\n        <span>\"a\"</span>：以追加的方式打开文件。\n        <span>\"b\"</span>：操作的文件是一个二进制文件\n             b 只是在 Windows 有效，在 Linux 用 r 和 rb 的结果是一样的，\n             这是因为文本方式和二进制方式在打开文件时的区别，仅仅体现在换行符的处理上，\n             而 Linux 下的换行符就是 \\n，所以文本文件方式和二进制方式无区别；\n             对于 Window 系统：\n                当对文件使用文本方式打开的时候，读写的 windows 文件中的换行符 \\r\\n 会被替换成 \\n 读到内存中，\n                当在 windows 下写入文件的时候，\\n 被替换成 \\r\\n 再写入文件。\n                如果使用二进制方式打开文件，则不进行 \\r\\n 和 \\n 之间的转换。\n                也就是说，<span>\"b\"</span> 的作用就在于：不进行 \\r\\n 和 \\n 之间的转换。 \n    返回值：\n        成功：返回打开文件的文件指针\n        失败：<span>NULL</span>\n</code></pre></div><p><strong>关闭文件</strong></p>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>int</span> <span>fclose</span><span>(</span>FILE <span>*</span> stream<span>)</span><span>;</span>\n    参<span>1</span>：打开文件的 fp（fopen 的返回值）\n    返回值：\n        成功： <span>0</span>， \n        失败：<span>-</span><span>1</span><span>;</span>\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day10/02.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_6-文件访问路径-绝对路径-相对路径\" tabindex=\"-1\"> 6. 文件访问路径：绝对路径 &amp; 相对路径</h2>\n<p><strong>绝对路径</strong></p>\n<div><pre><code>从系统磁盘的根盘符开始，找到待访问的文件路径。\nWindows 书写方法：\n    1. C:\\\\Users\\\\afei\\\\Desktop\\\\06-文件分类.avi\n    2. C:/Users/afei/Desktop/06-文件分类.avi  (也适用于 Linux)\n</code></pre></div><p><strong>相对路径</strong></p>\n<div><pre><code>1. 如果在 VS 环境下编译执行（Ctrl+F5），文件相对路径是指相对于 day10.vcxproj 所在目录位置。\n2. 如果是双击 xxx.exe 文件执行，文件的相对路径是相对于 xxx.exe 所在目录位置。\n</code></pre></div><h2 id=\"_7-按字符写文件-fputc\" tabindex=\"-1\"> 7. 按字符写文件：<code>fputc</code></h2>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>int</span> <span>fputc</span><span>(</span><span>int</span> ch<span>,</span> FILE <span>*</span> stream<span>)</span><span>;</span>\n    参<span>1</span>：待写入的字符\n    参<span>2</span>：打开文件的 fp（fopen 的返回值）\n    返回值：\n        成功：写入文件中的字符对应的 ASCII 码\n        失败：<span>-</span><span>1</span>\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day10/03.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_8-按字符读文件-fgetc\" tabindex=\"-1\"> 8. 按字符读文件：<code>fgetc</code></h2>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>int</span> <span>fgetc</span><span>(</span>FILE <span>*</span> stream<span>)</span><span>;</span>\n    参<span>1</span>：待读取的文件 fp（fopen 的返回值）\n    返回值： \n        成功：读到的字符对应的 ASCII 码\n        失败：<span>-</span><span>1</span>\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day10/04.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>文本文件的结束标记：<code>EOF</code></p>\n<div><pre><code><span><span>#</span><span>define</span> <span>EOF</span>  <span><span>(</span><span>-</span><span>1</span><span>)</span></span></span>\n</code></pre></div></blockquote>\n<h2 id=\"_9-判断是否到达文件结尾-feof\" tabindex=\"-1\"> 9. 判断是否到达文件结尾：<code>feof</code></h2>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>int</span> <span>feof</span><span>(</span>FILE <span>*</span> stream<span>)</span><span>;</span>\n    参<span>1</span>： fopen 的返回值\n    返回值： \n        到达文件结尾：非<span>0</span>【真】\n        没到达文件结尾：<span>0</span>【假】\n    作用：    \n        用来判断到达文件结尾。既可以判断文本文件；也可以判断二进制文件。\n    特性：\n        要想使用 <span>feof</span><span>(</span><span>)</span> 检测文件结束标记，必须在该函数调用之前，使用读文件函数。\n        即：<span>feof</span><span>(</span><span>)</span> 调用之前，必须有读文件函数调用。\n</code></pre></div><p><strong>示例1：使用 <code>if (ch == EOF)</code> 判断是否到达文件结尾的问题</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day10/05.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>如上图，使用 <code>ch == EOF</code> 判断是否到达文件结尾是存在 <code>bug</code> 的。</p>\n</blockquote>\n<p><strong>示例2：使用 <code>if (feof(fp))</code> 判断是否到达文件结尾</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day10/06.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>如上图，通过 <code>feof</code> 函数判断是否读到文件结尾，可以避免当写入了 <code>ASCII</code> 码为 <code>-1</code> 的文本后，所造成的读取时 <code>if(ch == EOF)</code> 引起误判的 <code>bug</code>。</p>\n</blockquote>\n<p><strong>示例3：调用 <code>feof</code> 函数前需要进行文件的读操作</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day10/07.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>如上图，在 <code>feof</code> 函数调用前，需要进行文件的读操作，否则 <code>feof</code> 函数总是返回假，即总是判定没有到达文件结尾。</p>\n</blockquote>\n<p><strong>示例4：避免将 <code>EOF</code> 打印出来</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day10/08.png\" alt=\"\" loading=\"lazy\"></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day10/09.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_10-从指定输入流中获取一个字符串-fgets\" tabindex=\"-1\"> 10. 从指定输入流中获取一个字符串：<code>fgets</code></h2>\n<blockquote>\n<p>参考：<a href=\"/zkq/c_and_cpp/_1_c-basic/day05.html#_4-4-2-%E4%BB%8E%E6%8C%87%E5%AE%9A%E8%BE%93%E5%85%A5%E6%B5%81%E4%B8%AD%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2-fgets\">day05-从指定输入流中获取一个字符串：fgets</a></p>\n</blockquote>\n<h2 id=\"_11-将一个字符串写出到指定输出流-fputs\" tabindex=\"-1\"> 11. 将一个字符串写出到指定输出流：<code>fputs</code></h2>\n<blockquote>\n<p>参考：<a href=\"/zkq/c_and_cpp/_1_c-basic/day05.html#_4-4-4-%E5%B0%86%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%86%99%E5%87%BA%E5%88%B0%E6%8C%87%E5%AE%9A%E8%BE%93%E5%87%BA%E6%B5%81-fputs\">day05-将一个字符串写出到指定输出流：fputs</a></p>\n</blockquote>\n<h2 id=\"_12-案例\" tabindex=\"-1\"> 12. 案例</h2>\n<h3 id=\"_12-1-案例1-获取用户键盘输入保存到文件\" tabindex=\"-1\"> 12.1 案例1：获取用户键盘输入保存到文件</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day10/10.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_12-2-案例2-文件版四则运算\" tabindex=\"-1\"> 12.2 案例2：文件版四则运算</h3>\n<p><strong>需求：</strong></p>\n<div><pre><code>将文件内容：\n    10/2=\n    10*3=\n    4+3=\n    8-6=\n\n读取出来，进行四则运算，再将结果写入到文件中：\n    10/2=5\n    10*3=30\n    4+3=7\n    8-6=2\n</code></pre></div><p><strong>思路：</strong></p>\n<div><pre><code>1. 调用 fgets 函数按行读取文件（fgets 函数遇换行符终止读取）\n    fgets(buf, 4096, 文件fp)  =>  \"10/2=\\n\" \n\n2. 对读取到的一行字符串进行分解 \n    \"10/2=\\n\"  =>  sscanf(buf, \"%d%c%d=\\n\", &amp;a, &amp;c, &amp;b);  =>  a=10, b=2, c='/'\n\n3. 根据分解得到的运算符进行不同的运算\n    switch (c) {\n        case '/':\n            a / b;\n            break;\n        case '+':\n            a + b;\n            break;\n        ....\n    }\n\n4. 将运算结果拼接到表达式上，再将多个带有结果的运算表达式拼接成一个字符串，最后再写入到原文件中\n    char result[];  sprintf()/strcat()  =>  \"10/2=5\\n10*3=30\\n4+3=7\\n8-6=2\\n\"  =>  fputs(result, fp)\n</code></pre></div><p><strong>代码实现：</strong></p>\n<div><pre><code>step1：\n    准备一份未写入运算结果的文件 test08.txt\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day10/11.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>step2:\n    a. 按行读取 test08.txt 中的运算表达式；\n    b. 解析运算表达式，并计算结果；\n    c. 将计算结果拼接到运算表达式上 \n    d. 将多个带有结果的运算表达式拼接成一个字符串\n    e. 再将拼接得到的字符串写入到 test08.txt 文件\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day10/12.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>step3:\n    main 函数\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day10/13.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-21T05:58:47.000Z",
      "authors": [],
      "tags": [
        "C语言基础"
      ]
    },
    {
      "title": "第11天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day11.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day11.html",
      "content_html": "<h2 id=\"_1-fprintf-函数\" tabindex=\"-1\"> 1. <code>fprintf</code> 函数</h2>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>int</span> <span>fprintf</span><span>(</span>FILE <span>*</span> stream<span>,</span> <span>const</span> <span>char</span> <span>*</span> format<span>,</span> <span>.</span><span>.</span><span>.</span><span>)</span><span>;</span>\n\n    功能：根据参数 format 字符串来转换并格式化数据，然后将结果输出到 stream 指定的文件中，指定出现字符串结束符 <span>'\\0'</span>  为止。\n\n    参数：\n        stream：已经打开的文件\n        format：字符串格式，用法和 <span>printf</span><span>(</span><span>)</span> 一样\n\n    返回值：\n        成功：实际写入文件的字符个数\n        失败：<span>-</span><span>1</span>\n</code></pre></div><h2 id=\"_2-printf-sprintf-fprintf-对比\" tabindex=\"-1\"> 2. <code>printf</code>/<code>sprintf</code>/<code>fprintf</code> 对比</h2>\n<p><strong>1. 函数原型对比</strong></p>\n<div><pre><code><span>/* printf */</span>\n<span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>int</span> <span>printf</span><span>(</span><span>const</span> <span>char</span> <span>*</span><span>const</span> _Format<span>,</span> <span>.</span><span>.</span><span>.</span><span>)</span>\n\n<span>/* sprintf */</span>\n<span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>int</span> <span>sprintf</span><span>(</span><span>char</span> <span>*</span>str<span>,</span> <span>const</span> <span>char</span> <span>*</span>format<span>,</span> <span>.</span><span>.</span><span>.</span><span>)</span>\n\n<span>/* fprintf */</span>\n<span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>int</span> <span>fprintf</span><span>(</span>FILE <span>*</span> stream<span>,</span> <span>const</span> <span>char</span> <span>*</span> format<span>,</span> <span>.</span><span>.</span><span>.</span><span>)</span>\n</code></pre></div><div><pre><code>1. 三者都是变参函数：即形参列表最后都是 \"...\"，\n2. 三个函数的形参列表中，最后一个变参之前的固参，通常是格式描述串（可能包含格式匹配符）。\n</code></pre></div><p><strong>2. 输出位置对比</strong></p>\n<div><pre><code><span>/* printf 输出到屏幕  */</span>\n<span>printf</span><span>(</span><span>\"hello\"</span><span>)</span><span>;</span> <span>// 只有一个固参（未包含格式匹配符的格式描述串）</span>\n<span>printf</span><span>(</span><span>\"%s\"</span><span>,</span> <span>\"hello\"</span><span>)</span><span>;</span>\n<span>printf</span><span>(</span><span>\"ret = %d+%d\\n\"</span><span>,</span> <span>10</span><span>,</span> <span>5</span><span>)</span><span>;</span>\n<span>printf</span><span>(</span><span>\"%d = %d%c%d\\n\"</span><span>,</span> <span>10</span><span>+</span><span>5</span><span>,</span> <span>10</span><span>,</span> <span>'+'</span><span>,</span> <span>5</span><span>)</span><span>;</span>  \n\n<span>/* sprintf 输出到内存 buf 中 */</span>\n<span>char</span> buf<span>[</span><span>1024</span><span>]</span><span>;</span>   <span>//缓冲区  </span>\n<span>sprintf</span><span>(</span>buf<span>,</span> <span>\"%d = %d%c%d\\n\"</span><span>,</span> <span>10</span><span>+</span><span>5</span><span>,</span> <span>10</span><span>,</span> <span>'+'</span><span>,</span> <span>5</span><span>)</span><span>;</span> \n\n<span>/* fprintf 输出到磁盘文件中 */</span>\nFILE <span>*</span> fp <span>=</span> <span>fopen</span><span>(</span><span>)</span><span>;</span>\n<span>fprintf</span><span>(</span>fp<span>,</span> <span>\"%d = %d%c%d\\n\"</span><span>,</span> <span>10</span><span>+</span><span>5</span><span>,</span> <span>10</span><span>,</span> <span>'+'</span><span>,</span> <span>5</span><span>)</span><span>;</span>    \n</code></pre></div><h2 id=\"_3-fscanf-函数\" tabindex=\"-1\"> 3. <code>fscanf</code> 函数</h2>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>int</span> <span>fscanf</span><span>(</span>FILE <span>*</span> stream<span>,</span> <span>const</span> <span>char</span> <span>*</span> format<span>,</span> <span>.</span><span>.</span><span>.</span><span>)</span>\n    功能：从 stream 指定的文件读取字符串，并根据参数 format 字符串来转换并格式化数据。\n    参数：\n        stream：已经打开的文件\n        format：字符串格式，用法和 <span>scanf</span><span>(</span><span>)</span> 一样\n    返回值：\n        成功：参数数目，成功转换的值的个数\n        失败：<span>-</span><span>1</span>\n</code></pre></div><p><strong>示例1：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day11/01.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>示例2：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day11/02.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_4-scanf-sscanf-fscanf-对比\" tabindex=\"-1\"> 4. <code>scanf</code>/<code>sscanf</code>/<code>fscanf</code> 对比</h2>\n<p><strong>函数原型对比</strong></p>\n<div><pre><code><span>/* scanf */</span>\n<span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>int</span> <span>scanf</span><span>(</span><span>const</span> <span>char</span> <span>*</span><span>const</span> _Format<span>,</span> <span>.</span><span>.</span><span>.</span><span>)</span>\n\n<span>/* sscanf */</span>\n<span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>int</span> <span>sscanf</span><span>(</span><span>const</span> <span>char</span> <span>*</span>str<span>,</span> <span>const</span> <span>char</span> <span>*</span>format<span>,</span> <span>.</span><span>.</span><span>.</span><span>)</span>\n\n<span>/* fscanf */</span>\n<span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>int</span> <span>fscanf</span><span>(</span>FILE <span>*</span> stream<span>,</span> <span>const</span> <span>char</span> <span>*</span> format<span>,</span> <span>.</span><span>.</span><span>.</span><span>)</span>\n</code></pre></div><h2 id=\"_5-处理文本文件的函数-fgetc-fputc、fgets-fputs、fprintf-fscanf\" tabindex=\"-1\"> 5. 处理文本文件的函数：<code>fgetc</code>/<code>fputc</code>、<code>fgets</code>/<code>fputs</code>、<code>fprintf</code>/<code>fscanf</code></h2>\n<div><pre><code>fgetc/fputc\nfgets/fputs\nfprintf/fscanf \n</code></pre></div><h2 id=\"_6-处理二进制文件的函数-也可用来处理文本文件\" tabindex=\"-1\"> 6. 处理二进制文件的函数（也可用来处理文本文件）</h2>\n<h3 id=\"_6-1-以数据块的方式向文件中写入内容-fwrite\" tabindex=\"-1\"> 6.1 以数据块的方式向文件中写入内容：<code>fwrite</code></h3>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>size_t</span> <span>fwrite</span><span>(</span><span>const</span> <span>void</span> <span>*</span>ptr<span>,</span> <span>size_t</span> size<span>,</span> <span>size_t</span> nmemb<span>,</span> FILE <span>*</span>stream<span>)</span>\n    功能：以数据块的方式给文件写入内容\n    参数：\n        ptr：准备写入文件数据的地址\n        size： <span>size_t</span> 为 <span>unsigned</span> <span>int</span> 类型，此参数指定写入文件内容的块数据大小\n        nmemb：写入文件的块数，写入文件数据总大小为：size <span>*</span> nmemb\n        stream：已经打开的文件指针\n    返回值：\n        成功：实际成功写入文件数据的块数目，此值和 nmemb 相等\n        失败：<span>0</span>\n\n通常将参数 size 传 <span>1.</span> 将参数 nmemb 传实际写出字节数。依此可判断，当成功时，若返回值 <span>==</span> nmemb，说明数据写入成功。\n</code></pre></div><p><strong>示例：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day11/03.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong><code>fwrite</code> 写入数据时的注意事项</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day11/04.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_6-2-以数据块的方式从文件中读取内容-fread\" tabindex=\"-1\"> 6.2 以数据块的方式从文件中读取内容：<code>fread</code></h3>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>size_t</span> <span>fread</span><span>(</span><span>void</span> <span>*</span>ptr<span>,</span> <span>size_t</span> size<span>,</span> <span>size_t</span> nmemb<span>,</span> FILE <span>*</span>stream<span>)</span>\n    功能：以数据块的方式从文件中读取内容\n    参数：\n        ptr：存放读取出来数据的内存空间\n        size： <span>size_t</span> 为 <span>unsigned</span> <span>int</span> 类型，此参数指定读取文件内容的块数据大小\n        nmemb：读取文件的块数，读取文件数据总大小为：size <span>*</span> nmemb\n        stream：已经打开的文件指针\n    返回值：\n        成功：实际成功读取到内容的块数，如果此值比 nmemb 小，但大于 <span>0</span>，说明读到文件的结尾。\n        失败：<span>0</span>\n        <span>0</span><span>:</span> 表示读到文件结尾。【<span>feof</span><span>(</span><span>)</span>】\n\n通常将参数 size 传 <span>1.</span> 将参数 nmemb 传欲读出的字节数。\n</code></pre></div><p><strong>示例：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day11/05.png\" alt=\"\" loading=\"lazy\"></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day11/06.png\" alt=\"\" loading=\"lazy\"></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day11/07.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_6-3-案例-文件拷贝\" tabindex=\"-1\"> 6.3 案例：文件拷贝</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day11/08.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_7-文件随机读写\" tabindex=\"-1\"> 7. 文件随机读写</h2>\n<h3 id=\"_7-1-移动文件读写指针-fseek\" tabindex=\"-1\"> 7.1 移动文件读写指针：<code>fseek</code></h3>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>int</span> <span>fseek</span><span>(</span>FILE <span>*</span>stream<span>,</span> <span>long</span> offset<span>,</span> <span>int</span> whence<span>)</span><span>;</span>\n    参<span>1</span>：文件\n    参<span>2</span>：\n        偏移量（矢量，<span>+</span> 向后，<span>-</span> 向前）\n        根据 whence 来移动的位移数（偏移量），可以是正数，也可以负数，\n        如果是正数，则相对于 whence 向右（后）移动。如果向右（后）移动的字节数超过了文件末尾，再次写入时将增大文件尺寸；\n        如果是负数，则相对于 whence 向左（前）移动。如果向左（前）移动的字节数超过了文件开头，则返回失败。\n    参<span>3</span>：    \n        <span>SEEK_SET</span>：文件开头位置\n        <span>SEEK_CUR</span>：当前位置\n        <span>SEEK_END</span>：文件结尾位置\n    返回值： \n        成功： <span>0</span> \n        失败：<span>-</span><span>1</span>\n</code></pre></div><h3 id=\"_7-2-获取文件读写指针的位置-ftell\" tabindex=\"-1\"> 7.2 获取文件读写指针的位置：<code>ftell</code></h3>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>long</span> <span>ftell</span><span>(</span>FILE <span>*</span>stream<span>)</span><span>;</span>\n    返回：从文件当前读写位置到起始位置（文件开头）的偏移量。\n\n注意：可以借助 <span>ftell</span><span>(</span>fp<span>)</span> <span>+</span> <span>fseek</span><span>(</span>fp<span>,</span> <span>0</span><span>,</span> <span>SEEK_END</span><span>)</span><span>;</span> 来获取文件大小。\n</code></pre></div><h3 id=\"_7-3-将文件读写指针移动到文件开头-回卷-rewind\" tabindex=\"-1\"> 7.3 将文件读写指针移动到文件开头（回卷）：<code>rewind</code></h3>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>void</span> <span>rewind</span><span>(</span>FILE <span>*</span>stream<span>)</span><span>;</span>\n\n回卷文件读写指针。将读写指针移动到起始位置（文件开头）。\n</code></pre></div><h3 id=\"_7-4-示例-fseek、ftell、rewind-的使用-获取文件大小\" tabindex=\"-1\"> 7.4 示例：<code>fseek</code>、<code>ftell</code>、<code>rewind</code> 的使用 &amp; 获取文件大小</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day11/09.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_7-5-一个文件内只有一个文件读写指针\" tabindex=\"-1\"> 7.5 一个文件内只有一个文件读写指针</h3>\n<div><pre><code>在一个文件内只有一个文件读写指针，即文件读和写时所用到的指针是同一个。\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day11/10.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_8-linux-和-windows-文件区别\" tabindex=\"-1\"> 8. <code>Linux</code> 和 <code>windows</code> 文件区别</h2>\n<div><pre><code>1. 对于二进制文件操作，Windows 使用 \"b\"， Linux 下二进制和文本没区别。\n\n2. windows 下，回车 \\r，换行 \\n。 \\r\\n， Linux 回车换行 \\n\n\n3. 对文件指针，\n    先写后读。windows 和 Linux 效果一致。\n    先读后写。Linux 无需修改。windows 下需要在写操作之前添加 fseek(fp, 0, SEEK_CUR); 来获取文件读写指针，使之生效。\n</code></pre></div><p><strong>示例：<code>windows</code> 下先读后写的问题与解决方式</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day11/11.png\" alt=\"\" loading=\"lazy\"></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day11/12.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_9-获取文件状态属性信息-int-stat-const-char-path-struct-stat-buf\" tabindex=\"-1\"> 9. 获取文件状态属性信息：<code>int stat(const char *path, struct stat *buf)</code></h2>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;sys/types.h></span></span>\n<span><span>#</span><span>include</span> <span>&lt;sys/stat.h></span></span>\n<span>int</span> <span>stat</span><span>(</span><span>const</span> <span>char</span> <span>*</span>path<span>,</span> <span>struct</span> <span>stat</span> <span>*</span>buf<span>)</span><span>;</span>\n    功能：获取文件状态信息\n    参数：\n        path：文件路径名\n        buf：保存文件信息的结构体\n    返回值：\n        成功： <span>0</span>\n        失败：<span>-</span><span>1</span>\n</code></pre></div><p><strong>保存文件状态的结构体 <code>stat</code></strong></p>\n<div><pre><code><span>struct</span> <span>stat</span> <span>{</span>\n    <span>dev_t</span>         st_dev<span>;</span>       <span>// 文件的设备编号</span>\n    <span>ino_t</span>         st_ino<span>;</span>       <span>// 节点</span>\n    <span>mode_t</span>        st_mode<span>;</span>      <span>// 文件的类型和存取的权限</span>\n    <span>nlink_t</span>       st_nlink<span>;</span>     <span>// 连到该文件的硬连接数目，刚建立的文件值为1</span>\n    <span>uid_t</span>         st_uid<span>;</span>       <span>// 用户ID</span>\n    <span>gid_t</span>         st_gid<span>;</span>       <span>// 组ID</span>\n    <span>dev_t</span>         st_rdev<span>;</span>      <span>// (设备类型)若此文件为设备文件，则为其设备编号</span>\n    <span>off_t</span>         st_size<span>;</span>      <span>// 文件字节数(文件大小)</span>\n    <span>unsigned</span> <span>long</span> st_blksize<span>;</span>   <span>// 块大小(文件系统的I/O 缓冲区大小)</span>\n    <span>unsigned</span> <span>long</span> st_blocks<span>;</span>    <span>// 块数</span>\n    <span>time_t</span>        st_atime<span>;</span>     <span>// 最后一次访问时间</span>\n    <span>time_t</span>        st_mtime<span>;</span>     <span>// 最后一次修改时间</span>\n    <span>time_t</span>        st_ctime<span>;</span>     <span>// 最后一次改变时间(指属性)</span>\n<span>}</span><span>;</span>\n</code></pre></div><p><strong>示例：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day11/13.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_10-删除文件-remove\" tabindex=\"-1\"> 10. 删除文件：<code>remove</code></h2>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>int</span> <span>remove</span><span>(</span><span>const</span> <span>char</span> <span>*</span>pathname<span>)</span><span>;</span>\n    参数：\n        pathname：文件名\n    返回值：\n        成功： <span>0</span>\n        失败：<span>-</span><span>1</span>\n</code></pre></div><h2 id=\"_11-重命名文件-rename\" tabindex=\"-1\"> 11. 重命名文件：<code>rename</code></h2>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>int</span> <span>rename</span><span>(</span><span>const</span> <span>char</span> <span>*</span>oldpath<span>,</span> <span>const</span> <span>char</span> <span>*</span>newpath<span>)</span><span>;</span>\n    功能：把 oldpath 的文件名改为 newpath\n    参数：\n        oldpath：旧文件名\n        newpath：新文件名\n    返回值：\n        成功： <span>0</span>\n        失败：<span>-</span><span>1</span>\n</code></pre></div><h2 id=\"_12-文件缓冲区-预读入、缓输出\" tabindex=\"-1\"> 12. 文件缓冲区（预读入、缓输出）</h2>\n<div><pre><code>ANSI C 标准采用 “缓冲文件系统” 处理数据文件。\n所谓缓冲文件系统，是指系统自动地在内存区，为程序中每一个正在使用的文件开辟一个文件缓冲区，\n从内存向磁盘输出数据，必须先送到内存中的缓冲区，装满缓冲区后，才一起送到磁盘去。\n如果从磁盘向计算机读入数据，则一次从磁盘文件将一批数据输入到内存缓冲区（充满缓冲区），\n然后再从缓冲区逐个地将数据送到程序数据区（给程序变量）\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day11/14.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_12-1-缓冲区刷新-行缓冲、全缓冲、无缓冲、隐式回收\" tabindex=\"-1\"> 12.1 缓冲区刷新（行缓冲、全缓冲、无缓冲、隐式回收）</h3>\n<div><pre><code>标准输出 -- stdout文件（磁盘） -- 标准输出缓冲区（内存） \n    写给屏幕的数据，都是先存缓冲区中，由缓冲区一次性刷新到物理设备（屏幕）\n\n标准输入 -- stdin文件（磁盘） -- 标准输入缓冲区（内存）  \n    从键盘读取的数据，直接读到缓冲区中，由缓冲区给程序提供数据。\n</code></pre></div><div><pre><code>行缓冲：\n    如 printf(); \n    遇到 \\n 就会将缓冲区中的数据刷新到物理设备上。\n\n全缓冲：\n    如 文件。 \n    缓冲区存满，数据刷新到物理设备上。\n\n无缓冲：\n    如 perror。 \n    缓冲区中只要有数据，就立即刷新到物理设备。\n\n文件关闭时，缓冲区会被自动刷新。  \n\n程序终止后，进行隐式回收：\n1. 关闭文件；\n2. 刷新缓冲区；\n3. 释放 malloc。\n</code></pre></div><p><strong>示例：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day11/15.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_12-2-使用缓冲区的优势\" tabindex=\"-1\"> 12.2 使用缓冲区的优势</h3>\n<div><pre><code>1. 减少了对硬盘的读写次数，提高了硬盘的寿命；\n2. 缓冲区位于内存中，读写内存 较 读写硬盘 的效率更高，即提高了读写效率。\n</code></pre></div><h3 id=\"_12-3-手动刷新缓冲区-实时刷新-int-fflush-file-stream\" tabindex=\"-1\"> 12.3 手动刷新缓冲区（实时刷新）：<code>int fflush(FILE *stream);</code></h3>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>int</span> <span>fflush</span><span>(</span>FILE <span>*</span>stream<span>)</span><span>;</span>\n    功能：刷新缓冲区，让缓冲区的数据立马写到文件中。\n    参数：\n        stream：文件指针\n    返回值：\n        成功： <span>0</span>\n        失败：<span>-</span><span>1</span>\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day11/16.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-21T05:58:47.000Z",
      "authors": [],
      "tags": [
        "C语言基础"
      ]
    },
    {
      "title": "第12天（贪吃蛇小游戏）",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day12.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day12.html",
      "content_html": "<h2 id=\"_1-修改控制台光标位置-setconsolecursorposition\" tabindex=\"-1\"> 1. 修改控制台光标位置：<code>SetConsoleCursorPosition</code></h2>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;conio.h></span>   <span>// conio --> console io ： 控制台 输入/输出</span></span>\n<span><span>#</span><span>include</span> <span>&lt;Windows.h></span></span>\nBOOL <span>SetConsoleCursorPosition</span><span>(</span>HANDLE hConsoleOutput<span>,</span> COORD dwCursorPosition<span>)</span>\n    作用： \n        在处理 hConsoleOutput 指定的输出类型之前（如处理标准输出 or 标准错误之前），将光标移动到位置 dwCursorPosition 处\n\n    参数：\n        HANDLE 类型： \n            指定控制台的处理对象（可以是标准输入 or 标准输出 or 标准错误）\n            可通过 GetStdHandle 函数指定 HANDLE\n                <span>GetStdHandle</span><span>(</span>STD_INPUT_HANDLE<span>)</span>  获取标准输入对应的 HANDLE\n                <span>GetStdHandle</span><span>(</span>STD_OUTPUT_HANDLE<span>)</span> 获取标准输出对应的 HANDLE\n                <span>GetStdHandle</span><span>(</span>STD_ERROR_HANDLE<span>)</span>  获取标准错误对应的 HANDLE\n        \n        COORD类型： \n            COORD 是 Windows API 中定义的一种结构，表示一个字符在控制台屏幕上的坐标\n                <span>typedef</span> <span>struct</span> <span>_COORD</span> <span>{</span>\n                    SHORT X<span>;</span>\n                    SHORT Y<span>;</span>\n                <span>}</span>COORD<span>;</span>\n\n    返回值：\n        BOOL 类型： <span>typedef</span> <span>int</span>   BOOL<span>;</span>\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day12/01.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_2-不回显地接收用户输入-getch\" tabindex=\"-1\"> 2. 不回显地接收用户输入：<code>getch</code></h2>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;conio.h></span></span>\n<span>int</span> <span>_getch</span><span>(</span><span>void</span><span>)</span>\n    功能：\n        从控制台无回显地接收一个键盘输入字符\n        所谓回显，就是如 getchar 函数那样，在接收到一个键盘输入字符后，还会把接收到的字符打印在控制台上显示出来。\n        而 _getch 函数仅接收键盘输入的字符，并不会打印显示到控制台上。\n\n    用法：\n        <span>char</span> key <span>=</span> <span>_getch</span><span>(</span><span>)</span><span>;</span>\n\n    返回值：\n        读取的字符 ASCII 码\n\n注意：如果调用 <span>getch</span><span>(</span><span>)</span> 编译时出错，尝试使用 <span>_getch</span><span>(</span><span>)</span><span>;</span>\n</code></pre></div><h2 id=\"_3-以非阻塞方式检查当前是否有键盘输入-kbhit\" tabindex=\"-1\"> 3. 以非阻塞方式检查当前是否有键盘输入：<code>kbhit</code></h2>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;conio.h></span></span>\n<span>int</span> <span>_kbhit</span><span>(</span><span>void</span><span>)</span>\n    功能：\n        非阻塞地判断用户输入。\n        如 scanf 或 getchar 函数调用时，会阻塞并等待用户输入；\n        而通过 _kbhit 结合 _getch 或 getchar 函数，可实现非阻塞地接收用户输入：\n            <span>if</span><span>(</span><span>_kbhit</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                <span>char</span> ch <span>=</span> <span>_getch</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n\n    返回值：\n        有用户输入，返回 “真”，\n        否则返回 “假”。\n\n注意：如果调用 <span>kbhit</span><span>(</span><span>)</span> 编译时出错，尝试使用 <span>_kbhit</span><span>(</span><span>)</span><span>;</span>\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day12/02.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_4-设置控制台光标属性-setconsolecursorinfo\" tabindex=\"-1\"> 4. 设置控制台光标属性：<code>SetConsoleCursorInfo</code></h2>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;conio.h></span></span>\n<span><span>#</span><span>include</span> <span>&lt;Windows.h></span></span>\nBOOL <span>SetConsoleCursorInfo</span><span>(</span>HANDLE hConsoleOutput<span>,</span> <span>const</span> CONSOLE_CURSOR_INFO <span>*</span>lpConsoleCursorInfo<span>)</span>\n    作用：\n        在处理 hConsoleOutput 指定的输出类型之前（如处理标准输出 or 标准错误之前），设置光标属性信息\n\n    参数：\n        HANDLE 类型：\n            指定控制台的处理对象（可以是标准输入 or 标准输出 or 标准错误）\n            可通过 GetStdHandle 函数指定 HANDLE\n                <span>GetStdHandle</span><span>(</span>STD_INPUT_HANDLE<span>)</span>  获取标准输入对应的 HANDLE\n                <span>GetStdHandle</span><span>(</span>STD_OUTPUT_HANDLE<span>)</span> 获取标准输出对应的 HANDLE\n                <span>GetStdHandle</span><span>(</span>STD_ERROR_HANDLE<span>)</span>  获取标准错误对应的 HANDLE\n        \n        CONSOLE_CURSOR_INFO 类型：\n            CONSOLE_CURSOR_INFO 描述终端光标信息\n                <span>typedef</span> <span>struct</span> <span>_CONSOLE_CURSOR_INFO</span> <span>{</span>\n                    DWORD  dwSize<span>;</span> <span>// 光标大小</span>\n                    BOOL   bVisible<span>;</span> <span>// 光标是否可见</span>\n                <span>}</span> CONSOLE_CURSOR_INFO<span>;</span>\n\n    返回值：\n        BOOL 类型： <span>typedef</span> <span>int</span>   BOOL<span>;</span>\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day12/03.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_5-参考源码\" tabindex=\"-1\"> 5. 参考源码</h2>\n<p><a href=\"https://github.com/zengkaiqiang562/JavaGuide-Demo/blob/main/docs/zkq/c_and_cpp/_1_c-basic/%E8%B4%AA%E5%90%83%E8%9B%87%E5%B0%8F%E6%B8%B8%E6%88%8F/snake.h\" target=\"_blank\" rel=\"noopener noreferrer\">贪吃蛇小游戏<ExternalLinkIcon/></a></p>\n",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-21T08:28:13.000Z",
      "authors": [],
      "tags": [
        "C语言基础"
      ]
    },
    {
      "title": "第13天（Linux系统入门）",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day13.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day13.html",
      "content_html": "<h2 id=\"_1-linux-内核版本\" tabindex=\"-1\"> 1. <code>Linux</code> 内核版本</h2>\n<h3 id=\"_1-1-什么是内核\" tabindex=\"-1\"> 1.1 什么是内核</h3>\n<p>内核（<code>kernel</code>）是系统的心脏，是运行程序和管理像磁盘和打印机等硬件设备的核心程序，它提供了一个在裸设备与应用程序间的抽象层。</p>\n<p>可以把内核简单地理解为：<strong>除去应用程序之外的操作系统</strong>。</p>\n<h3 id=\"_1-2-内核源码网址-http-www-kernel-org\" tabindex=\"-1\"> 1.2 内核源码网址：<code>http://www.kernel.org</code></h3>\n<p>内核源码网址是 <a href=\"http://www.kernel.org\" target=\"_blank\" rel=\"noopener noreferrer\">http://www.kernel.org<ExternalLinkIcon/></a>，所有来自全世界的对 <code>Linux</code> 源码的修改最终都会汇总到这个网站。然后由 <code>Linus</code> 领导的开源社区对其进行甄别和修改最终决定是否进入到 <code>Linux</code> 主线内核源码中。</p>\n<h3 id=\"_1-3-内核版本分类\" tabindex=\"-1\"> 1.3 内核版本分类</h3>\n<h4 id=\"_1-3-1-稳定版-ubuntu-xx-04-测试版-ubuntu-xx-10\" tabindex=\"-1\"> 1.3.1 稳定版（<code>Ubuntu-XX.04</code>）&amp; 测试版（<code>Ubuntu-XX.10</code>）</h4>\n<p><code>Linux</code> 内核版本分为稳定版和开发版：</p>\n<ol>\n<li>\n<p>4月份发布的版本是稳定版，如 <code>Ubuntu-14.04</code></p>\n</li>\n<li>\n<p>10月份发布的版本是测试版，如 <code>Ubuntu-14.10</code></p>\n</li>\n</ol>\n<h4 id=\"_1-3-2-长期支持版-ubuntu-双数-xx-短期支持版-ubuntu-单数-xx\" tabindex=\"-1\"> 1.3.2 长期支持版(<code>Ubuntu-双数-XX</code>) &amp; 短期支持版(<code>Ubuntu-单数-XX</code>)</h4>\n<p>从 <code>Ubuntu-10</code> 开始，区分双数版本和单数版本：</p>\n<ol>\n<li>\n<p>双数版本，如 <code>Ubuntu-14</code> 为长期支持版本，即系统中的软件服务的有效期是3年（2016起为5年）</p>\n</li>\n<li>\n<p>而单数版本，如 <code>Ubuntu-13</code> 为短期支持版本，即系统中的软件服务的有效期是1年</p>\n</li>\n</ol>\n<h4 id=\"_1-3-2-推荐使用版本-长期支持的稳定版-ubunt-双数-04\" tabindex=\"-1\"> 1.3.2 推荐使用版本：长期支持的稳定版（<code>Ubunt-双数.04</code>）</h4>\n<p>作为普通用户下载 <code>Linux</code> 操作系统时，最好下载4月份版本的双数版本。</p>\n<h2 id=\"_2-linux-目录结构\" tabindex=\"-1\"> 2. <code>Linux</code> 目录结构</h2>\n<h3 id=\"_2-1-根目录\" tabindex=\"-1\"> 2.1 根目录：<code>/</code></h3>\n<div><pre><code>根目录，一般根目录下只存放目录，在 Linux 下有且只有一个根目录。\n</code></pre></div><h3 id=\"_2-2-放置可执行文件的目录-bin、-usr-bin\" tabindex=\"-1\"> 2.2 放置可执行文件的目录：<code>/bin</code>、<code>/usr/bin</code></h3>\n<div><pre><code>可执行二进制文件的目录，\n如常用的命令文件 ls、tar、mv、cat 等。\n</code></pre></div><h3 id=\"_2-3-放置系统启动相关文件的目录-boot\" tabindex=\"-1\"> 2.3 放置系统启动相关文件的目录：<code>/boot</code></h3>\n<div><pre><code>放置 linux 系统启动时用到的一些文件，\n如:\n    Linux 的内核文件：/boot/vmlinuz\n    系统引导管理器：/boot/grub\n</code></pre></div><h3 id=\"_2-4-放置设备文件的目录-dev\" tabindex=\"-1\"> 2.4 放置设备文件的目录：<code>/dev</code></h3>\n<div><pre><code>存放 linux 系统下的设备文件，访问该目录下某个文件，相当于访问某个设备。\n常用的是挂载光驱：\n    如执行命令 \"mount /dev/cdrom /mnt\" \n    将 /dev/cdrom 表示的光驱设备挂载到目录 /mnt 上，于是，访问目录 /mnt 即访问光驱内容\n</code></pre></div><h3 id=\"_2-5-放置配置文件的目录-etc\" tabindex=\"-1\"> 2.5 放置配置文件的目录：<code>/etc</code></h3>\n<div><pre><code>系统配置文件存放的目录，\n不建议在此目录下存放可执行文件，\n重要的配置文件有:\n    /etc/inittab、\n    /etc/fstab、\n    /etc/init.d、\n    /etc/X11、\n    /etc/sysconfig、\n    /etc/xinetd.d\n\n安装的应用程序的配置文件也是放在该目录下的。\n</code></pre></div><h3 id=\"_2-6-放置函数库文件的目录-lib、-usr-lib、-usr-local-lib\" tabindex=\"-1\"> 2.6 放置函数库文件的目录：<code>/lib</code>、<code>/usr/lib</code>、<code>/usr/local/lib</code></h3>\n<div><pre><code>系统使用的函数库的目录。\n程序在执行过程中，需要调用一些额外的参数时，需要函数库的协助。\n</code></pre></div><h3 id=\"_2-7-放置系统异常时遗失的片段-lost-fount\" tabindex=\"-1\"> 2.7 放置系统异常时遗失的片段：<code>/lost+fount</code></h3>\n<div><pre><code>系统异常产生错误时，会将一些遗失的片段放置于此目录下。\n</code></pre></div><h3 id=\"_2-8-挂载目录-mnt、-media\" tabindex=\"-1\"> 2.8 挂载目录：<code>/mnt</code>、<code>/media</code></h3>\n<div><pre><code>光盘默认挂载点，通常光盘挂载于 /mnt/cdrom 下。（也不一定，可以选择任意位置进行挂载）\n\n\"/mnt\", \"/media\", \"/dev\" 三者的区别:\n\n1. /mnt 是被系统管理员使用，手动挂载一些临时媒体设备的目录。\n\n2. /media 是自动挂载的目录。\n   比如我们的 U 盘插在 ubuntu 下时会自动挂载。即会在 /media 下生成一个目录，这个目录就是 U 盘所在目录（或者说文件）\n\n3. /dev 不是存放设备的驱动程序，而是作为访问外部设备文件的接口。\n   比如，我们的 U 盘插入到 linux 系统后，执行 \"fdisk -l\" 查看分区，显示文件为 /dev/sda1，\n   此时，若我们要将 u 盘挂载到 /mnt/usb1 下，执行 \"mount /dev/sda1 /mnt/usb1\" 即可。\n</code></pre></div><h3 id=\"_2-9-第三方软件的安装目录-opt\" tabindex=\"-1\"> 2.9 第三方软件的安装目录：<code>/opt</code></h3>\n<div><pre><code>给主机额外安装软件所摆放的目录。如作为 QQ、迅雷 等第三方应用程序的安装目录。\n</code></pre></div><h3 id=\"_2-10-放置内存中数据的目录-proc\" tabindex=\"-1\"> 2.10 放置内存中数据的目录：<code>/proc</code></h3>\n<div><pre><code>此目录的数据都在内存中，如系统核心，外部设备，网络状态。（由于数据都存放于内存中，所以不占用磁盘空间）\n进程相关的数据都存放在该目录下。\n\n比较重要的目录有：\n/proc/cpuinfo\n/proc/interrupts\n/proc/dma\n/proc/ioports\n/proc/net/* \n</code></pre></div><h3 id=\"_2-11-root-用户的家目录-root\" tabindex=\"-1\"> 2.11 <code>root</code> 用户的家目录：<code>/root</code></h3>\n<div><pre><code>系统管理员 root 的家目录（家目录的学名为：宿主目录）\n</code></pre></div><h3 id=\"_2-12-放置-root-用户使用的可执行文件-sbin、-usr-sbin、-usr-local-sbin\" tabindex=\"-1\"> 2.12 放置 <code>root</code> 用户使用的可执行文件：<code>/sbin</code>、<code>/usr/sbin</code>、<code>/usr/local/sbin</code></h3>\n<div><pre><code>放置系统管理员使用的可执行命令，如 fdisk、shutdown、mount 等。\n与 /bin 不同的是，这几个目录是给系统管理员 root 使用的命令，一般用户只能 \"查看\"，而不能设置和使用。\n</code></pre></div><h3 id=\"_2-13-放置临时文件的目录-tmp\" tabindex=\"-1\"> 2.13 放置临时文件的目录：<code>/tmp</code></h3>\n<div><pre><code>给一般用户或正在执行的程序，临时存放文件的目录。\n任何人都可以访问；\n重要数据不可放置在此目录下。\n</code></pre></div><h3 id=\"_2-14-放置服务启动后所访问数据的目录-srv\" tabindex=\"-1\"> 2.14 放置服务启动后所访问数据的目录：<code>/srv</code></h3>\n<div><pre><code>服务启动之后需要访问的数据目录。\n如 www 服务需要访问的网页数据存放在 /srv/www 内。\n</code></pre></div><h3 id=\"_2-15-应用程序存放目录-usr-unix-software-resource\" tabindex=\"-1\"> 2.15 应用程序存放目录：<code>/usr</code>（<code>unix software resource</code>）</h3>\n<div><pre><code>unix software resource：Unix软件系统资源目录，即应用程序存放目录。其中：\n\n/usr/bin：存放应用程序，\n/usr/share：存放共享数据，\n/usr/lib：存放不能直接运行的，却是许多程序运行所必需的一些函数库文件。\n/usr/local：存放软件升级包。\n/usr/share/doc：系统说明文件存放目录。\n/usr/share/man：程序说明文件存放目录\n/user/include：存放头文件\n    \n如：\n头文件 stdio.h 源码存放在 /usr/include 目录下；\n头文件 stdio.h 所生成的库文件 libc.so 存放在 /usr/lib/x86_64-linux-gnu 目录下。\n</code></pre></div><h3 id=\"_2-16-放置系统执行时变化数据的目录-var\" tabindex=\"-1\"> 2.16 放置系统执行时变化数据的目录：<code>/var</code></h3>\n<div><pre><code>放置系统执行过程中经常变化的文件，如：\n/var/log：随时更改的日志文件，\n/var/log/message：所有的登录文件存放目录，\n/var/spool/mail：邮件存放的目录，\n/var/run：程序或服务启动后，其 PID 存放在该目录下。\n</code></pre></div><h2 id=\"_3-linux-文件分类\" tabindex=\"-1\"> 3. <code>Linux</code> 文件分类</h2>\n<p>通常，<code>Unix/Linux</code> 系统中常用的文件类型有 <code>7</code> 种：</p>\n<div><pre><code>普通文件\n目录文件\n套接字文件\n管道文件\n软链接文件\n字符设备文件\n块设备文件\n\n其中，字符设备文件和块设备文件统称为设备文件。\n</code></pre></div><p>形如 <code>crw-rw----</code> 中的第1个字符用于文件分类：</p>\n<div><pre><code>- 表示普通文件\nd 表示目录文件\ns 表示套接字文件（多用于进程间的通信）\np 表示管道文件（通过命令 mkfifo 可创建管道文件）\nl 表示软链接文件（相当于 windows 中的快捷方式）\nc 表示字符设备文件（字符设备的存取以一个字符为单位）\nb 表示块设备文件（块设备的存取以字符块为单位）\n</code></pre></div><p><strong>示例：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day13/01.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>如上图，标准输入文件 <code>stdin</code>、 标准输出文件 <code>stdout</code>、 标准错误文件 <code>stderr</code> 都是软链接文件。</p>\n</blockquote>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day13/02.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>如上图，文件 <code>log</code> 是套接字文件。套接字文件可用于网络通信。</p>\n</blockquote>\n<h2 id=\"_4-查看帮助文档\" tabindex=\"-1\"> 4. 查看帮助文档</h2>\n<h3 id=\"_4-1-通过选项-help-查看帮助文档\" tabindex=\"-1\"> 4.1 通过选项 <code>--help</code> 查看帮助文档</h3>\n<div><pre><code>执行 \"命令名 --help\" 可以查看大部分 Linux 命令自带的帮助信息，但是并不是所有命令都自带这个选项。\n如我们想查看命令 ls 的用法：ls --help\n</code></pre></div><h3 id=\"_4-2-通过命令-man-查看帮助文档\" tabindex=\"-1\"> 4.2 通过命令 <code>man</code> 查看帮助文档</h3>\n<div><pre><code>man 是 Linux 提供的一个手册，包含了绝大部分的命令、函数使用说明。\n\n该手册分成很多章节（section），使用 man 时可以指定不同的章节来浏览不同的内容。\n\nman 中各个 section 意义如下：\n    1. Standard commands（标准命令）\n    2. System calls（系统调用，如 open、write）\n    3. Library functions（库函数，如 printf、fopen）\n    4. Special devices（设备文件的说明，/dev 下各种设备）\n    5. File formats（文件格式，如 passwd）\n    6. Games and toys（游戏和娱乐）\n    7. Miscellaneous（杂项、惯例与协定等，例如 Linux 档案系统、网络协定、ASCII 码；environ 全局变量）\n    8. Administrative Commands（管理员命令，如 ifconfig）\n\n执行命令 \"man man\" 可以查看 man 手册的使用说明\n\n执行命令 \"man ls\" 可以查看命令 ls 的使用说明\n（相当于执行 \"man 1 ls\"，其中 1 表示：指定在 man 手册的第1章内查找 ls 命令的使用说明 ）\n\n执行命令 \"man 3 printf\" 可以查看 man手册第3章 中 库函数 printf 的使用说明\n</code></pre></div><h2 id=\"_5-通配符-与\" tabindex=\"-1\"> 5. 通配符 <code>*</code> 与 <code>?</code></h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day13/03.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>如上图：\n* 通配 多个 字符\n? 通配 1个 字符\n</code></pre></div><h2 id=\"_6-输出重定向-与\" tabindex=\"-1\"> 6. 输出重定向 <code>&gt;</code> 与 <code>&gt;&gt;</code></h2>\n<p><code>Linux</code> 允许将命令执行结果重定向到一个文件，本应显示在终端上的内容保存到指定文件中，如：</p>\n<div><pre><code><span># test.txt 如果不存在，则创建，存在则覆盖其内容</span>\n<span>ls</span> <span>></span> test.txt\n</code></pre></div><div><pre><code>输出重定向 \">\" 会覆盖原来的内容， \n输出重定向 \">>\" 则会追加到文件的尾部。\n</code></pre></div><h2 id=\"_7-查看或者合并文件内容-cat\" tabindex=\"-1\"> 7. 查看或者合并文件内容：<code>cat</code></h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day13/04.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_8-拷贝文件-cp\" tabindex=\"-1\"> 8. 拷贝文件：<code>cp</code></h2>\n<div><pre><code>-a\n    该选项通常在复制目录时使用，\n    它保留链接、文件属性，并递归地复制目录，\n    简单而言，保持文件原有属性。\n-f\n    覆盖已经存在的目标文件而不提示\n-i\n    交互式复制，在覆盖目标文件之前将给出提示要求用户确认\n-r\n    若给出的源文件是目录文件，则 cp 将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名。\n-v\n    显示拷贝进度\n</code></pre></div><h2 id=\"_9-移动或重命名文件-mv\" tabindex=\"-1\"> 9. 移动或重命名文件：<code>mv</code></h2>\n<div><pre><code>可以使用 mv 命令来移动文件或目录；也可以重命名文件或目录。\n</code></pre></div><h2 id=\"_10-获取文件类型-file\" tabindex=\"-1\"> 10. 获取文件类型：<code>file</code></h2>\n<div><pre><code>Linux 系统文件类型不是根据文件扩展名分类的，通过 file 命令可以确认文件具体类型。\n</code></pre></div>",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-21T08:28:13.000Z",
      "authors": [],
      "tags": [
        "C语言基础"
      ]
    },
    {
      "title": "第01天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_2_c-advance/day01.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_2_c-advance/day01.html",
      "content_html": "<h2 id=\"_1-理解数据类型-固定大小内存的别名\" tabindex=\"-1\"> 1. 理解数据类型（固定大小内存的别名）</h2>\n<div><pre><code>1. 数据类型是为了更好进行内存的管理，让编译器能确定分配多少内存；\n2. 类型是对数据的抽象；\n3. 类型相同的数据具有相同的表示形式、存储格式以及相关操作；\n4. 程序中所有的数据都必定属于某种数据类型；\n5. 数据类型可以理解为创建变量的模具：固定大小内存的别名。\n</code></pre></div><h2 id=\"_2-typedef-的作用\" tabindex=\"-1\"> 2. <code>typedef</code> 的作用</h2>\n<p><code>typedef</code> 的作用：</p>\n<div><pre><code>1. 简化 struct 关键字\n2. 区分数据类型\n3. 提高移植性\n</code></pre></div><h3 id=\"_2-1-简化-struct-关键字\" tabindex=\"-1\"> 2.1 简化 <code>struct</code> 关键字</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/01.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>如上图，使用 <code>typedef</code> 可以简化 <code>struct</code> 关键字。</p>\n</blockquote>\n<h3 id=\"_2-2-更方便地区分数据类型\" tabindex=\"-1\"> 2.2 更方便地区分数据类型</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/02.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>如上图，使用 <code>typedef</code> 可以更方便地区分数据类型。</p>\n</blockquote>\n<h3 id=\"_2-3-提高可移植性\" tabindex=\"-1\"> 2.3 提高可移植性</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/03.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>如上图，若以后想将 int 类型替换为 long 类型，那么只需将 \"typedef int  MYINT;\" 修改为 \"typedef long  MYINT;\" 即可，\n而不需要挨个去查找 int 类型的变量进行修改，从而提高了可移植性。\n</code></pre></div><h2 id=\"_3-void-无类型-的使用\" tabindex=\"-1\"> 3. <code>void</code>（无类型）的使用</h2>\n<h3 id=\"_3-1-不能通过-void-无类型-创建变量\" tabindex=\"-1\"> 3.1 不能通过 void（无类型）创建变量</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/04.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_3-2-void-的使用场景-限定函数的返回值或参数\" tabindex=\"-1\"> 3.2 <code>void</code> 的使用场景：限定函数的返回值或参数</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/05.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_3-3-万能指针-void\" tabindex=\"-1\"> 3.3 万能指针：<code>void *</code></h3>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/06.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_4-sizeof-的使用\" tabindex=\"-1\"> 4. <code>sizeof</code> 的使用</h2>\n<h3 id=\"_4-1-sizeof-是一个操作符-不是函数\" tabindex=\"-1\"> 4.1 <code>sizeof</code> 是一个操作符，不是函数</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/07.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_4-2-sizeof-的返回值类型-unsigned-int-无符号整型\" tabindex=\"-1\"> 4.2 <code>sizeof</code> 的返回值类型：<code>unsigned int</code>（无符号整型）</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/08.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_4-3-sizeof-统计数组长度时的注意事项\" tabindex=\"-1\"> 4.3 <code>sizeof</code> 统计数组长度时的注意事项</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/09.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_5-变量-既能读又能写的内存对象\" tabindex=\"-1\"> 5. 变量（既能读又能写的内存对象）</h2>\n<p>既能读又能写的内存对象，称为变量。</p>\n<p>变量名的本质：一段连续内存空间的别名。</p>\n<div><pre><code>a. 程序通过变量来申请和命名内存空间 int a = 0；\nb. 通过变量名访问内存空间；\nc. 不是向变量名读写数据，而是向变量所代表的内存空间中读写数据\n</code></pre></div><h3 id=\"_5-1-变量的修改方式-直接修改-间接修改-通过指针修改\" tabindex=\"-1\"> 5.1 变量的修改方式：直接修改 &amp; 间接修改（通过指针修改）</h3>\n<p><strong>示例1：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/10.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>示例2：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/11.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_6-内存分区\" tabindex=\"-1\"> 6. 内存分区</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/12.png\" alt=\"\" loading=\"lazy\"></p>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/13.png\" alt=\"\" loading=\"lazy\"></p>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/14.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_6-1-运行前的分区-代码区、数据区、未初始化数据区\" tabindex=\"-1\"> 6.1 运行前的分区（代码区、数据区、未初始化数据区）</h3>\n<div><pre><code>在没有运行程序前，也就是说程序没有加载到内存前，可执行程序内部已经分好 3 段信息，分别为：\n1. 代码区（text）\n2. 数据区（data）\n3. 未初始化数据区（bss）\n\n有些人直接把 data 和 bss 合起来叫做静态区或全局区。\n\n代码区特点：共享、只读。\n\n疑问：常量是存放在 data 段，还是 rodata 段，或者是可以有条件地选择存放在二者之一中？\n</code></pre></div><h3 id=\"_6-2-运行后的分区-增加了栈区、堆区\" tabindex=\"-1\"> 6.2 运行后的分区（增加了栈区、堆区）</h3>\n<div><pre><code>程序在加载到内存前，代码区和全局区（data 和 bss）的大小就是固定的，程序运行期间不能改变。\n然后，运行可执行程序，操作系统把物理硬盘程序 load（加载）到内存。\n除了根据可执行程序的信息分出代码区（text）、数据区（data）和未初始化数据区（bss）之外，还额外增加了栈区、堆区。\n</code></pre></div><h3 id=\"_6-3-栈区的注意事项\" tabindex=\"-1\"> 6.3 栈区的注意事项</h3>\n<p><strong>调用函数时，不要返回局部变量的地址</strong>，因为栈中的局部变量在函数执行完毕后就被释放了。</p>\n<div><pre><code>这里说的局部变量的地址，指的是栈空间中的地址。\n如果该局部变量是一个指向堆空间地址的指针（malloc），那么只要函数执行完毕后没有 free，\n就可以返回该局部变量的值（即指针变量的内容，而不是指针变量的地址）\n</code></pre></div><h3 id=\"_6-4-堆区分配内存的注意事项\" tabindex=\"-1\"> 6.4 堆区分配内存的注意事项</h3>\n<p><strong>示例1：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/15.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>示例2：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/16.png\" alt=\"\" loading=\"lazy\"></p>\n<p>如上代码所示，若主调函数（<code>test02</code>）中没有分配内存，被调函数（<code>allocateSpace02</code>）需要 <strong>用更高级的指针去操作低级指针</strong>，进行分配内存。</p>\n<h2 id=\"_7-static-和-extern\" tabindex=\"-1\"> 7. <code>static</code> 和 <code>extern</code></h2>\n<h3 id=\"_7-1-static-修饰局部变量-只改变生命周期-不改变作用域\" tabindex=\"-1\"> 7.1 <code>static</code> 修饰局部变量（只改变生命周期，不改变作用域）</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/17.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_7-2-extern-在声明局部变量时的作用\" tabindex=\"-1\"> 7.2 <code>extern</code> 在声明局部变量时的作用</h3>\n<div><pre><code>如下代码所示：\n定义全局变量时，默认都隐式地添加了关键字 extern。表示当前文件中定义的全局变量可以被其他文件访问到。\n当其他文件中需要访问当前文件中定义的全局变量时，还需要先通过 extern 关键字声明变量，将全局变量的作用域 \"扩展\" 到当前文件中来。\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/18.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>如下代码所示：\n如果使用 extern 关键字声明变量时，在其他文件中未找到同名的全局变量，那么程序报错。\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/19.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_7-3-static-修饰全局变量-不能被其他文件访问到\" tabindex=\"-1\"> 7.3 <code>static</code> 修饰全局变量（不能被其他文件访问到）</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/20.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_8-常量\" tabindex=\"-1\"> 8. 常量</h2>\n<h3 id=\"_8-1-const-修饰的全局变量-保存在常量区-不可以间接修改\" tabindex=\"-1\"> 8.1 <code>const</code> 修饰的全局变量（保存在常量区，不可以间接修改）</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/21.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_8-2-const-修改的局部变量-仍然保存在栈中-可以间接修改\" tabindex=\"-1\"> 8.2 <code>const</code> 修改的局部变量（仍然保存在栈中，可以间接修改）</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/22.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_8-3-字符串常量\" tabindex=\"-1\"> 8.3 字符串常量</h3>\n<p><strong>示例1：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/23.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>示例2：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/24.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>注意：</strong></p>\n<div><pre><code>ANSI C（即 C89）标准并没有制定出字符串常量是否可以修改的标准，\n根据编译器不同，可能最终结果也是不同的。所以，尽量不要去修改字符串常量！\n</code></pre></div>",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-22T09:23:59.000Z",
      "authors": [],
      "tags": [
        "C高级编程"
      ]
    },
    {
      "title": "第02天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_2_c-advance/day02.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_2_c-advance/day02.html",
      "content_html": "<h2 id=\"_1-宏函数\" tabindex=\"-1\"> 1. 宏函数</h2>\n<div><pre><code>如下代码所示， MYADD 称为宏函数。\n\n宏函数的特点：\n1. 宏函数需要加小括号修饰，保证运算的完整性；\n2. 通常会将频繁、短小的函数写成宏函数；\n3. 宏函数会比普通函数在一定程度上效率高，因为省去了普通函数入栈、出栈时间上的开销。\n\n宏函数的优点可总结为：以空间换时间。\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day02/01.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>以上代码表示：宏函数需要加小括号修饰，以保证运算的完整性。</p>\n</blockquote>\n<h2 id=\"_2-栈-stack\" tabindex=\"-1\"> 2. 栈（<code>stack</code>）</h2>\n<p>栈（<code>stack</code>）是现代计算机程序里最为重要的概念之一，几乎每一个程序都使用了栈，<strong>没有栈就没有函数，没有局部变量</strong>。</p>\n<p>在经典的计算机科学中，栈被定义为一个特殊的容器，用户可以将数据压入栈中（入栈，或称为压栈，<code>push</code>），也可以将压入栈中的数据弹出（出栈，<code>pop</code>）。但是栈容器必须遵循一条规则：先入栈的数据最后出栈（<code>First In Last Out，FILO</code>）</p>\n<p><strong>注意：</strong></p>\n<div><pre><code>在经典的操作系统中，栈总是向下增长的。即：压栈的操作使得栈顶的地址减小，出栈操作使得栈顶地址增大。\n</code></pre></div><h2 id=\"_3-栈帧\" tabindex=\"-1\"> 3. 栈帧</h2>\n<p>栈中保存了一个函数调用所需要维护的信息，这通常被称为 <strong>栈帧（<code>Stack Frame</code>）</strong> 或者 <strong>活动记录（<code>Activate Record</code>）</strong>。</p>\n<h3 id=\"_3-1-栈帧中保存信息-即-函数调用过程所需的信息\" tabindex=\"-1\"> 3.1 栈帧中保存信息（即：函数调用过程所需的信息）</h3>\n<p>一个函数调用过程所需要的信息一般包括以下几个方面（即栈帧中保存的信息如下）：</p>\n<div><pre><code>1. 函数的返回地址；\n2. 函数的参数；\n3. 临时变量；\n4. 保存的上下文：包括在函数调用前后需要保持不变的寄存器。\n</code></pre></div><h2 id=\"_4-调用惯例-calling-convention\" tabindex=\"-1\"> 4. 调用惯例（<code>Calling Convention</code>）</h2>\n<h3 id=\"_4-1-什么是调用惯例\" tabindex=\"-1\"> 4.1 什么是调用惯例</h3>\n<p><strong>主调函数</strong> 和 <strong>被调函数</strong> 在函数调用时必须要有一致约定，才能正确的调用函数，这个约定我们称为 <strong>调用惯例（<code>Calling Convention</code>）</strong>。例如：</p>\n<div><pre><code>它们双方都一致的认为函数的参数是按照某个固定的方式压入栈中。如果不这样的话，函数将无法正确运行，即：\n如果主调函数（函数调用方）在传递参数的时候先压入参数 a，再压入参数 b，而被调函数则认为先压入的是 b，后压入的是 a，\n那么被调函数在使用 a，b 值时候，就会颠倒。\n</code></pre></div><h3 id=\"_4-2-调用惯例的规定内容\" tabindex=\"-1\"> 4.2 调用惯例的规定内容</h3>\n<h4 id=\"_4-2-1-函数参数的传递方式和传递顺序\" tabindex=\"-1\"> 4.2.1 函数参数的传递方式和传递顺序</h4>\n<p><strong>函数参数的传递方式</strong></p>\n<div><pre><code>函数参数的传递有很多种方式：\n1. 最常见的是通过栈传递，即：主调函数（函数调用方）将参数压入栈中，被调函数（函数自己）再从栈中将参数取出。\n2. 另外，有些调用惯例还允许使用寄存器传递参数，以提高性能。\n</code></pre></div><p><strong>函数参数的传递顺序</strong></p>\n<div><pre><code>对于有多个参数的函数，调用惯例还需要规定主调函数（函数调用方）将参数压栈的顺序：从左向右 or 从右向左。\n</code></pre></div><p>以上，调用惯例需要规定：</p>\n<div><pre><code>1. 函数参数是通过栈传递，还是通过寄存器传递；\n2. 以及当存在多个参数时，需要规定对参数列表的压栈顺序是从左向右，还是从右向左。\n</code></pre></div><h4 id=\"_4-2-2-栈的维护方式\" tabindex=\"-1\"> 4.2.2 栈的维护方式</h4>\n<div><pre><code>在主调函数将参数压入栈中之后，（被调函数的）函数体会被调用，\n函数体调用完毕后，需要将被压入栈中的参数全部弹出（出栈），以使得栈在函数调用前后保持一致。\n这个弹出的工作（出栈）可以由主调函数（函数调用方）来完成，也可以由被调函数（函数自己）来完成。\n</code></pre></div><p>以上，调用惯例需要规定：</p>\n<div><pre><code>出栈方是主调函数（函数调用方），还是被调函数（函数自己）。\n</code></pre></div><h4 id=\"_4-2-3-函数名称的修饰\" tabindex=\"-1\"> 4.2.3 函数名称的修饰</h4>\n<div><pre><code>为了在链接的时候对调用惯例进行区分，调用惯例需要要对函数本身（即被调函数）的名称进行修饰。\n不同的调用惯例有不同的名称修饰策略。\n</code></pre></div><p>以上，调用惯例需要规定：</p>\n<div><pre><code>函数名称的修饰策略。\n</code></pre></div><h3 id=\"_4-3-c-c-中的调用惯例-cdecl、stdcall、fastcall、pascal\" tabindex=\"-1\"> 4.3 <code>c/c++</code> 中的调用惯例：<code>cdecl</code>、<code>stdcall</code>、<code>fastcall</code>、<code>pascal</code></h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>调用惯例</strong></th>\n<th style=\"text-align:left\"><strong>出栈方</strong></th>\n<th style=\"text-align:left\"><strong>参数传递</strong></th>\n<th style=\"text-align:left\"><strong>名称修饰策略</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>cdecl</code>（默认）</td>\n<td style=\"text-align:left\">主调函数（函数调用方）</td>\n<td style=\"text-align:left\">从右至左参数入栈</td>\n<td style=\"text-align:left\">下划线+函数名</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>stdcall</code></td>\n<td style=\"text-align:left\">被调函数（函数本身）</td>\n<td style=\"text-align:left\">从右至左参数入栈</td>\n<td style=\"text-align:left\">下划线+函数名+<code>@</code>+参数字节数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>fastcall</code></td>\n<td style=\"text-align:left\">被调函数（函数本身）</td>\n<td style=\"text-align:left\">前两个参数由寄存器传递，其余参数通过堆栈传递</td>\n<td style=\"text-align:left\"><code>@</code>+函数名+<code>@</code>+参数的字节数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>pascal</code></td>\n<td style=\"text-align:left\">被调函数（函数本身）</td>\n<td style=\"text-align:left\">从左至右参数入栈</td>\n<td style=\"text-align:left\">较为复杂，参见相关文档</td>\n</tr>\n</tbody>\n</table>\n<div><pre><code>如上表所示，在 C/C++ 中存在着多个调用惯例，而默认的调用惯例是 cdecl，即：任何一个没有显示指定调用惯例的函数，都默认是 cdecl 惯例。也就是说：\n    int func(int a, int b);   等价于  int _cdecl func(int a, int b);\n\n注意：\n_cdecl 不是标准的关键字，在不同的编译器里可能有不同的写法，例如：gcc 里就不存在 _cdecl 这样的关键字，而是使用 __attribute__((cdecl))\n</code></pre></div><p><strong>示例：不同调用惯例的函数名称修饰策略</strong></p>\n<div><pre><code><span>// 1. cdecl 调用惯例：</span>\n<span>int</span> _cdecl <span>_func</span><span>(</span><span>int</span> a<span>,</span> <span>int</span> b<span>)</span><span>;</span>\n\n<span>// 2. stdcall 调用惯例：</span>\n<span>int</span> _stdcall _func@<span>8</span><span>(</span><span>int</span> a<span>,</span> <span>int</span> b<span>)</span><span>;</span>  <span>// 其中 8 表示两个参数变量所占的总字节数是 8 字节（int 占 4 字节）</span>\n</code></pre></div><h2 id=\"_5-变量在函数之间的传递分析\" tabindex=\"-1\"> 5. 变量在函数之间的传递分析</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day02/02.png\" alt=\"\" loading=\"lazy\"></p>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day02/03.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_6-栈的生长方向-从高地址向低地址扩展\" tabindex=\"-1\"> 6. 栈的生长方向（从高地址向低地址扩展）</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day02/04.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_7-数据的内存存放方式-小端对齐方式\" tabindex=\"-1\"> 7. 数据的内存存放方式：小端对齐方式</h2>\n<div><pre><code>如下代码所示：\n对于 “高位字节数据存放在高地址；低位字节数据存放在低地址” 这种数据的内存存放方式，\n称为：小端对齐方式（即高位数据对应高地址，低位数据对应低地址）\n\n蓝色框的代码和打印日志表示：堆中的数据也是采用小端对齐方式存储的。\n\n注意：并非所有的操作系统都采用小端对齐方式存储数据，有的操作系统可能会采用大端对齐方式。\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day02/05.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_8-空指针-野指针\" tabindex=\"-1\"> 8. 空指针 &amp; 野指针</h2>\n<h3 id=\"_8-1-不允许向-null-和非法地址写入数据\" tabindex=\"-1\"> 8.1 不允许向 <code>NULL</code> 和非法地址写入数据</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day02/06.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>如上图，不允许向 <code>NULL</code> 和非法地址写入数据。</p>\n</blockquote>\n<h3 id=\"_8-2-导致出现野指针的情况\" tabindex=\"-1\"> 8.2 导致出现野指针的情况</h3>\n<h4 id=\"_8-2-1-情况1-指针变量未初始化\" tabindex=\"-1\"> 8.2.1 情况1：指针变量未初始化</h4>\n<div><pre><code>任何指针变量刚被创建时不会自动成为 NULL 指针，它的缺省值是随机的，它会乱指一气。\n所以，指针变量在创建的同时应当被初始化，要么将指针设置为 NULL，要么让它指向合法的内存。\n</code></pre></div><h4 id=\"_8-2-2-情况2-指针释放后未置空\" tabindex=\"-1\"> 8.2.2 情况2：指针释放后未置空</h4>\n<div><pre><code>有时指针在 free 或 delete 后未赋值 NULL，便会使人以为是合法的。\n别看 free 和 delete 的名字（尤其是 delete），它们只是把指针所指的内存给释放掉，但并没有把指针本身干掉。\n此时指针指向的就是 “垃圾” 内存。释放后的指针应立即将指针置为 NULL，防止产生 “野指针”。\n</code></pre></div><h4 id=\"_8-2-3-情况3-指针操作超越变量作用域\" tabindex=\"-1\"> 8.2.3 情况3：指针操作超越变量作用域</h4>\n<div><pre><code>不要返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放。\n</code></pre></div><h4 id=\"_8-2-4-示例1-出现野指针的异常代码\" tabindex=\"-1\"> 8.2.4 示例1：出现野指针的异常代码</h4>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day02/07.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_8-2-5-示例2-free-函数传入空指针不会报错\" tabindex=\"-1\"> 8.2.5 示例2：<code>free</code> 函数传入空指针不会报错</h4>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day02/08.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_8-3-规避野指针的方式\" tabindex=\"-1\"> 8.3 规避野指针的方式</h3>\n<blockquote>\n<p>操作野指针是非常危险的操作，应该规避野指针的出现。</p>\n</blockquote>\n<h4 id=\"_8-3-1-方式1-初始化指针变量时置为-null\" tabindex=\"-1\"> 8.3.1 方式1：初始化指针变量时置为 <code>NULL</code></h4>\n<div><pre><code>指针变量一定要初始化为 NULL，因为任何指针变量刚被创建时不会自动成为 NULL 指针，它的缺省值是随机的。\n</code></pre></div><h4 id=\"_8-3-2-方式2-释放指针变量时置为-null\" tabindex=\"-1\"> 8.3.2 方式2：释放指针变量时置为 <code>NULL</code></h4>\n<div><pre><code>当指针 p 指向的内存空间释放时，没有设置指针 p 的值为 NULL。\ndelete 和 free 只是把内存空间释放了，但是并没有将指针 p 的值赋为 NULL。\n通常判断一个指针是否合法，都是使用 if 语句测试该指针是否为 NULL。\n</code></pre></div><h2 id=\"_9-指针的步长\" tabindex=\"-1\"> 9. 指针的步长</h2>\n<p>指针的步长涵盖两个方面的内容：</p>\n<div><pre><code>1. +1 之后跳跃的字节数；\n2. 解引用所解出的字节数。\n</code></pre></div><h3 id=\"_9-1-指针-1-之后跳跃的字节数\" tabindex=\"-1\"> 9.1 指针 <code>+1</code> 之后跳跃的字节数</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day02/09.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_9-2-解引用解出的字节数\" tabindex=\"-1\"> 9.2 解引用解出的字节数</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day02/10.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_10-offsetof-宏函数-计算结构体成员相对于结构体首地址的偏移\" tabindex=\"-1\"> 10. <code>offsetof</code> 宏函数（计算结构体成员相对于结构体首地址的偏移）</h2>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stddef.h></span></span>\n<span><span>#</span><span>define</span> <span>offsetof</span><span><span>(</span>s<span>,</span>m<span>)</span> <span>(</span><span>(</span><span>size_t</span><span>)</span><span>&amp;</span><span>(</span><span>(</span><span>(</span>s<span>*</span><span>)</span><span>0</span><span>)</span><span>-></span>m<span>)</span><span>)</span></span></span>\n    功能：\n        计算结构体 s 中的成员变量 m 相对于结构体首地址的偏移量（单位：字节）\n    参数：\n        s：结构体类型名称\n        m：预计算偏移量的结构体成员变量\n</code></pre></div><p><strong>示例：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day02/11.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_11-指针做函数参数时的输入输出特性\" tabindex=\"-1\"> 11. 指针做函数参数时的输入输出特性</h2>\n<h3 id=\"_11-1-输入特性-主调函数分配内存-被调函数使用\" tabindex=\"-1\"> 11.1 输入特性：主调函数分配内存，被调函数使用</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day02/12.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_11-2-输出特性-在被调函数中分配内存-主调函数使用\" tabindex=\"-1\"> 11.2 输出特性：在被调函数中分配内存，主调函数使用</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day02/13.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_12-字符串强化练习\" tabindex=\"-1\"> 12. 字符串强化练习</h2>\n<h3 id=\"_12-1-八进制转义字符和十六进制转义字符的使用\" tabindex=\"-1\"> 12.1 八进制转义字符和十六进制转义字符的使用</h3>\n<div><pre><code>在 C 中有两种特殊的字符，八进制转义字符和十六进制转义字符：\n    八进制字符的一般形式是：'\\ddd'，其中，d 表示 0-7 的数字。\n    十六进制字符的一般形式是：'\\xhh'，其中，h 表示 0-9 或 A-F 内的一个。\n\n八进制字符和十六进制字符表示的是字符的 ASCII 码对应的数值。比如 ：\n    '\\063' 表示的是字符 '3'，因为 '3' 的 ASCII 码是 51；\n    '\\x41' 表示的是字符 'A'，因为 'A' 的 ASCII 码是 65。\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day02/14.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_12-2-拷贝字符串的三种方式\" tabindex=\"-1\"> 12.2 拷贝字符串的三种方式</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day02/15.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-27T11:44:34.000Z",
      "authors": [],
      "tags": [
        "C高级编程"
      ]
    },
    {
      "title": "第03天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_2_c-advance/day03.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_2_c-advance/day03.html",
      "content_html": "<h2 id=\"_1-calloc-函数-申请一段初始化为0的内存空间\" tabindex=\"-1\"> 1. <code>calloc</code> 函数：申请一段初始化为0的内存空间</h2>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdlib.h></span></span>\n<span>void</span> <span>*</span><span>calloc</span><span>(</span><span>size_t</span> nmemb<span>,</span> <span>size_t</span> size<span>)</span><span>;</span>\n    功能：\n        在内存动态存储区中分配 nmemb 块长度为 size 字节的连续区域。calloc 自动将分配的内存置 <span>0</span>。\n    参数：\n        nmemb：所需内存单元数量\n        size：每个内存单元的大小（单位：字节）\n    返回值：\n        成功：分配空间的起始地址\n        失败：<span>NULL</span>\n</code></pre></div><h3 id=\"_1-1-calloc-与-malloc-函数的区别\" tabindex=\"-1\"> 1.1 <code>calloc</code> 与 <code>malloc</code> 函数的区别</h3>\n<p><code>calloc</code> 和 <code>malloc</code> 的主要区别在于：</p>\n<div><pre><code>calloc 申请到的内存空间做了初始化，初始值是<span>0</span>；\nmalloc 申请到的内存空间未做初始化，初始值是不确定的；\n</code></pre></div><p>另外，<code>calloc</code> 与 <code>malloc</code> 的函数声明对比如下：</p>\n<div><pre><code><span>/* calloc */</span>\n<span><span>#</span><span>include</span> <span>&lt;stdlib.h></span></span>\n<span>void</span> <span>*</span><span>calloc</span><span>(</span><span>size_t</span> nmemb<span>,</span> <span>size_t</span> size<span>)</span><span>;</span>\n\n<span>/* malloc */</span>\n<span><span>#</span><span>include</span> <span>&lt;stdlib.h></span></span>\n<span>void</span> <span>*</span><span>malloc</span> <span>(</span><span>size_t</span> size<span>)</span><span>;</span>\n</code></pre></div><p>从各自的函数声明来看，若 <code>calloc</code> 和 <code>malloc</code> 分别申请10个 <code>int</code> 大小的内存空间，则有如下区别：</p>\n<div><pre><code><span>/* calloc */</span>\n<span>calloc</span><span>(</span><span>10</span><span>,</span> <span>sizeof</span><span>(</span><span>int</span><span>)</span><span>)</span><span>;</span>\n\n<span>/* malloc */</span>\n<span>malloc</span><span>(</span><span>sizeof</span><span>(</span><span>int</span><span>)</span> <span>*</span> <span>10</span><span>)</span><span>;</span>\n</code></pre></div><p><strong>示例：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day03/01.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_2-realloc-函数-重新分配堆中申请了的内存空间\" tabindex=\"-1\"> 2. <code>realloc</code> 函数：重新分配堆中申请了的内存空间</h2>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdlib.h></span></span>\n<span>void</span> <span>*</span><span>realloc</span><span>(</span><span>void</span> <span>*</span>ptr<span>,</span> <span>size_t</span> size<span>)</span><span>;</span>\n    功能：\n        对通过 malloc 或 calloc 函数在堆中开辟的内存空间进行重新分配。\n    参数：\n        ptr：为之前用 malloc 或 calloc 分配的内存地址，如果此参数等于 <span>NULL</span>，那么和 realloc 与 malloc 功能一致\n        size：为重新分配内存的大小，单位：字节。\n    返回值：\n        成功：新分配的堆内存地址\n        失败：<span>NULL</span>\n</code></pre></div><p><strong>注意：</strong></p>\n<div><pre><code>当重新分配的内存空间比原来大时：\n    1. realloc 不会初始化新空间为 0，即新增的内存空间中的值是不确定的；\n    2. 如果 ptr 指向的地址后面有足够的连续空间，那么就会在已有地址基础上增加内存；\n    3. 如果 ptr 指向的地址后面没有空间了，那么 realloc 会重新分配新的连续内存，把旧内存的值拷贝到新内存，同时释放旧内存。\n\n当重新分配的内存空间比原来小时：\n    1. 会将原内存后面缩减了的部分空间释放掉。\n</code></pre></div><h2 id=\"_3-字符串格式化函数-sprintf\" tabindex=\"-1\"> 3. 字符串格式化函数：<code>sprintf</code></h2>\n<h2 id=\"_4-字符串格式化函数-sscanf\" tabindex=\"-1\"> 4. 字符串格式化函数：<code>sscanf</code></h2>\n<h2 id=\"_5-字符串格式化案例\" tabindex=\"-1\"> 5. 字符串格式化案例</h2>\n<h2 id=\"_6-一级指针易错点\" tabindex=\"-1\"> 6. 一级指针易错点</h2>\n<h3 id=\"_6-1-易错点1-越界-没有考虑到字符串结束标记字符-0\" tabindex=\"-1\"> 6.1 易错点1：越界（没有考虑到字符串结束标记字符 <code>'\\0'</code>）</h3>\n<h3 id=\"_6-2-易错点2-因改变原指针指向而导致-free-失败\" tabindex=\"-1\"> 6.2 易错点2：因改变原指针指向而导致 <code>free</code> 失败</h3>\n<h3 id=\"_6-3-易错点3-被调函数返回局部变量地址\" tabindex=\"-1\"> 6.3 易错点3：被调函数返回局部变量地址</h3>\n<h3 id=\"_6-4-易错点4-同一块内存释放多次-不可以释放野指针\" tabindex=\"-1\"> 6.4 易错点4：同一块内存释放多次（不可以释放野指针）</h3>\n<h2 id=\"_7-位运算-、-、-、\" tabindex=\"-1\"> 7. 位运算（<code>~</code>、<code>&amp;</code>、<code>|</code>、<code>^</code>）</h2>\n<h2 id=\"_8-两数交换的三种方式\" tabindex=\"-1\"> 8. 两数交换的三种方式</h2>\n<h3 id=\"_8-1-方式1-采用临时变量\" tabindex=\"-1\"> 8.1 方式1：采用临时变量</h3>\n<h3 id=\"_8-2-方式2-利用按位异或的特性\" tabindex=\"-1\"> 8.2 方式2：利用按位异或的特性</h3>\n<h3 id=\"_8-3-方式3-利用加减法的特性\" tabindex=\"-1\"> 8.3 方式3：利用加减法的特性</h3>\n",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-28T01:29:00.000Z",
      "authors": [],
      "tags": [
        "C高级编程"
      ]
    },
    {
      "title": "第04天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_2_c-advance/day04.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_2_c-advance/day04.html",
      "content_html": "",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": [
        "C高级编程"
      ]
    },
    {
      "title": "第05天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_2_c-advance/day05.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_2_c-advance/day05.html",
      "content_html": "",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": [
        "C高级编程"
      ]
    },
    {
      "title": "第06天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_2_c-advance/day06.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_2_c-advance/day06.html",
      "content_html": "",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": [
        "C高级编程"
      ]
    },
    {
      "title": "第07天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_2_c-advance/day07.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_2_c-advance/day07.html",
      "content_html": "",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": [
        "C高级编程"
      ]
    },
    {
      "title": "扩展01 - 详解宏定义（#define）",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_2_c-advance/ext01.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_2_c-advance/ext01.html",
      "content_html": "",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": [
        "C高级编程"
      ]
    },
    {
      "title": "第01天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_3_data-structure/day01.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_3_data-structure/day01.html",
      "content_html": "",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": [
        "c/c++ 数据结构"
      ]
    },
    {
      "title": "第02天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_3_data-structure/day02.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_3_data-structure/day02.html",
      "content_html": "",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": [
        "c/c++ 数据结构"
      ]
    },
    {
      "title": "第03天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_3_data-structure/day03.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_3_data-structure/day03.html",
      "content_html": "",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": [
        "c/c++ 数据结构"
      ]
    },
    {
      "title": "第01天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_5_stl/day01.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_5_stl/day01.html",
      "content_html": "",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": [
        "STL"
      ]
    },
    {
      "title": "第02天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_5_stl/day02.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_5_stl/day02.html",
      "content_html": "",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": [
        "STL"
      ]
    },
    {
      "title": "第03天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_5_stl/day03.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_5_stl/day03.html",
      "content_html": "",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": [
        "STL"
      ]
    },
    {
      "title": "第01天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_4_cpp-core/day01.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_4_cpp-core/day01.html",
      "content_html": "",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": [
        "C++核心编程"
      ]
    },
    {
      "title": "第02天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_4_cpp-core/day02.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_4_cpp-core/day02.html",
      "content_html": "",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": [
        "C++核心编程"
      ]
    },
    {
      "title": "第03天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_4_cpp-core/day03.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_4_cpp-core/day03.html",
      "content_html": "",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": [
        "C++核心编程"
      ]
    },
    {
      "title": "第04天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_4_cpp-core/day04.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_4_cpp-core/day04.html",
      "content_html": "",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": [
        "C++核心编程"
      ]
    },
    {
      "title": "第05天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_4_cpp-core/day05.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_4_cpp-core/day05.html",
      "content_html": "",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": [
        "C++核心编程"
      ]
    },
    {
      "title": "第06天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_4_cpp-core/day06.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_4_cpp-core/day06.html",
      "content_html": "",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": [
        "C++核心编程"
      ]
    },
    {
      "title": "第07天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_4_cpp-core/day07.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_4_cpp-core/day07.html",
      "content_html": "",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": [
        "C++核心编程"
      ]
    },
    {
      "title": "第08天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_4_cpp-core/day08.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_4_cpp-core/day08.html",
      "content_html": "",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": [
        "C++核心编程"
      ]
    },
    {
      "title": "第09天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_4_cpp-core/day09.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_4_cpp-core/day09.html",
      "content_html": "",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": [
        "C++核心编程"
      ]
    },
    {
      "title": "扩展01 - C++ 11 中using的使用",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_4_cpp-core/ext01.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_4_cpp-core/ext01.html",
      "content_html": "",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": [
        "C++核心编程"
      ]
    },
    {
      "title": "扩展02 - 详解C++的模板中typename关键字的用法",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_4_cpp-core/ext02.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_4_cpp-core/ext02.html",
      "content_html": "",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": [
        "C++核心编程"
      ]
    },
    {
      "title": "Books",
      "url": "https://zengkaiqiang562.github.io/zkq/books/",
      "id": "https://zengkaiqiang562.github.io/zkq/books/",
      "content_html": "",
      "date_published": "2023-03-09T15:22:56.000Z",
      "date_modified": "2023-03-09T15:22:56.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "第1章 Linux内核简介",
      "url": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_01_linux_kernel_introduction.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_01_linux_kernel_introduction.html",
      "content_html": "",
      "date_published": "2023-03-09T15:22:56.000Z",
      "date_modified": "2023-03-09T15:22:56.000Z",
      "authors": [],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "第2章 从内核出发",
      "url": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_02_begin_from_kernel.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_02_begin_from_kernel.html",
      "content_html": "",
      "date_published": "2023-03-09T15:22:56.000Z",
      "date_modified": "2023-03-09T15:22:56.000Z",
      "authors": [],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "第3章 进程管理",
      "url": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_03_process_manager.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_03_process_manager.html",
      "content_html": "",
      "date_published": "2023-03-09T15:22:56.000Z",
      "date_modified": "2023-03-09T15:22:56.000Z",
      "authors": [],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "第4章 进程调度",
      "url": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_04_process_dispatch.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_04_process_dispatch.html",
      "content_html": "",
      "date_published": "2023-03-09T15:22:56.000Z",
      "date_modified": "2023-03-09T15:22:56.000Z",
      "authors": [],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "第5章 系统调用",
      "url": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_05_system_call.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_05_system_call.html",
      "content_html": "",
      "date_published": "2023-03-09T15:22:56.000Z",
      "date_modified": "2023-03-09T15:22:56.000Z",
      "authors": [],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "第6章 内核数据结构",
      "url": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_06_kernel_data_structure.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_06_kernel_data_structure.html",
      "content_html": "",
      "date_published": "2023-03-09T15:22:56.000Z",
      "date_modified": "2023-03-09T15:22:56.000Z",
      "authors": [],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "第7章 中断和中断处理",
      "url": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_07_interrupt_and_deal.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_07_interrupt_and_deal.html",
      "content_html": "",
      "date_published": "2023-03-09T15:22:56.000Z",
      "date_modified": "2023-03-09T15:22:56.000Z",
      "authors": [],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "第8章 下半部和推后执行的工作",
      "url": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_08_bottom_half_and_defer_execute.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_08_bottom_half_and_defer_execute.html",
      "content_html": "",
      "date_published": "2023-03-09T15:22:56.000Z",
      "date_modified": "2023-03-09T15:22:56.000Z",
      "authors": [],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "第9章 内核同步介绍",
      "url": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_09_kernel_sync_introduction.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_09_kernel_sync_introduction.html",
      "content_html": "",
      "date_published": "2023-03-09T15:22:56.000Z",
      "date_modified": "2023-03-09T15:22:56.000Z",
      "authors": [],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "第10章 内核同步方法",
      "url": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_10_kernel_sync_method.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_10_kernel_sync_method.html",
      "content_html": "",
      "date_published": "2023-03-09T15:22:56.000Z",
      "date_modified": "2023-03-09T15:22:56.000Z",
      "authors": [],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "第11章 定时器和时间管理",
      "url": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_11_timer_and_manage.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_11_timer_and_manage.html",
      "content_html": "",
      "date_published": "2023-03-09T15:22:56.000Z",
      "date_modified": "2023-03-09T15:22:56.000Z",
      "authors": [],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "第12章 内存管理",
      "url": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_12_memory_manage.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_12_memory_manage.html",
      "content_html": "",
      "date_published": "2023-03-09T15:22:56.000Z",
      "date_modified": "2023-03-09T15:22:56.000Z",
      "authors": [],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "第13章 虚拟文件系统",
      "url": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_13_virtual_file_system.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_13_virtual_file_system.html",
      "content_html": "",
      "date_published": "2023-03-09T15:22:56.000Z",
      "date_modified": "2023-03-09T15:22:56.000Z",
      "authors": [],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "第14章 块I/O层",
      "url": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_14_block_io_layer.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_14_block_io_layer.html",
      "content_html": "",
      "date_published": "2023-03-09T15:22:56.000Z",
      "date_modified": "2023-03-09T15:22:56.000Z",
      "authors": [],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "第15章 进程地址空间",
      "url": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_15_process_addr_space.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_15_process_addr_space.html",
      "content_html": "",
      "date_published": "2023-03-09T15:22:56.000Z",
      "date_modified": "2023-03-09T15:22:56.000Z",
      "authors": [],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "第16章 页高速缓存和页回写",
      "url": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_16_page_high_cache_and_page_rewrite.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_16_page_high_cache_and_page_rewrite.html",
      "content_html": "",
      "date_published": "2023-03-09T15:22:56.000Z",
      "date_modified": "2023-03-09T15:22:56.000Z",
      "authors": [],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "第17章 设备与模块",
      "url": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_17_device_and_module.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_17_device_and_module.html",
      "content_html": "",
      "date_published": "2023-03-09T15:22:56.000Z",
      "date_modified": "2023-03-09T15:22:56.000Z",
      "authors": [],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "第18章 调试",
      "url": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_18_debug.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_18_debug.html",
      "content_html": "",
      "date_published": "2023-03-09T15:22:56.000Z",
      "date_modified": "2023-03-09T15:22:56.000Z",
      "authors": [],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "第19章 可移植性",
      "url": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_19_transplant.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_19_transplant.html",
      "content_html": "",
      "date_published": "2023-03-09T15:22:56.000Z",
      "date_modified": "2023-03-09T15:22:56.000Z",
      "authors": [],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "第20章 补丁、开发和社区",
      "url": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_20_patch_and_dev_community.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_20_patch_and_dev_community.html",
      "content_html": "",
      "date_published": "2023-03-09T15:22:56.000Z",
      "date_modified": "2023-03-09T15:22:56.000Z",
      "authors": [],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "Gradle相关介绍",
      "url": "https://zengkaiqiang562.github.io/zkq/gradle/_01_introduce.html",
      "id": "https://zengkaiqiang562.github.io/zkq/gradle/_01_introduce.html",
      "content_html": "<p><code>Gradle</code> 是一款构建工具。<code>Maven</code> 和 <code>Ant</code> 能做的，<code>Gradle</code> 也能做；<code>Gradle</code> 能做的，<code>Maven</code> 和 <code>Ant</code> 却不一定能做。</p>\n<p><code>Maven</code> 和 <code>Ant</code> 都是使用 <code>XML</code> 配置，但是 <code>Gradle</code> 使用程序代替传统的 <code>XML</code> 配置，使项目构建更灵活。</p>\n<p><code>Gradle</code> 本身也是一门程序语言，有丰富的第三方插件库可以使用。</p>\n<p>目前的 <code>Android</code> 项目和 <code>Java</code> 项目基本都是用 <code>Gradle</code> 构建的。</p>\n<h2 id=\"_1-dsl-领域特定语言介绍\" tabindex=\"-1\"> 1. <code>DSL</code> 领域特定语言介绍</h2>\n<p><code>DSL</code> 就是领域特定语言（<code>Domain Specific Language</code>），<code>DSL</code> 语言是用来解决某一特定领域内问题的语言。</p>\n<p><strong><code>DSL</code> 的核心思想：</strong> 求专不求全，解决特定问题。</p>\n<p><strong>注意：</strong> <code>DSL</code> 并不是一个新的语言，而是一个语言种类。</p>\n<p><strong>例如：</strong></p>\n<div><pre><code>1. Matlab 建模语言是 DSL 语言中的一种，专门用来做计算的；\n2. UML 建模语言也是 DSL 语言中的一种，专门用来建模的；\n3. HTML 语言也是 DSL 语言中的一种，专门用来做浏览器网页的；\n4. Groovy 语言也是 DSL 语言中的一种，专门用来写脚本，类似于 Python 脚本语言和 Ruby 脚本语言。\n</code></pre></div><h2 id=\"_2-groovy-语言介绍\" tabindex=\"-1\"> 2. <code>Groovy</code> 语言介绍</h2>\n<p><code>Groovy</code> 是一种基于 <code>JVM</code> 的敏捷开发语言。同 <code>Java</code> 语言一样，可以编译成 <code>class</code> 字节码文件交给 <code>JVM</code> 运行处理。</p>\n<p><code>Groovy</code> 结合了 <code>Python</code>、<code>Ruby</code>、<code>Smalltalk</code> 的许多强大特性，之所以不直接使用 <code>Python</code>、<code>Ruby</code>、<code>Smalltalk</code> 这些语言，是因为 <code>Groovy</code> 可以理解为 <code>Java</code> 语言的扩展，<code>Java</code> 语法基本都适用于 <code>Groovy</code>。也就是说，对于 <code>Java</code> 开发者，可以快速地掌握 <code>Groovy</code>，而不用重头再去学习 <code>Python</code>、<code>Ruby</code>、<code>Smalltalk</code>。</p>\n<p><code>Groovy</code> 可以与 <code>Java</code> 完美结合，<code>Groovy</code> 可以使用 <code>Java</code> 所有的库。</p>\n<h2 id=\"_3-groovy-特性\" tabindex=\"-1\"> 3. <code>Groovy</code> 特性</h2>\n<ol>\n<li>\n<p>语法上支持动态类型、闭包等新一代语言特性；</p>\n</li>\n<li>\n<p>无缝集成所有已经存在的 <code>Java</code> 类库；</p>\n</li>\n<li>\n<p>即支持面向对象编程，也支持面向过程编程。</p>\n<blockquote>\n<p><code>Groovy</code> 是 <code>Java</code> 的扩展，所以支持面向对象编程（因此可以将 <code>Groovy</code> 作为编程语言）；</p>\n<p><code>Groovy</code> 结合了 <code>Python</code>、<code>Ruby</code>、<code>Smalltalk</code> 这些脚本语言的特性，所以也支持面向过程编程（因此也可以将 <code>Groovy</code> 作为脚本语言）；</p>\n<p>我们学习 <code>Groovy</code> 主要是用来编写构建脚本，所以主要学习如何使用 <code>Groovy</code> 进行面向过程编程。</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"_4-开发环境搭建\" tabindex=\"-1\"> 4. 开发环境搭建</h2>\n<h3 id=\"_4-1-windows-mac-linux-操作系统中配置-groovy-开发环境\" tabindex=\"-1\"> 4.1 <code>Windows</code>/<code>Mac</code>/<code>Linux</code> 操作系统中配置 <code>Groovy</code> 开发环境</h3>\n<p>以 <code>Windows</code> 为例（其他操作系统基本一致）：</p>\n<p><strong>Step 1. 安装 <code>JDK</code> 环境</strong></p>\n<p><strong>Step 2. 下载 <code>Groovy SDK</code> 并配置 <code>Groovy</code> 相关的环境变量</strong></p>\n<blockquote>\n<p>官网地址：<a href=\"http://www.groovy-lang.org\" target=\"_blank\" rel=\"noopener noreferrer\">http://www.groovy-lang.org<ExternalLinkIcon/></a></p>\n<p>下载地址：<a href=\"https://groovy.apache.org/download.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://groovy.apache.org/download.html<ExternalLinkIcon/></a></p>\n<p>所有版本下载地址：<a href=\"https://archive.apache.org/dist/groovy/\" target=\"_blank\" rel=\"noopener noreferrer\">https://archive.apache.org/dist/groovy/<ExternalLinkIcon/></a></p>\n</blockquote>\n<p>本课程使用的版本为 <code>Groovy 2.4.12</code>，所以下载 <code>apache-groovy-sdk-2.4.12.zip</code> 解压到合适位置。</p>\n<p>解压后的目录结构如下：</p>\n<div><pre><code>bin 目录下包含一些可执行文件：\n1. groovy 相当于 jdk 的 bin 目录下的 java 可执行程序，用来执行编译生成的字节码文件；\n2. groovyc 相当于 javac ，用于将 Groov 编写的程序编译成字节码文件；\n3. groovysh 则用来解释执行 Groovy 编写的脚本。\n\ndoc 目录下的：\n1. html\\documentation 文件夹中包含 Groovy 的教程文档；\n2. html\\api 文件夹中包含 Groovy 的 API 文档。\n</code></pre></div><p><img src=\"@source/zkq/gradle/images/_01_introduce/01.png\" alt=\"\" loading=\"lazy\"></p>\n<p><img src=\"@source/zkq/gradle/images/_01_introduce/02.png\" alt=\"\" loading=\"lazy\"></p>\n<p>配置 <code>Groovy</code> 相关的环境变量：</p>\n<div><pre><code>将 Groovy 安装目录下的 bin 文件夹配置到环境变量中即可。\n成功执行 groovy -version 说明配置完成。\n</code></pre></div><h3 id=\"_4-2-intellij-idea-中配置-groovy-开发环境\" tabindex=\"-1\"> 4.2 <code>IntelliJ IDEA</code> 中配置 <code>Groovy</code> 开发环境</h3>\n<p><code>IntelliJ</code> 中配置 <code>Groovy</code>，就是安装 <code>Groovy</code> 插件。</p>\n<blockquote>\n<p>高版本的 <code>IntelliJ</code> 一般都默认安装了 <code>Groovy</code> 插件的。</p>\n</blockquote>\n<p><img src=\"@source/zkq/gradle/images/_01_introduce/03.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_5-intellij-idea-中创建-groovy-工程\" tabindex=\"-1\"> 5. <code>IntelliJ IDEA</code> 中创建 <code>Groovy</code> 工程</h2>\n<p><strong>Step 1.</strong> 点击 <code>File</code> -&gt; <code>new</code> -&gt; <code>Project</code> 弹出 <code>New Project</code> 对话框。选择 <code>Groovy</code> 工程，其中 <code>Groovy library</code> 路径设置为 <code>Groovy</code> 安装目录，然后点击 <code>Next</code>。</p>\n<p><img src=\"@source/zkq/gradle/images/_01_introduce/04.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>Step 2.</strong> 设置 <code>Groovy</code> 工程的名称和保存路径，点击 <code>Finish</code> 即可。</p>\n<p><img src=\"@source/zkq/gradle/images/_01_introduce/05.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_6-groovy-工程中的-hello-world\" tabindex=\"-1\"> 6. <code>Groovy</code> 工程中的 <code>Hello World</code></h2>\n<p><strong>新建 Groovy 源文件：</strong> 右键 <code>src</code> -&gt; <code>Groovy class</code></p>\n<p><img src=\"@source/zkq/gradle/images/_01_introduce/06.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>注意：</strong></p>\n<ol>\n<li>\n<p><code>Groovy</code> 是 <code>Java</code> 的扩展，所以 <code>Groovy</code> 中支持 <code>Java</code> 语法。</p>\n</li>\n<li>\n<p><code>HelloGroovy.groovy</code> 编译后生成字节码文件 <code>HelloGroovy.class</code></p>\n<p><img src=\"@source/zkq/gradle/images/_01_introduce/07.png\" alt=\"\" loading=\"lazy\"></p>\n</li>\n<li>\n<p><code>Groovy</code> 中，可以省略函数的访问权限修饰；省略函数的形参类型；省略代码语句后面的分号 &quot;<code>;</code>&quot;</p>\n<p><img src=\"@source/zkq/gradle/images/_01_introduce/08.png\" alt=\"\" loading=\"lazy\"></p>\n</li>\n</ol>\n<p><strong><code>Groovy</code> 中 <code>hello groovy</code> 的脚本形式：</strong></p>\n<blockquote>\n<p>可以发现：</p>\n<p>不管是像 <code>Java</code> 那样编写 <code>hello groovy</code>，还是像脚本那样编写 <code>hello groovy</code>， 最终都会生成字节码文件 <code>HelloGroovy.class</code></p>\n<p>而字节码文件中的语法形式仍然跟 <code>Java</code> 一样！</p>\n</blockquote>\n<p><img src=\"@source/zkq/gradle/images/_01_introduce/09.png\" alt=\"\" loading=\"lazy\"></p>\n<p><img src=\"@source/zkq/gradle/images/_01_introduce/10.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "date_published": "2022-10-23T14:49:16.000Z",
      "date_modified": "2022-10-23T14:49:16.000Z",
      "authors": [],
      "tags": [
        "gradle"
      ]
    },
    {
      "title": "Gradle高级用法实战",
      "url": "https://zengkaiqiang562.github.io/zkq/gradle/_03_advance.html",
      "id": "https://zengkaiqiang562.github.io/zkq/gradle/_03_advance.html",
      "content_html": "<h2 id=\"_1-json-操作\" tabindex=\"-1\"> 1. <code>json</code> 操作</h2>\n<h3 id=\"_1-1-实体类转换为-json-字符串-jsonoutput-tojson-obj\" tabindex=\"-1\"> 1.1 实体类转换为 <code>json</code> 字符串：<code>JsonOutput.toJson(obj)</code></h3>\n<div><pre><code>通过调用\nString jsonStr = JsonOutput.toJson(类对象); \n可以将实体类转为 json 字符串\n</code></pre></div><p><img src=\"@source/zkq/gradle/images/_03_advance/01.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_1-2-json-字符串格式化-jsonoutput-prettyprint-json\" tabindex=\"-1\"> 1.2 <code>json</code> 字符串格式化：<code>JsonOutput.prettyPrint(json)</code></h3>\n<div><pre><code>通过调用 \nString formatJsonStr = JsonOutput.prettyPrint(jsonStr);\n可以将 json 字符串转为带 json 格式的 json 字符串\n</code></pre></div><h3 id=\"_1-3-示例代码\" tabindex=\"-1\"> 1.3 示例代码</h3>\n<p><img src=\"@source/zkq/gradle/images/_03_advance/02.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_1-4-json-字符串转为实体类\" tabindex=\"-1\"> 1.4 <code>json</code> 字符串转为实体类</h3>\n<h4 id=\"_1-4-1-通过-jsonslurper-类提供的-parsetext-parse-方法进行转换\" tabindex=\"-1\"> 1.4.1 通过 <code>JsonSlurper</code> 类提供的 <code>parseText</code>/<code>parse</code> 方法进行转换</h4>\n<p>使用 <code>JsonSlurper</code> 类提供的 <code>parseText</code> 和 <code>parse</code> 方法可以将 <code>json</code> 字符串，<code>json</code> 文件转换为实体类对象。</p>\n<h4 id=\"_1-4-2-jsonslurper-的缺陷-无法将-json-字符串转换为自定义类对象\" tabindex=\"-1\"> 1.4.2 <code>JsonSlurper</code> 的缺陷：无法将 <code>json</code> 字符串转换为自定义类对象</h4>\n<p><code>JsonSlurper</code> 只能将 <code>json</code> 字符串转换为 <code>Map</code>，<code>List</code>，或基本数据类型的包装类。</p>\n<p>无法使用 <code>JsonSlurper</code> 将 <code>json</code> 字符串直接转换为自定义类对象。</p>\n<p>对于表示自定义类对象转换生成的 <code>json</code> 字符串，再通过 <code>JsonSlurper</code> 时，只能转换为 <code>Map</code> 对象。</p>\n<h4 id=\"_1-4-3-示例代码\" tabindex=\"-1\"> 1.4.3 示例代码</h4>\n<p><img src=\"@source/zkq/gradle/images/_03_advance/03.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_1-4-4-使用-gson-进行转换\" tabindex=\"-1\"> 1.4.4 使用 <code>Gson</code> 进行转换</h4>\n<p>可以导入第三方 <code>jar</code> 包（如 <code>gson</code>），使用第三方开源库将 <code>json</code> 字符串转换为实体类对象。</p>\n<h4 id=\"_1-4-5-groovy-工程中导入第三方-jar-包文件的步骤\" tabindex=\"-1\"> 1.4.5 <code>Groovy</code> 工程中导入第三方 <code>jar</code> 包文件的步骤</h4>\n<p><strong>Step 1.</strong> 在根目录下创建 <code>libs</code> 文件夹。</p>\n<p><strong>Step 2.</strong> 将 <code>jar</code> 文件添加到 <code>libs</code> 文件夹中。</p>\n<p><strong>Step 3.</strong> 右键 <code>libs</code> 文件夹下的 <code>jar</code> 文件，选择 &quot;<code>Add as Library...</code>&quot;。</p>\n<h2 id=\"_2-xml-文件操作\" tabindex=\"-1\"> 2. <code>xml</code> 文件操作</h2>\n<h3 id=\"_2-1-解析-xml-格式数据-xmlslurper\" tabindex=\"-1\"> 2.1 解析 <code>xml</code> 格式数据：<code>XmlSlurper</code></h3>\n<p>通过 <code>XmlSlurper</code> 类提供的 <code>parseText</code> 和 <code>parse</code> 方法，可以对 <code>xml</code> 格式的字符串和 <code>xml</code> 格式的文件进行解析。</p>\n<p><code>parseText</code> 和 <code>parse</code> 方法返回表示 <code>xml</code> 格式数据中根节点的类型为 <code>NodeChild</code> 的对象，<code>NodeChild</code> 中封装了 <code>Node</code> 类型的节点，实际上，<code>XmlSlurper</code> 把 <code>xml</code> 数据中的每个节点都解析为 <code>Node</code> 对象，并封装在 <code>NodeChild</code> 对象中。</p>\n<p><code>XmlSlurper</code> 中通过 <code>NodeChildren</code> 类型的迭代器来访问 <code>xml</code> 数据中的子节点。同级的同名节点使用一个与节点同名的 <code>NodeChildren</code> 迭代器来访问，通过 &quot;<code>nodeChildren[index]</code>&quot; 来访问指定索引处的子节点。特别地，当同级下的同名节点只有一个时，访问 <code>nodeChildren</code> 就相当于访问 <code>nodeChildren[0]</code>。</p>\n<p>于是，从根节点开始，可以通过如下的方式访问到 <code>xml</code> 数据中任意位置的节点：</p>\n<div><pre><code>root.level_1_nodeChildren[index].level_2_nodeChildren[index]. ... .level_n_nodeChildren[index]\n</code></pre></div><p>通过 <code>nodeChild.text()</code> 访问双标签节点包裹的内容。</p>\n<p>通过 <code>nodeChild.@attrName</code> 访问节点的属性。</p>\n<p><code>NodeChild</code> 和 <code>NodeChildren</code> 都继承自 <code>GPathResult</code>。</p>\n<h4 id=\"_2-1-1-示例代码一\" tabindex=\"-1\"> 2.1.1 示例代码一</h4>\n<p><img src=\"@source/zkq/gradle/images/_03_advance/04.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_2-1-2-示例代码二-深度遍历-depthfirst\" tabindex=\"-1\"> 2.1.2 示例代码二：深度遍历（<code>depthFirst()</code>）</h4>\n<p>案例：获取作者为李刚的所有书的书名。</p>\n<p>有两种方式：</p>\n<ol>\n<li>\n<p>从 <code>books</code> 节点开始，调用 <code>DefaultGroovyMethods</code> 提供 <code>each</code> 方法进行遍历。</p>\n<p><img src=\"@source/zkq/gradle/images/_03_advance/05.png\" alt=\"\" loading=\"lazy\"></p>\n</li>\n<li>\n<p>调用 <code>depthFirst</code> 方法，从根节点开始依次遍历所有节点（深度遍历）。</p>\n<blockquote>\n<p>调用 <code>gPathResult.depthFirst()</code> 时，还可以写成 <code>gPathResult.'**'</code></p>\n</blockquote>\n<p><img src=\"@source/zkq/gradle/images/_03_advance/06.png\" alt=\"\" loading=\"lazy\"></p>\n</li>\n</ol>\n<h4 id=\"_2-1-3-示例代码三-广度遍历-children\" tabindex=\"-1\"> 2.1.3 示例代码三：广度遍历（<code>children()</code>）</h4>\n<p>与深度遍历 <code>depthFirst()</code> 相对于的还有广度遍历 <code>children()</code>，即：</p>\n<ol>\n<li>\n<p>深度遍历表示遍历各级的所有子节点；</p>\n</li>\n<li>\n<p>广度遍历表示只遍历下一级的各个子节点。</p>\n</li>\n</ol>\n<blockquote>\n<p>调用 <code>gPathResult.children()</code> 时，还可以写成 <code>gPathResult.'*'</code></p>\n</blockquote>\n<p><img src=\"@source/zkq/gradle/images/_03_advance/07.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_2-2-生成-xml-格式数据-markerupbuilder\" tabindex=\"-1\"> 2.2 生成 <code>xml</code> 格式数据：<code>MarkerupBuilder</code></h3>\n<p>使用 <code>MarkerupBuilder</code> 生成 <code>xml</code> 格式字符串的代码流程如下：</p>\n<div><pre><code><span>def</span> sw <span>=</span> <span>new</span> <span>StringWriter</span><span>(</span><span>)</span> <span>// StringWriter extends Writer</span>\n<span>def</span> xmlBuilder <span>=</span> <span>new</span> <span>MarkupBuilder</span><span>(</span>sw<span>)</span> <span>// 创建用于生成 xml 数据的构建器 MarkupBuilder</span>\n\n<span>//使用 xmlBuilder.rootNodeName 定义名为 rootNodeName 的根节点 </span>\nxmlBuilder<span>.</span><span>rootNodeName</span><span>(</span>attrName1<span>:</span> <span>'attrValue1'</span><span>,</span> attrName2<span>:</span> <span>'attrValue2'</span><span>,</span> <span>...</span><span>)</span> <span>{</span> <span>// 根节点下的 {} 中定义一级子节点</span>\n\n    <span>leve_1_NodeName1</span><span>(</span>attrName1<span>:</span> <span>'attrValue1'</span><span>,</span> attrName2<span>:</span> <span>'attrValue2'</span><span>,</span> <span>...</span><span>)</span> <span>{</span> <span>// 一级节点下的 {} 中定义二级子节点</span>\n\n        <span>leve_2_NodeName1</span><span>(</span>attrName1<span>:</span> <span>'attrValue1'</span><span>,</span> attrName2<span>:</span> <span>'attrValue2'</span><span>,</span> <span>...</span><span>)</span> <span>{</span> <span>// 二级节点下的 {} 中定义三级子节点</span>\n    \n            <span>/**\n             * 以此类推，层层定义各级子节点\n             */</span>        \n    \n        <span>}</span>\n\n        <span>leve_2_NodeName2</span><span>(</span>attrName1<span>:</span> <span>'attrValue1'</span><span>,</span> attrName2<span>:</span> <span>'attrValue2'</span><span>,</span> <span>...</span><span>)</span> <span>{</span><span>...</span><span>}</span>\n\n        <span>// 对于只包含内容的双标签节点，'contentValue' 表示其所包含的内容</span>\n        <span>leve_2_NodeName3</span><span>(</span>attrName1<span>:</span> <span>'attrValue1'</span><span>,</span> attrName2<span>:</span> <span>'attrValue2'</span><span>,</span> <span>...</span><span>,</span> <span>'contentValue'</span><span>)</span>\n        <span>...</span>\n    <span>}</span>\n\n    <span>leve_1_NodeName2</span><span>(</span>attrName1<span>:</span> <span>'attrValue1'</span><span>,</span> attrName2<span>:</span> <span>'attrValue2'</span><span>,</span> <span>...</span><span>)</span> <span>{</span><span>...</span><span>}</span>\n    <span>leve_1_NodeName3</span><span>(</span>attrName1<span>:</span> <span>'attrValue1'</span><span>,</span> attrName2<span>:</span> <span>'attrValue2'</span><span>,</span> <span>...</span><span>)</span> <span>{</span><span>...</span><span>}</span>\n    <span>...</span>\n<span>}</span>\n\n<span>//xml 数据都写入到了 StringWriter 中</span>\nprintln sw\n</code></pre></div><p><strong>示例代码：</strong></p>\n<p><img src=\"@source/zkq/gradle/images/_03_advance/08.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_2-3-将实体类转换为-xml-数据\" tabindex=\"-1\"> 2.3 将实体类转换为 <code>xml</code> 数据</h3>\n<p><strong>示例代码：</strong></p>\n<p><img src=\"@source/zkq/gradle/images/_03_advance/09.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_3-普通文件操作\" tabindex=\"-1\"> 3. 普通文件操作</h2>\n<h3 id=\"_3-1-groovy-操作普通文件的方式\" tabindex=\"-1\"> 3.1 <code>Groovy</code> 操作普通文件的方式</h3>\n<p>所有在 <code>Java</code> 中对文件的处理类，在 <code>Groovy</code> 中都可以使用。</p>\n<p>另外，<code>Groovy</code> 提供了 <code>ResourceGroovyMethods</code> 类，扩展了很多更加快捷和强大的方法。</p>\n<h3 id=\"_3-2-通过-resourcegroovymethods-提供的-api-操作文件\" tabindex=\"-1\"> 3.2 通过 <code>ResourceGroovyMethods</code> 提供的 <code>API</code> 操作文件</h3>\n<p><code>java.io.File</code> 对象可以通过调用 <code>ResourceGroovyMethods</code> 提供的相关 <code>API</code> 来操作文件。</p>\n<h4 id=\"_3-2-1-遍历文本文件的每行内容-each-self-closure\" tabindex=\"-1\"> 3.2.1 遍历文本文件的每行内容：<code>each(self, closure)</code></h4>\n<div><pre><code><span>static</span> <span>&lt;</span>T<span>></span> T <span>eachLine</span><span>(</span>File self<span>,</span> Closure<span>&lt;</span>T<span>></span> closure<span>)</span> <span>throws</span> IOException\n</code></pre></div><h4 id=\"_3-2-2-以字符串的形式获取文本文件的所有内容-gettext-file\" tabindex=\"-1\"> 3.2.2 以字符串的形式获取文本文件的所有内容：<code>getText(file)</code></h4>\n<div><pre><code><span>static</span> String <span>getText</span><span>(</span>File file<span>)</span> <span>throws</span> IOException\n</code></pre></div><h4 id=\"_3-2-3-以集合的形式获取文本文件的所有内容-readlines-file\" tabindex=\"-1\"> 3.2.3 以集合的形式获取文本文件的所有内容：<code>readLines(file)</code></h4>\n<div><pre><code><span>static</span> List<span>&lt;</span>String<span>></span> <span>readLines</span><span>(</span>File file<span>)</span> <span>throws</span> IOException\n</code></pre></div><blockquote>\n<p>注意：集合中的一个元素表示一行内容。</p>\n</blockquote>\n<h4 id=\"_3-2-4-示例代码一\" tabindex=\"-1\"> 3.2.4 示例代码一</h4>\n<p><img src=\"@source/zkq/gradle/images/_03_advance/10.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_3-2-5-读文件-withreader-file-closure\" tabindex=\"-1\"> 3.2.5 读文件：<code>withReader(file, closure)</code></h4>\n<div><pre><code><span>static</span> <span>&lt;</span>T<span>></span> T <span>withReader</span><span>(</span>File file<span>,</span> Closure<span>&lt;</span>T<span>></span> closure<span>)</span> <span>throws</span> IOException\n</code></pre></div><h4 id=\"_3-2-6-写文件-withwriter-file-closure\" tabindex=\"-1\"> 3.2.6 写文件：<code>withWriter(file, closure)</code></h4>\n<div><pre><code><span>static</span> <span>&lt;</span>T<span>></span> T <span>withWriter</span><span>(</span>File file<span>,</span> Closure<span>&lt;</span>T<span>></span> closure<span>)</span>\n</code></pre></div><h4 id=\"_3-2-7-示例代码二\" tabindex=\"-1\"> 3.2.7 示例代码二</h4>\n<p><img src=\"@source/zkq/gradle/images/_03_advance/11.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_3-3-对象的持久化存储\" tabindex=\"-1\"> 3.3 对象的持久化存储</h3>\n<p><strong>示例代码：</strong></p>\n<p><img src=\"@source/zkq/gradle/images/_03_advance/12.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "date_published": "2022-10-23T14:49:16.000Z",
      "date_modified": "2022-10-26T03:03:54.000Z",
      "authors": [],
      "tags": [
        "gradle"
      ]
    },
    {
      "title": "Gradle生命周期探索",
      "url": "https://zengkaiqiang562.github.io/zkq/gradle/_04_lifecycle.html",
      "id": "https://zengkaiqiang562.github.io/zkq/gradle/_04_lifecycle.html",
      "content_html": "<h2 id=\"_1-gradle-概述\" tabindex=\"-1\"> 1. <code>Gradle</code> 概述</h2>\n<p><code>Gradle</code> 有自己的编程语言和 <code>API</code>，所以 <code>Gradle</code> 不仅仅是一种像 <code>Maven</code>，<code>Ant</code> 那样的构建工具，更是一种编程框架。</p>\n<p><code>Gradle</code> 最大的特色就是通过编程去实现构建过程中的各种需求。</p>\n<h3 id=\"_1-1-gradle-的组成\" tabindex=\"-1\"> 1.1 <code>Gradle</code> 的组成</h3>\n<p><code>Gradle</code> 由以下几部分组成：</p>\n<ol>\n<li>\n<p><code>Groovy</code> 核心语法</p>\n<blockquote>\n<p>就像 <code>Android</code> 使用 <code>Java</code> 作为编程语言一样，<code>Gradle</code> 使用 <code>Groovy</code> 作为编程语言。</p>\n</blockquote>\n</li>\n<li>\n<p><code>build script block</code></p>\n<blockquote>\n<p>这部分是 <code>Gradle</code> 特有的，可以在不同的 <code>build script block</code> 中处理不同的事情。</p>\n</blockquote>\n</li>\n<li>\n<p><code>Gradle API</code></p>\n</li>\n</ol>\n<h3 id=\"_1-2-gradle-的优势\" tabindex=\"-1\"> 1.2 <code>Gradle</code> 的优势</h3>\n<p><code>Gradle</code> 的优势总结为如下 <code>4</code> 个方面：</p>\n<ol>\n<li>\n<p>灵活性方面：</p>\n<div><pre><code>使用 Maven 工具或 Ant 工具进行构建时，工具提供了哪些功能，我们就只能使用哪些功能，无法根据需求自主地进行功能扩展。\n也就是说 Maven 工具和Ant 工具的构建脚本是写死的，我们只能修改 xml 配置文件，不能修改构建脚本。\n但是使用 Gradle，可以根据实际需求对构建脚本进行修改，在功能扩展方面提供了强大的灵活性。\n</code></pre></div></li>\n<li>\n<p>粒度性方面：</p>\n<div><pre><code>使用 Maven 工具或 Ant 工具对项目工程进行构建时，构建脚本和项目源码是相互独立的，且构建脚本是封装好了的，\n我们无法知道构建工具内部是如何对项目工程进行构建的。只知道输入什么，输出什么，中间过程是封闭的。\n但是使用 Gradle，不管是项目源码的编译，还是资源文件的编译，都是由一个个的 Task 任务完成的，并且 Task 的源码是开源的，\n我们可以通过修改 Task 的代码，自定义项目工程的构建过程。也就是说，Gradle 是以 Task 为单位进行构建的，并且 Task 是可修改的。\n</code></pre></div></li>\n<li>\n<p>扩展性方面：</p>\n<div><pre><code>使用 Gradle 构建时，可以使用 Gradle 插件。\nGradle 插件就相当于第三方依赖库。\n通过使用已有的 Gradle 插件，可以方便地扩展别人已经写好的功能。\n</code></pre></div></li>\n<li>\n<p>兼容性方面：</p>\n<div><pre><code>对于 Maven 和 Ant 中的功能，Gradle 都做了兼容。\n也就是说，Maven 和 Ant 能做到的事情，Gradle 也能做到。\n</code></pre></div></li>\n</ol>\n<h2 id=\"_2-gradle-的生命周期-gradle-构建过程的执行流程\" tabindex=\"-1\"> 2. <code>Gradle</code> 的生命周期（<code>Gradle</code> 构建过程的执行流程）</h2>\n<p><code>Gradle</code> 的生命周期就是指 <code>Gradle</code> 构建过程的执行流程。</p>\n<h3 id=\"_2-1-执行-task-任务时经历的三个阶段\" tabindex=\"-1\"> 2.1 执行 <code>Task</code> 任务时经历的三个阶段</h3>\n<p>通过 &quot;<code>gradlew taskName</code>&quot; 命令执行 <code>Task</code> 任务时，会经历三个阶段：初始化阶段、配置阶段、执行阶段。</p>\n<p><img src=\"@source/zkq/gradle/images/_04_lifecycle/01.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_2-1-1-initialization-初始化阶段\" tabindex=\"-1\"> 2.1.1 <code>Initialization</code> 初始化阶段</h4>\n<div><pre><code>settings.gradle 文件在初始化阶段执行。\n</code></pre></div><h4 id=\"_2-1-2-configuration-配置阶段\" tabindex=\"-1\"> 2.1.2 <code>Configuration</code> 配置阶段</h4>\n<div><pre><code>1. 解析 task；\n2. 构建 task 的拓补图（即 task 依赖树）。\n</code></pre></div><h4 id=\"_2-1-3-execution-执行阶段\" tabindex=\"-1\"> 2.1.3 <code>Execution</code> 执行阶段</h4>\n<div><pre><code>执行时，先根据 Task 的依赖关系，执行被依赖 Task；\n最后再执行 \"gradlew taskName\" 命令中的 taskName 指定的 Task。\n</code></pre></div><h3 id=\"_2-2-gradle-生命周期的监听回调\" tabindex=\"-1\"> 2.2 <code>Gradle</code> 生命周期的监听回调</h3>\n<p><code>Project</code> 类中提供了如下方法对 <code>Gradle</code> 的生命周期进行监听：</p>\n<div><pre><code>1. void beforeEvaluate(Closure closure); // 配置阶段开始前的回调\n2. void afterEvaluate(Closure closure); // 配置阶段完成后的回调\n</code></pre></div><p><code>Gradle</code> 类中提供了如下方法对 <code>Gradle</code> 的生命周期进行监听：</p>\n<div><pre><code>1. void buildFinished(Closure closure); // 执行阶段完成后的回调\n2. void beforeProject(Closure closure);\n3. void afterProject(Closure closure);\n4. void addBuildListener(BuildListener buildListener);\n5. void addListener(Object listener);\n6. ProjectEvaluationListener addProjectEvaluationListener(ProjectEvaluationListener listener);\n</code></pre></div><h4 id=\"_2-2-1-示例代码-gradlew-clean-清理任务的执行过程\" tabindex=\"-1\"> 2.2.1 示例代码：<code>gradlew clean</code> 清理任务的执行过程</h4>\n<p><img src=\"@source/zkq/gradle/images/_04_lifecycle/02.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_2-3-执行-gradlew-tasks-查看-project-中的所有-task\" tabindex=\"-1\"> 2.3 执行 &quot;<code>gradlew tasks</code>&quot; 查看 <code>Project</code> 中的所有 <code>Task</code></h3>\n",
      "date_published": "2022-10-23T14:49:16.000Z",
      "date_modified": "2022-10-28T10:30:45.000Z",
      "authors": [],
      "tags": [
        "gradle"
      ]
    },
    {
      "title": "Project详解与实战",
      "url": "https://zengkaiqiang562.github.io/zkq/gradle/_05_project.html",
      "id": "https://zengkaiqiang562.github.io/zkq/gradle/_05_project.html",
      "content_html": "<h2 id=\"_1-project-概述\" tabindex=\"-1\"> 1. <code>Project</code> 概述</h2>\n<h3 id=\"_1-1-每个-module-都是一个-project-子-project\" tabindex=\"-1\"> 1.1 每个 <code>Module</code> 都是一个 <code>Project</code>（子 <code>Project</code>）</h3>\n<p>一个通过 <code>Gradle</code> 构建的 <code>Android</code> 项目中，除了项目本身是一个 <code>Project</code>（根 <code>Project</code>）外，</p>\n<p>项目中的每个 <code>Module</code> 也是一个 <code>Project</code>（子 <code>Project</code>）。</p>\n<h3 id=\"_1-2-遍历-android-项目中的所有-project-gradlew-projects\" tabindex=\"-1\"> 1.2 遍历 <code>Android</code> 项目中的所有 <code>Project</code>：<code>gradlew projects</code></h3>\n<p>执行命令 &quot;<code>gradlew projects</code>&quot;（其中 <code>projects</code> 是一个 <code>Task</code> 的名称）可以遍历出 <code>Android</code> 项目中的所有 <code>Project</code>。</p>\n<p><img src=\"@source/zkq/gradle/images/_05_project/01.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_1-3-一个-build-gradle-文件表示一个-project\" tabindex=\"-1\"> 1.3 一个 <code>build.gradle</code> 文件表示一个 <code>Project</code></h3>\n<p>每个 <code>Project</code> 中都包含有一个 <code>build.gradle</code> 文件。</p>\n<p>如果删除了 <code>Project</code> 文件夹下的 <code>build.gradle</code> 文件，那么这个 <code>Project</code> 文件夹就是一个普通的文件夹，不会被识别为 <code>Project</code>。</p>\n<p>也就是说，一个 <code>build.gradle</code> 文件表示一个 <code>Project</code>。</p>\n<h3 id=\"_1-4-根-project-的作用-管理子-project\" tabindex=\"-1\"> 1.4 根 <code>Project</code> 的作用：管理子 <code>Project</code></h3>\n<p>根 <code>Project</code> 的作用主要是用来管理子 <code>Project</code>。</p>\n<h3 id=\"_1-5-子-project-的作用-生成构建产物\" tabindex=\"-1\"> 1.5 子 <code>Project</code> 的作用：生成构建产物</h3>\n<p>子 <code>Project</code> 的作用就是用来生成构建产物的，如：</p>\n<ol>\n<li>\n<p><code>app</code> 模块作为子 <code>Project</code> 生成 <code>apk</code> 文件；</p>\n</li>\n<li>\n<p>其他模块作为子 <code>Project</code> 生成 <code>aar</code> 库文件。</p>\n</li>\n</ol>\n<h2 id=\"_2-project-的-api-组成\" tabindex=\"-1\"> 2. <code>Project</code> 的 <code>API</code> 组成</h2>\n<p><code>Project</code> 的 <code>API</code> 可以分为六大部分。</p>\n<p><img src=\"@source/zkq/gradle/images/_05_project/02.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_2-1-gradle-生命周期-api\" tabindex=\"-1\"> 2.1 <code>Gradle</code> 生命周期 <code>API</code></h3>\n<p>参考：<a href=\"/zkq/gradle/_04_lifecycle.html#_2-2-gradle-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%9B%91%E5%90%AC%E5%9B%9E%E8%B0%83\">Gradle 生命周期的监听回调</a></p>\n<h3 id=\"_2-2-project-相关的-api\" tabindex=\"-1\"> 2.2 <code>Project</code> 相关的 <code>API</code></h3>\n<p>提供了操作父 <code>Project</code>，管理子 <code>Project</code> 的功能。</p>\n<h4 id=\"_2-2-1-build-gradle-文件中编写的代码相当于-project-类中的代码\" tabindex=\"-1\"> 2.2.1 <code>build.gradle</code> 文件中编写的代码相当于 <code>Project</code> 类中的代码</h4>\n<p>在学习 <code>Groovy</code> 时，我们在 <code>Groovy</code> 脚本文件中编写的代码经过编译后会生成字节码文件。</p>\n<p>字节码文件中 <code>Groovy</code> 脚本文件名做为一个类，继承自 <code>Script</code>。也就是说，在 <code>Groovy</code> 脚本文件中的代码其实就是在 <code>Script</code> 类中编写代码，可以访问到 <code>Script</code> 类的 <code>API</code>（如 <code>println</code> 方法就是 <code>Script</code> 类提供的）。</p>\n<p>类似的，在 <code>Gradle</code> 中，<code>build.gradle</code> 文件也会经过编译生成字节码文件，<code>build.gradle</code> 文件中的代码其实就是在 <code>Project</code> 类中编写的代码。</p>\n<p>也就是说，<strong>在 <code>build.gradle</code> 文件中可以访问到 <code>Project</code> 类的 <code>API</code></strong>。</p>\n<h4 id=\"_2-2-2-build-gradle-文件中编写的代码都是在配置阶段执行\" tabindex=\"-1\"> 2.2.2 <code>build.gradle </code>文件中编写的代码都是在配置阶段执行</h4>\n<p>所有在 <code>build.gradle</code> 文件中编写的代码，都是在配置阶段执行的。</p>\n<blockquote>\n<p>如何使代码在执行阶段执行，在讲解 <code>Task</code> 时进行讲解。</p>\n</blockquote>\n<h4 id=\"_2-2-3-project-类提供的-api\" tabindex=\"-1\"> 2.2.3 <code>Project</code> 类提供的 <code>API</code></h4>\n<h5 id=\"_2-2-3-1-获取所有-project-getallprojects\" tabindex=\"-1\"> 2.2.3.1 获取所有 <code>Project</code>：<code>getAllprojects()</code></h5>\n<div><pre><code>Set<span>&lt;</span>Project<span>></span> <span>getAllprojects</span><span>(</span><span>)</span>\n</code></pre></div><div><pre><code>遍历项目中的所有 Project（包括根 Project 和各个子 Project）\n</code></pre></div><p><img src=\"@source/zkq/gradle/images/_05_project/03.png\" alt=\"\" loading=\"lazy\"></p>\n<h5 id=\"_2-2-3-2-获取所有子-project-getsubprojects\" tabindex=\"-1\"> 2.2.3.2 获取所有子 <code>Project</code>：<code>getSubprojects()</code></h5>\n<div><pre><code>Set<span>&lt;</span>Project<span>></span> <span>getSubprojects</span><span>(</span><span>)</span>\n</code></pre></div><div><pre><code>遍历调用该方法的 build.gradle 所对应的 Project 下的所有子 Project\n</code></pre></div><p><img src=\"@source/zkq/gradle/images/_05_project/04.png\" alt=\"\" loading=\"lazy\"></p>\n<h5 id=\"_2-2-3-3-获取父-project-getparent\" tabindex=\"-1\"> 2.2.3.3 获取父 <code>Project</code>：<code>getParent()</code></h5>\n<div><pre><code>Project <span>getParent</span><span>(</span><span>)</span>\n</code></pre></div><div><pre><code>返回调用该方法的 build.gradle 所对应的 Project 的父 Project。\n如果 build.gradle 所对应的 Project 是根 Project，那么该方法返回 null。\n</code></pre></div><p><img src=\"@source/zkq/gradle/images/_05_project/05.png\" alt=\"\" loading=\"lazy\"></p>\n<h5 id=\"_2-2-3-4-获取根-project-getrootproject\" tabindex=\"-1\"> 2.2.3.4 获取根 <code>Project</code>：<code>getRootProject()</code></h5>\n<div><pre><code>Project <span>getRootProject</span><span>(</span><span>)</span>\n</code></pre></div><div><pre><code>返回项目的根 Project，不管在哪个 build.gradle 中调用，都不会返回 null。\n</code></pre></div><p><img src=\"@source/zkq/gradle/images/_05_project/06.png\" alt=\"\" loading=\"lazy\"></p>\n<h5 id=\"_2-2-3-5-获取指定-project-并对其进行配置-project-path-closure\" tabindex=\"-1\"> 2.2.3.5 获取指定 <code>Project</code> 并对其进行配置：<code>project(path, closure)</code></h5>\n<div><pre><code>Project <span>project</span><span>(</span>String path<span>,</span> Closure configureClosure<span>)</span>\n</code></pre></div><div><pre><code>1. 参数 path 用来指定一个 Project，当 path 为相对路径时，表示调用该方法的 build.gradle 所对应的 Project 目录下的相对路径。即：\n    如果在根 Project 的 build.gradle 中调用 project('app') {...}\n    那么 'app' 表示 \"./app/\"，而 \"./app/\" 文件夹表示子 Project(app)。\n\n2. 参数闭包 configureClosure 作用是用来对参数 path 指定的 Project 进行配置，需注意：\n    1. 闭包的参数传入 path 指定的 Project 对象；\n    2. 闭包的 delegate 属性指定的委托对象 也就是 path 指定的 Project 对象；\n    3. 因为该闭包的委托策略 resolveStrategy=2，即 OWNER_ONLY，\n       而闭包的 owner 属性指定的 Project 也就是 path 指定的 Project（但不是同一个对象）\n       所以，在闭包中访问的属性和方法，就是在访问 path指定的Project 的属性和方法\n\n3. 返回参数 path 指定的 Project。\n\n4. 使用该 project(path.closure) 方法，可以在根 Project 的 build.gradle 中，实现对子 Project 的配置。\n    但通常，我们不会以这种方式去处理对子 Project 的所有配置，还是应该以在子 Project 的 build.gradle 中配置为主。\n\n5. Project project(String path) throws UnknownProjectException; // 该重载方法仅用于返回参数 path 指定的 Project\n</code></pre></div><p><img src=\"@source/zkq/gradle/images/_05_project/07.png\" alt=\"\" loading=\"lazy\"></p>\n<h5 id=\"_2-2-3-6-遍历所有-project-并进行配置-allprojects-closure\" tabindex=\"-1\"> 2.2.3.6 遍历所有 <code>Project</code> 并进行配置：<code>allprojects(closure)</code></h5>\n<div><pre><code><span>void</span> <span>allprojects</span><span>(</span>Closure configureClosure<span>)</span>\n</code></pre></div><div><pre><code>1. 作用：遍历当前 build.gradle 对应的 Project 下的所有子 Project（包含当前 build.gradle 对应的 Project）。\n\n2. 参数闭包 configureClosure 接收一个 Project 类型的参数，表示当前遍历到的 Project。\n\n3. project(path, closure) 方法是对参数 path 指定的 Project 进行配置处理\n    allprojects(closure) 方法是对当前 Project 和当前 Project 下的所有子 Project 进行配置处理。\n\n4. 因为在 allprojects 方法内部每次遍历调用该实参闭包时，闭包的委托策略都是 resolveStrategy=2，即 Closure.OWNER_ONLY，\n    而每次遍历调用该实参闭包时，闭包的 owner 属性指定为当前遍历到的 Project，\n    所以每次遍历调用该实参闭包时，在闭包中访问的属性和方法就是在访问当前遍历到的 Project 中的属性和方法。\n</code></pre></div><p><img src=\"@source/zkq/gradle/images/_05_project/08.png\" alt=\"\" loading=\"lazy\"></p>\n<h5 id=\"_2-2-3-7-遍历所有子-project-并进行配置-subprojects-closure\" tabindex=\"-1\"> 2.2.3.7 遍历所有子 <code>Project</code> 并进行配置：<code>subprojects(closure)</code></h5>\n<div><pre><code><span>void</span> <span>subprojects</span><span>(</span>Closure configureClosure<span>)</span>\n</code></pre></div><div><pre><code>subprojects(closure) 和 allprojects(closure) 的唯一区别在于：\n1. allprojects 会遍历到当前 build.gradle 对应的 Project；\n2. subprojects 不会遍历到当前 build.gradle 对应的 Project。\n</code></pre></div><p><img src=\"@source/zkq/gradle/images/_05_project/09.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_2-3-task-相关的-api\" tabindex=\"-1\"> 2.3 <code>Task</code> 相关的 <code>API</code></h3>\n<p>提供了新增 <code>Task</code>，使用 <code>Project</code> 中已有 <code>Task</code> 的功能。</p>\n<h3 id=\"_2-4-属性相关的-api\" tabindex=\"-1\"> 2.4 属性相关的 <code>API</code></h3>\n<p>除了操作 <code>Gradle</code> 本身提供的属性外，还可以为 <code>Project</code> 添加新的属性。</p>\n<h4 id=\"_2-4-1-project-类默认提供的属性\" tabindex=\"-1\"> 2.4.1 <code>Project</code> 类默认提供的属性</h4>\n<h5 id=\"_2-4-1-1-default-build-file\" tabindex=\"-1\"> 2.4.1.1 <code>DEFAULT_BUILD_FILE</code></h5>\n<div><pre><code>String DEFAULT_BUILD_FILE <span>=</span> <span><span>\"build.gradle\"</span></span>\n</code></pre></div><div><pre><code>该属性指定了 Project 的构建脚本文件名默认为 build.gradle\n</code></pre></div><h5 id=\"_2-4-1-2-path-separator\" tabindex=\"-1\"> 2.4.1.2 <code>PATH_SEPARATOR</code></h5>\n<div><pre><code>String PATH_SEPARATOR <span>=</span> <span><span>\":\"</span></span>\n</code></pre></div><div><pre><code>该属性指定了 Project 路径名和 Task 路径名的层级分隔符为冒号 \":\"\n相当于普通文件系统中的路径分隔符 \"/\"\n</code></pre></div><h5 id=\"_2-4-1-3-default-build-dir-name\" tabindex=\"-1\"> 2.4.1.3 <code>DEFAULT_BUILD_DIR_NAME</code></h5>\n<div><pre><code>String DEFAULT_BUILD_DIR_NAME <span>=</span> <span><span>\"build\"</span></span>\n</code></pre></div><div><pre><code>该属性指定了对 Project 进行构建后输出目录为 build 目录。\n即：对根 Project 和各个子 Project 进行构建后，都会在每个 Project 文件夹下生成一个 build 目录。\n</code></pre></div><h5 id=\"_2-4-1-4-gradle-properties\" tabindex=\"-1\"> 2.4.1.4 <code>GRADLE_PROPERTIES</code></h5>\n<div><pre><code>String GRADLE_PROPERTIES <span>=</span> <span><span>\"gradle.properties\"</span></span>\n</code></pre></div><div><pre><code>该属性指定了用于对 Gradle 的属性进行配置的默认文件为 gradle.properties\n</code></pre></div><h4 id=\"_2-4-2-分析-ext-扩展属性的内部实现\" tabindex=\"-1\"> 2.4.2 分析 <code>ext</code> 扩展属性的内部实现</h4>\n<p><code>build.gradle</code> 文件对应的 <code>Project</code> 对象的类是 <code>DefaultProject</code> 子类：</p>\n<div><pre><code>1. 是通过 org.gradle.testfixtures.internal.ProjectBuilderImpl 类提供的 createProject 和 createChildProject 方法动态创建出来的；\n2. 是 org.gradle.api.internal.project.DefaultProject 的子类。\n\n参考：\n1. org.gradle.testfixtures.internal.ProjectBuilderImpl\n2. org.gradle.api.internal.AsmBackedClassGenerator\n   动态创建的 DefaultProject 子类就是在 AsmBackedClassGenerator 的静态内部类 ClassBuilderImpl 中完成的。\n</code></pre></div><p>动态创建 <code>DefaultProject</code> 子类时会动态定义 <code>invokeMethod</code> 方法：</p>\n<div><pre><code>1. invokeMethod 方法内部则是调用了 DefaultProject 的 getAsDynamicObject().invokeMethod 方法，即:\n\n    public Object invokeMethod(String name, Object params) { \n        return getAsDynamicObject().invokeMethod(name, (Object[])params); \n    }\n\n    参考：org.gradle.api.internal.AsmBackedClassGenerator.ClassBuilderImpl#addDynamicMethods\n\n2. getAsDynamicObject() 方法返回的是一个 org.gradle.api.internal.ExtensibleDynamicObject 类对象\n\n    ExtensibleDynamicObject 的继承结构图如下：\n        DynamicObject\n        --AbstractDynamicObject\n        ----CompositeDynamicObject\n        ------MixInClosurePropertiesAsMethodsDynamicObject\n        --------ExtensibleDynamicObject    \n</code></pre></div><p>也就是说，调用 <code>Project</code> 类的 <code>invokeMethod</code> 方法，其实就是在调用 <code>ExtensibleDynamicObject</code> 类的 <code>invokeMethod</code> 方法：</p>\n<div><pre><code>ExtensibleDynamicObject 类提供的 invokeMethod 方法在父类 AbstractDynamicObject 中定义：\n\n    @Override\n    public Object invokeMethod(String name, Object... arguments) throws groovy.lang.MissingMethodException {\n        DynamicInvokeResult result = tryInvokeMethod(name, arguments);\n        if (result.isFound()) {\n            return result.getValue();\n        }\n        throw methodMissingException(name, arguments);\n    }\n</code></pre></div><p>也就是说，调用 <code>ExtensibleDynamicObject</code> 类的 <code>invokeMethod</code> 方法，其实就是在调用 <code>tryInvokeMethod</code> 方法，其中：</p>\n<div><pre><code>1. tryInvokeMethod 方法在 CompositeDynamicObject 和 MixInClosurePropertiesAsMethodsDynamicObject 中都进行了重写；\n2. 在 CompositeDynamicObject 类重写的 tryInvokeMethod 方法中，会遍历 DynamicObject[] 数组，\n   并调用每个 DynamicObject 类的 tryInvokeMethod 方法：\n\n    @Override\n    public DynamicInvokeResult tryInvokeMethod(String name, Object... arguments) {\n        for (DynamicObject object : objects) {\n            DynamicInvokeResult result = object.tryInvokeMethod(name, arguments);\n            if (result.isFound()) {\n                return result;\n            }\n        }\n        return DynamicInvokeResult.notFound();\n    }\n</code></pre></div><p>也就是说，调用 <code>ExtensibleDynamicObject</code> 的 <code>tryInvokeMethod</code> 方法，其实就是在调用 <code>DynamicObject</code> 的 <code>tryInvokeMethod</code> 方法。</p>\n<div><pre><code>其中，DynamicObject[] 数组 objects 会在 ExtensibleDynamicObject 类的构造方法中通过调用 updateDelegates() 方法进行设置。\n\n在 ExtensibleDynamicObject.updateDelegates() 方法中，\n会把 convention.getExtensionsAsDynamicObject() 返回的 DynamicObject 子类对象放到 objects 中。\n\n在 ExtensibleDynamicObject 的构造方法中，成员属性 convention = new DefaultConvention(instantiator)，\n也就是说，convention.getExtensionsAsDynamicObject() 返回的 DynamicObject 对象要在 DefaultConvention 类中找。\n\n在 DefaultConvention 类中，有如下代码：\n\n    public class DefaultConvention implements Convention, ExtensionContainerInternal {\n        ...\n        DefaultConvention.ExtensionsDynamicObject extensionsDynamicObject = new ExtensionsDynamicObject();\n        ...\n        @Override\n        public DynamicObject getExtensionsAsDynamicObject() {\n           return extensionsDynamicObject;\n        }\n        ...\n        private class ExtensionsDynamicObject extends AbstractDynamicObject {\n            ...\n            @Override\n            public DynamicInvokeResult tryInvokeMethod(String name, Object... args) {\n                if (isConfigureExtensionMethod(name, args)) {\n                    return DynamicInvokeResult.found(configureExtension(name, args));\n                }\n                ...\n            }\n        }\n    } \n\n也就是说：\n1. DefaultConvention.getExtensionsAsDynamicObject() 返回\n   DynamicObject 的子类 DefaultConvention.ExtensionsDynamicObject 创建的对象；\n2. DefaultConvention.ExtensionsDynamicObject 中重写了 tryInvokeMethod 方法。\n</code></pre></div><p>也就是说，调用 <code>DynamicObject</code> 的 <code>tryInvokeMethod</code> 方法，其实就是在调用 <code>DefaultConvention.ExtensionsDynamicObject</code> 的 <code>tryInvokeMethod</code> 方法。</p>\n<div><pre><code>在 DefaultConvention.ExtensionsDynamicObject.tryInvokeMethod 方法中，isConfigureExtensionMethod(name, args) 用于判断：\n1. 名为 name 的方法的参数列表 args 是否只有一个 Closure 类型的闭包参数；\n2. 名为 name 的方法是否已经注册到 DefaultConvention 的成员属性 extensionsStorage 中。\n\n在 DefaultConvention 中有如下代码：\n\n    public class DefaultConvention implements Convention, ExtensionContainerInternal {\n        ...\n        TypeOf&lt;ExtraPropertiesExtension> EXTRA_PROPERTIES_EXTENSION_TYPE = typeOf(ExtraPropertiesExtension.class);\n        ExtensionsStorage extensionsStorage = new ExtensionsStorage();\n        ExtraPropertiesExtension extraProperties = new DefaultExtraPropertiesExtension();\n\n        public DefaultConvention(Instantiator instantiator) {\n            this.instantiator = instantiator;\n            //其中，ExtraPropertiesExtension.EXTENSION_NAME = \"ext\"\n            //即：add(EXTRA_PROPERTIES_EXTENSION_TYPE, \"ext\", extraProperties)\n            add(EXTRA_PROPERTIES_EXTENSION_TYPE, ExtraPropertiesExtension.EXTENSION_NAME, extraProperties);\n        }\n\n        @Override\n        public &lt;T> void add(TypeOf&lt;T> publicType, String name, T extension) {\n            extensionsStorage.add(publicType, name, extension);\n        }\n    }\n\n也就是说，在 DefaultConvention 的构造方法中，就已经把方法 \"ext\" 注册到 DefaultConvention 的成员属性 extensionsStorage 中了。\n\n注意：\n在注册时，为方法 \"ext\" 绑定了一个 DefaultExtraPropertiesExtension 对象 extraProperties，\n这个 extraProperties 对象，就是调用 ext(closure) 方法时，传给闭包 closure 的唯一参数。\n</code></pre></div><p>在 <code>DefaultConvention.ExtensionsDynamicObject.tryInvokeMethod</code> 方法中调用的 <code>configureExtension(name, args)</code> 方法在 <code>DefaultConvention</code> 中的定义如下：</p>\n<div><pre><code><span>private</span> Object <span>configureExtension</span><span>(</span>String name<span>,</span> Object<span>[</span><span>]</span> args<span>)</span> <span>{</span>\n    Closure closure <span>=</span> <span>(</span>Closure<span>)</span> args<span>[</span><span>0</span><span>]</span><span>;</span>\n    Action<span>&lt;</span>Object<span>></span> action <span>=</span> ConfigureUtil<span>.</span><span>configureUsing</span><span>(</span>closure<span>)</span><span>;</span>\n    <span>return</span> extensionsStorage<span>.</span><span>configureExtension</span><span>(</span>name<span>,</span> action<span>)</span><span>;</span>\n<span>}</span>\n</code></pre></div><div><pre><code>其中：\n1. ConfigureUtil.configureUsing 方法的作用就是将闭包 closure 封装在 Action 中；\n2. ExtensionsStorage.configureExtension(name, action) 方法的作用就是：\n    1. 执行 action.execute 方法（最终会调用闭包 closure）；\n    2. 将注册方法 \"ext\" 时绑定的 extraProperties 对象作为 ext(closure) 方法中闭包 closure 的唯一参数；\n    3. 创建 ConfigureDelegate 类型的委托对象作为闭包的 owner，并设置闭包的委托策略为 Closure.OWNER_ONLY。\n\n注意：\nConfigureDelegate 委托对象其实也是一个代理，其内部封装了 _owner 和 _delegate 两个属性，\n对于在 build.gradle 中调用的 ext(closure) 方法：\n1. _owner = DynamicObjectUtil.asDynamicObject(closure.getOwner());\n   因为 ext(closure) 在 build.gradle 中调用，所以 closure.getOwner() 返回 Project 对象，\n   又因为 DefaultProject 实现了 DynamicObjectAware 接口，\n   所以 DynamicObjectUtil.asDynamicObject(closure.getOwner()) 返回的是 DefaultProject.getAsDynamicObject()，\n   也就是说，_owner 就是依赖了 DefaultConvention的ExtensibleDynamicObject 对象；\n\n2. _delegate = DynamicObjectUtil.asDynamicObject(extraProperties);\n   查看源码可知，_delegate 是一个封装了 extraProperties 的 BeanDynamicObject 对象。\n\nConfigureDelegate 内部的委托流程就是：\n先使用 _delegate 处理闭包 closure 中的属性和方法，_delegate 处理不了的，再使用 _owner 处理。\n\n也就是说，ext(closure) 方法调用时，闭包 closure 中可以直接访问 BeanDynamicObject 和 ExtensibleDynamicObject 中的属性和方法。\n</code></pre></div><p><strong>综上得出如下结论：</strong></p>\n<div><pre><code>在 build.gradle 中编写 ext{...} ，就是调用动态生成的 Project 子类中的 invokeMethod 方法来执行未定义的 ext(closure) 方法，其中：\n1. 闭包 closure 接收 DefaultExtraPropertiesExtension 类型的对象作为唯一参数；\n2. 闭包 closure 中可以直接访问 BeanDynamicObject 和 ExtensibleDynamicObject 中的属性和方法。\n</code></pre></div><p><strong>注意：</strong></p>\n<div><pre><code>1. 注册到 DefaultConvention.extensionsStorage 中的标识符 \"ext\" 即是一个方法，也是一个属性：\n    1. 当在 build.gradle 中编写 ext{...} 时，最终调用到 DefaultConvention.ExtensionsDynamicObject.tryInvokeMethod 方法，\n       此时 ext 是一个方法，闭包作为方法参数。\n    2. 当在 build.gradle 中编写 this.ext.extAttrName 时，最终调用到 DefaultConvention.ExtensionsDynamicObject.tryGetProperty，\n       此时 ext 是一个属性，指定注册 \"ext\" 时绑定的 extraProperties 对象。\n\n    也就是说，在 ext{...} 中扩展的属性，可以在 ext{...} 之外通过 this.ext 访问到。\n    当然，为 Project 扩展的属性也可以在 build.gradle 中直接访问到。\n\n2. 另外还需要注意，通过 ext{...} 为 Project 扩展的属性是可以被子 Project 继承的。\n</code></pre></div><h4 id=\"_2-4-3-为-project-扩展新的属性\" tabindex=\"-1\"> 2.4.3 为 <code>Project</code> 扩展新的属性</h4>\n<p>在 <code>build.gradle</code> 中可以调用 <code>ext(closure)</code> 方法为 <code>Project</code> 扩展属性。语法如下：</p>\n<div><pre><code>ext <span>{</span>\n    extAttrName1 <span>=</span> extAttrValue1\n    extAttrName2 <span>=</span> extAttrValue2\n    <span>...</span>\n    extAttrName3 <span>=</span> extAttrValue3\n<span>}</span>\n</code></pre></div><p>在当前 <code>Project</code> 中可以通过如下方式访问到扩展属性：</p>\n<div><pre><code><span>// 方式 1</span>\n<span>this</span><span>.</span>ext<span>.</span>extAttrName\n\n<span>// 方式 2</span>\n<span>this</span><span>.</span>extAttrName\n</code></pre></div><p>在子 <code>Project</code> 中可以通过如下方式访问到父 <code>Project</code> 的扩展属性：</p>\n<div><pre><code><span>this</span><span>.</span>extAttrName <span>// this 表示子 Project</span>\n</code></pre></div><p><strong>注意：</strong></p>\n<div><pre><code>1. 根 Project 中扩展的属性会被子 Project 继承，是作为子 Project 的属性，但不会作为子 Project 的扩展属性；\n\n2. 为了避免当 Project 中存在于扩展属性同名的属性时所产生的冲突，建议使用扩展属性时按照定义时的 \"路径\" 来访问，\n   如，在根 Project 中定义的扩展属性，在子 Project 中建议这样访问：rootProject.ext.extAttrName\n\n3. 因为 Project 类提供了 getRootProject, 即提供了 rootProject 的 getter 方法，\n   所以执行 this.rootProject 就相当于调用 this.getRootProject() 方法。\n</code></pre></div><p><strong>示例代码：</strong></p>\n<p><img src=\"@source/zkq/gradle/images/_05_project/10.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_2-4-4-扩展属性的实际案例-引入外部文件-ext-gradle-中的扩展属性\" tabindex=\"-1\"> 2.4.4 扩展属性的实际案例：引入外部文件 ext.gradle 中的扩展属性</h4>\n<p><strong>案例步骤：</strong></p>\n<div><pre><code>step1. 在单独的外部文件 ext.gradle 中定义扩展属性；\n\nstep2. 在根 Project 的 build.gradle 中，通过 Project.apply(Map&lt;String, ?> options) 方法导入外部文件 ext.gradle；\n\n    注意：\n    \"from\" 类型的导入方式，相当于 C/C++ 中的 #include，\n    也就是说，导入 ext.gradle 后，其中的 ext{...} 就相当于在根 Project 的 build.gradle 中定义了。\n\nstep3. 在子 Project 中，为了避免同名冲突，建议通过 rootProject.ext.extAttrName 的方式来访问根 Project 中定义的扩展属性。\n</code></pre></div><p><strong>示例代码：</strong></p>\n<p><img src=\"@source/zkq/gradle/images/_05_project/11.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_2-4-5-在-gradle-properties-文件中定义扩展属性\" tabindex=\"-1\"> 2.4.5 在 <code>gradle.properties</code> 文件中定义扩展属性</h4>\n<p>在根 <code>Project</code> 下的 <code>gradle.properties</code> 文件只能定义简单的键值对属性。</p>\n<p>并且在 <code>gradle.properties</code> 中定义的属性名建议不要跟 <code>build.gradle</code> 中的属性名同名，否则可能报错。</p>\n<p>在 <code>gradle.properties</code> 中定义的键值对扩展属性，使用时属性值默认都是 <code>String</code> 类型，需要调用 <code>toXXX()</code> 转换一下。</p>\n<p><strong>示例代码：</strong></p>\n<p><img src=\"@source/zkq/gradle/images/_05_project/12.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_2-4-6-分析-setting-gradle-文件的内部实现\" tabindex=\"-1\"> 2.4.6 分析 <code>setting.gradle</code> 文件的内部实现</h4>\n<p>如上代码所示：</p>\n<div><pre><code>1. settings.gradle 编译生成的字节码文件，是一个 SettingsScript 的子类文件；\n\n2. SettingsScript 类是一个脚本类，其中的 getScriptTarget() 返回一个目标对象 target，\n   这个目标对象 target 为 settings.gradle 文件中提供了可以使用的 API；\n\n3. 为 settings.gradle 文件中提供可以使用的 API 的目标对象 target 就是一个动态创建的 DefaultSettings 的子类。\n   也就是说，setting.gradle 文件中可以使用 DefaultSettings 提供的API；\n\n4. 查看源码，大概判断是使用 AsmBackedClassGenerator 来动态创建 DefaultSettings 的子类的。\n   这与动态创建 DefaultProject 的子类所使用的生成器一样。在 AsmBackedClassGenerator 中，\n   可以看到创建 DefaultSettings 子类时所动态生成的一些 API，这些动态生成的 API 也可以在该 settings.gradle 中使用。\n\n参考：\norg.gradle.initialization.SettingsScript\norg.gradle.initialization.DefaultSettings // implements Settings\norg.gradle.api.initialization.Settings\norg.gradle.initialization.SettingsFactory\norg.gradle.internal.service.scopes.BuildScopeServices\norg.gradle.api.internal.ClassGeneratorBackedInstantiator\norg.gradle.api.internal.AsmBackedClassGenerator\n</code></pre></div><h3 id=\"_2-5-文件-file-相关的-api\" tabindex=\"-1\"> 2.5 文件（<code>file</code>）相关的 <code>API</code></h3>\n<p>主要是用来处理 <code>Project</code> 下的一些文件。</p>\n<h4 id=\"_2-5-1-project-类提供的获取路径相关的-api\" tabindex=\"-1\"> 2.5.1 <code>Project</code> 类提供的获取路径相关的 <code>API</code></h4>\n<h5 id=\"_2-5-1-1-获取表示根-project-文件夹-getrootdir\" tabindex=\"-1\"> 2.5.1.1 获取表示根 <code>Project</code> 文件夹：<code>getRootDir()</code></h5>\n<div><pre><code>File <span>getRootDir</span><span>(</span><span>)</span>\n</code></pre></div><div><pre><code>返回表示根 Project 文件夹的 File 对象。\n</code></pre></div><h5 id=\"_2-5-1-2-获取表示当前-project-的-build-文件夹-getbuilddir\" tabindex=\"-1\"> 2.5.1.2 获取表示当前 <code>Project</code> 的 <code>build</code> 文件夹：<code>getBuildDir()</code></h5>\n<div><pre><code>File <span>getBuildDir</span><span>(</span><span>)</span>\n</code></pre></div><div><pre><code>返回表示当前 build.gradle 所对应的 Project 的 build 文件夹的 File 对象。\n</code></pre></div><h5 id=\"_2-5-1-3-获取表示当前-project-的文件夹-getprojectdir\" tabindex=\"-1\"> 2.5.1.3 获取表示当前 <code>Project</code> 的文件夹：<code>getProjectDir()</code></h5>\n<div><pre><code>File <span>getProjectDir</span><span>(</span><span>)</span>\n</code></pre></div><div><pre><code>返回表示当前 build.gradle 所对应的 Project 文件夹的 File 对象。\n</code></pre></div><h5 id=\"_2-5-1-3-示例代码\" tabindex=\"-1\"> 2.5.1.3 示例代码</h5>\n<p><img src=\"@source/zkq/gradle/images/_05_project/13.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_2-5-2-project-类提供的文件操作相关的-api\" tabindex=\"-1\"> 2.5.2 <code>Project</code> 类提供的文件操作相关的 <code>API</code></h4>\n<h5 id=\"_2-5-2-1-获取相对于当前-project-的某个-path-路径-file-path\" tabindex=\"-1\"> 2.5.2.1 获取相对于当前 <code>Project</code> 的某个 <code>path</code> 路径：<code>file(path)</code></h5>\n<div><pre><code>File <span>file</span><span>(</span>Object path<span>)</span>\n</code></pre></div><div><pre><code>返回相对于当前 Project 的 path 路径所表示的 File 对象。\n</code></pre></div><h5 id=\"_2-5-2-2-获取相对于当前-project-的某些-path-路径-files-paths\" tabindex=\"-1\"> 2.5.2.2 获取相对于当前 <code>Project</code> 的某些 <code>path</code> 路径：<code>files(paths)</code></h5>\n<div><pre><code>ConfigurableFileCollection <span>files</span><span>(</span>Object<span>...</span> paths<span>)</span>\n</code></pre></div><div><pre><code>1. 返回 paths 数组指定的多个 File 对象的集合；\n2. ConfigurableFileCollection 继承自 FileCollection；\n3. 可以通过 FileCollection.getFiles() 可以返回 File 对象构成的 Set 集合。\n</code></pre></div><h5 id=\"_2-5-2-3-示例代码\" tabindex=\"-1\"> 2.5.2.3 示例代码</h5>\n<p><img src=\"@source/zkq/gradle/images/_05_project/14.png\" alt=\"\" loading=\"lazy\"></p>\n<h5 id=\"_2-5-2-4-文件拷贝-copy-closure\" tabindex=\"-1\"> 2.5.2.4 文件拷贝：<code>copy(closure)</code></h5>\n<div><pre><code>WorkResult <span>copy</span><span>(</span>Closure closure<span>)</span>\n</code></pre></div><div><pre><code>作用：\n1. 在实参闭包 closure 中，通过调用 CopySpec 提供的 API 完成文件的拷贝操作。\n\n注意：\n1. 调用 copy(closure) 方法时，实参闭包传入的参数是 CopySpec 的子类对象\n2. 实参闭包的委托策略机制是 OWNER_ONLY\n3. 实参闭包的 owner 是 ConfigureDelegate 类对象\n4. ConfigureDelegate 中的 _delegate 是封装了 CopySpec 的 BeanDynamicObject 对象。\n    由此可知，实参闭包中可以访问到 CopySpec 提供的 API\n5. 在 copy 方法的实参闭包中，可以调用 CopySpec 提供的如下API进行文件拷贝：\n    1. CopySpec from(Object... sourcePaths); \n        指定拷贝的源文件。\n        参数可以是源文件的路径字符串，也可以是源文件的 File 对象，\n        源文件以路径字符串表示时，可以是绝对路径，也可以是相对于当前 Project 的路径。\n    2. CopySpec into(Object destPath); \n        指定拷贝输出的目标文件夹。\n        参数可以是目标文件的路径字符串，也可以是目标文件夹的 File 对象，\n        目标文件以路径字符串表示时，可以是绝对路径，也可以是相对于当前 Project 的路径。\n    3. CopySpec exclude(Closure excludeSpec); \n        排除不想拷贝的文件。\n    4. CopySpec rename(Closure closure); \n        对拷贝后的文件进行重命名。\n        闭包传入拷贝的文件名，闭包的返回值就是重命名的文件名。\n6. 在调用方法时，如果只有一个参数，那么可以省略括号 \"()\"\n</code></pre></div><h5 id=\"_2-5-2-5-示例代码\" tabindex=\"-1\"> 2.5.2.5 示例代码</h5>\n<p><img src=\"@source/zkq/gradle/images/_05_project/15.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_2-5-3-project-类提供的文件树的操作\" tabindex=\"-1\"> 2.5.3 <code>Project</code> 类提供的文件树的操作</h4>\n<h5 id=\"_2-5-3-1-什么是文件树\" tabindex=\"-1\"> 2.5.3.1 什么是文件树</h5>\n<p><code>Gradle</code> 中，可以将根 <code>Project</code> 文件夹下的所有文件（包括根 <code>Project</code> 文件夹）看成是一棵文件树（相当于树结构）。</p>\n<p>其中根 <code>Project</code> 文件夹作为根节点。并且，根 <code>Project</code> 文件夹下的每个文件夹也都可以作为一棵文件树。</p>\n<p><code>Gradle</code> 中用 <code>ConfigurableFileTree</code> 表示一棵文件树。</p>\n<h5 id=\"_2-5-3-2-文件树-configurablefiletree-提供的常用-api\" tabindex=\"-1\"> 2.5.3.2 文件树 <code>ConfigurableFileTree</code> 提供的常用 <code>API</code></h5>\n<h6 id=\"_2-5-3-2-1-设置文件树的根节点-setdir-dir\" tabindex=\"-1\"> 2.5.3.2.1 设置文件树的根节点：<code>setDir(dir)</code></h6>\n<div><pre><code>ConfigurableFileTree <span>setDir</span><span>(</span>Object dir<span>)</span>\n</code></pre></div><div><pre><code>设置作为文件树的根节点的文件夹路径。可以是相对于当前 Project 的相对路径。\n</code></pre></div><h6 id=\"_2-5-3-2-2-设置文件树中需要排除的文件-setexcludes-excludes\" tabindex=\"-1\"> 2.5.3.2.2 设置文件树中需要排除的文件：<code>setExcludes(excludes)</code></h6>\n<div><pre><code>PatternFilterable <span>setExcludes</span><span>(</span>Iterable<span>&lt;</span>String<span>></span> excludes<span>)</span>\n</code></pre></div><div><pre><code>设置文件树中需要排除的文件，参数表示排除文件的集合。\n</code></pre></div><h6 id=\"_2-5-3-2-3-设置文件树中需要导入的文件-setincludes-includes\" tabindex=\"-1\"> 2.5.3.2.3 设置文件树中需要导入的文件：<code>setIncludes(includes)</code></h6>\n<div><pre><code>PatternFilterable <span>setIncludes</span><span>(</span>Iterable<span>&lt;</span>String<span>></span> includes<span>)</span>\n</code></pre></div><div><pre><code>设置文件树中需要导入的文件，参数表示导入文件的集合。\n</code></pre></div><h6 id=\"_2-5-3-2-4-遍历文件树-visit-closure\" tabindex=\"-1\"> 2.5.3.2.4 遍历文件树：<code>visit(closure)</code></h6>\n<div><pre><code>FileTree <span>visit</span><span>(</span>Closure visitor<span>)</span>\n</code></pre></div><div><pre><code>遍历文件树。\n实参闭包传入封装了当前遍历到的文件对象的 FileTreeElement 子类对象，\nFileTreeElement 提供了 getFile() 方法来获取当前遍历到的 File 对象。\n</code></pre></div><h5 id=\"_2-5-3-3-构建文件树-filetree\" tabindex=\"-1\"> 2.5.3.3 构建文件树：<code>fileTree</code></h5>\n<p><code>Project</code> 类提供如下方法构建一棵文件树：</p>\n<p><strong>方法一</strong></p>\n<div><pre><code>ConfigurableFileTree <span>fileTree</span><span>(</span>Object baseDir<span>,</span> Closure configureClosure<span>)</span>\n</code></pre></div><div><pre><code>baseDir: 设置作为文件树的根节点的文件夹路径，可以是相对于当前 Project 的相对路径；\nconfigureClosure: 对文件树进行配置，闭包中可以访问 ConfigurableFileTree 提供的 API。\n</code></pre></div><p><strong>方法二</strong></p>\n<div><pre><code>ConfigurableFileTree <span>fileTree</span><span>(</span>Map<span>&lt;</span>String<span>,</span> <span>?</span><span>></span> args<span>)</span>\n</code></pre></div><div><pre><code>args: 用于配置文件树的键值对属性 Map，其中 ConfigurableFileTree 提供的 setXxx 方法的参数作为属性值，xxx 作为属性名。\n</code></pre></div><h5 id=\"_2-5-3-4-示例代码\" tabindex=\"-1\"> 2.5.3.4 示例代码</h5>\n<p><img src=\"@source/zkq/gradle/images/_05_project/16.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_2-6-依赖相关的-api\" tabindex=\"-1\"> 2.6 依赖相关的 <code>API</code></h3>\n<p>项目中的依赖配置主要可分为 3 大类：</p>\n<ol>\n<li>\n<p>配置依赖仓库；</p>\n</li>\n<li>\n<p>配置 <code>Gradle</code> 构建工程时依赖的 <code>Gradle</code> 插件；</p>\n</li>\n<li>\n<p>配置应用程序编译时依赖的第三方库。</p>\n</li>\n</ol>\n<h4 id=\"_2-6-1-配置依赖仓库\" tabindex=\"-1\"> 2.6.1 配置依赖仓库</h4>\n<p>仓库就是用来存放 <code>Gradle</code> 插件和第三方库的。所以，不仅要为 <code>Gradle</code> 插件配置依赖仓库；还要为第三方库配置依赖仓库。</p>\n<h5 id=\"_2-6-1-1-配置-gradle-插件的依赖仓库\" tabindex=\"-1\"> 2.6.1.1 配置 <code>Gradle</code> 插件的依赖仓库</h5>\n<p><strong>Step 1.</strong></p>\n<div><pre><code>调用 Project.buildscript(closure)\n</code></pre></div><blockquote>\n<p>注意：一般会在根 <code>Project</code> 的 <code>build.gradle</code> 中调用该方法。</p>\n</blockquote>\n<p><strong>Step 2.</strong></p>\n<div><pre><code>在 Project.buildscript(closure) 的实参闭包中，调用 ScriptHandler.repositories(closure)\n</code></pre></div><p><strong>Step 3.</strong></p>\n<div><pre><code>在 ScriptHandler.repositories(closure) 的实参闭包中，调用 RepositoryHandler 提供的 API 配置 Gradle 插件的依赖仓库\n</code></pre></div><h5 id=\"_2-6-1-2-配置第三方库的依赖仓库\" tabindex=\"-1\"> 2.6.1.2 配置第三方库的依赖仓库</h5>\n<p><strong>Step 1.</strong></p>\n<div><pre><code>调用 Project.buildscript(closure)\n</code></pre></div><blockquote>\n<p>注意：一般会在根 <code>Project</code> 中调用 <code>allprojects(closure)</code>，遍历每个 <code>Project</code>，并调用该方法。</p>\n</blockquote>\n<p><strong>Step 2.</strong></p>\n<div><pre><code>在 Project.repositories(closure) 的实参闭包中，调用 RepositoryHandler 提供的 API 配置第三方库的依赖仓库\n</code></pre></div><h5 id=\"_2-6-1-3-repositoryhandler-类提供的配置依赖仓库的-api\" tabindex=\"-1\"> 2.6.1.3 <code>RepositoryHandler</code> 类提供的配置依赖仓库的 <code>API</code></h5>\n<h6 id=\"_2-6-1-3-1-配置本地仓库-flatdir-closure\" tabindex=\"-1\"> 2.6.1.3.1 配置本地仓库：<code>flatDir(closure)</code></h6>\n<div><pre><code>FlatDirectoryArtifactRepository <span>flatDir</span><span>(</span>Closure configureClosure<span>)</span>\n</code></pre></div><div><pre><code>参数闭包 configureClosure 中可以使用 FlatDirectoryArtifactRepository 提供的 API \n</code></pre></div><p><strong>示例代码：</strong></p>\n<div><pre><code>flatDir <span>{</span>\n    dirs <span>'libs'</span>  <span>// 将当前 Project 下的 libs 文件夹作为本地仓库</span>\n<span>}</span>\n</code></pre></div><h6 id=\"_2-6-1-3-2-配置-maven-仓库-maven-closure\" tabindex=\"-1\"> 2.6.1.3.2 配置 <code>maven</code> 仓库：<code>maven(closure)</code></h6>\n<div><pre><code>MavenArtifactRepository <span>maven</span><span>(</span>Closure closure<span>)</span>\n</code></pre></div><div><pre><code>参数闭包 closure 中可以使用 MavenArtifactRepository 及其父类提供的 API：\n\n1. 设置 maven 仓库的 url 地址：\n    void setUrl(Object url) // MavenArtifactRepository 类提供\n\n2. 为当前配置的 maven 仓库起别名：\n    void setName(String name) // ArtifactRepository 类提供\n\n3. 设置私有 maven 仓库的认证信息：\n    void credentials(Action&lt;? super PasswordCredentials> action) // AuthenticationSupported 类提供\n\n    调用 credentials(closure) 就相当于调用 credentials(action)\n    闭包 closure 中可以使用 PasswordCredentials 提供的 API\n    闭包 closure 中主要调用 setUsername 和 setPassword 方法设置私有 maven 仓库的认证信息（即用户名和密码）\n</code></pre></div><p><strong>示例代码：</strong></p>\n<div><pre><code>maven <span>{</span>\n    url <span>'http://mvn.cloud.alipay.com/nexus/content/repositories/releases/'</span>\n    name <span>'alipay'</span> <span>// 为此 maven 仓库起别名，可省略</span>\n    credentials <span>{</span> <span>// 如果该 maven 仓库需要登录才能访问，需要配置用户名和密码</span>\n        username <span>'mvn_read_ws'</span>\n        password <span>'mrk8929'</span>\n    <span>}</span>\n<span>}</span>\n</code></pre></div><h6 id=\"_2-6-1-3-3-配置-mavencentral-仓库-mavencentral\" tabindex=\"-1\"> 2.6.1.3.3 配置 <code>mavenCentral </code> 仓库：<code>mavenCentral()</code></h6>\n<div><pre><code>MavenArtifactRepository <span>mavenCentral</span><span>(</span><span>)</span>\n</code></pre></div><p>相当于：</p>\n<div><pre><code>maven <span>{</span>\n    url <span>'https://repo.maven.apache.org/maven2/'</span>\n    name <span>'MavenRepo'</span>\n<span>}</span>\n</code></pre></div><h6 id=\"_2-6-1-3-4-配置本地maven仓库-mavenlocal\" tabindex=\"-1\"> 2.6.1.3.4 配置本地maven仓库 ：<code>mavenLocal()</code></h6>\n<div><pre><code>MavenArtifactRepository <span>mavenLocal</span><span>(</span><span>)</span>\n</code></pre></div><h6 id=\"_2-6-1-3-5-配置-jcenter仓库-jcenter\" tabindex=\"-1\"> 2.6.1.3.5 配置 jcenter仓库：<code>jcenter()</code></h6>\n<div><pre><code>MavenArtifactRepository <span>jcenter</span><span>(</span><span>)</span>\n</code></pre></div><h5 id=\"_2-6-1-4-示例代码\" tabindex=\"-1\"> 2.6.1.4 示例代码</h5>\n<p><img src=\"@source/zkq/gradle/images/_05_project/17.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_2-6-2-配置依赖的-gradle-插件\" tabindex=\"-1\"> 2.6.2 配置依赖的 <code>Gradle</code> 插件</h4>\n<p><code>Gradle</code> 本身可以理解为一个编程框架，在使用 <code>Gradle</code> 编写脚本代码时也可以使用一些第三方库，而 <code>Gradle</code> 插件可以理解为编写 Gradle 脚本代码时所需要依赖的第三方库。</p>\n<p>配置 <code>Gradle</code> 插件的步骤：</p>\n<p><strong>Step 1.</strong></p>\n<div><pre><code>调用 Project.buildscript(closure)\n</code></pre></div><div><pre><code>注意：一般会在根 Project 的 build.gradle 中调用该方法。\n</code></pre></div><p><strong>Step 2.</strong></p>\n<div><pre><code>在 Project.buildscript(closure) 的实参闭包中，调用 ScriptHandler.dependencies(closure)\n</code></pre></div><p><strong>Step 3.</strong></p>\n<div><pre><code>在 ScriptHandler.dependencies(closure) 的实参闭包中，调用 DependencyHandler 提供的 API 配置 Gradle 插件\n</code></pre></div><p><code>ScriptHandler.dependencies(closure)</code> 中的依赖配置举例：</p>\n<div><pre><code>classpath <span>'com.android.tools.build:gradle:3.4.2'</span>\n</code></pre></div><div><pre><code>其中：\n1. classpath 作为 configurationName；'com.android.tools.build:gradle:3.4.2' 作为 dependencyNotation\n\n2. 'com.android.tools.build:gradle:3.4.2' 表示的 Android Gradle 插件中，\n    集成了插件 'com.android.application' 和插件 'com.android.library'。\n</code></pre></div><h4 id=\"_2-6-3-配置依赖的第三方库\" tabindex=\"-1\"> 2.6.3 配置依赖的第三方库</h4>\n<p><strong>Step 1.</strong></p>\n<div><pre><code>调用 Project.dependencies(closure)\n</code></pre></div><div><pre><code>注意：一般会在每个子 Project 的 build.gradle 中分别调用该方法，为每个子 Project 单独配置依赖的第三方库。\n</code></pre></div><p><strong>Step 2.</strong></p>\n<div><pre><code>在 Project.dependencies(closure) 的实参闭包中，调用 DependencyHandler 提供的 API 配置第三方库\n</code></pre></div><p><strong><code>Project.dependencies(closure)</code> 中的依赖配置举例如下：</strong></p>\n<h5 id=\"_2-6-3-1-导入依赖仓库中的第三方库\" tabindex=\"-1\"> 2.6.3.1 导入依赖仓库中的第三方库</h5>\n<div><pre><code>implementation <span>'group:name:version'</span>\n</code></pre></div><div><pre><code>group=groupId, name=artifactId, version=versionId\n</code></pre></div><h5 id=\"_2-6-3-2-导入-1-个或多个本地-jar-文件\" tabindex=\"-1\"> 2.6.3.2 导入 1 个或多个本地 <code>jar</code> 文件</h5>\n<div><pre><code>implementation <span>files</span><span>(</span><span>'jarFilePath1'</span><span>,</span> <span>'jarFilePath2'</span><span>,</span> <span>...</span><span>)</span>\n</code></pre></div><div><pre><code>路径是相对于当前 Project 的相对路径，如：\nimplementation files('libs/name1.jar') // 导入当前 Project 下的 libs 文件夹中的 name1.jar 文件\nimplementation files('libs/name1.jar', 'libs/name2.jar')\n</code></pre></div><h5 id=\"_2-6-3-3-导入当前-project-下的以-libs-为根节点的文件树\" tabindex=\"-1\"> 2.6.3.3 导入当前 <code>Project</code> 下的以 <code>libs</code> 为根节点的文件树</h5>\n<div><pre><code><span>// 导入当前 Project 下的以 libs 为根节点的文件树</span>\nimplementation <span>fileTree</span><span>(</span><span>'libs'</span><span>)</span>\n</code></pre></div><div><pre><code><span>//  导入当 前Project 下的以 libs 为根节点的文件树中以 .jar 为后缀名的所有文件</span>\nimplementation <span>fileTree</span><span>(</span>dir<span>:</span> <span>'libs'</span><span>,</span> includes<span>:</span> <span>[</span><span>'*.jar'</span><span>]</span><span>)</span>\n</code></pre></div><div><pre><code><span>// 导入当前 Project 下的以 libs 为根节点的文件树中不以 .jar 为后缀名的所有文件</span>\nimplementation <span>fileTree</span><span>(</span>dir<span>:</span> <span>'libs'</span><span>,</span> excludes<span>:</span> <span>[</span><span>'*.jar'</span><span>]</span><span>)</span>\n</code></pre></div><h5 id=\"_2-6-3-4-排除-group-name-version-内部的依赖\" tabindex=\"-1\"> 2.6.3.4 排除 <code>'group:name:version'</code> 内部的依赖</h5>\n<div><pre><code><span>// 排除 'group:name:version' 内部的某个依赖</span>\nimplementation <span>(</span><span>'group:name:version'</span><span>)</span> <span>{</span>\n    exclude group<span>:</span> <span>'innerGroup'</span><span>,</span> module<span>:</span> <span>'innerName'</span>\n<span>}</span>\n</code></pre></div><div><pre><code>implementation <span>(</span><span>'group:name:version'</span><span>)</span> <span>{</span>\n    <span>// 排除 'group:name:version' 内部的所有依赖</span>\n    <span>// 即当前 Project 仅直接依赖 'group:name:version'，不会间接依赖其内部依赖</span>\n    transitive <span>=</span> <span>false</span>\n<span>}</span>\n</code></pre></div><h5 id=\"_2-6-3-5-依赖本地的子-project\" tabindex=\"-1\"> 2.6.3.5 依赖本地的子 <code>Project</code></h5>\n<div><pre><code>implementation <span>project</span><span>(</span><span>':name'</span><span>)</span> <span>// 依赖本地的子 Project</span>\n</code></pre></div><h5 id=\"_2-6-3-6-导入当前-project-的-libs-文件夹下的-aar-库文件\" tabindex=\"-1\"> 2.6.3.6 导入当前 <code>Project</code> 的 <code>libs</code> 文件夹下的 <code>aar</code> 库文件</h5>\n<div><pre><code><span>implementation</span><span>(</span>name<span>:</span> <span>'fileName'</span><span>,</span> ext<span>:</span> <span>'aar'</span><span>)</span>\n</code></pre></div><div><pre><code>注意：必须在 Project.repositories(closure) 的闭包中指定当前 Project 的 libs 文件夹为依赖仓库\n\nProject.repositories {\n    ...\n    flatDir {\n        dirs 'libs'\n    }\n    ...\n}\n</code></pre></div><h5 id=\"_2-6-3-7-占位编译配置-provided\" tabindex=\"-1\"> 2.6.3.7 占位编译配置 <code>provided</code></h5>\n<p>可以使用 <code>provided</code> 代替 <code>compile</code> 或 <code>implementation</code> 导入依赖。此时，<code>provided</code> 导入的依赖库只在编译时期起作用，不会将依赖库添加到 <code>apk</code> 或 <code>aar</code> 或 <code>jar</code> 等构建产品中。</p>\n<p>使用 <code>provided</code> 的使用场景：</p>\n<ol>\n<li>\n<p>对于只在编译时期起作用的依赖库，使用 <code>provided</code> 导入，避免添加到 <code>apk</code> 中，减小 <code>apk</code> 体积。</p>\n<blockquote>\n<p>举例：如果依赖库只是用于在编译时期动态生成类文件，那么可以使用 <code>provided</code> 导入这类依赖库。</p>\n</blockquote>\n</li>\n<li>\n<p>当 <code>app</code> 模块使用的依赖库，在其他本地依赖模块中也使用到时，其他本地依赖模块中可以使用 <code>provided</code> 导入依赖库，</p>\n<blockquote>\n<p>即打包时，只把 <code>app</code> 模块中的依赖库添加到 <code>apk</code> 中即可。</p>\n</blockquote>\n</li>\n</ol>\n<p><strong>注意：</strong> 能使用 <code>provided</code> 占位编译导入的依赖库，就尽量使用 <code>provided</code> 导入，这样可以减小 <code>apk</code> 体积。</p>\n<h5 id=\"_2-6-3-8-示例代码\" tabindex=\"-1\"> 2.6.3.8 示例代码</h5>\n<p><img src=\"@source/zkq/gradle/images/_05_project/18.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_2-7-外部命令执行相关的-api\" tabindex=\"-1\"> 2.7 外部命令执行相关的 <code>API</code></h3>\n<p><code>Project</code> 类提供的执行外部命令的 <code>API</code> 如下：</p>\n<div><pre><code>ExecResult <span>exec</span><span>(</span>Closure closure<span>)</span>\n</code></pre></div><div><pre><code>实参闭包中可以调用 org.gradle.process.ExecSpec 提供的 API 来配置外部命令\n</code></pre></div><p><strong>示例代码：</strong></p>\n<div><pre><code>知识点：\n\n1. 在 Project 中创建一个 Task 任务\n\n    Task task(String taskName, Closure configureClosure)\n\n    Project 类提供了如上的 task 方法，创建一个名为 taskName 的 Task 任务；\n    实参闭包中可以调用 org.gradle.api.Task 提供的 API，对 Task 任务进行配置。\n\n2. Task 类提供的用于配置 Task 任务的 API\n\n    Task doLast(Closure action)\n\n    实参闭包中的代码在 Gradle 执行阶段才会执行\n\n3. 对于可变字符串（双引号字符串），其中的 ${变量} 可简写为 $变量\n\n4. 可以在根目录下执行 gradlew taskName 命令来执行一个 Task 任务\n\n5. Windows 和 Linux 下的外部命令是不同的\n</code></pre></div><p><img src=\"@source/zkq/gradle/images/_05_project/19.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "date_published": "2022-10-23T14:49:16.000Z",
      "date_modified": "2022-11-13T15:38:57.000Z",
      "authors": [],
      "tags": [
        "gradle"
      ]
    },
    {
      "title": "Task详解与实战",
      "url": "https://zengkaiqiang562.github.io/zkq/gradle/_06_task.html",
      "id": "https://zengkaiqiang562.github.io/zkq/gradle/_06_task.html",
      "content_html": "<h2 id=\"_1-task-的创建-配置\" tabindex=\"-1\"> 1. <code>Task</code> 的创建 &amp; 配置</h2>\n<h3 id=\"_1-1-创建-task\" tabindex=\"-1\"> 1.1 创建 <code>Task</code></h3>\n<p><code>Project</code> 类提供如下方法创建一个 <code>Task</code>。</p>\n<p><strong>方式一：</strong></p>\n<div><pre><code>Task <span>task</span><span>(</span>String name<span>,</span> Closure configureClosure<span>)</span>\n</code></pre></div><p><strong>方式二：</strong></p>\n<div><pre><code>TaskContainer <span>getTasks</span><span>(</span><span>)</span>\n\n<span>// TaskContainer 提供了多个重载的 create 方法来创建 task</span>\nTask <span>create</span><span>(</span>String name<span>,</span> Closure configureClosure<span>)</span>\n</code></pre></div><p><strong>注意：</strong></p>\n<div><pre><code>1. Project 依赖 TaskContainer 来管理 Task。可以通过 TaskContainer 来创建和查找 Task；\n\n2. task(name, configureClosure) 和 tasks.create(name, configureClosure) 中的实参闭包用于配置 Task，\n    并且，在 Gradle 配置阶段就会执行配置 Task 的实参闭包；\n\n3. 在执行 gradlew taskName 命令执行某个 Task 时，会经历 Gradle 的配置阶段，\n    此时，所有在 Project 中创建的 Task，在创建时用于配置 Task 的实参闭包都会执行到；\n\n4. 采用 task 'name' {...} 创建 task 时，其中的单引号可省略，即写成：task name {...}\n\n5. task 创建后，taskName 作为 Project 的属性，可以直接在 build.gradle 中通过 taskName 调用 Task 的 API\n</code></pre></div><p><strong>示例代码：</strong></p>\n<p><img src=\"@source/zkq/gradle/images/_06_task/01.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_1-2-配置-task\" tabindex=\"-1\"> 1.2 配置 <code>Task</code></h3>\n<h4 id=\"_1-2-1-task-中可配置的属性\" tabindex=\"-1\"> 1.2.1 <code>Task</code> 中可配置的属性</h4>\n<p><code>org.gradle.api.Task</code> 类中定义了如下几个属性用于配置 <code>Task</code>。</p>\n<h5 id=\"_1-2-1-1-配置-task-的名字-name\" tabindex=\"-1\"> 1.2.1.1 配置 <code>Task</code> 的名字：<code>name</code></h5>\n<div><pre><code>String TASK_NAME <span>=</span> <span><span>\"name\"</span></span>\n</code></pre></div><h5 id=\"_1-2-1-2-配置-task-的描述信息-description\" tabindex=\"-1\"> 1.2.1.2 配置 <code>Task</code> 的描述信息：<code>description</code></h5>\n<div><pre><code>String TASK_DESCRIPTION <span>=</span> <span><span>\"description\"</span></span>\n</code></pre></div><h5 id=\"_1-2-1-3-配置-task-的分组-group\" tabindex=\"-1\"> 1.2.1.3 配置 <code>Task</code> 的分组：<code>group</code></h5>\n<div><pre><code>String TASK_GROUP <span>=</span> <span><span>\"group\"</span></span>\n</code></pre></div><h5 id=\"_1-2-1-4-配置-task-的类型-type\" tabindex=\"-1\"> 1.2.1.4 配置 <code>Task</code> 的类型：<code>type</code></h5>\n<div><pre><code>String TASK_TYPE <span>=</span> <span><span>\"type\"</span></span>\n</code></pre></div><h5 id=\"_1-2-1-5-配置-task-所依赖的其他-task-dependson\" tabindex=\"-1\"> 1.2.1.5 配置 <code>Task</code> 所依赖的其他 <code>Task</code>：<code>dependsOn</code></h5>\n<div><pre><code>String TASK_DEPENDS_ON <span>=</span> <span><span>\"dependsOn\"</span></span>\n</code></pre></div><h5 id=\"_1-2-1-6-配置-task-用于重写-overwrite-属性指定的-task-overwrite\" tabindex=\"-1\"> 1.2.1.6 配置 <code>Task</code> 用于重写 <code>overwrite</code> 属性指定的 <code>Task</code>：<code>overwrite</code></h5>\n<div><pre><code>String TASK_OVERWRITE <span>=</span> <span><span>\"overwrite\"</span></span>\n</code></pre></div><h5 id=\"_1-2-1-7-配置-task-的动作-即执行逻辑-action\" tabindex=\"-1\"> 1.2.1.7 配置 <code>Task</code> 的动作（即执行逻辑）：<code>action</code></h5>\n<div><pre><code>String TASK_ACTION <span>=</span> <span><span>\"action\"</span></span>\n</code></pre></div><h4 id=\"_1-2-2-配置-task-的-2-种方式\" tabindex=\"-1\"> 1.2.2 配置 <code>Task</code> 的 <code>2</code> 种方式</h4>\n<p><strong>方式一：</strong></p>\n<div><pre><code><span>// 调用 Project 类提供的方法</span>\nTask <span>task</span><span>(</span>Map<span>&lt;</span>String<span>,</span> <span>?</span><span>></span> args<span>,</span> String name<span>,</span> Closure configureClosure<span>)</span>\n\n<span>// 调用示例</span>\ntask <span>(</span><span>[</span>attrName1<span>:</span> attrValue1<span>,</span> attrName2<span>:</span> attrValue2<span>,</span> <span>...</span><span>]</span><span>,</span> <span>'taskName'</span><span>)</span> <span>{</span><span>...</span><span>}</span>\n\n<span>// 还可以写成</span>\n<span>// 其中，taskName 可以省略单引号，上面的书写形式中不可以省略</span>\ntask <span>taskName</span><span>(</span>attrName1<span>:</span> attrValue1<span>,</span> attrName2<span>:</span> attrValue2<span>,</span> <span>...</span><span>)</span> <span>{</span><span>...</span><span>}</span>\n</code></pre></div><p><strong>方式二：</strong></p>\n<div><pre><code><span>// 调用 Project 类提供的方法：</span>\nTask <span>task</span><span>(</span>String name<span>,</span> Closure configureClosure<span>)</span>\n\n<span>// 调用示例</span>\n<span>// 其中，1. taskName 可以省略单引号；2. 在实参闭包中设置 Task 属性</span>\ntask taskName <span>{</span>\n    attrName1 <span>=</span> attrValue1\n    attrName2 <span>=</span> attrValue2\n    <span>...</span>\n<span>}</span>\n</code></pre></div><p><strong>注意：</strong></p>\n<div><pre><code>如果不设置 Task 的 group 属性，那么 Task 默认放在当前 Project 的 other 组中。\n</code></pre></div><p><strong>示例代码：</strong></p>\n<p><img src=\"@source/zkq/gradle/images/_06_task/02.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_2-task-的动作集合-dolast-dofirst\" tabindex=\"-1\"> 2. <code>Task</code> 的动作集合 &amp; <code>doLast</code> &amp; <code>doFirst</code></h2>\n<h3 id=\"_2-1-注-只有通过-task-才能将业务放在-gradle-执行阶段去处理\" tabindex=\"-1\"> 2.1 注：只有通过 <code>Task</code> 才能将业务放在 <code>Gradle</code> 执行阶段去处理</h3>\n<h3 id=\"_2-2-task-的动作集合就是-task-在-gradle-执行阶段才执行的代码\" tabindex=\"-1\"> 2.2 <code>Task</code> 的动作集合就是 <code>Task</code> 在 <code>Gradle</code> 执行阶段才执行的代码</h3>\n<h3 id=\"_2-3-一个动作-action-就是一段代码-动作集合就是代码段集合\" tabindex=\"-1\"> 2.3 一个动作（<code>Action</code>）就是一段代码，动作集合就是代码段集合</h3>\n<h3 id=\"_2-4-向动作集合的头部插入一个动作-dofirst-closure\" tabindex=\"-1\"> 2.4 向动作集合的头部插入一个动作：<code>doFirst(closure)</code></h3>\n<div><pre><code>doFirst(closure) 用于将实参闭包表示的动作插入到动作集合的头部。\n\n注意：多次调用 doFirst(closure)，最后一次调用的 doFirst 配置的动作最先执行。\n</code></pre></div><h3 id=\"_2-5-向动作集合的尾部插入一个动作-dolast-closure\" tabindex=\"-1\"> 2.5 向动作集合的尾部插入一个动作：<code>doLast(closure)</code></h3>\n<div><pre><code>doLast(closure) 用于将实参闭包表示的动作插入到动作集合的尾部。\n\n注意：多次调用 doLast(closure), 最后一次调用的 doLast 配置的动作最后执行。\n</code></pre></div><h3 id=\"_2-6-示例代码\" tabindex=\"-1\"> 2.6 示例代码</h3>\n<p><img src=\"@source/zkq/gradle/images/_06_task/03.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_2-7-案例-统计-build-时长\" tabindex=\"-1\"> 2.7 案例：统计 <code>build</code> 时长</h3>\n<h4 id=\"_2-7-1-如何查找所有存在的-task\" tabindex=\"-1\"> 2.7.1 如何查找所有存在的 <code>task</code></h4>\n<div><pre><code>调用 tasks.getByName(taskName) 可以查找指定的 task。另外，也可以通过 tasks 遍历所有存在的 task。\n\n注意：\n为了保证 tasks.getByName(taskName) 能够查找到所有存在的 task，应该在 Gradle 配置阶段完后，即所有 task 都配置完成后，\n再调用 tasks.getByName(taskName) 方法。也就是说，应该在 Project.afterEvaluate(closure) 的实参闭包中调用该方法。\n</code></pre></div><h4 id=\"_2-7-2-案例代码\" tabindex=\"-1\"> 2.7.2 案例代码</h4>\n<p><img src=\"@source/zkq/gradle/images/_06_task/04.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_3-task-的执行顺序\" tabindex=\"-1\"> 3. <code>Task</code> 的执行顺序</h2>\n<h3 id=\"_3-1-通过-task-的-dependson-属性指定依赖-task\" tabindex=\"-1\"> 3.1 通过 <code>Task</code> 的 <code>dependsOn</code> 属性指定依赖 <code>Task</code></h3>\n<p><strong>方式一：</strong></p>\n<div><pre><code><span>// 调用 Project 提供的如下方法，在参数 args 中指定依赖 Task</span>\n<span>task</span><span>(</span>Map<span>&lt;</span>String<span>,</span> <span>?</span><span>></span> args<span>,</span> String name<span>,</span> Closure configureClosure<span>)</span>\n</code></pre></div><div><pre><code>参数 args 是一个 map，map 的 key 表示 Task 的属性，value 表示属性值。\n注意：该方法可以通过 \"task name(args) {}\" 的形式调用，其中 {} 表示配置闭包 configureClosure。\n</code></pre></div><div><pre><code><span>// 1. 指定一个依赖 Task</span>\n<span>// 只为参数 args 配置了一个键值对元素（key=dependsOn）</span>\ntask <span>taskMainName</span><span>(</span>dependsOn<span>:</span> taskOtherName<span>)</span> <span>{</span><span>...</span><span>}</span> \n</code></pre></div><div><pre><code><span>// 2. 指定多个依赖 Task</span>\n<span>// 只为参数 args 配置了一个键值对元素（key=dependsOn）</span>\ntask <span>taskMainName</span><span>(</span>dependsOn<span>:</span> <span>[</span>taskOtherName1<span>,</span> taskOtherName2<span>,</span> <span>...</span><span>]</span><span>)</span> <span>{</span><span>...</span><span>}</span> \n</code></pre></div><p><strong>方式二：</strong></p>\n<div><pre><code><span>// 调用 Project 提供的如下方法，在配置闭包 configureClosure 中指定依赖 Task</span>\n<span>task</span><span>(</span>String name<span>,</span> Closure configureClosure<span>)</span>\n</code></pre></div><div><pre><code><span>/* 配置闭包中可以通过如下方式配置依赖：*/</span>\n\n<span>// 1. 调用 Task 的 setDependsOn(Iterable&lt;?> dependsOnTasks) 方法，示例如下：</span>\n\ntask taskMainName <span>{</span>\n    <span>// 指定一个依赖 Task</span>\n    dependsOn <span>=</span> <span>[</span>taskOtherName1<span>]</span> \n<span>}</span>\n\ntask taskMainName <span>{</span>\n    <span>// 指定多个依赖 Task</span>\n    dependsOn <span>=</span> <span>[</span>taskOtherName1<span>,</span> taskOtherName2<span>,</span> <span>...</span><span>]</span>  \n<span>}</span>  \n\n<span>// 2. 调用 Task 的 dependsOn(Object... paths) 方法，示例如下：</span>\ntask taskMainName <span>{</span>\n    <span>// 指定一个依赖Task</span>\n    dependsOn  taskOtherName1 \n<span>}</span>\n\ntask taskMainName <span>{</span>\n    <span>// 指定多个依赖 Task</span>\n    dependsOn  taskOtherName1<span>,</span> taskOtherName2<span>,</span> <span>...</span>  \n<span>}</span>\n</code></pre></div><h4 id=\"_3-1-1-注-先执行依赖-task-的动作集合-再执行-task-本身的动作集合\" tabindex=\"-1\"> 3.1.1 注：先执行依赖 <code>Task</code> 的动作集合，再执行 <code>Task</code> 本身的动作集合</h4>\n<h4 id=\"_3-1-2-示例代码一-多个依赖-task-之间的执行顺序默认是不确定的\" tabindex=\"-1\"> 3.1.2 示例代码一：多个依赖 <code>Task</code> 之间的执行顺序默认是不确定的</h4>\n<p><img src=\"@source/zkq/gradle/images/_06_task/05.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_3-1-3-示例代码二-多个依赖-task-之间使用-dependson-指定执行顺序\" tabindex=\"-1\"> 3.1.3 示例代码二：多个依赖 <code>Task</code> 之间使用 <code>dependsOn</code> 指定执行顺序</h4>\n<p><img src=\"@source/zkq/gradle/images/_06_task/06.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_3-1-4-示例代码三-结合-tasks-动态指定满足条件的依赖-task\" tabindex=\"-1\"> 3.1.4 示例代码三：结合 <code>tasks</code> 动态指定满足条件的依赖 <code>Task</code></h4>\n<p><img src=\"@source/zkq/gradle/images/_06_task/07.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_3-2-通过-task-类的-mustrunafter-方法指定执行顺序\" tabindex=\"-1\"> 3.2 通过 <code>Task</code> 类的 <code>mustRunAfter</code> 方法指定执行顺序</h3>\n<p><code>Task</code> 类提供了 <code>mustRunAfter</code> 方法指定 <code>Task</code> 的执行顺序。</p>\n<div><pre><code><span>// 示例 mustRunAfter task1, task2, ...</span>\nTask <span>mustRunAfter</span><span>(</span>Object<span>...</span> paths<span>)</span><span>;</span>\n\n<span>// 示例 mustRunAfter = [task1, task2, ...]</span>\n<span>void</span> <span>setMustRunAfter</span><span>(</span>Iterable<span>&lt;</span><span>?</span><span>></span> mustRunAfter<span>)</span><span>;</span> \n\nTaskDependency <span>getMustRunAfter</span><span>(</span><span>)</span><span>;</span>\n</code></pre></div><p><strong>注意：</strong></p>\n<div><pre><code>1. 通过 mustRunAfter 仅仅只是指定多个 task 一起执行时的先后顺序，并不会指定多个 task 的依赖关系。\n    也就是说，当执行 gradlew task3, task2, task1 命令，执行多个 task 时，\n    会按照 mustRunAfter 指定的先后顺序执行 task，\n    但是，当执行 gradlew task3 命令时，仅仅只会执行 task3，因为 task3 没有依赖 task。\n\n2. 通过 dependsOn 为 task3 指定依赖 task1 和 task2，\n    此时，执行 gradlew task3 命令，会先执行依赖 task1 和 task2，最后执行 task3。\n    但是，task1 和 task2 的执行顺序是不确定的，\n    此时，可以通过 mustRunAfter 来指定 task1 和 task2 的执行顺序。\n</code></pre></div><h4 id=\"_3-2-1-示例代码一\" tabindex=\"-1\"> 3.2.1 示例代码一</h4>\n<p><img src=\"@source/zkq/gradle/images/_06_task/08.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_3-2-2-示例代码二\" tabindex=\"-1\"> 3.2.2 示例代码二</h4>\n<p><img src=\"@source/zkq/gradle/images/_06_task/09.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_3-3-将自定义-task-挂接到构建过程中\" tabindex=\"-1\"> 3.3 将自定义 <code>Task</code> 挂接到构建过程中</h3>\n<p><strong>挂接步骤：</strong></p>\n<div><pre><code>step1：先执行一次 build 任务，通过打印确定构建过程中涉及到的内部 Task；\n\nstep2：通过 dependsOn 和 mustRunAfter 将自定义 Task 插入到内部 Task 执行序列中。\n</code></pre></div><p><strong>注意：</strong></p>\n<div><pre><code>1. 为了看到 build 时的所有执行的 task，需要从 AS 的 Gradle 面板中点击对应 Project 的 build 任务执行；\n\n2. 如果要将自定义 Task(customTask) 挂接到内部 Task(innerTask) 之前执行，\n    那么可以通过建立依赖关系 \"innerTask.dependsOn customTask\" 实现；\n\n3. 如果要将自定义 Task(customTask) 挂接到内部 Task(innerTask) 之后执行，那么有如下两种方式：\n\n    1. 将 customTask 作为 innerTask 的下一个内部 Task(nextInnerTask) 的依赖，然后将 customTask 的执行顺序放在 innerTask 之后，即：\n\n        nextInnerTask.dependsOn  customTask\n        customTask.mustRunAfter innerTask\n\n    2. 取出 customTask 的动作集合（actions），将一个个的动作依次分别添加到 innerTask 的 doLast 中，即：\n\n        customTask.actions.each { action ->\n            innerTask.doLast action  // 这里调用了 Task.doLast(action) 方法\n        }\n</code></pre></div><h4 id=\"_3-3-1-示例代码\" tabindex=\"-1\"> 3.3.1 示例代码</h4>\n<p><img src=\"@source/zkq/gradle/images/_06_task/10.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_4-task-的输入输出\" tabindex=\"-1\"> 4. <code>Task</code> 的输入输出</h2>\n<h3 id=\"_4-1-task-类中表示输入和输出的属性-inputs-outputs\" tabindex=\"-1\"> 4.1 <code>Task</code> 类中表示输入和输出的属性：<code>inputs</code> &amp; <code>outputs</code></h3>\n<p><code>Task</code> 类中存在 <code>inputs</code> 和 <code>outputs</code> 这两个属性分别表示输入和输出。</p>\n<div><pre><code><span>// 即 inputs 属性为只读</span>\nTaskInputs <span>getInputs</span><span>(</span><span>)</span><span>;</span>\n\n<span>// 即 outputs 属性为只读</span>\nTaskOutputs <span>getOutputs</span><span>(</span><span>)</span><span>;</span>\n</code></pre></div><h3 id=\"_4-2-taskinputs-提供的-api\" tabindex=\"-1\"> 4.2 <code>TaskInputs</code> 提供的 <code>API</code></h3>\n<h4 id=\"_4-2-1-向-taskinputs-中存取键值对属性\" tabindex=\"-1\"> 4.2.1 向 <code>TaskInputs</code> 中存取键值对属性</h4>\n<div><pre><code><span>/* 只是存在内存中 */</span>\n\n<span>property</span><span>(</span>String name<span>,</span> <span>@Nullable</span> Object value<span>)</span><span>;</span>\n\n<span>properties</span><span>(</span>Map<span>&lt;</span>String<span>,</span> <span>?</span><span>></span> properties<span>)</span><span>;</span>\n\nMap<span>&lt;</span>String<span>,</span> Object<span>></span> <span>getProperties</span><span>(</span><span>)</span><span>;</span>\n</code></pre></div><h4 id=\"_4-2-2-设置-获取输入文件\" tabindex=\"-1\"> 4.2.2 设置/获取输入文件</h4>\n<div><pre><code><span>file</span><span>(</span>Object path<span>)</span> <span>// 设置单个输入文件</span>\n\n<span>files</span><span>(</span>Object<span>...</span> paths<span>)</span> <span>// 设置多个输入文件</span>\n\n<span>dir</span><span>(</span>Object dirPath<span>)</span> <span>// 将整个文件夹作为输入源</span>\n\nFileCollection <span>getFiles</span><span>(</span><span>)</span> <span>// 获取输入源</span>\n</code></pre></div><p><code>FileCollection</code> 表示文件集合，提供了如下 <code>API</code> 访问指定的文件：</p>\n<div><pre><code>File <span>getSingleFile</span><span>(</span><span>)</span> <span>// 若文件集合中只有一个文件，返回这个文件，其他情况会抛出异常</span>\nSet<span>&lt;</span>File<span>></span> <span>getFiles</span><span>(</span><span>)</span> <span>// 返回所有的文件集合</span>\n</code></pre></div><h3 id=\"_4-3-taskoutpus-提供的-api\" tabindex=\"-1\"> 4.3 <code>TaskOutpus</code> 提供的 <code>API</code></h3>\n<h4 id=\"_4-3-1-设置-获取输出文件\" tabindex=\"-1\"> 4.3.1 设置/获取输出文件</h4>\n<div><pre><code><span>file</span><span>(</span>Object path<span>)</span> <span>// 设置单个输出文件</span>\n<span>files</span><span>(</span>Object<span>...</span> paths<span>)</span> <span>// 设置多个输出文件</span>\n\n<span>dir</span><span>(</span>Object path<span>)</span> <span>// 设置单个输出文件夹</span>\n<span>dirs</span><span>(</span>Object<span>...</span> paths<span>)</span> <span>// 设置多个输出文件夹</span>\n\nFileCollection <span>getFiles</span><span>(</span><span>)</span> <span>// 获取输出源</span>\n</code></pre></div><h2 id=\"_5-task-的类型\" tabindex=\"-1\"> 5. <code>Task</code> 的类型</h2>\n<p>在 <a href=\"https://docs.gradle.org/5.1.1/dsl/index.html\" target=\"_blank\" rel=\"noopener noreferrer\">Gradle 5.1.1 版本的官方文档<ExternalLinkIcon/></a> 中的 <code>Task Types</code> 栏目中介绍了各种 <code>Task</code> 类型，如：</p>\n<div><pre><code>Copy\nDelete\nJar\nJavaCompile\nJavadoc\nTest\nUpload\n</code></pre></div><h3 id=\"_5-1-注-可以通过-task-的-type-属性设置-task-的类型\" tabindex=\"-1\"> 5.1 注：可以通过 <code>Task</code> 的 <code>type</code> 属性设置 <code>Task</code> 的类型</h3>\n<div><pre><code>每种 Task 类型名都对应一个同名的类，在创建某类型的 Task 时，配置闭包中可以调用对应类提供的 API。\n注意：如果没有通过 Task 的 type 属性指定 Task 类型，那么就是默认类型，对应类 DefaultTask。\n</code></pre></div><h3 id=\"_5-2-获取同一类型的-task-集合\" tabindex=\"-1\"> 5.2 获取同一类型的 <code>Task</code> 集合</h3>\n<p><strong>Step 1.</strong></p>\n<div><pre><code>调用 Project.getTasks() 方法获取管理 task 的容器类 TaskContainer。\n</code></pre></div><p><strong>Step 2.</strong></p>\n<div><pre><code>调用 TaskContainer 提供的 withType 方法访问同一类型的 Task。\n</code></pre></div><div><pre><code><span>&lt;</span>S <span>extends</span> <span>Task</span><span>></span> DomainObjectCollection<span>&lt;</span>S<span>></span> <span>withType</span><span>(</span>Class<span>&lt;</span>S<span>></span> type<span>)</span>\n<span>&lt;</span>S <span>extends</span> <span>Task</span><span>></span> DomainObjectCollection<span>&lt;</span>S<span>></span> <span>withType</span><span>(</span>Class<span>&lt;</span>S<span>></span> type<span>,</span> Closure configureClosure<span>)</span>\n</code></pre></div><div><pre><code>参数 type 传入 Task 类型对应的类的字节码对象，如传入 Javadoc.class 时，返回的是 Javadoc 类型的 Task 集合。\n参数 configureClosure 作为配置闭包，对返回的同一类型的所有 Task 进行统一配置。\n</code></pre></div><h3 id=\"_5-3-示例代码\" tabindex=\"-1\"> 5.3 示例代码</h3>\n<p><img src=\"@source/zkq/gradle/images/_06_task/11.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "date_published": "2022-10-23T14:49:16.000Z",
      "date_modified": "2022-11-23T15:57:11.000Z",
      "authors": [],
      "tags": [
        "gradle"
      ]
    },
    {
      "title": "Settings类 & SourceSets类",
      "url": "https://zengkaiqiang562.github.io/zkq/gradle/_07_settings_sourcesets.html",
      "id": "https://zengkaiqiang562.github.io/zkq/gradle/_07_settings_sourcesets.html",
      "content_html": "<h2 id=\"_1-settings-类和-settings-gradle-文件\" tabindex=\"-1\"> 1. <code>Settings</code> 类和 <code>settings.gradle</code> 文件</h2>\n<p>在 <a href=\"/zkq/gradle/_05_project.html#_2-4-6-%E5%88%86%E6%9E%90-setting-gradle-%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0\">分析 setting.gradle 文件的内部实现</a> 中有提到：</p>\n<div><pre><code>1. settings.gradle 编译生成的字节码文件，是一个 SettingsScript 的子类文件；\n\n2. SettingsScript 类是一个脚本类，其中的 getScriptTarget() 返回一个目标对象 target，\n   这个目标对象 target 为 settings.gradle 文件中提供了可以使用的 API；\n\n3. 为 settings.gradle 文件中提供可以使用的 API 的目标对象 target 就是一个动态创建的 DefaultSettings 的子类。\n   也就是说，setting.gradle 文件中可以使用 DefaultSettings 提供的API；\n\n4. 查看源码，大概判断是使用 AsmBackedClassGenerator 来动态创建 DefaultSettings 的子类的。\n   这与动态创建 DefaultProject 的子类所使用的生成器一样。在 AsmBackedClassGenerator 中，\n   可以看到创建 DefaultSettings 子类时所动态生成的一些 API，这些动态生成的 API 也可以在该 settings.gradle 中使用。\n\n参考：\norg.gradle.initialization.SettingsScript\norg.gradle.initialization.DefaultSettings // implements Settings\norg.gradle.api.initialization.Settings\norg.gradle.initialization.SettingsFactory\norg.gradle.internal.service.scopes.BuildScopeServices\norg.gradle.api.internal.ClassGeneratorBackedInstantiator\norg.gradle.api.internal.AsmBackedClassGenerator\n</code></pre></div><p>综上，就像 <code>build.gradle</code> 文件中可以调用 <code>Project</code> 的 <code>API</code> 来初始化一个 <code>Project</code> 类对象一样。</p>\n<p><code>settings.gradle</code> 文件中则可以调用 <code>Settings</code> 的 <code>API</code> 用来初始化一个 <code>Settings</code> 类对象。</p>\n<h3 id=\"_1-1-settings-gradle-文件的主要作用-导入子-project\" tabindex=\"-1\"> 1.1 <code>settings.gradle</code> 文件的主要作用：导入子 <code>Project</code></h3>\n<p><code>settings.gradle</code> 文件的主要作用就是通过 <code>Settings</code> 类提供的 <code>include</code> 方法导入子 <code>Project</code>。</p>\n<h3 id=\"_1-2-gradle-初始化阶段的主要工作-解析出-project-树结构\" tabindex=\"-1\"> 1.2 <code>Gradle</code> 初始化阶段的主要工作：解析出 <code>Project</code> 树结构</h3>\n<p><code>Gradle</code> 初始化阶段的主要工作就是对 <code>settings.gradle</code> 文件进行处理，解析出整个 <code>Project</code> 项目的 <code>Project</code> 树结构。</p>\n<h3 id=\"_1-3-settings-类的相关-api\" tabindex=\"-1\"> 1.3 <code>Settings</code> 类的相关 <code>API</code></h3>\n<h4 id=\"_1-3-1-导入一个或多个子-project\" tabindex=\"-1\"> 1.3.1 导入一个或多个子 <code>Project</code></h4>\n<div><pre><code><span>void</span> <span>include</span><span>(</span>String<span>...</span> projectPaths<span>)</span>\n</code></pre></div><div><pre><code>作用：导入一个或多个子 Project\n\n注意：projectPath 并不是表示子 Project 所在的文件路径，而是表示在将要构建的整个 Project 树结构中该子 Project 所在的结构位置，如：\n\n    include ':projectName1'  \n        1. 表示导入了一个名为 projectName1 的一级子 Project，即该子 Project 是根 Project 下的直接子 Project\n        2. 默认情况下，在根 Project 的文件夹下，应该有一个名为 projectName1 的文件夹作为该子 Project 的文件夹\n\n    include ':projectName1:projectName2'\n        1. 表示导入了一个名为 projectName2 的二级子 Project，即该子 Project 是一级子 Project(projectName1) 下的子 Project\n        2. 默认情况下，在根 Project 的文件夹下的 projectName1 文件夹下，应该有一个名为 projectName2 的文件夹\n</code></pre></div><h4 id=\"_1-3-2-导入项目之外的文件夹作为子-project\" tabindex=\"-1\"> 1.3.2 导入项目之外的文件夹作为子 <code>Project</code></h4>\n<p>导入根 <code>Project</code> 目录之外的文件夹作为子 <code>Project</code> 的步骤如下：</p>\n<div><pre><code>Step1. 先执行 include ':subProject'  表示导入了一个名为 subProject 的一级子 Project\n\nStep2. 再执行 project(':subProject').projectDir = file('subProjectDir')\n    该代码表示将 subProjectDir（根 Project 目录之外的文件夹路径）作为 subProject 的工程目录。\n</code></pre></div><h2 id=\"_2-sourceset-类\" tabindex=\"-1\"> 2. <code>SourceSet</code> 类</h2>\n<h3 id=\"_2-1-使用示例\" tabindex=\"-1\"> 2.1 使用示例</h3>\n<div><pre><code>android <span>{</span> <span>// android 表示一个 Android 工程，配置闭包中对 Android 工程进行配置</span>\n    sourceSets <span>{</span> <span>// 从 \"Sets\" 可以看出，是set的集合（即集合的集合），sourceSets 表示资源集合，配置闭包中对资源进行配置</span>\n        main <span>{</span> <span>// main 表示一个 set 集合，这里就是 AndroidSourceSet，配置闭包中对 Android 资源进行配置</span>\n            <span>//可以调用 AndroidSourceSet 的 API</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre></div><h3 id=\"_2-2-sourcesets-configureclosure-的作用\" tabindex=\"-1\"> 2.2 <code>sourceSets(configureClosure)</code> 的作用</h3>\n<div><pre><code>sourceSets(configureClosure) 的作用就是用来配置 sourceSets 对象的\nsourceSets 对象是一个容器，容器中的元素是 AndroidSourceSet，即 Android 资源集合，\n也就是说 sourceSets(configureClosure) 就是用来配置各种 Android 资源集合的，\n具体有哪些 Android 资源集合，由 Android-Gradle 插件来初始化，\n从上面的源码可以看出，sourceSets 容器中保存了一个名为 main 的 Android 资源集合（即 main 是一个 AndroidSourceSet 对象）\n可以通过 main(configureClosure) 配置名为 main 的 Android 资源集合，配置闭包中可以调用 AndroidSourceSet 的 API\n</code></pre></div><h3 id=\"_2-3-android-资源集合-main-的配置详解\" tabindex=\"-1\"> 2.3 <code>Android</code> 资源集合 &quot;<code>main</code>&quot; 的配置详解</h3>\n<p><code>main(configureClosure)</code> 可以访问 <code>DefaultAndroidSourceSet</code> 的 <code>API</code>。</p>\n<p>配置 <code>Android</code> 资源集合，主要就是通过配置 <code>DefaultAndroidSourceSet</code> 中的相关属性，来指定相关文件的访问路径。</p>\n<p><code>DefaultAndroidSourceSet</code> 中的部分属性如下：</p>\n<ol>\n<li>\n<p>表示资源目录的 <code>AndroidSourceDirectorySet</code> 类型的属性</p>\n<div><pre><code>res\nassets\njava\naidl\njni\njniLibs\n</code></pre></div><div><pre><code><span>/* 调用 AndroidSourceDirectorySet 的如下 API 可以为这些属性分别指定资源目录的实际路径 */</span>\nAndroidSourceDirectorySet <span>srcDir</span><span>(</span>Object srcDir<span>)</span><span>;</span>\nAndroidSourceDirectorySet <span>srcDirs</span><span>(</span>Object<span>...</span> srcDirs<span>)</span><span>;</span>\nAndroidSourceDirectorySet <span>setSrcDirs</span><span>(</span>Iterable<span>&lt;</span><span>?</span><span>></span> srcDirs<span>)</span><span>;</span>\n\nSet<span>&lt;</span>File<span>></span> <span>getSrcDirs</span><span>(</span><span>)</span><span>;</span>\nString <span>getName</span><span>(</span><span>)</span><span>;</span>\n</code></pre></div></li>\n<li>\n<p>表示资源文件的 <code>AndroidSourceFile</code> 类型的属性</p>\n<div><pre><code>manifest\n</code></pre></div><div><pre><code><span>/* 调用 AndroidSourceFile 的如下 API 可以为该属性指定资源文件的实际路径 */</span>\nAndroidSourceFile <span>srcFile</span><span>(</span>Object srcPath<span>)</span><span>;</span>\n\nFile <span>getSrcFile</span><span>(</span><span>)</span><span>;</span>\nString <span>getName</span><span>(</span><span>)</span><span>;</span>\n</code></pre></div></li>\n</ol>\n<h3 id=\"_2-4-示例代码\" tabindex=\"-1\"> 2.4 示例代码</h3>\n<p><img src=\"@source/zkq/gradle/images/_07_settings_sourcesets/01.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "date_published": "2022-10-23T14:49:16.000Z",
      "date_modified": "2022-11-24T07:51:52.000Z",
      "authors": [],
      "tags": [
        "gradle"
      ]
    },
    {
      "title": "Plugin插件",
      "url": "https://zengkaiqiang562.github.io/zkq/gradle/_08_plugin.html",
      "id": "https://zengkaiqiang562.github.io/zkq/gradle/_08_plugin.html",
      "content_html": "<h2 id=\"_1-自定义-plugin-插件\" tabindex=\"-1\"> 1. 自定义 <code>Plugin</code> 插件</h2>\n<h3 id=\"_1-1-手动创建一个本地的-buildsrc-插件模块\" tabindex=\"-1\"> 1.1 手动创建一个本地的 <code>buildSrc</code> 插件模块</h3>\n<p><strong><code>buildSrc</code> 插件模块的文件结构如下：</strong></p>\n<div><pre><code>buildSrc\n—— src/\n———— main/\n—————— groovy/\n—————— resources/\n———————— META-INF/\n—————————— gradle-plugins/\n———————————— {packageId}.properties // 如 com.zengk.plugin.properties\n—— build.gradle\n—— gradle.properties\n</code></pre></div><p><strong>注意：本地的插件模块必须命名为 <code>buildSrc</code>，否则无法在根 <code>Project</code> 下的其他子 <code>Project</code> 中引入该插件模块。</strong></p>\n<p><strong>插件模块的主要创建步骤如下：</strong></p>\n<ol>\n<li>\n<p><code>build.gradle</code> 文件内容模版如下：</p>\n<div><pre><code>apply plugin<span>:</span> <span>'groovy'</span> \n\nsourceSets <span>{</span>\n    main <span>{</span>\n        groovy <span>{</span>\n            srcDir <span>'src/main/groovy'</span>  <span>// 存放 groovy 源码文件的路径</span>\n        <span>}</span>\n\n        resources <span>{</span>\n            srcDir <span>'src/main/resources'</span>  <span>// 存放插件用到的资源文件的路径</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre></div></li>\n<li>\n<p>在 <code>src/main/groovy/</code> 目录下创建包路径 <code>com.zengk.plugin</code></p>\n</li>\n<li>\n<p>在包路径下创建普通文件 <code>MyPlugin.groovy</code></p>\n<blockquote>\n<p>因为 <code>AS</code> 不支持直接创建 <code>groovy</code> 文件，所以创建后缀为 <code>.groovy</code> 的普通文件也是一样的。</p>\n</blockquote>\n<div><pre><code><span>/* MyPlugin.groovy */</span>\n<span>package</span> com<span>.</span>zengk<span>.</span>plugin\n\n<span>import</span> org<span>.</span>gradle<span>.</span>api<span>.</span>Plugin\n<span>import</span> org<span>.</span>gradle<span>.</span>api<span>.</span>Project\n\n<span>class</span> <span>MyPlugin</span> implementsPlugin<span>&lt;</span>Project<span>></span> <span>{</span> <span>// MyPlugin 表示一个自定义插件</span>\n    \n    <span>/**\n      * 将插件引入到 Project 时会调用该 apply 方法\n      * 参数 project 表示引入了该插件的 Project\n     */</span>\n    <span>@override</span>\n    <span>void</span> <span>apply</span><span>(</span>Project project<span>)</span> <span>{</span>\n        println <span><span>\"hello MyPlugin in project:</span><span><span>${</span><span>project<span>.</span>name</span><span>}</span></span><span>\"</span></span> <span>// 自定义插件 MyPlugin 仅用来打印这条日志</span>\n    <span>}</span>\n<span>}</span>\n</code></pre></div><blockquote>\n<p>注意：<code>Gradle</code> 同步后该 <code>MyPlugin.groovy</code> 会与自动生成的 <code>buildSrc/build/</code> 下的 <code>MyPlugin.class</code> 产生同名冲突，但不影响使用。</p>\n</blockquote>\n</li>\n<li>\n<p>在 <code>src/main/resources/META-INF/gradle-plugins/</code> 目录下创建 <code>com.zengk.plugin.properties</code> 文件，文件内容如下：</p>\n<div><pre><code>implementation-class=com.zengk.plugin.MyPlugin\n</code></pre></div><div><pre><code>com.zengk.plugin.properties 文件的作用就是用来声明自定义插件的，\n其中 \"com.zengk.plugin\" 是自定义插件类的包路径，\n当我们要在其他子 Project 中引入该插件时，\"com.zengk.plugin\" 就作为引入插件时的标识 id\n</code></pre></div></li>\n<li>\n<p>在其他子 <code>Project</code> 的 <code>build.gradle</code> 文件中通过 <code>apply plugin 'com.zengk.plugin'</code> 即可引入该本地插件</p>\n</li>\n</ol>\n<p><strong>本地的 <code>buildSrc</code> 插件的使用示例：</strong></p>\n<p><img src=\"@source/zkq/gradle/images/_08_plugin/01.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_1-2-通过-plugin-插件为-project-添加扩展\" tabindex=\"-1\"> 1.2 通过 <code>Plugin</code> 插件为 <code>Project</code> 添加扩展</h3>\n<p><strong>步骤如下：</strong></p>\n<ol>\n<li>\n<p>自定义扩展类；</p>\n</li>\n<li>\n<p>在插件类的 <code>apply</code> 方法中，调用 <code>project.extension.create</code> 方法为 <code>project</code> 添加扩展。</p>\n<blockquote>\n<p>哪个 <code>project</code> 中引入了该插件，就是在为哪个 <code>project</code> 添加扩展。</p>\n</blockquote>\n</li>\n</ol>\n<p><strong>如何在 <code>Project</code> 中访问已添加的扩展：</strong></p>\n<p>如插件类的 <code>apply</code> 方法中添加的扩展如下：</p>\n<div><pre><code>project<span>.</span>extensions<span>.</span><span>create</span><span>(</span><span>'versionInfo'</span><span>,</span> VersionInfo<span>.</span><span>class</span><span>)</span>\n</code></pre></div><div><pre><code>如上代码为 project 添加了一个名为 versionInfo 的扩展，于是：\n1. project 中可以调用 versionInfo(configureClosure)，在闭包中调用 VersionInfo 的 API 初始化一个 VersionInfo 对象\n2. project 中多了一个 versionInfo 属性，属性值就是 VersionInfo 对象\n</code></pre></div><p><strong>示例代码：</strong></p>\n<p><img src=\"@source/zkq/gradle/images/_08_plugin/02.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_1-3-通过-plugin-插件为-project-添加-task-任务\" tabindex=\"-1\"> 1.3 通过 <code>Plugin</code> 插件为 <code>Project</code> 添加 <code>Task</code> 任务</h3>\n<p><strong>步骤如下：</strong></p>\n<ol>\n<li>\n<p>自定义 <code>Task</code> 任务类（继承自 <code>DefaultTask</code>）；</p>\n</li>\n<li>\n<p>在自定义 <code>Task</code> 中定义方法，并使用注解 <code>@TaskAction</code> 将该方法标记为在 <code>Gradle</code> 执行阶段才执行的 <code>Task</code> 动作；</p>\n</li>\n<li>\n<p>在自定义插件类的 <code>apply</code> 方法中，调用 <code>project.tasks.create(taskName, taskClass)</code> 创建 <code>Task</code> 任务。</p>\n</li>\n</ol>\n<p><strong>示例代码：</strong></p>\n<p><img src=\"@source/zkq/gradle/images/_08_plugin/03.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_2-android-插件\" tabindex=\"-1\"> 2. <code>Android</code> 插件</h2>\n<blockquote>\n<p>参考：<a href=\"https://avatarqing.github.io/Gradle-Plugin-User-Guide-Chinese-Verision/index.html\" target=\"_blank\" rel=\"noopener noreferrer\">Gradle Android插件用户指南翻译<ExternalLinkIcon/></a></p>\n<p>参考：<a href=\"https://developer.android.com/studio/build\" target=\"_blank\" rel=\"noopener noreferrer\">Android 项目中 Gradle 配置的官方文档<ExternalLinkIcon/></a></p>\n</blockquote>\n<h3 id=\"_2-1-android-插件为-gradle-添加的扩展\" tabindex=\"-1\"> 2.1 <code>Android</code> 插件为 <code>Gradle</code> 添加的扩展</h3>\n<p>对于 <code>android(configureClosure)</code> 其中，<code>android</code> 是 <code>project</code> 的扩展，于是：</p>\n<ol>\n<li>\n<p><code>android</code> 作为 <code>project</code> 的扩展属性时，表示一个 <code>BaseExtension</code> 子类对象；</p>\n</li>\n<li>\n<p><code>android</code> 作为 <code>project</code> 的扩展方法时，带一个闭包参数，闭包中对 <code>BaseExtension</code> 子类对象进行初始化配置。</p>\n</li>\n</ol>\n<p><code>android(configureClosure)</code> 的配置闭包中可以使用 <code>BaseExtension</code> 提供的 <code>API</code> 来配置一个 <code>Android</code> 项目。</p>\n<p>也就是说，<code>Android</code> 插件为 <code>Gradle</code> 添加的扩展中所使用的 <code>API</code> 基本上可以在 <code>BaseExtension</code> 类中找到出处：</p>\n<div><pre><code>android <span>{</span>\n    <span>/* 更多的请参考 BaseExtension 中的 API，基本上参数为 Action 的方法，都对应一个配置闭包 */</span>\n\n    compileSdkVersion  <span>'version'</span>  <span>// void compileSdkVersion(String version)</span>\n\n    buildToolsVersion <span>'version'</span>  <span>// void buildToolsVersion(String version)</span>\n\n    defaultConfig <span>{</span><span>...</span><span>}</span>  <span>// void defaultConfig(Action&lt;DefaultConfig> action), 该闭包中可以使用 DefaultConfig 的API</span>\n\n    signingConfigs <span>{</span><span>...</span><span>}</span> <span>// void signingConfigs(Action&lt;? super NamedDomainObjectContainer&lt;SigningConfig>> action)</span>\n\n    buildTypes <span>{</span><span>...</span><span>}</span>  <span>// void buildTypes(Action&lt;? super NamedDomainObjectContainer&lt;BuildType>> action)</span>\n\n    lintOptions <span>{</span><span>...</span><span>}</span>  <span>// void lintOptions(Action&lt;LintOptions> action)</span>\n\n    dexOptions <span>{</span><span>...</span><span>}</span>  <span>// void dexOptions(Action&lt;DexOptions> action)</span>\n\n    compileOptions <span>{</span><span>...</span><span>}</span>  <span>// void compileOptions(Action&lt;CompileOptions> action)</span>\n\n    sourceSets <span>{</span><span>...</span><span>}</span>  <span>// void sourceSets(Action&lt;NamedDomainObjectContainer&lt;AndroidSourceSet>> action)</span>\n\n    productFlavors <span>{</span><span>...</span><span>}</span>  <span>// void productFlavors(Action&lt;? super NamedDomainObjectContainer&lt;ProductFlavor>> action)</span>\n\n    packagingOptions <span>{</span><span>...</span><span>}</span>  <span>// void packagingOptions(Action&lt;PackagingOptions> action)</span>\n<span>}</span>\n</code></pre></div><p><strong><code>BaseExtension</code> 的继承关系如下：</strong></p>\n<div><pre><code>AndroidConfig\n—— BaseExtension\n———— TestedExtension\n—————— AppExtension\n———————— BaseAppModuleExtension\n\n参考：\n{@link com.android.build.gradle.AndroidConfig}\n{@link com.android.build.gradle.BaseExtension}\n{@link com.android.build.gradle.TestedExtension}\n{@link com.android.build.gradle.AppExtension}\n{@link com.android.build.gradle.internal.dsl.BaseAppModuleExtension}\n</code></pre></div><h3 id=\"_2-2-android-插件为-gradle-添加的-task-任务\" tabindex=\"-1\"> 2.2 <code>Android</code> 插件为 <code>Gradle</code> 添加的 <code>Task</code> 任务</h3>\n<div><pre><code>在 BaseVariant 类中定义的返回值类型为 TaskProvider&lt;T> 的方法所返回的对象就是一个封装了 Task 对象的 TaskProvider，\n调用 TaskProvider.get 方法就可以获取到 Task 对象，\n泛型 T 表示该 Task 对象的类型。\n</code></pre></div><h3 id=\"_2-3-变体-variant\" tabindex=\"-1\"> 2.3 变体（<code>Variant</code>）</h3>\n<p>变体（<code>Variant</code>）就是子 <code>Project</code> 构建生成的产物。</p>\n<p><code>android(configureClosure)</code> 的作用就是用来对变体（<code>Variant</code>）进行配置。</p>\n<blockquote>\n<p>配置不同，得到的变体（<code>Variant</code>）也不同。</p>\n<p>闭包中的配置项也都会保存在变体对象中。</p>\n</blockquote>\n<p>变体的基类是 <code>BaseVariant</code>，有如下 <code>2</code> 种变体类型：</p>\n<ol>\n<li>\n<p><code>ApplicationVariant</code></p>\n</li>\n<li>\n<p><code>LibraryVariant</code></p>\n</li>\n</ol>\n<p>变体类型不同时，<code>android(configureClosure)</code> 的作用不同：</p>\n<ol>\n<li>\n<p>当子 <code>Project</code> 是一个 <code>Android</code> 应用程序时（<code>apply plugin: 'com.android.application'</code>）</p>\n<div><pre><code>1. android(configureClosure) 配置初始化一个 AppExtension 对象\n2. 子 Project 构建生成的变体 Variant 是 ApplicationVariant\n3. 在当前 Project 中，可以通过如下方式访问所有变体：\n    this.afterEvaluate {\n        this.android.applicationVariants.all { applicationVariant ->\n            //可能的变体种类有：debug，release\n        }\n    }\n</code></pre></div></li>\n<li>\n<p>当子 <code>Project</code> 是一个 <code>Android</code> 库时（<code>apply plugin: 'com.android.library'</code>）</p>\n<div><pre><code>1. android(configureClosure) 配置初始化一个 LibraryExtension 对象\n2. 子 Project 构建生成的变体 Variant 是 LibraryVariant\n3. 在当前 Project 中，可以通过如下方式访问所有变体：\n    this.afterEvaluate {\n        this.android.libraryVariants.all { libraryVariant->\n            //可能的变体种类有：debug，release\n        }\n    }\n</code></pre></div></li>\n</ol>\n<p><strong>参考：</strong></p>\n<div><pre><code>{@link com.android.build.gradle.AppExtension#getApplicationVariants}\n{@link com.android.build.gradle.api.ApplicationVariant}\n{@link com.android.build.gradle.LibraryExtension#getLibraryVariants}\n{@link com.android.build.gradle.api.LibraryVariant}\n{@link com.android.build.gradle.api.BaseVariant}\n\nApplicationVariant 继承关系图：\n—— ApkVariant\n———— BaseVariant\n———— InstallableVariant\n———— AndroidArtifactVariant\n—————— VersionedVariant\n—— TestedVariant\n\nLibraryVariant 继承关系图：\n—— BaseVariant\n—— TestedVariant\n</code></pre></div><h4 id=\"_2-3-1-示例代码-遍历所有变体\" tabindex=\"-1\"> 2.3.1 示例代码：遍历所有变体</h4>\n<p><img src=\"@source/zkq/gradle/images/_08_plugin/04.png\" alt=\"\" loading=\"lazy\"></p>\n<p>如上代码所示：</p>\n<div><pre><code><span>this</span><span>.</span>afterEvaluate <span>{</span>\n    <span>this</span><span>.</span>android<span>.</span>applicationVariants<span>.</span>all <span>{</span>applicationVariant <span>-></span>\n        <span>/**\n         * applicationVariant 是 BaseVariant 的子类对象，所以这里可以调用 BaseVariant 的 API：\n         *      1. 调用返回 TaskProvider&lt;T> 类型的方法，可以拿到 Task 对象（泛型 T 就是 Task 对象的具体类型）\n         *         从而可以调用 Task 的 doFirst(closure) 和 doLast(closure) 往该 Task 的动作集合中添加我们自己的业务代码\n         *\n         *      2. 调用其他的一些配置属性，则可以改变生成该变体时的一些配置参数值\n         */</span>\n    <span>}</span>\n<span>}</span>\n</code></pre></div><h2 id=\"_3-java-插件\" tabindex=\"-1\"> 3. <code>Java</code> 插件</h2>\n<blockquote>\n<p>参考：<a href=\"https://docs.gradle.org/5.1.1/userguide/java_plugin.html\" target=\"_blank\" rel=\"noopener noreferrer\">The Java Plugin<ExternalLinkIcon/></a></p>\n</blockquote>\n<p><code>Java</code> 中没有变体的概念，所以 <code>Java</code> 插件中创建的 <code>Task</code> 都是唯一的，不会像 <code>Android</code> 那样，变体不同则对应有不同名称的 <code>Task</code>。</p>\n<p>如下图，给出了 <code>Java</code> 插件中的 <code>Task</code> 的依赖关系图：</p>\n<blockquote>\n<p><code>Android</code> 插件的 <code>Task</code> 也可以参考该图，不过 <code>Android</code> 插件中的 <code>Task</code> 随着变体不同而对应有不同的 <code>Task</code> 名称。</p>\n<p>并且 <code>Android</code> 插件的 <code>Task</code> 的依赖关系图比 <code>Java</code> 插件的更复杂。</p>\n</blockquote>\n<p><img src=\"@source/zkq/gradle/images/_08_plugin/05.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "date_published": "2022-10-23T14:49:16.000Z",
      "date_modified": "2022-11-24T09:38:20.000Z",
      "authors": [],
      "tags": [
        "gradle"
      ]
    },
    {
      "title": "其他",
      "url": "https://zengkaiqiang562.github.io/zkq/gradle/_09_other.html",
      "id": "https://zengkaiqiang562.github.io/zkq/gradle/_09_other.html",
      "content_html": "<h2 id=\"_1-gradle-持续集成与打包\" tabindex=\"-1\"> 1. <code>Gradle</code> 持续集成与打包</h2>\n",
      "date_published": "2022-10-23T14:49:16.000Z",
      "date_modified": "2022-10-23T14:49:16.000Z",
      "authors": [],
      "tags": [
        "gradle"
      ]
    },
    {
      "title": "gradle",
      "url": "https://zengkaiqiang562.github.io/zkq/gradle/",
      "id": "https://zengkaiqiang562.github.io/zkq/gradle/",
      "content_html": "",
      "date_published": "2022-10-23T14:49:16.000Z",
      "date_modified": "2022-10-23T14:49:16.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "基础语法",
      "url": "https://zengkaiqiang562.github.io/zkq/gradle/_02_grammar/_01_basic.html",
      "id": "https://zengkaiqiang562.github.io/zkq/gradle/_02_grammar/_01_basic.html",
      "content_html": "<h2 id=\"_1-变量\" tabindex=\"-1\"> 1. 变量</h2>\n<h3 id=\"_1-1-变量类型-基本类型-对象类型\" tabindex=\"-1\"> 1.1 变量类型：基本类型 &amp; 对象类型</h3>\n<p><code>Groovy</code> 中的变量类型分为 <strong>基本类型</strong> 和 <strong>对象类型</strong>。</p>\n<p><strong>注意：</strong> <code>Groovy</code> 中的基本类型最终会被自动装箱成对象类型，因此，<code>Groovy</code> 中的变量类型最终都是一个对象类型。如下图所示：</p>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_01_basic/01.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>如上图，把源文件中的 <code>class</code> 类定义删掉，<code>src</code> 目录下的源文件图标就会由 &quot;<code>C</code>&quot; 变为 &quot;<code>G</code>&quot; ，并且显示出源文件的后缀名，</p>\n<p>此时，相当于把 <code>variablestudy.groovy</code> 作为了一个脚本文件。</p>\n</blockquote>\n<h3 id=\"_1-2-变量定义-强类型定义-弱类型定义-def\" tabindex=\"-1\"> 1.2 变量定义：强类型定义 &amp; 弱类型定义（<code>def</code>）</h3>\n<p><code>Groovy</code> 中的变量定义分为 <strong>强类型定义</strong> 和 <strong>弱类型定义</strong>：</p>\n<ol>\n<li>\n<p>强类型定义就像 <code>Java</code> 那样指定变量的具体类型；</p>\n</li>\n<li>\n<p>弱类型定义就是用 <code>def</code> 关键字代替变量的具体类型。</p>\n</li>\n</ol>\n<p><strong>两种变量定义方式的使用场景：</strong></p>\n<ol>\n<li>\n<p>当变量只在模块内部自己使用时，采用弱类型定义，方便变量类型的转换；</p>\n</li>\n<li>\n<p>当变量要传给其他模块时，为了避免调用方由于不知道变量类型而产生疑惑，应该采用强类型定义，明确变量类型。</p>\n</li>\n</ol>\n<p><strong>弱类型定义的特点：</strong></p>\n<ol>\n<li>\n<p>弱类型 <code>def</code> 定义变量时，根据变量的初始值，编译器自动推断变量的具体类型；</p>\n</li>\n<li>\n<p>弱类型定义变量时，可以方便的转换变量类型。</p>\n<blockquote>\n<p>变量采用弱类型定义时，可以将变量类型理解为基类 <code>Object</code>，</p>\n<p>因为 <code>Groovy</code> 中的变量类型最终都是对象类型，所以 <code>Object</code> 类型的变量可以接收任意类型的数据（多态）。</p>\n</blockquote>\n</li>\n</ol>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_01_basic/02.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_2-字符串\" tabindex=\"-1\"> 2. 字符串</h2>\n<p><code>Groovy</code> 中既支持 <code>Java</code> 中的 <code>String</code> 类型的字符串，又另外定义了一个 <code>Groovy</code> 特有的 <code>GString</code> 类型的字符串。</p>\n<h3 id=\"_2-1-字符串的三种定义方式-单引号定义、双引号定义、三引号定义\" tabindex=\"-1\"> 2.1 字符串的三种定义方式：单引号定义、双引号定义、三引号定义</h3>\n<p><strong>单引号定义：</strong> 跟 <code>Java</code> 中的双引号定义一致，又称为不可变字符串。</p>\n<p><strong>双引号定义：</strong> 字符串中可以包含变量。包含变量的字符串又称为可变字符串。</p>\n<p><strong>三引号定义：</strong> 字符串是什么样就打印出什么样。如：可以直接定义多行字符串，不用像 <code>Java</code> 那样用 &quot;<code>+</code>&quot; 号拼接。</p>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_01_basic/03.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>如上图所示，三种定义方式中都支持转义字符。</p>\n</blockquote>\n<h3 id=\"_2-2-三引号字符串可不通过转义字符实现换行-原样输出\" tabindex=\"-1\"> 2.2 三引号字符串可不通过转义字符实现换行（原样输出）</h3>\n<p>采用单引号或双引号定义字符串时，如果不采用转义字符 <code>\\n</code> 则无法实现换行。</p>\n<p>而采用三引号定义字符串，则可以原样输出，实现换行：</p>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_01_basic/04.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_2-3-双引号定义可扩展的字符串-变量名-表达式\" tabindex=\"-1\"> 2.3 双引号定义可扩展的字符串：<code>${&lt;变量名&gt;/&lt;表达式&gt;}</code></h3>\n<p>采用双引号定义字符串时，可以通过 <code>${变量名}</code> 的形式向字符串中插入变量，实现可扩展的字符串。</p>\n<p><strong>注意：</strong></p>\n<ol>\n<li>\n<p>当字符串中使用了 <code>${变量名}</code> 插入变量后，编译器将此字符串推断为 <code>GString</code> 类型的字符串，而不再是 <code>String</code> 类型。</p>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_01_basic/05.png\" alt=\"\" loading=\"lazy\"></p>\n</li>\n<li>\n<p>在双引号定义的字符串中，<code>${}</code> 中不仅可以是一个变量名，还可以是一个表达式，即 <code>${表达式}</code></p>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_01_basic/06.png\" alt=\"\" loading=\"lazy\"></p>\n</li>\n</ol>\n<h3 id=\"_2-4-gstring-和-string-的转换\" tabindex=\"-1\"> 2.4 <code>GString</code> 和 <code>String</code> 的转换</h3>\n<p><code>GString</code> 类型的字符串可以直接转换为 <code>String</code> 类型的字符串，但 <code>String</code> 类型的字符串不能直接转换为 <code>GString</code> 类型的字符串。</p>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_01_basic/07.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_2-5-字符串相关的-api\" tabindex=\"-1\"> 2.5 字符串相关的 <code>API</code></h3>\n<p>在 <code>Groovy</code> 中，<code>String</code> 类型的变量除了能够使用 <code>java.lang.String</code> 类提供的 <code>API</code>，还可以使用 <code>Groovy</code> 特有的 <code>DefaultGroovyMethods</code> 类和 <code>StringGroovyMethods</code> 类提供的 API。</p>\n<p>其中 <code>StringGroovyMethods</code> 继承自 <code>DefaultGroovyMethods</code>，重点学习 <code>StringGroovyMethods</code> 提供的 <code>API</code>。</p>\n<p>可以将 <code>StringGroovyMethods</code> 中的 <code>API</code> 方法分为两大类：</p>\n<ol>\n<li>\n<p>方法参数为普通类型的方法；</p>\n</li>\n<li>\n<p>方法参数为闭包类型的方法（在闭包中进行讲解）。</p>\n</li>\n</ol>\n<blockquote>\n<p><strong>注意：</strong> <code>GString</code> 类型的字符串变量也可以使用 <code>DefaultGroovyMethods</code> 和 <code>StringGroovyMethods</code> 提供的 <code>API</code> 方法。</p>\n</blockquote>\n<h4 id=\"_2-5-1-字符串填充-center-padleft\" tabindex=\"-1\"> 2.5.1 字符串填充：<code>center</code> &amp; <code>padLeft</code></h4>\n<div><pre><code><span>center</span><span>(</span>Number numberOfChars<span>,</span> CharSequence padding<span>)</span>\n</code></pre></div><div><pre><code>作用：使用子串 padding 填充字符串两侧，得到长度为 numberOfChars 的目标字符串。\n注意：长度 numberOfChars &lt;= 字符串的长度时，字符串不变。\n</code></pre></div><div><pre><code><span>padLeft</span><span>(</span>Number numberOfChars<span>,</span> CharSequence padding<span>)</span>\n</code></pre></div><div><pre><code>作用：使用子串 padding 填充字符串左侧，得到长度为 numberOfChars 的目标字符串。\n</code></pre></div><p><img src=\"@source/zkq/gradle/_02_grammar/images/_01_basic/08.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_2-5-2-字符串相关的运算符-比较运算符、下标运算符、减法运算符\" tabindex=\"-1\"> 2.5.2 字符串相关的运算符：比较运算符、下标运算符、减法运算符</h4>\n<p><code>Groovy</code> 为字符串提供的运算符及相对应的 <code>API</code> 方法：</p>\n<ol>\n<li>\n<p><code>Groovy</code> 中支持使用比较运算符，对字符串进行逐字符的 <code>ASCII</code> 码比较；</p>\n<blockquote>\n<p>作用同 <code>java.lang.String</code> 提供的方法 <code>compareTo</code></p>\n</blockquote>\n</li>\n<li>\n<p><code>Groovy</code> 中支持使用下标运算符 &quot;<code>[]</code>&quot; 获取字符串中指定索引处的字符；</p>\n<blockquote>\n<p>作用同 <code>java.lang.String</code> 提供的方法 <code>charAt</code></p>\n</blockquote>\n</li>\n<li>\n<p><code>Groovy</code> 中支持使用下标运算符 &quot;<code>[beginIndex...endIndex]</code>&quot; 获取字符串中索引范围内（首尾包含）的子串；</p>\n<blockquote>\n<p>作用同 <code>java.lang.String</code> 提供的方法 <code>substring(int beginIndex, int endIndex)</code>（包含首，不包含尾）</p>\n</blockquote>\n</li>\n<li>\n<p><code>Groovy</code> 中支持使用减法运算符，将作为被减数的子串从字符串中移除。</p>\n<blockquote>\n<p>作用同 <code>StringGroovyMethods</code> 提供的方法 <code>minus</code>。</p>\n<p>注意：</p>\n<ol>\n<li>\n<p>只移除从左到右遇到的第一个匹配的子串</p>\n</li>\n<li>\n<p>字符串中不包含子串时，返回的字符串不变</p>\n</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_01_basic/09.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_2-5-3-反转字符串-reverse\" tabindex=\"-1\"> 2.5.3 反转字符串：<code>reverse()</code></h4>\n<h4 id=\"_2-5-4-字符串首字母大写-capitalizee\" tabindex=\"-1\"> 2.5.4 字符串首字母大写：<code>capitalizee()</code></h4>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_01_basic/10.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_2-5-5-判断字符串是否为数字-isnumbere\" tabindex=\"-1\"> 2.5.5 判断字符串是否为数字：<code>isNumbere()</code></h4>\n<h4 id=\"_2-5-6-字符串转数字类型-tointeger-、tofloat-、\" tabindex=\"-1\"> 2.5.6 字符串转数字类型：<code>toInteger()</code>、<code>toFloat()</code>、...</h4>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_01_basic/11.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_3-逻辑控制语句\" tabindex=\"-1\"> 3. 逻辑控制语句</h2>\n<p><code>Groovy</code> 对 <code>switch</code> 条件语句做了的扩展；对一些特殊数据结构的 <code>for</code> 循环也做了扩展。</p>\n<p>而对于顺序语句，<code>if/else</code> 条件语句，<code>while</code> 循环语句，同 <code>Java</code> 中的使用方式一致。</p>\n<h3 id=\"_3-1-groovy-对-switch-语句的扩展\" tabindex=\"-1\"> 3.1 <code>Groovy</code> 对 <code>switch</code> 语句的扩展</h3>\n<ol>\n<li>\n<p><code>switch</code> 语句可以接收任意类型的变量。包括 <code>var.class</code> 这种 <code>Class</code> 类型的字节码对象；</p>\n</li>\n<li>\n<p>如果 <code>case</code> 为列表类型，那么当 <code>switch</code> 传入的变量匹配列表中的元素时，就意味着匹配该 <code>case</code>。</p>\n</li>\n</ol>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_01_basic/12.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_3-2-groovy-对-for-循环语句的扩展\" tabindex=\"-1\"> 3.2 <code>Groovy</code> 对 <code>for</code> 循环语句的扩展</h3>\n<p><code>Groovy</code> 对范围类型 <code>Range</code>、列表类型 <code>List</code>、映射类型 <code>Map</code> 的 <code>for</code> 循环进行了扩展。</p>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_01_basic/13.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "date_published": "2022-10-23T14:49:16.000Z",
      "date_modified": "2022-10-23T14:49:16.000Z",
      "authors": [],
      "tags": [
        "gradle"
      ]
    },
    {
      "title": "闭包讲解",
      "url": "https://zengkaiqiang562.github.io/zkq/gradle/_02_grammar/_02_closure.html",
      "id": "https://zengkaiqiang562.github.io/zkq/gradle/_02_grammar/_02_closure.html",
      "content_html": "<h2 id=\"_1-闭包基础\" tabindex=\"-1\"> 1. 闭包基础</h2>\n<h3 id=\"_1-1-什么是闭包\" tabindex=\"-1\"> 1.1 什么是闭包？</h3>\n<p>闭包（<code>closure</code>）其实就是一个代码块，作用类似于函数。</p>\n<h3 id=\"_1-2-闭包的定义与调用\" tabindex=\"-1\"> 1.2 闭包的定义与调用</h3>\n<p>闭包的定义和闭包的调用如下图：</p>\n<blockquote>\n<p>可以发现 <code>groovy.lang.Closure</code> 是闭包基类。</p>\n</blockquote>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_02_closure/01.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_1-3-闭包的参数\" tabindex=\"-1\"> 1.3 闭包的参数</h3>\n<h4 id=\"_1-3-1-带普通参数的闭包\" tabindex=\"-1\"> 1.3.1 带普通参数的闭包</h4>\n<p>带普通参数的闭包的定义方式：</p>\n<div><pre><code><span>def</span> closure <span>=</span> <span>{</span> T1 t1<span>,</span> T2 t2<span>,</span> T3 t3<span>,</span> <span>...</span> <span>-></span> 执行语句 <span>}</span>\n</code></pre></div><p>带普通参数的闭包的调用方式：</p>\n<div><pre><code>closure<span>.</span><span>call</span><span>(</span>v1<span>,</span> v2<span>,</span> v3<span>,</span> <span>...</span><span>)</span>\n<span>closure</span><span>(</span>v1<span>,</span> v2<span>,</span> v3<span>,</span> <span>...</span><span>)</span>\n</code></pre></div><h4 id=\"_1-3-2-带隐式参数的闭包\" tabindex=\"-1\"> 1.3.2 带隐式参数的闭包</h4>\n<p>当定义闭包时，如果没有显示定义闭包参数，那么闭包中默认会存在一个名为 <code>it</code> 的隐式参数。</p>\n<blockquote>\n<p>如果显示定义了参数，那么隐式参数 <code>it</code> 就不存在了。</p>\n</blockquote>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_02_closure/02.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_1-4-闭包的返回值\" tabindex=\"-1\"> 1.4 闭包的返回值</h3>\n<p>如下图代码：</p>\n<div><pre><code>1. 从 closure2 中可以发现：闭包一定有返回值，就算没有写 return 语句也返回 null；\n2. 结合 closure3 和 closure4 可以发现：闭包的返回值就是最后一条执行语句结果值，如果最后一条执行语句没有结果值，就返回 null。\n</code></pre></div><p><img src=\"@source/zkq/gradle/_02_grammar/images/_02_closure/03.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_2-闭包的使用\" tabindex=\"-1\"> 2. 闭包的使用</h2>\n<h3 id=\"_2-1-与基本类型结合使用\" tabindex=\"-1\"> 2.1 与基本类型结合使用</h3>\n<h4 id=\"_2-1-1-闭包作为函数参数-递增函数-upto-number-closure\" tabindex=\"-1\"> 2.1.1 闭包作为函数参数 &amp; 递增函数：<code>upto(Number, Closure)</code></h4>\n<div><pre><code>Number<span>.</span><span>upto</span><span>(</span>Number<span>,</span> Closure<span>)</span>\n</code></pre></div><div><pre><code>实现从调用者 Number 到参数 Number 的循环递增，循环因子作为闭包 Closure 的参数。\n</code></pre></div><p><img src=\"@source/zkq/gradle/_02_grammar/images/_02_closure/04.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_2-1-2-闭包写在-后面-递减函数-downto-number-closure\" tabindex=\"-1\"> 2.1.2 闭包写在 &quot;<code>()</code>&quot; 后面 &amp; 递减函数：<code>downto(Number, Closure)</code></h4>\n<p>当闭包作为其他函数的最后一个参数时，在调用这个函数时，可以把最后的实参闭包写在函数调用运算符 &quot;<code>()</code>&quot; 的后面。如下图代码所示：</p>\n<div><pre><code>Number<span>.</span><span>downto</span><span>(</span>Number<span>,</span> Closure<span>)</span>\n</code></pre></div><div><pre><code> 实现从调用者 Number 到参数 Number 的循环递减，循环因子作为闭包 Closure 的参数。\n</code></pre></div><p><img src=\"@source/zkq/gradle/_02_grammar/images/_02_closure/05.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_2-1-3-如何确定实参闭包中的参数个数和参数类型\" tabindex=\"-1\"> 2.1.3 如何确定实参闭包中的参数个数和参数类型</h4>\n<p>通过查看带参数闭包的函数的源码来确定参数闭包在函数体中执行时所接收的参数个数和参数类型。</p>\n<h4 id=\"_2-1-4-实参闭包中可省略参数类型-递增函数-times-closure\" tabindex=\"-1\"> 2.1.4 实参闭包中可省略参数类型 &amp; 递增函数：<code>times(Closure)</code></h4>\n<div><pre><code>Number<span>.</span><span>times</span><span>(</span>Closure<span>)</span>\n</code></pre></div><div><pre><code>从 0 到调用者 Number-1 循环递增，循环因子作为闭包参数。\n</code></pre></div><p><img src=\"@source/zkq/gradle/_02_grammar/images/_02_closure/06.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>注意：在定义实参闭包时，可以省略闭包参数的类型。</p>\n</blockquote>\n<h3 id=\"_2-2-与-string-结合使用\" tabindex=\"-1\"> 2.2 与 <code>String</code> 结合使用</h3>\n<h4 id=\"_2-2-1-遍历字符串中的字符-each-closure\" tabindex=\"-1\"> 2.2.1 遍历字符串中的字符：<code>each(Closure)</code></h4>\n<div><pre><code>String str<span>.</span><span>each</span><span>(</span>Closure<span>)</span>\n</code></pre></div><div><pre><code>作用： 遍历调用字符串 str 的每个字符，将每次遍历到的字符作为闭包参数传给闭包处理。\n返回值：返回调用字符串 str 本身。\n注意：每次遍历得到的字符实际是作为 java.lang.String 类型处理的。\n</code></pre></div><h4 id=\"_2-2-2-字符串多次拼接-multiply-number\" tabindex=\"-1\"> 2.2.2 字符串多次拼接：<code>multiply(Number)</code></h4>\n<div><pre><code>String str<span>.</span><span>multiply</span><span>(</span>Number<span>)</span>\n</code></pre></div><div><pre><code>作用：将 Number 个调用字符串 str 拼接成一个字符串返回，如：\"hello\".multiply(2) 返回 \"hellohello\"\n</code></pre></div><p><img src=\"@source/zkq/gradle/_02_grammar/images/_02_closure/07.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_2-2-3-字符串中查找某个字符-find-closure\" tabindex=\"-1\"> 2.2.3 字符串中查找某个字符：<code>find(Closure)</code></h4>\n<div><pre><code>String str<span>.</span><span>find</span><span>(</span>Closure<span>)</span>\n</code></pre></div><div><pre><code>作用：\n    遍历调用字符串 str 的每个字符，将每次遍历到的字符作为闭包参数传给闭包处理。\n    闭包必须返回一个布尔值，用于判断当前传入的字符是否是我们要查找的。\n    当闭包返回 true，那么当前遍历到的字符就作为 find 方法的返回值。\n\n注意：\n    遍历到的字符实际是作为 java.lang.String 类型处理的。\n</code></pre></div><p><img src=\"@source/zkq/gradle/_02_grammar/images/_02_closure/08.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_2-2-4-字符串中查找某些字符-findall-closure\" tabindex=\"-1\"> 2.2.4 字符串中查找某些字符：<code>findAll(Closure)</code></h4>\n<div><pre><code>java<span>.</span>util<span>.</span>Collection str<span>.</span><span>findAll</span><span>(</span>Closure<span>)</span>\n</code></pre></div><div><pre><code>作用：\n    遍历调用字符串 str 的每个字符，将每次遍历到的字符作为闭包参数传给闭包处理。\n    闭包必须返回一个布尔值，用于判断当前传入的字符是否是我们要查找的。\n    当闭包返回 true，那么当前遍历到的字符放入到一个创建好的集合中，当全部遍历完毕后，返回这个集合。\n\n注意：\n    遍历到的字符实际是作为 java.lang.String 类型处理的。\n</code></pre></div><h4 id=\"_2-2-5-集合元素拼接成字符串-toliststring\" tabindex=\"-1\"> 2.2.5 集合元素拼接成字符串：<code>toListString()</code></h4>\n<div><pre><code>String collection<span>.</span><span>toListString</span><span>(</span><span>)</span>\n</code></pre></div><div><pre><code>作用： 将集合元素拼接成字符串 \"[ele1, ele2, ele3, ...]\" 的形式返回\n</code></pre></div><p><img src=\"@source/zkq/gradle/_02_grammar/images/_02_closure/09.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_2-2-6-判断字符串中的任一字符是否满足条件-any-closure\" tabindex=\"-1\"> 2.2.6 判断字符串中的任一字符是否满足条件：<code>any(Closure)</code></h4>\n<div><pre><code><span>boolean</span> str<span>.</span><span>any</span><span>(</span>Closure<span>)</span>\n</code></pre></div><div><pre><code>作用： \n    遍历字符串 str 中的每个字符，将字符作为参数交给闭包处理。\n    闭包必须返回布尔值，用于判断参数字符是否满足某种需求。\n    只要字符串 str 中有一个字符满足闭包中的业务需求，则方法 any 返回 true；否则返回 false。\n</code></pre></div><h4 id=\"_2-2-7-判断字符串中的所有字符是否满足条件-every-closure\" tabindex=\"-1\"> 2.2.7 判断字符串中的所有字符是否满足条件：<code>every(Closure)</code></h4>\n<div><pre><code><span>boolean</span> str<span>.</span><span>every</span><span>(</span>Closure<span>)</span>\n</code></pre></div><div><pre><code>作用： \n    遍历字符串 str 中的每个字符，将字符作为参数交给闭包处理。\n    闭包必须返回布尔值，用于判断参数字符是否满足某种需求。\n    当字符串 str 中所有的字符都满足闭包中的业务需求时，则方法 every 返回 true；否则返回 false。\n</code></pre></div><p><img src=\"@source/zkq/gradle/_02_grammar/images/_02_closure/10.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_2-2-8-返回根据字符串中字符转换成的集合-collect-closure\" tabindex=\"-1\"> 2.2.8 返回根据字符串中字符转换成的集合：<code>collect(Closure)</code></h4>\n<div><pre><code>List str<span>.</span><span>collect</span><span>(</span>Closure<span>)</span>\n</code></pre></div><div><pre><code>作用：\n    遍历 str 中的每个字符，将字符作为参数传给闭包处理。\n    闭包处理后，根据业务需求返回某种类型的数据，然后将闭包返回的数据存入一个创建好的集合中，collect 执行完毕后返回该集合。\n</code></pre></div><p><img src=\"@source/zkq/gradle/_02_grammar/images/_02_closure/11.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_2-3-与数据结构结合使用\" tabindex=\"-1\"> 2.3 与数据结构结合使用</h3>\n<blockquote>\n<p>在讲数据结构时讲解。</p>\n</blockquote>\n<h3 id=\"_2-4-与文件等结合使用\" tabindex=\"-1\"> 2.4 与文件等结合使用</h3>\n<blockquote>\n<p>与文件的结合使用在讲文件时讲解。</p>\n</blockquote>\n<h2 id=\"_3-闭包进阶\" tabindex=\"-1\"> 3. 闭包进阶</h2>\n<h3 id=\"_3-1-闭包中的三个重要变量-this、owner、delegate\" tabindex=\"-1\"> 3.1 闭包中的三个重要变量：<code>this</code>、<code>owner</code>、<code>delegate</code></h3>\n<p><strong><code>this</code></strong></p>\n<div><pre><code>代表闭包定义处的类或类对象\n（闭包作为静态变量时，this 代表类；闭包作为非静态变量时，this 代表类对象）\n</code></pre></div><p><strong><code>owner</code></strong></p>\n<div><pre><code>当闭包在类中定义时，代表类或类对象。\n当闭包在类中的其他闭包中定义时，代表其他闭包对象（如：当闭包嵌套定义时，内层闭包的 owner 就是外层闭包对象）\n</code></pre></div><p><strong><code>delegate</code></strong></p>\n<div><pre><code>可以是任意对象，默认情况下同 owner\n</code></pre></div><p><img src=\"@source/zkq/gradle/_02_grammar/images/_02_closure/12.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>注意：</strong> 只能修改 <code>delegate</code>，不能手动修改 <code>this</code> 和 <code>owner</code>。</p>\n<h4 id=\"_3-1-1-静态闭包中的-this-代表类-非静态闭包中的-this-代表类对象\" tabindex=\"-1\"> 3.1.1 静态闭包中的 <code>this</code> 代表类；非静态闭包中的 <code>this</code> 代表类对象</h4>\n<p>闭包作为静态变量时 <code>this</code> 代表类；闭包作为非静态变量时 <code>this</code> 代表类对象。</p>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_02_closure/14.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_3-1-2-闭包嵌套定义时内层闭包的-owner-就是外层闭包对象\" tabindex=\"-1\"> 3.1.2 闭包嵌套定义时内层闭包的 <code>owner</code> 就是外层闭包对象</h4>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_02_closure/13.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_3-1-3-在调用闭包前可以将闭包的-delegate-变量设置为其他任意对象\" tabindex=\"-1\"> 3.1.3 在调用闭包前可以将闭包的 <code>delegate</code> 变量设置为其他任意对象</h4>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_02_closure/15.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_3-2-闭包的委托策略\" tabindex=\"-1\"> 3.2 闭包的委托策略</h3>\n<h4 id=\"_3-2-1-闭包的委托对象\" tabindex=\"-1\"> 3.2.1 闭包的委托对象</h4>\n<p>闭包中的 <code>owner</code> 和 <code>delegate</code> 变量指定的对象就是闭包的委托对象。</p>\n<p>闭包中可以直接访问委托对象的成员方法和成员属性。</p>\n<h4 id=\"_3-2-2-闭包的委托策略包括两个方面\" tabindex=\"-1\"> 3.2.2 闭包的委托策略包括两个方面</h4>\n<h5 id=\"_3-2-2-1-修改闭包的-delegate-变量\" tabindex=\"-1\"> 3.2.2.1 修改闭包的 <code>delegate</code> 变量</h5>\n<p>通过修改闭包的 <code>delegate</code> 变量来指定的委托对象。</p>\n<h5 id=\"_3-2-2-2-修改闭包的委托策略方式\" tabindex=\"-1\"> 3.2.2.2 修改闭包的委托策略方式</h5>\n<p>通过修改闭包的委托策略方式，从而改变由哪个委托对象来提供闭包中访问的成员属性或成员方法。</p>\n<h4 id=\"_3-2-3-closure-类中定义的几种委托方式\" tabindex=\"-1\"> 3.2.3 <code>Closure</code> 类中定义的几种委托方式</h4>\n<h5 id=\"_3-2-3-1-closure-owner-first-默认方式\" tabindex=\"-1\"> 3.2.3.1 <code>Closure.OWNER_FIRST</code>（默认方式）</h5>\n<p>闭包执行时，闭包中所访问的成员属性或成员方法先从 <code>owner</code> 变量指定的委托对象中查找；</p>\n<p>查找不到，再从 <code>delegate</code> 变量指定的委托对象中查看；</p>\n<p>再查找不到则报错，提示找不到所访问的成员属性或成员方法。</p>\n<h5 id=\"_3-2-3-2-closure-delegate-first\" tabindex=\"-1\"> 3.2.3.2 <code>Closure.DELEGATE_FIRST</code></h5>\n<p>闭包执行时，闭包中所访问的成员属性或成员方法先从 <code>delegate</code> 变量指定的委托对象中查找；</p>\n<p>查找不到，再从 <code>owner</code> 变量指定的委托对象中查找；</p>\n<p>再查找不到则报错，提示找不到所访问的成员属性或成员方法。</p>\n<h5 id=\"_3-2-3-3-closure-owner-only\" tabindex=\"-1\"> 3.2.3.3 <code>Closure.OWNER_ONLY</code></h5>\n<p>闭包执行时，闭包中所访问的成员属性或成员方法仅从 <code>owner</code> 变量指定的委托对象中查找；</p>\n<p>查找不到则报错，提示找不到所访问的成员属性或成员方法。</p>\n<h5 id=\"_3-2-3-4-closure-delegate-only\" tabindex=\"-1\"> 3.2.3.4 <code>Closure.DELEGATE_ONLY</code></h5>\n<p>闭包执行时，闭包中所访问的成员属性或成员方法仅从 <code>delegate</code> 变量指定的委托对象中查找；</p>\n<p>查找不到则报错，提示找不到所访问的成员属性或成员方法。</p>\n<h5 id=\"_3-2-3-5-closure-to-self-了解即可\" tabindex=\"-1\"> 3.2.3.5 <code>Closure.TO_SELF</code>（了解即可）</h5>\n<p>闭包执行时，闭包中所访问的成员属性或成员方法不直接从 <code>owner</code> 变量和 <code>delegate</code> 变量指定的委托对象中查找；</p>\n<p>而是从 <code>MetaClass</code> 对象中查找。</p>\n<h4 id=\"_3-2-4-设置闭包的委托策略方式\" tabindex=\"-1\"> 3.2.4 设置闭包的委托策略方式</h4>\n<p>通过形如 <code>closure.resolveStrategy = Closure.DELEGATE_FIRST</code> 的方式来设置闭包的委托策略方式。</p>\n<p><strong>注意：</strong> 从下一次调用闭包开始生效。</p>\n<h4 id=\"_3-2-5-闭包中的局部变量与委托对象的成员变量同名时采用就近原则\" tabindex=\"-1\"> 3.2.5 闭包中的局部变量与委托对象的成员变量同名时采用就近原则</h4>\n<p><strong>注意：</strong> 当闭包中访问的成员属性和闭包中定义的局部变量同名时，采用就近原则，即此时访问的应该是闭包中的局部变量。</p>\n<h4 id=\"_3-2-6-代码示例\" tabindex=\"-1\"> 3.2.6 代码示例</h4>\n<h5 id=\"_3-2-6-1-修改-delegate-并设置委托方式为-delegate-first\" tabindex=\"-1\"> 3.2.6.1 修改 <code>delegate</code> 并设置委托方式为 <code>DELEGATE_FIRST</code></h5>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_02_closure/16.png\" alt=\"\" loading=\"lazy\"></p>\n<h5 id=\"_3-2-6-2-修改-delegate-并设置委托方式为-delegate-only\" tabindex=\"-1\"> 3.2.6.2 修改 <code>delegate</code> 并设置委托方式为 <code>DELEGATE_ONLY</code></h5>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_02_closure/17.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "date_published": "2022-10-23T14:49:16.000Z",
      "date_modified": "2022-10-24T12:05:04.000Z",
      "authors": [],
      "tags": [
        "gradle"
      ]
    },
    {
      "title": "数据结构",
      "url": "https://zengkaiqiang562.github.io/zkq/gradle/_02_grammar/_03_datastructure.html",
      "id": "https://zengkaiqiang562.github.io/zkq/gradle/_02_grammar/_03_datastructure.html",
      "content_html": "<h2 id=\"_1-列表-list\" tabindex=\"-1\"> 1. 列表（<code>List</code>）</h2>\n<h3 id=\"_1-1-列表的定义方式\" tabindex=\"-1\"> 1.1 列表的定义方式</h3>\n<p><code>Groovy</code> 中有两种定义列表的方式：</p>\n<ol>\n<li>\n<p>采用 <code>java</code> 中的方式创建列表对象</p>\n</li>\n<li>\n<p><code>Groovy</code> 特有的方式定义列表</p>\n<div><pre><code><span>def</span> list <span>=</span> <span>[</span><span>]</span> <span>// 定义空列表</span>\n<span>def</span> list <span>=</span> <span>[</span>e1<span>,</span> e2<span>,</span> e3<span>,</span> <span>...</span><span>]</span> <span>// 定义带初始元素的列表</span>\n</code></pre></div></li>\n</ol>\n<p><strong>注意：</strong></p>\n<ol>\n<li>\n<p><code>Groovy</code> 中定义的列表类型就是 <code>java</code> 中的 <code>java.util.ArrayList</code> 类型；</p>\n</li>\n<li>\n<p><code>Groovy</code> 中的列表可以存储不同类型的元素，实际上就是 <code>ArrayList</code> 中存储 <code>Object</code> 类型的元素；</p>\n</li>\n</ol>\n<h3 id=\"_1-2-数组的定义方式\" tabindex=\"-1\"> 1.2 数组的定义方式</h3>\n<p><code>Groovy</code> 中定义列表就好像定义数组一样，那么 <code>Groovy</code> 中如何定义数组呢？</p>\n<div><pre><code><span>/* 方式 1 */</span>\n<span>def</span> arr <span>=</span> <span>[</span>e1<span>,</span> e2<span>,</span> e3<span>,</span> <span>...</span><span>]</span> <span>as</span> T<span>[</span><span>]</span>  <span>// 通过 关键字 as 将列表转为数组</span>\n\n<span>/* 方式 2  */</span>\nT<span>[</span><span>]</span> arr <span>=</span> <span>[</span>e1<span>,</span> e2<span>,</span> e3<span>,</span> <span>...</span><span>]</span>         <span>// 显示指定变量为数组类型</span>\n</code></pre></div><p><img src=\"@source/zkq/gradle/_02_grammar/images/_03_datastructure/01.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_1-2-列表相关操作的-api\" tabindex=\"-1\"> 1.2 列表相关操作的 <code>API</code></h3>\n<h4 id=\"_1-2-1-排序-sort-self-closure\" tabindex=\"-1\"> 1.2.1 排序：<code>sort(self, closure)</code></h4>\n<h5 id=\"_1-2-1-1-两种排序方式\" tabindex=\"-1\"> 1.2.1.1 两种排序方式</h5>\n<p><strong>方式一：</strong> 采用 <code>java</code> 的方式进行排序；</p>\n<p><strong>方式二：</strong> 采用 <code>DefaultGroovyMethods</code> 提供的如下两个方法进行排序：</p>\n<div><pre><code><span>static</span> <span>&lt;</span>T<span>></span> List<span>&lt;</span>T<span>></span> <span>sort</span><span>(</span>Iterable<span>&lt;</span>T<span>></span> self<span>)</span>\n</code></pre></div><div><pre><code>作用：对 self 中的元素本身进行自然排序。\n参数：参数 self 是调用者本身，不需要手动传参。\n</code></pre></div><div><pre><code><span>static</span> <span>&lt;</span>T<span>></span> List<span>&lt;</span>T<span>></span> <span>sort</span><span>(</span>Iterable<span>&lt;</span>T<span>></span> self<span>,</span> Closure closure<span>)</span>\n</code></pre></div><div><pre><code>作用：按自定义规则排序。\n参数：\n    self 是调用者本身，不需要手动传参\n    closure 用于定义比较规则，闭包参数类型为可变参数，可以传入一个元素，也可以传入两个元素：\n        当传入一个元素时：\n            按照闭包的返回结果进行自然排序\n        当传入两个元素时：\n            返回 0 表示 参数1元素 = 参数2元素\n            返回-1 表示 参数1元素 &lt; 参数2元素\n            返回 1 表示 参数1元素 > 参数2元素\n</code></pre></div><h5 id=\"_1-2-1-2-示例一-java-方式与-groovy-方式\" tabindex=\"-1\"> 1.2.1.2 示例一：<code>Java</code> 方式与 <code>Groovy</code> 方式</h5>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_03_datastructure/02.png\" alt=\"\" loading=\"lazy\"></p>\n<h5 id=\"_1-2-1-3-示例二-sort-self-closure-中参数-closure-传入一个元素\" tabindex=\"-1\"> 1.2.1.3 示例二：<code>sort(self, closure)</code> 中参数 <code>closure</code> 传入一个元素</h5>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_03_datastructure/03.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_1-2-2-查找\" tabindex=\"-1\"> 1.2.2 查找</h4>\n<p>采用 <code>DefaultGroovyMethods</code> 提供的方法进行查找。</p>\n<h5 id=\"_1-2-2-1-查找满足条件的某个元素-find-self-closure\" tabindex=\"-1\"> 1.2.2.1 查找满足条件的某个元素：<code>find(self, closure)</code></h5>\n<div><pre><code><span>static</span> <span>&lt;</span>T<span>></span> T <span>find</span><span>(</span>Collection<span>&lt;</span>T<span>></span> self<span>,</span> Closure closure<span>)</span>\n</code></pre></div><div><pre><code>作用：\n    按照参数闭包定义的查找规则，从左往右查找满足规则的元素，\n    只要找到一个即可结束查找，并返回查找到的元素。\n参数：\n    self 指调用者本身，不需要传参；\n    closure 是一个用来定义查找规则的闭包，将当前遍历到的列表元素作为闭包参数，返回布尔值表示当前元素是否满足查找规则。\n返回值：\n    返回第一个查找到的元素；没查找到则返回 null。\n</code></pre></div><h5 id=\"_1-2-2-2-查找满足条件的某些元素-findall-self-closure\" tabindex=\"-1\"> 1.2.2.2 查找满足条件的某些元素：<code>findAll(self, closure)</code></h5>\n<div><pre><code><span>static</span> <span>&lt;</span>T<span>></span> List<span>&lt;</span>T<span>></span> <span>findAll</span><span>(</span>List<span>&lt;</span>T<span>></span> self<span>,</span> Closure closure<span>)</span>\n</code></pre></div><div><pre><code>作用：\n    按照参数闭包定义的查找规则，从左往右查找满足规则的元素，\n    将所有查找到的元素存入一个创建好的新列表中。\n参数：\n    self 指调用者本身，不需要传参；\n    closure 是一个用来定义查找规则的闭包，将当前遍历到的列表元素作为闭包参数，返回布尔值表示当前元素是否满足查找规则。\n返回值：\n    返回存储了所有满足查找规则的元素的新列表；如果一个元素没找到，则返回的新列表是一个空列表。\n</code></pre></div><h5 id=\"_1-2-2-3-判断是否存在任一元素满足条件-any-self-closure\" tabindex=\"-1\"> 1.2.2.3 判断是否存在任一元素满足条件：<code>any(self, closure)</code></h5>\n<div><pre><code><span>static</span> <span>&lt;</span>T<span>></span> <span>boolean</span> <span>any</span><span>(</span>Iterable<span>&lt;</span>T<span>></span> self<span>,</span> Closure closure<span>)</span>\n</code></pre></div><div><pre><code>作用：\n    按照参数闭包定义的查找规则，从左往右查找满足规则的元素，\n    判断列表中是否至少有一个满足规则的元素。\n参数：\n    self 指调用者本身，不需要传参；\n    closure 是一个用来定义查找规则的闭包，将当前遍历到的列表元素作为闭包参数，返回布尔值表示当前元素是否满足查找规则。\n返回值：\n    true 列表中存在至少一个满足规则的元素；\n    false 列表中不存在满足规则的元素。\n</code></pre></div><h5 id=\"_1-2-2-4-判断是否所有元素满足条件-every-self-closure\" tabindex=\"-1\"> 1.2.2.4 判断是否所有元素满足条件：<code>every(self, closure)</code></h5>\n<div><pre><code><span>static</span> <span>&lt;</span>T<span>></span> <span>boolean</span> <span>every</span><span>(</span>Iterable<span>&lt;</span>T<span>></span> self<span>,</span> Closure closure<span>)</span>\n</code></pre></div><div><pre><code>作用：\n    按照参数闭包定义的查找规则，从左往右查找满足规则的元素，\n    判断列表中是否所有元素都满足规则。\n参数：\n    self 指调用者本身，不需要传参；\n    closure 是一个用来定义查找规则的闭包，将当前遍历到的列表元素作为闭包参数，返回布尔值表示当前元素是否满足查找规则。\n返回值：\n    true 列表中所有元素都满足规则；\n    false 列表中存在不满足规则的元素。\n</code></pre></div><h5 id=\"_1-2-2-5-示例代码一\" tabindex=\"-1\"> 1.2.2.5 示例代码一</h5>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_03_datastructure/04.png\" alt=\"\" loading=\"lazy\"></p>\n<h5 id=\"_1-2-2-6-取出列表中的最小元素-min-self-closure\" tabindex=\"-1\"> 1.2.2.6 取出列表中的最小元素：<code>min(self, closure)</code></h5>\n<div><pre><code><span>static</span> <span>&lt;</span>T<span>></span> T <span>min</span><span>(</span>Iterable<span>&lt;</span>T<span>></span> self<span>)</span>\n</code></pre></div><div><pre><code>作用： \n    对 self 中的元素本身进行相互比较，返回最小元素。\n参数：\n    self 表示调用者本身，不需要传参。\n返回值：\n    返回最小元素。\n</code></pre></div><div><pre><code><span>static</span> <span>&lt;</span>T<span>></span> T <span>min</span><span>(</span>Iterable<span>&lt;</span>T<span>></span> self<span>,</span> Closure closure<span>)</span>\n</code></pre></div><div><pre><code>作用：\n    通过闭包指定比较规则，对闭包的返回结果进行相互比较，\n    返回最小的闭包返回结果所对应的 self 中的元素。\n参数：\n    self 表示调用者本身，不需要传参；\n    closure 用于指定比较规则，将当前遍历到的 self 中的元素作为闭包参数，闭包的返回结果作为比较对象。\n返回值：\n   返回最小的闭包返回结果所对应的 self 中的元素。\n</code></pre></div><h5 id=\"_1-2-2-7-取出列表中的最大元素-max-self-closure\" tabindex=\"-1\"> 1.2.2.7 取出列表中的最大元素：<code>max(self, closure)</code></h5>\n<div><pre><code><span>static</span> <span>&lt;</span>T<span>></span> T <span>max</span><span>(</span>Iterable<span>&lt;</span>T<span>></span> self<span>)</span>\n</code></pre></div><div><pre><code>与 min(self) 类似。\n</code></pre></div><div><pre><code><span>static</span> <span>&lt;</span>T<span>></span> T <span>max</span><span>(</span>Iterable<span>&lt;</span>T<span>></span> self<span>,</span> Closure closure<span>)</span>\n</code></pre></div><div><pre><code>与 min(self, closure) 类似。\n</code></pre></div><h5 id=\"_1-2-2-8-示例代码二\" tabindex=\"-1\"> 1.2.2.8 示例代码二</h5>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_03_datastructure/05.png\" alt=\"\" loading=\"lazy\"></p>\n<h5 id=\"_1-2-2-9-统计满足条件的元素个数-count-self-closure\" tabindex=\"-1\"> 1.2.2.9 统计满足条件的元素个数：<code>count(self, closure)</code></h5>\n<div><pre><code><span>static</span> <span>&lt;</span>T<span>></span> Number <span>count</span><span>(</span>Iterable<span>&lt;</span>T<span>></span> self<span>,</span> Closure closure<span>)</span>\n</code></pre></div><div><pre><code>作用：\n    通过闭包指定统计规则，返回满足统计规则的 self 中的元素个数。\n参数：\n    self 作为调用者，不需要传参；\n    closure 用于指定统计规则，将当前遍历到的 self 中的元素作为闭包参数，返回布尔值表示当前元素是否满足统计规则。\n返回值：\n    返回满足统计规则的 self 中的元素个数。\n</code></pre></div><h5 id=\"_1-2-2-10-示例代码三\" tabindex=\"-1\"> 1.2.2.10 示例代码三</h5>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_03_datastructure/06.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_2-映射-map\" tabindex=\"-1\"> 2. 映射（<code>Map</code>）</h2>\n<h3 id=\"_2-1-map-的定义方式\" tabindex=\"-1\"> 2.1 <code>Map</code> 的定义方式</h3>\n<p><strong>方式一：</strong> <code>Java</code> 语法的定义形式</p>\n<div><pre><code><span>def</span> map <span>=</span> <span>new</span> <span>HashMap</span><span>(</span><span>)</span>\n</code></pre></div><p><strong>方式二：</strong> <code>Groovy</code> 特有的定义形式</p>\n<div><pre><code><span>def</span> map <span>=</span> <span>[</span>key1<span>:</span> value1<span>,</span> key2<span>:</span> value2<span>,</span> key3<span>:</span> value3<span>,</span> <span>...</span><span>]</span>\n\n<span>// 定义空 map</span>\n<span>def</span> map <span>=</span> <span>[</span><span>:</span><span>]</span>\n</code></pre></div><p><strong>注意：</strong></p>\n<ol>\n<li>\n<p>定义 <code>Map</code> 进行元素初始化时，如果 <code>key</code> 是一个不可变字符串（单引号字符串），那么可以省略单引号；</p>\n</li>\n<li>\n<p>定义 <code>Map</code> 进行元素初始化时，如果 <code>key</code> 是包含字母的标识符，那么会把 <code>key</code> 当做一个不可变字符串（单引号字符串）类型的 <code>key</code> 值；</p>\n</li>\n<li>\n<p>采用 <code>Groovy</code> 特有的方式定义 <code>Map</code> 时，默认使用的是 <code>java.util.LinkedHashMap</code>，也可以在定义时使用关键字 <code>as</code> 转为其他类型的 <code>Map</code>，如：</p>\n<div><pre><code><span>def</span> map <span>=</span> <span>[</span>key1<span>:</span> value1<span>,</span> key2<span>:</span> value2<span>,</span> key3<span>:</span> value3<span>,</span> <span>...</span><span>]</span> <span>as</span> TreeMap\n</code></pre></div><div><pre><code>由于 LinkedHashMap 是 HashMap 的子类，所以再执行\n    def map = [key1: value1, key2: value2, key3: value3, ...] as HashMap \n并不会把 LinkedHashMap 转为 HashMap，这是因为多态的特性。（LinkedHashMap 可以透明的当成 HashMap）\n</code></pre></div></li>\n<li>\n<p><code>Map</code> 中的可以存放任意类型的键值对，即每个 <code>key</code> 的类型可以是任意的，每个 <code>value</code> 的类型也可以是任意；</p>\n</li>\n<li>\n<p>查看 <code>Map</code> 对象的类型时，应该使用 <code>map.getClass();</code> 不能使用 <code>map.class</code>，这样会把 &quot;<code>class</code>&quot; 当做 <code>map</code> 中的 <code>key</code> 值看待；</p>\n</li>\n<li>\n<p>可以直接打印 <code>Map</code>，即：</p>\n<div><pre><code>println map\n<span>// 相当于：</span>\nprintln map<span>.</span><span>toMapString</span><span>(</span><span>)</span>\n</code></pre></div></li>\n</ol>\n<h4 id=\"_2-1-1-示例代码一\" tabindex=\"-1\"> 2.1.1 示例代码一</h4>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_03_datastructure/07.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_2-1-2-示例代码二\" tabindex=\"-1\"> 2.1.2 示例代码二</h4>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_03_datastructure/08.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_2-2-map-中元素的存取\" tabindex=\"-1\"> 2.2 <code>Map</code> 中元素的存取</h3>\n<p><strong>存的四种方式：</strong></p>\n<div><pre><code><span>// 方式一：定义 Map 时，进行初始化存储： </span>\n<span>def</span> map <span>=</span> <span>[</span>key<span>:</span> value<span>]</span>\n\n<span>// 方式二</span>\nmap<span>.</span><span>put</span><span>(</span>key<span>,</span> value<span>)</span>\n\n<span>// 方式三</span>\nmap<span>.</span>key <span>=</span> value\n\n<span>// 方式四</span>\nmap<span>[</span>key<span>]</span> <span>=</span> value\n</code></pre></div><p><strong>取的三种方式：</strong></p>\n<div><pre><code><span>// 方式一</span>\nmap<span>.</span><span>get</span><span>(</span>key<span>)</span>\n\n<span>// 方式二</span>\nmap<span>.</span>key\n\n<span>// 方式三</span>\nmap<span>[</span>key<span>]</span>\n</code></pre></div><p><strong>注意：</strong></p>\n<ol>\n<li>\n<p>当 <code>key</code> 是不可变字符串（单引号字符串）时，只有 <code>map.key</code> 的形式才能省略单引号；</p>\n<blockquote>\n<p>同时也表示，如果 <code>key</code> 是包含字母的标识符，那么 <code>map.key</code> 的形式中，会把 <code>key</code> 看待成一个不可变字符串。</p>\n</blockquote>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_03_datastructure/09.png\" alt=\"\" loading=\"lazy\"></p>\n</li>\n<li>\n<p>采用 <code>map[key]</code>、<code>map.put(key)</code> 或 <code>map.get(key)</code> 的形式时，如果 <code>key</code> 是一个不可变字符串（单引号字符串），那么不能省略单引号；</p>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_03_datastructure/10.png\" alt=\"\" loading=\"lazy\"></p>\n</li>\n<li>\n<p>如果 <code>key</code> 包含字母，且 <code>key</code> 不是一个不可变字符串，如 <code>key</code> 是一个非字符串类型的变量名，那么应该使用 <code>map[key]</code>、<code>map.put(key)</code> 或 <code>map.get(key)</code></p>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_03_datastructure/11.png\" alt=\"\" loading=\"lazy\"></p>\n</li>\n<li>\n<p>特别地，当 <code>key</code> 是一个可变字符串（<code>GString</code> 类型）时，由于 <code>map[key]</code> 会把 <code>key</code> 先转换为不可变字符串（<code>String</code> 类型），所以不能采用 <code>map[key]</code> 的形式进行存取。应该采用 <code>map.put(key)</code> 或 <code>map.get(key)</code> 的形式存取。另外，也可以在定义 <code>map</code> 时初始化存入一个可变字符串，但是取的时候只能通过 <code>map.get(key)</code> 的形式取。</p>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_03_datastructure/12.png\" alt=\"\" loading=\"lazy\"></p>\n</li>\n</ol>\n<h3 id=\"_2-3-map-的遍历操作\" tabindex=\"-1\"> 2.3 <code>Map</code> 的遍历操作</h3>\n<p><strong>注意：</strong></p>\n<p>如果 <code>Map</code> 对象是 <code>LinkedHashMap</code> 类型，那么 <code>Map</code> 容器中的键值对元素 <code>entry</code> 就是 <code>LinkedHashMap.Entry</code> 类型。</p>\n<p>并且在 <code>Groovy</code> 中，可以通过 <code>entry.key</code> 来获取 <code>key</code> 值；通过 <code>entry.value</code> 来获取 <code>value</code> 值（不用像 <code>Java</code> 中那样调用 <code>getter</code> 方法）。</p>\n<h4 id=\"_2-3-1-采用-each-self-closure-方法进行遍历\" tabindex=\"-1\"> 2.3.1 采用 <code>each(self, closure)</code> 方法进行遍历</h4>\n<p><code>DefaultGroovyMethods</code> 提供的 <code>each</code> 方法进行遍历。</p>\n<div><pre><code><span>static</span> <span>&lt;</span>K<span>,</span> V<span>></span> Map<span>&lt;</span>K<span>,</span> V<span>></span> <span>each</span><span>(</span>Map<span>&lt;</span>K<span>,</span> V<span>></span> self<span>,</span> Closure closure<span>)</span>\n</code></pre></div><div><pre><code>作用：\n    对 self 表示的 Map 容器进行遍历，并将每次遍历到的键值对元素交给参数闭包处理。\n参数：\n    self：表示调用者本身，即调用 each 方法的 Map 对象。是一个隐式参数，不需要传参；\n    closure：可以是带一个参数的闭包，也可以是带两个参数的闭包\n        1. 当实参闭包定义为带一个参数的闭包时，这个参数表示键值对 entry，\n           key 值可以通过 entry.key 获取；value 值可以通过 entry.value 获取；\n        2. 当实参闭包定义为带两个参数的闭包时，参数1为 key 值，参数2为 value 值。\n返回值：\n    each 方法返回 self 调用者本身。\n</code></pre></div><h4 id=\"_2-3-2-采用-eachwithindex-self-closure-方法进行遍历\" tabindex=\"-1\"> 2.3.2 采用 <code>eachWithIndex(self, closure)</code> 方法进行遍历</h4>\n<p><code>DefaultGroovyMethods</code> 提供的 <code>eachWithIndex</code> 方法进行遍历。</p>\n<div><pre><code><span>static</span> <span>&lt;</span>K<span>,</span> V<span>></span> Map<span>&lt;</span>K<span>,</span> V<span>></span> <span>eachWithIndex</span><span>(</span>Map<span>&lt;</span>K<span>,</span> V<span>></span> self<span>,</span> Closure closure<span>)</span>\n</code></pre></div><div><pre><code>作用：\n    对 self 表示的 Map 容器进行遍历，并将每次遍历到的键值对元素交给参数闭包处理。\n参数：\n    self：表示调用者本身，即调用 eachWithIndex 方法的 Map 对象。是一个隐式参数，不需要传参；\n    closure：可以是带两个参数的闭包，也可以是带三个参数的闭包\n        1. 当实参闭包定义为带两个参数的闭包时，\n            参数1表示键值对 entry。key 值可以通过 entry.key 获取；value 值可以通过 entry.value 获取；\n            参数2表示当前键值对在遍历时的索引值 index。\n        2. 当实参闭包定义为 带三个参数的闭包时，\n            参数1为 key 值；\n            参数2为 value 值；\n            参数3表示当前键值对在遍历时的索引值 index。\n返回值：\n    eachWithIndex 方法返回 self 调用者本身。\n</code></pre></div><h4 id=\"_2-3-3-采用-for-in-循环进行遍历\" tabindex=\"-1\"> 2.3.3 采用 <code>for-in</code> 循环进行遍历</h4>\n<div><pre><code><span>for</span><span>(</span>entry <span>in</span> map<span>)</span> <span>{</span>\n    <span>// key 通过 entry.key 获取</span>\n    <span>// value 通过 entry.value 获取</span>\n<span>}</span>\n</code></pre></div><h4 id=\"_2-3-4-示例代码\" tabindex=\"-1\"> 2.3.4 示例代码</h4>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_03_datastructure/13.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_2-4-map-的查找操作\" tabindex=\"-1\"> 2.4 <code>Map</code> 的查找操作</h3>\n<h4 id=\"_2-4-1-查找满足条件的某个键值对元素-find-self-closure\" tabindex=\"-1\"> 2.4.1 查找满足条件的某个键值对元素：<code>find(self, closure)</code></h4>\n<div><pre><code><span>static</span> <span>&lt;</span>K<span>,</span> V<span>></span> Map<span>.</span>Entry<span>&lt;</span>K<span>,</span> V<span>></span> <span>find</span><span>(</span>Map<span>&lt;</span>K<span>,</span> V<span>></span> self<span>,</span> Closure<span>&lt;</span><span>?</span><span>></span> closure<span>)</span>\n</code></pre></div><div><pre><code>作用：\n    对 self 表示的 Map 容器进行遍历，返回符合闭包 closure 所指定条件的第1个键值对元素。\n参数：\n    self：表示调用该 find 方法的 Map 对象本身。为隐式参数，不需要手动传参；\n    closure：指定查找条件，应该返回布尔值，用来通知主调函数 find 传入闭包的键值对元素是否满足条件。\n        当定义的实参闭包带一个参数时，参数为 Map.Entry 类型的键值对元素（推荐）；\n        当定义的实参闭包带两个参数时，参数1为 key 值，参数2为 value 值。\n返回值：\n    返回符合闭包 closure 所指定条件的第1个 Map.Entry 类型的键值对元素。\n</code></pre></div><h4 id=\"_2-4-2-查找满足条件的某些键值对元素-findall-self-closure\" tabindex=\"-1\"> 2.4.2 查找满足条件的某些键值对元素：<code>findAll(self, closure)</code></h4>\n<div><pre><code><span>static</span> <span>&lt;</span>K<span>,</span> V<span>></span> Map<span>&lt;</span>K<span>,</span> V<span>></span> <span>findAll</span><span>(</span>Map<span>&lt;</span>K<span>,</span> V<span>></span> self<span>,</span> Closure closure<span>)</span>\n</code></pre></div><div><pre><code>作用：\n    对 self 表示的 Map 容器进行遍历，返回符合闭包 closure 所指定条件的所有键值对元素。\n参数：\n    self：表示调用该 findAll 方法的 Map 对象本身。为隐式参数，不需要手动传参；\n    closure：指定查找条件，应该返回布尔值，用来通知主调函数 findAll 传入闭包的键值对元素是否满足条件。\n        当定义的实参闭包带一个参数时，参数为 Map.Entry 类型的键值对元素（推荐）；\n        当定义的实参闭包带两个参数时，参数1为 key 值，参数2为 value 值。\n返回值：\n    返回符合闭包 closure 所指定条件的所有键值对元素所组成的新的 Map 容器。\n</code></pre></div><h4 id=\"_2-4-3-统计满足条件的键值对元素个数-count-self-closure\" tabindex=\"-1\"> 2.4.3 统计满足条件的键值对元素个数：<code>count(self, closure)</code></h4>\n<div><pre><code><span>static</span> <span>&lt;</span>K<span>,</span>V<span>></span> Number <span>count</span><span>(</span>Map<span>&lt;</span>K<span>,</span>V<span>></span> self<span>,</span> Closure<span>&lt;</span><span>?</span><span>></span> closure<span>)</span>\n</code></pre></div><div><pre><code>作用：\n    对 self 表示的 Map 容器进行遍历，返回符合闭包 closure 所指定条件的所有键值对元素的总个数。\n参数：\n    self：表示调用该 count 方法的 Map 对象本身。为隐式参数，不需要手动传参；\n    closure：指定查找条件，应该返回布尔值，用来通知主调函数 count 传入闭包的键值对元素是否满足条件。\n        当定义的实参闭包带一个参数时，参数为 Map.Entry 类型的键值对元素（推荐）；\n        当定义的实参闭包带两个参数时，参数1为 key 值，参数2为 value 值。\n返回值：\n    返回符合闭包 closure 所指定条件的所有键值对元素的总个数。\n</code></pre></div><h4 id=\"_2-4-4-返回根据键值对转换成的集合-collect-self-transform\" tabindex=\"-1\"> 2.4.4 返回根据键值对转换成的集合：<code>collect(self, transform)</code></h4>\n<div><pre><code><span>static</span> <span>&lt;</span>T<span>,</span>K<span>,</span>V<span>></span> List<span>&lt;</span>T<span>></span> <span>collect</span><span>(</span>Map<span>&lt;</span>K<span>,</span>V<span>></span> self<span>,</span> Closure<span>&lt;</span>T<span>></span> transform<span>)</span>\n</code></pre></div><div><pre><code>作用：\n    对 self 表示的 Map 容器进行遍历，将遍历到的键值对元素交给闭包 transform 处理。\n    并将处理后由闭包 transform 返回的结果值存入一个 list 容器中，最后主调函数 collect 返回这个 list 容器。\n参数：\n    self：表示调用该 collect 方法的 Map 对象本身。为隐式参数，不需要手动传参；\n    closure：对传入的键值对元素进行处理，并将处理后的结果值返回给主调函数 collect，闭包返回的结果值可以是任意类型。\n        当定义的实参闭包带一个参数时，参数为 Map.Entry 类型的键值对元素（推荐）；\n        当定义的实参闭包带两个参数时，参数1为 key 值，参数2为 value 值。\n返回值：\n    返回由闭包 transform 的结果值所构成的 list 容器。\n</code></pre></div><h4 id=\"_2-4-5-对键值对进行分组-groupby-self-closure\" tabindex=\"-1\"> 2.4.5 对键值对进行分组：<code>groupBy(self, closure)</code></h4>\n<div><pre><code><span>static</span> <span>&lt;</span>G<span>,</span> K<span>,</span> V<span>></span> Map<span>&lt;</span>G<span>,</span> Map<span>&lt;</span>K<span>,</span> V<span>>></span> <span>groupBy</span><span>(</span>Map<span>&lt;</span>K<span>,</span> V<span>></span> self<span>,</span> Closure<span>&lt;</span>G<span>></span> closure<span>)</span>\n</code></pre></div><div><pre><code>作用：\n    对 self 表示的 Map 容器进行遍历，将遍历到的键值对元素交给闭包 closure 处理。\n    并将处理后由闭包 closure 返回的结果值作为分组条件，然后将同一分组条件下的键值对元素作为一组，存入一个新的 Map 容器。\n    最后，以分组条件（即闭包 closure 的结果值）作为 key，以满足该分组条件的同组下的所有键值对元素（即一个新的 Map 容器）作为 value，\n    构成另一个新的表示最终的分组结果的 Map 容器，主调函数 groupBy 返回这个表示最终分组结果的 Map 容器。\n参数：\n    self：表示调用该 groupBy 方法的 Map 对象本身。为隐式参数，不需要手动传参；\n    closure：对传入的键值对元素进行处理，并将处理后的结果值返回给主调函数 groupBy，闭包返回的结果值可以是任意类型。\n        当定义的实参闭包带一个参数时，参数为 Map.Entry 类型的键值对元素（推荐）；\n        当定义的实参闭包带两个参数时，参数1为 key 值，参数2为 value 值。\n返回值：\n    返回以分组条件（即闭包 closure 的结果值）作为 key，以满足该分组条件的同组下的所有键值对元素（即一个新的 Map 容器）作为 value，\n    所构成另一个新的表示最终的分组结果的 Map 容器。\n</code></pre></div><h4 id=\"_2-4-6-示例代码\" tabindex=\"-1\"> 2.4.6 示例代码</h4>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_03_datastructure/14.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_2-5-map-的排序操作-sort-self-closure\" tabindex=\"-1\"> 2.5 <code>Map</code> 的排序操作：<code>sort(self, closure)</code></h3>\n<div><pre><code><span>static</span> <span>&lt;</span>K<span>,</span> V<span>></span> Map<span>&lt;</span>K<span>,</span> V<span>></span> <span>sort</span><span>(</span>Map<span>&lt;</span>K<span>,</span> V<span>></span> self<span>,</span> Closure closure<span>)</span>\n</code></pre></div><div><pre><code>作用：\n    按照闭包 closure 指定的排序规则，对 self 表示的 Map 容器进行排序。\n参数：\n    self：表示调用该 sort 方法的 Map 对象本身。为隐式参数，不需要手动传参；\n    closure：指定排序规则\n        当定义的实参闭包带一个参数时，参数为 Map.Entry 类型的键值对元素，此时：\n            以对参数元素进行处理后得到的结果值为排序对象，进行自然排序（即按照结果值从小到大对元素进行排序）。\n        当定义的实参闭包带两个参数时，参数1和参数2都为 Map.Entry 类型的键值对元素，此时：\n            通过闭包的结果值来比较参数1元素和参数2元素的大小：\n                结果值为0  -> 参数1元素 = 参数2元素\n                结果值为-1 -> 参数1元素 &lt; 参数2元素\n                结果值为1  -> 参数1元素 > 参数2元素\n返回值：\n    返回排序后的另一个新的 Map 容器。\n</code></pre></div><h4 id=\"_2-5-1-map-排序与-list-排序的区别\" tabindex=\"-1\"> 2.5.1 <code>Map</code> 排序与 <code>List</code> 排序的区别</h4>\n<p><code>list.sort</code> 返回的 <code>list</code> 就是调用者 <code>list</code>，即 <strong><code>list</code> 容器是对自身进行排序</strong>。</p>\n<p>而 <code>map.sort</code> 返回的 <code>map</code> 是一个新的 <code>map</code>，即 <strong><code>map</code> 容器不能对自身进行重新排序</strong>。</p>\n<h4 id=\"_2-5-2-示例代码\" tabindex=\"-1\"> 2.5.2 示例代码</h4>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_03_datastructure/15.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_3-范围-range\" tabindex=\"-1\"> 3. 范围（<code>Range</code>）</h2>\n<h3 id=\"_3-1-range-就是一个轻量级的-list\" tabindex=\"-1\"> 3.1 <code>Range</code> 就是一个轻量级的 <code>List</code></h3>\n<p><code>Range</code> 其实就是一个轻量级的 <code>List</code>。</p>\n<p><code>Range</code> 继承自 <code>List</code>，所以 <code>List</code> 相关的 <code>API</code>，<code>Range</code> 都能使用。</p>\n<div><pre><code><span>interface</span> <span>Range</span><span>&lt;</span>T <span>extends</span> <span>Comparable</span><span>></span> <span>extends</span> <span>List</span><span>&lt;</span>T<span>></span>\n</code></pre></div><h3 id=\"_3-2-range-的三个实现类-intrange、objectrange、emptyrange\" tabindex=\"-1\"> 3.2 <code>Range</code> 的三个实现类：<code>IntRange</code>、<code>ObjectRange</code>、<code>EmptyRange</code></h3>\n<p><strong><code>IntRange</code></strong></p>\n<div><pre><code><span>class</span> <span>IntRange</span> <span>extends</span> <span>AbstractList</span><span>&lt;</span>Integer<span>></span> <span>implements</span> <span>Range</span><span>&lt;</span>Integer<span>></span>\n</code></pre></div><p><strong><code>ObjectRange</code></strong></p>\n<div><pre><code><span>class</span> <span>ObjectRange</span> <span>extends</span> <span>AbstractList</span> <span>implements</span> <span>Range</span>\n</code></pre></div><p><strong><code>EmptyRange</code></strong></p>\n<div><pre><code><span>class</span> <span>EmptyRange</span> <span>extends</span> <span>AbstractList</span> <span>implements</span> <span>Range</span>\n</code></pre></div><h3 id=\"_3-3-range-的定义\" tabindex=\"-1\"> 3.3 <code>Range</code> 的定义</h3>\n<p><strong>注意：</strong></p>\n<ol>\n<li>\n<p>采用 <code>from..to</code> 的形式定义的 <code>Range</code> 的范围是 <code>[from, to]</code>，即包含 <code>to</code>；</p>\n</li>\n<li>\n<p>采用 <code>from..&lt;to</code> 的形式定义的 Range 的范围是 <code>[from, to)</code>，即不包含 <code>to</code>。</p>\n</li>\n</ol>\n<h4 id=\"_3-3-1-intrange-的定义\" tabindex=\"-1\"> 3.3.1 <code>IntRange</code> 的定义</h4>\n<div><pre><code><span>def</span> range <span>=</span> from<span>..</span>to \n</code></pre></div><div><pre><code>range 的元素范围是 [from, to]，其中元素 from 和元素 to 都是 int 整型。\n</code></pre></div><h4 id=\"_3-3-2-objectrange-的定义\" tabindex=\"-1\"> 3.3.2 <code>ObjectRange</code> 的定义</h4>\n<div><pre><code><span>def</span> range <span>=</span> from<span>..</span>to\n</code></pre></div><div><pre><code>range 的元素范围是 [from, to]，其中元素 from 和元素 to 都是除整型之外的其他类型，如：浮点型、字符串或自定义类型。\n</code></pre></div><p><strong>注意：</strong></p>\n<ol>\n<li>\n<p>当自定类型作为 <code>Range</code> 的元素时：</p>\n<div><pre><code>1. 自定义类 T 需要继承接口 Comparable&lt;T>，并重写 \"int compareTo(T t)\" 方法；\n2. 自定义类 T 中还需要定义 \"T next()\" 方法，该方法会通过反射在 ObjectRange 中调用；\n3. 自定义类 T 中还需要定义 \"T previous()\" 方法，该方法会通过反射在 ObjectRange 中调用。\n</code></pre></div></li>\n<li>\n<p>对于 <code>GString</code> 和 <code>String</code> 类型的字符串：</p>\n<div><pre><code>1. GString 和 String 都继承了接口 Comparable；\n2. 并且 next 和 previous 方法由 StringGroovyMethods 类提供。\n</code></pre></div></li>\n<li>\n<p>对于 <code>int</code> 整型之外其他数字：</p>\n<div><pre><code>1. 都会自动装箱成对应的数字类型；\n2. 数字类型都继承了接口 Comparable；\n3. 并且 next 和 previous 方法由 DefaultGroovyMethods 类提供。\n</code></pre></div></li>\n<li>\n<p><code>ObjectRange</code> 重写了 <code>List</code> 的 <code>contains</code> 方法；</p>\n</li>\n<li>\n<p><code>ObjectRange</code> 中的元素只要实现了 <code>Comparable</code> 接口即可，不需要重写 <code>equals</code> 方法。</p>\n</li>\n</ol>\n<h4 id=\"_3-3-3-emptyrange-的定义\" tabindex=\"-1\"> 3.3.3 <code>EmptyRange</code> 的定义</h4>\n<div><pre><code><span>def</span> range <span>=</span> from<span>..&lt;</span>from\n</code></pre></div><div><pre><code>其中元素 from 可以是任意类型。\n</code></pre></div><h4 id=\"_3-3-4-示例代码\" tabindex=\"-1\"> 3.3.4 示例代码</h4>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_03_datastructure/16.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_3-4-range-中访问元素的操作\" tabindex=\"-1\"> 3.4 <code>Range</code> 中访问元素的操作</h3>\n<p><strong>注意：</strong>\n1. Range容器中的元素是通过对 端点值from进行计算得到的，计算的元素值不超过端点值to\n可能存在 Range容器中不包含元素为端点to的情况</p>\n<pre><code>2. ObjectRange中重写了List的contains方法\n    Range中的元素只要实现了 Comparable接口即可，不需要重写 equals方法\n</code></pre>\n<h4 id=\"_3-4-1-获取范围-from-to-的端点值-range-to、range-from\" tabindex=\"-1\"> 3.4.1 获取范围 <code>[from, to]</code> 的端点值：<code>range.to</code>、<code>range.from</code></h4>\n<div><pre><code><span>def</span> from <span>=</span> range<span>.</span>from\n<span>def</span> to <span>=</span> range<span>.</span>to\n</code></pre></div><h4 id=\"_3-4-2-通过下标运算符获取指定索引处的元素-range-index\" tabindex=\"-1\"> 3.4.2 通过下标运算符获取指定索引处的元素：<code>range[index]</code></h4>\n<div><pre><code><span>def</span> element <span>=</span> range<span>[</span>index<span>]</span>\n</code></pre></div><h4 id=\"_3-4-3-判断-range-中是否包含指定元素-range-contains-element\" tabindex=\"-1\"> 3.4.3 判断 <code>Range</code> 中是否包含指定元素：<code>range.contains(element)</code></h4>\n<div><pre><code>range<span>.</span><span>contains</span><span>(</span>element<span>)</span> <span>// 返回布尔值</span>\n</code></pre></div><h4 id=\"_3-4-4-注意-可能存在-range-中不包含元素为端点-to-的情况\" tabindex=\"-1\"> 3.4.4 注意：可能存在 <code>Range</code> 中不包含元素为端点 <code>to</code> 的情况</h4>\n<p><code>Range</code> 容器中的元素是通过对端点值 <code>from</code> 进行计算得到的，计算的元素值不超过端点值 <code>to</code>。</p>\n<p>因此，可能存在 <code>Range</code> 容器中不包含元素为端点 <code>to</code> 的情况。</p>\n<h4 id=\"_3-4-5-示例代码\" tabindex=\"-1\"> 3.4.5 示例代码</h4>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_03_datastructure/17.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_3-5-range-的遍历-each-self-closure\" tabindex=\"-1\"> 3.5 <code>Range</code> 的遍历：<code>each(self, closure)</code></h3>\n<p>因为 <code>Range</code> 继承自 <code>List</code>，所以遍历 <code>List</code> 的方式同样适用于 <code>Range</code>。</p>\n<div><pre><code><span>static</span> <span>&lt;</span>T<span>></span> List<span>&lt;</span>T<span>></span> <span>each</span><span>(</span>List<span>&lt;</span>T<span>></span> self<span>,</span> Closure closure<span>)</span>\n</code></pre></div><blockquote>\n<p>另外，也可以使用 <code>for-in</code> 循环遍历 <code>Range</code>。</p>\n</blockquote>\n<h4 id=\"_3-5-1-建议-在-groovy-中-能使用闭包的就尽量使用闭包\" tabindex=\"-1\"> 3.5.1 建议：在 <code>Groovy</code> 中，能使用闭包的就尽量使用闭包</h4>\n<p>在 <code>Groovy</code> 中，能使用闭包的就尽量使用闭包，所以不推荐使用 <code>for-in</code> 循环遍历 <code>Range</code>。</p>\n<h4 id=\"_3-5-2-示例代码\" tabindex=\"-1\"> 3.5.2 示例代码</h4>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_03_datastructure/18.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_3-6-range-在-switch-语句中的使用-range-最常用的场景\" tabindex=\"-1\"> 3.6 <code>Range</code> 在 <code>switch</code> 语句中的使用（<code>Range</code> 最常用的场景）</h3>\n<p>在 <code>Java</code> 中，为了判断输入值是否在某个范围内，只能通过 <code>if-else</code> 语句结合关系运算符和逻辑运算符来进行判断，如：</p>\n<div><pre><code><span>if</span> <span>(</span>number <span>>=</span> <span>0</span> <span>&amp;&amp;</span> number <span>&lt;</span> <span>60</span><span>)</span> <span>{</span> \n\n<span>}</span> <span>else</span> <span>if</span><span>(</span>number <span>>=</span><span>60</span> <span>&amp;&amp;</span> number <span>&lt;</span> <span>70</span><span>)</span> <span>{</span> \n\n<span>}</span> <span>.</span><span>.</span><span>.</span>\n</code></pre></div><p>但是在 <code>Groovy</code> 中，通过 <code>Range</code> 我们可以使用 <code>switch-case</code> 语句实现上面的代码，如：</p>\n<div><pre><code><span>switch</span><span>(</span>number<span>)</span> <span>{</span>\n    <span>case</span> <span>0</span><span>..&lt;</span><span>60</span><span>:</span> <span>// 范围 [0, 60)</span>\n        <span>break</span>\n    <span>case</span> <span>60</span><span>..&lt;</span><span>70</span><span>:</span> <span>// 范围 [60, 70)</span>\n        <span>break</span>\n    <span>...</span>\n<span>}</span>\n</code></pre></div><blockquote>\n<p>以上就是 <code>Range</code> 最常用的场景。</p>\n</blockquote>\n<h4 id=\"_3-6-1-示例代码\" tabindex=\"-1\"> 3.6.1 示例代码</h4>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_03_datastructure/19.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_3-6-2-使用-def-定义不固定返回值类型的函数\" tabindex=\"-1\"> 3.6.2 使用 <code>def</code> 定义不固定返回值类型的函数</h4>\n<p>如上代码所示，可以使用 <code>def</code> 来定义一个不固定返回值类型的函数：</p>\n<div><pre><code>def 函数名(形参列表) {\n    // 函数体\n}\n</code></pre></div><div><pre><code>不需要给出函数的具体返回值类型，函数体中最后一条语句的执行结果作为返回值，\n所以最后一条语句的执行结果是什么类型，def 定义的函数的返回值就是什么类型，\n如果最后一条语句执行后没有结果值，那么 def 定义的函数返回 null。\n\n其实，def 定义的函数的返回值类型就是 Object，从而可以使用多态接收任意类型的返回结果。\n</code></pre></div>",
      "date_published": "2022-10-23T14:49:16.000Z",
      "date_modified": "2022-10-24T15:48:49.000Z",
      "authors": [],
      "tags": [
        "gradle"
      ]
    },
    {
      "title": "面向对象",
      "url": "https://zengkaiqiang562.github.io/zkq/gradle/_02_grammar/_04_oop.html",
      "id": "https://zengkaiqiang562.github.io/zkq/gradle/_02_grammar/_04_oop.html",
      "content_html": "<h2 id=\"_1-创建-groovy-脚本文件\" tabindex=\"-1\"> 1. 创建 <code>Groovy</code> 脚本文件</h2>\n<p>右键包名 -&gt; <code>New</code> -&gt; <code>Groovy Script</code></p>\n<blockquote>\n<p>相当于创建一个 <code>Groovy class</code> 文件，再把 <code>class</code> 类的定义删掉。</p>\n</blockquote>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_04_oop/01.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_2-类的定义与使用\" tabindex=\"-1\"> 2. 类的定义与使用</h2>\n<p><code>Groovy</code> 中如果省略访问权限修饰符，那么默认是 <code>public</code>。</p>\n<p><code>Groovy</code> 中的类除了默认继承自 <code>java.lang.Object</code>, 还默认都实现了 <code>groovy.lang.GroovyObject</code> 接口。</p>\n<p><code>Groovy</code> 中语句最后的分号 &quot;<code>;</code>&quot; 可以省略（<code>for</code> 循环中的分号不能省）。</p>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_04_oop/02.png\" alt=\"\" loading=\"lazy\"></p>\n<p><code>Groovy</code> 中创建对象的同时，可以对成员变量进行初始化：</p>\n<div><pre><code><span>def</span> 类对象 <span>=</span> <span>new</span> 类名<span>(</span>成员变量名<span>:</span> 成员变量值<span>,</span> 成员变量名<span>:</span> 成员变量值<span>,</span> 成员变量名<span>:</span> 成员变量值<span>,</span> <span>...</span><span>)</span>\n</code></pre></div><div><pre><code>注意：\n1. 这跟定义 Map 时初始化键值对元素是两回事；\n2. 可以只初始化部分成员变量。\n</code></pre></div><p>访问类对象的成员变量时，需要注意：</p>\n<ol>\n<li>\n<p><code>Groovy</code> 中的 &quot;对象.成员变量&quot; 并不是像 <code>Java</code> 那样直接访问成员变量，而是相当于调用了成员变量的 <code>setter/getter</code> 方法；</p>\n</li>\n<li>\n<p>当我们在类中定义了成员变量后，通过类所实现的接口 <code>GroovyObject</code>，会为每个成员变量自动生成 <code>setter/getter</code> 方法；</p>\n</li>\n<li>\n<p>在 <code>Groovy</code> 中的 &quot;对象.成员变量&quot; 就是在调用成员变量的 <code>setter/getter</code> 方法，所以，即使成员变量是私有 <code>private</code> 的，在 <code>Groovy</code> 中也可以使用 &quot;对象.成员变量&quot; 来访问成员变量。</p>\n</li>\n</ol>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_04_oop/03.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_3-接口的定义与使用\" tabindex=\"-1\"> 3. 接口的定义与使用</h2>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_04_oop/04.png\" alt=\"\" loading=\"lazy\"></p>\n<p><code>Groovy</code> 的接口中不允许定义非 <code>public</code> 修饰的方法。</p>\n<p><code>Groovy</code> 的接口中也可以使用 <code>def</code> 定义不确定返回值类型的方法。</p>\n<p><code>Groovy</code> 的接口中定义的方法都是抽象方法，所以不需要加 <code>abstract</code> 修饰，也就是说，实现类必须重写接口中的所有方法。</p>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_04_oop/05.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_4-trait-的定义与使用\" tabindex=\"-1\"> 4. <code>Trait</code> 的定义与使用</h2>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_04_oop/06.png\" alt=\"\" loading=\"lazy\"></p>\n<p><code>Groovy</code> 的 <code>Trait</code> 中不允许定义非 <code>public</code> 修饰的方法。</p>\n<p><code>Groovy</code> 的 <code>Trait</code> 中也可以使用 <code>def</code> 定义不确定返回值类型的方法。</p>\n<p><code>Groovy</code> 的 <code>Trait</code> 中即可以定义抽象方法，也可以定义默认方法，但是，定义抽象方法时必须使用关键字 <code>abstract</code> 进行修饰。</p>\n<p>子类也是通过关键字 <code>implements</code> 去实现 <code>Trait</code>。</p>\n<p><code>Groovy</code> 中的 <code>Trait</code> 和接口的唯一区别在于：</p>\n<ol>\n<li>\n<p><code>Trait</code> 中可以定义默认方法，子类只需要重写 <code>Trait</code> 中的抽象方法即可；</p>\n</li>\n<li>\n<p>接口中定义的方法只能是抽象方法，子类必须重写接口中的所有方法。</p>\n</li>\n</ol>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_04_oop/07.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_5-元编程\" tabindex=\"-1\"> 5. 元编程</h2>\n<h3 id=\"_5-1-通过元编程可以在运行时为对象添加属性和方法\" tabindex=\"-1\"> 5.1 通过元编程可以在运行时为对象添加属性和方法</h3>\n<p><strong>背景：</strong></p>\n<p>在 <code>Java</code> 中使用反射可以在运行时探索程序的结果，类、方法、参数等。</p>\n<p>但是 <code>Java</code> 反射仍然局限于所创建的静态结果，无法在运行时修改一个对象的类型，或是让它动态获得行为（方法）。</p>\n<p>如果可以基于应用的动态状态或基于应用所接受的输入，动态地（即运行时）添加方法和行为，那么代码会变得更灵活。</p>\n<p>在 <code>Groovy</code> 中元编程就提供了这一功能 —— 元编程。</p>\n<p><strong>元编程的概念：</strong></p>\n<p>元编程意味着编写能够操作程序的程序，包括操作程序自身。</p>\n<p>像 <code>Groovy</code> 这样的动态语言通过 <strong>元对象协议</strong>（<code>MOP：Meta Object Protocol</code>）提供了这种能力。</p>\n<p>在 <code>Groovy</code> 中使用 <code>MOP</code> 可以动态调用方法，甚至在运行时合成类和方法。</p>\n<h3 id=\"_5-2-groovy-中成员方法或成员属性的访问流程\" tabindex=\"-1\"> 5.2 <code>Groovy</code> 中成员方法或成员属性的访问流程</h3>\n<p><code>Java</code> 中的成员方法或成员属性如果在类或父类中找不到，那么在编译时期就会报错。</p>\n<p><code>Groovy</code> 中的成员方法或成员属性如果在类或父类中找不到，那么在编译时期是不会报错的。而是在运行时期，根据如下流程图所示，在 <code>MetaClass</code> 或其他途径下判断能否访问到相关的方法或属性。如果根据流程图所示，最终都无法访问到方法或属性，才会在运行时期报错。</p>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_04_oop/08.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>示例代码一：</strong></p>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_04_oop/09.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>示例代码二：</strong></p>\n<div><pre><code>如果 Person 对象调用了一个没有定义过的方法，但是 Person 类中重写了 \"def invokeMethod(String methodName, Object methodArgs)\" 方法，\n那么会执行该 invokeMethod 方法，其中：\n1. 参数 methodName 表示未定义的方法名；\n2. 参数 methodArgs 表示调用未定义的方法时传入的参数，可能是一个参数数组；\n3. invokeMethod 的返回值就是调用未定义方法时的返回值。\n</code></pre></div><p><img src=\"@source/zkq/gradle/_02_grammar/images/_04_oop/10.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>示例代码三：</strong></p>\n<div><pre><code>如果 Person 对象调用了一个没有定义过的方法，但是 Person 类中重写了 \"def methodMissing(String methodName, Object methodArgs)\" 方法，\n那么会执行该 methodMissing 方法，其中：\n1. 参数 methodName 表示未定义的方法名；\n2. 参数 methodArgs 表示调用未定义的方法时传入的参数，可能是一个参数数组；\n3. methodMissing 的返回值就是调用未定义方法时的返回值。\n</code></pre></div><p><img src=\"@source/zkq/gradle/_02_grammar/images/_04_oop/11.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_5-3-使用-metaclass-动态地添加属性和方法\" tabindex=\"-1\"> 5.3 使用 <code>MetaClass</code> 动态地添加属性和方法</h3>\n<h4 id=\"_5-3-1-groovy-中每个类都有对应有一个-metaclass\" tabindex=\"-1\"> 5.3.1 <code>Groovy</code> 中每个类都有对应有一个 <code>MetaClass</code></h4>\n<div><pre><code>对于自定义类，当我们执行 \"类名.metaClass\" 或者 \"对象名.metaClass\" 时，会调用 DefaultGroovyMethods 类的 getMetaClass/setMetaClass 方法。\n\nDefaultGroovyMethods 中会为自定义类创建一个 HandleMetaClass 类型的 metaClass 对象，但是 HandleMetaClass 其实只是一个代理。\n自定义类真正对应的 MetaClass 其实是 HandleMetaClass 中的 MetaClass 类型的属性 delegate 所指定的 MetaClass 对象。\n\n对于自定义类，HandleMetaClass.delegate 就是一个 MetaClassImpl 类对象。\n也就是说，当我们访问 \"类名.metaClass\" 或者 \"对象名.metaClass\" 时，其实就是在访问一个 MetaClassImpl 对象。\n\n当然，也可以通过 \"类名.metaClass = otherMetaClass\" 或者 \"对象名.metaClass = otherMetaClass\" 为自定义类指定其他的 MetaClass 子类对象。\n</code></pre></div><h4 id=\"_5-3-2-通过-metaclass-创建新的属性\" tabindex=\"-1\"> 5.3.2 通过 <code>MetaClass</code> 创建新的属性</h4>\n<div><pre><code>可以通过 \"类名.metaClass.newMemberName = newMemberValue\" 或者 \"对象名.metaClass.newMemberName = newMemberValue\" \n在类对应的 MetaClass 中动态地创建一个新属性，于是，\n通过 \"类名.newMemberName\" 或者 \"对象名.newMemberName\" 就可以访问到这个新属性。\n</code></pre></div><h4 id=\"_5-3-3-示例代码一\" tabindex=\"-1\"> 5.3.3 示例代码一</h4>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_04_oop/12.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_5-3-4-示例代码二\" tabindex=\"-1\"> 5.3.4 示例代码二</h4>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_04_oop/13.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_5-3-5-通过-metaclass-创建新的闭包-即新的方法\" tabindex=\"-1\"> 5.3.5 通过 <code>MetaClass</code> 创建新的闭包（即新的方法）</h4>\n<div><pre><code>可以通过 \"类名.metaClass.newClosureName = {形参列表 -> 函数体}\" 或者 \"对象名.metaClass.newClosureName = {形参列表 -> 函数体}\"\n在类对应的 MetaClass 中动态地创建一个新闭包（即新方法），于是，\n通过 \"类名.newClosureName(实参列表)\" 或者 \"对象名.newClosureName(实参列表)\"  就可以调用这个闭包（即方法）。\n</code></pre></div><h4 id=\"_5-3-6-示例代码三\" tabindex=\"-1\"> 5.3.6 示例代码三</h4>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_04_oop/14.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_5-3-7-通过-metaclass-创建静态方法\" tabindex=\"-1\"> 5.3.7 通过 <code>MetaClass</code> 创建静态方法</h4>\n<div><pre><code>类名.metaClass.static.newClosureName = {形参列表 -> 函数体}\n</code></pre></div><h4 id=\"_5-3-8-示例代码四\" tabindex=\"-1\"> 5.3.8 示例代码四</h4>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_04_oop/15.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_5-3-9-让-metaclass-动态创建的属性和方法全局可见\" tabindex=\"-1\"> 5.3.9 让 <code>MetaClass</code> 动态创建的属性和方法全局可见</h4>\n<div><pre><code>在一个 Groovy 文件中通过 MetaClass 为类动态添加的属性和方法，在另一个 Groovy 文件中默认是无法使用的。\n如果想在各个 Groovy 文件中都能访问到通过 MetaClass 为类动态添加的属性和方法，\n那么需要在添加属性和方法之前调用 \"ExpandoMetaClass.enablleGlobally()\"。\n</code></pre></div><h4 id=\"_5-3-10-示例代码五\" tabindex=\"-1\"> 5.3.10 示例代码五</h4>\n<p><img src=\"@source/zkq/gradle/_02_grammar/images/_04_oop/16.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "date_published": "2022-10-23T14:49:16.000Z",
      "date_modified": "2022-10-25T02:40:06.000Z",
      "authors": [],
      "tags": [
        "gradle"
      ]
    },
    {
      "title": "开发笔记",
      "url": "https://zengkaiqiang562.github.io/zkq/hnap/dev-note.html",
      "id": "https://zengkaiqiang562.github.io/zkq/hnap/dev-note.html",
      "content_html": "<h2 id=\"_4-keytool-命令生成应用签名文件\" tabindex=\"-1\"> 4. <code>keytool</code> 命令生成应用签名文件</h2>\n<div><pre><code>keytool <span>-genkey</span> <span>-keystore</span> xxx.keystore <span>-alias</span> xxx <span>-keypass</span> xxx <span>-keyalg</span> RSA <span>-keysize</span> <span>2048</span> <span>-validity</span> <span>36500</span> <span>-storepass</span> xxx\n</code></pre></div><p><img src=\"@source/zkq/hnap/images/dev-note/01.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>注意：</strong></p>\n<ol>\n<li>\n<p>后缀 <code>.jks</code> 的签名文件是 <code>AndroidStudio</code> 向导生成的；后缀 <code>.keystore</code> 的签名文件是 <code>Eclipse</code> 的向导生成的，通过 <code>keytool</code> 命令生成签名文件时，这两种后缀都可以；</p>\n</li>\n<li>\n<p><code>-keysize 1024</code> 会有警告，所以使用 <code>-keysize 2048</code>；</p>\n</li>\n<li>\n<p><code>-validity 36500</code> 是 <code>36500</code> 天，即有效期 <code>100</code> 年；</p>\n</li>\n<li>\n<p>建议签名文件名、别名、密码、以及组织、地区等信息都用同一个名称，方便记忆。</p>\n</li>\n</ol>\n<p><strong>另外，可以执行如下命令查看生成的签名文件：</strong></p>\n<div><pre><code>keytool <span>--list</span> <span>-v</span> <span>-keystore</span> xxx.keystore\n</code></pre></div><p><img src=\"@source/zkq/hnap/images/dev-note/02.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_5-通过-pepk-jar-导出签名中的密钥并输出为-output-zip-文件\" tabindex=\"-1\"> 5. 通过 <code>pepk.jar</code> 导出签名中的密钥并输出为 <code>output.zip</code> 文件</h2>\n<p><img src=\"@source/zkq/hnap/images/dev-note/03.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>执行命令如下：</strong></p>\n<div><pre><code><span>java</span> <span>-jar</span> pepk.jar <span>--keystore</span><span>=</span>xxx.keystore <span>--alias</span><span>=</span>xxx <span>--output</span><span>=</span>output.zip --include-cert <span>--encryptionkey</span><span>=</span>eb10fe8f7c7c9df715022017b00c6471f8ba8170b13049a11e6c09ffe3056a104a3bbe4ac5a955f4ba4fe93fc8cef27558a3eb9d2a529a2092761fb833b656cd48b9de6a\n</code></pre></div><p><img src=\"@source/zkq/hnap/images/dev-note/04.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_6-本地安装-aab-包\" tabindex=\"-1\"> 6. 本地安装 <code>aab</code> 包</h2>\n<p><strong>注意：</strong></p>\n<p>有的手机需要安装两次 <code>apks</code> 文件后，才能打开 <code>app</code>。（第一次安装后打开无法找到资源文件）</p>\n<h3 id=\"_6-1-本地安装签名的-aab-包\" tabindex=\"-1\"> 6.1 本地安装签名的 <code>aab</code> 包</h3>\n<p><strong>Step 1.</strong> 先下载 <a href=\"https://github.com/google/bundletool/releases\" target=\"_blank\" rel=\"noopener noreferrer\">bundtool 工具<ExternalLinkIcon/></a>（一个 <code>jar</code> 包）放在本地新建的文件夹中</p>\n<p><strong>Step 2.</strong> 生成设备信息的 <code>json</code> 文件 <code>device-spec.json</code></p>\n<div><pre><code><span>java</span> <span>-jar</span> bundletool-all-1.11.2.jar get-device-spec <span>--output</span><span>=</span>./device-spec.json\n</code></pre></div><p><strong>Step 3.</strong> 转换 <code>apk</code> 文件（即 <code>apks</code> 文件）</p>\n<div><pre><code><span>java</span> <span>-jar</span> bundletool-all-1.11.2.jar build-apks <span>--bundle</span><span>=</span>./app-release.aab <span>--output</span><span>=</span>./app-release.apks <span>--overwrite</span> <span>--ks</span><span>=</span>./xxx.jks --ks-pass<span>=</span>pass:xxx --ks-key-alias<span>=</span>xxx --key-pass<span>=</span>pass:xxx --device-spec<span>=</span>./device-spec.json\n</code></pre></div><p><strong>Step 4.</strong> 安装 <code>apks</code></p>\n<div><pre><code><span>java</span> <span>-jar</span> bundletool-all-1.11.2.jar install-apks <span>--apks</span><span>=</span>./app-release.apks\n</code></pre></div><h3 id=\"_6-2-本地安装测试的-aab-包\" tabindex=\"-1\"> 6.2 本地安装测试的 <code>aab</code> 包</h3>\n<p>本地安装测试的 <code>aab</code> 包不需要设备信息文件，也不需要配置签名相关的属性：</p>\n<p><strong>Step 1.</strong> 先转换 <code>apk</code> 文件：</p>\n<div><pre><code><span>java</span> <span>-jar</span> bundletool-all-1.11.2.jar build-apks --local-testing <span>--bundle</span><span>=</span>./app-debug.aab <span>--output</span><span>=</span>./app-debug.apks\n</code></pre></div><p><strong>Step 2.</strong> 再安装 <code>apk</code> 文件：</p>\n<div><pre><code><span>java</span> <span>-jar</span> bundletool-all-1.11.2.jar install-apks <span>--apks</span> app-debug.apks\n</code></pre></div><h2 id=\"_7-aab-包无法连接-vpn-的解决配置\" tabindex=\"-1\"> 7. <code>aab</code> 包无法连接 <code>vpn</code> 的解决配置</h2>\n<blockquote>\n<p>参考：<a href=\"https://github.com/schwabe/ics-openvpn/issues/1331\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/schwabe/ics-openvpn/issues/1331<ExternalLinkIcon/></a></p>\n</blockquote>\n<p><strong>问题原因</strong></p>\n<p><code>aab</code> 打包时 <code>vpn</code> 的 <code>aar</code> 库中的 <code>so</code> 库在打包时出现了问题。</p>\n<p><strong>解决方案（修改编译配置）</strong></p>\n<ol>\n<li>\n<p>在引用了 <code>vpn</code> 的 <code>aar</code> 库的 <code>VPN</code> 项目的 <code>gradle.properties</code> 文件中添加如下配置属性：</p>\n<div><pre><code>android.bundle.enableUncompressedNativeLibs=false\n</code></pre></div></li>\n<li>\n<p>在引用了 <code>vpn</code> 的 <code>arr</code> 库的 <code>VPN</code> 项目下的 <code>app</code> 模块的 <code>build.gradle</code> 文件中添加：</p>\n<div><pre><code>android <span>{</span>\n  bundle <span>{</span>\n    abi <span>{</span> enableSplit <span>=</span> <span>false</span> <span>}</span> \n  <span>}</span>\n<span>}</span>\n</code></pre></div></li>\n</ol>\n<h2 id=\"_8-github-生成-token\" tabindex=\"-1\"> 8. <code>GitHub</code> 生成 <code>token</code></h2>\n<p><strong>Step 1.</strong> 登录 <code>GitHub</code> ，点击右上角头像，选中 <code>Settings</code> (设置)。</p>\n<p><img src=\"@source/zkq/hnap/images/dev-note/05.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>Step 2.</strong> 选择左侧菜单的 <code>Developer settings</code> 一项</p>\n<p><img src=\"@source/zkq/hnap/images/dev-note/06.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>Step 3.</strong> 再选择 <code>Personal access tokens</code></p>\n<p><img src=\"@source/zkq/hnap/images/dev-note/07.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>Step 4.</strong> 点击 <code>Generate a personal access token</code></p>\n<p><img src=\"@source/zkq/hnap/images/dev-note/08.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>Step 5.</strong> 设置 <code>token</code> 名字 &amp; 勾选权限</p>\n<p>在 <code>Note</code> 中随便填一个描述名称，下面的复选框是你这个 <code>token</code> 需要的权限，全部勾上就可以了。</p>\n<p><img src=\"@source/zkq/hnap/images/dev-note/09.png\" alt=\"\" loading=\"lazy\"></p>\n<p>然后点击下面这个绿色的按钮：</p>\n<p><img src=\"@source/zkq/hnap/images/dev-note/10.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>Step 6.</strong> 复制 <code>token</code> 值</p>\n<p>下面这个就是你的 <code>token</code> 了，可以直接复制使用。（记住这个 <code>token</code> 值，此值只显示一次）</p>\n<p><img src=\"@source/zkq/hnap/images/dev-note/11.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_9-使用-token-访问远程仓库\" tabindex=\"-1\"> 9. 使用 <code>token</code> 访问远程仓库</h2>\n<p>当从本地向 <code>GitHub</code> <code>push</code> 代码时，若提示如下的错误信息，则原因是 <code>GitHub</code> 不再使用密码方式验证身份，而是使用个人 <code>token</code>。</p>\n<div><pre><code><span>remote:</span> Support for password authentication was remove on August <span>123</span><span>,</span> <span>2021</span><span>.</span> Please use a personal access token instead<span>.</span>\n</code></pre></div><p>当通过  后，在访问 <code>GitHub</code> 远程仓库时（如执行 <code>git clone</code>，<code>git push</code>，<code>git pull</code> 命令），提示输入的密码就是个人 <code>token</code>。</p>\n<div><pre><code>$ <span>git</span> clone https://github.com/username/repo.git\nUsername: your_username\nPassword: your_token\n</code></pre></div><h2 id=\"_10-为-github-生成-ssh-key\" tabindex=\"-1\"> 10. 为 <code>GitHub</code> 生成 <code>SSH key</code></h2>\n<p>如果本地想通过 <code>SSH</code> 协议（而不是 <code>Https</code> 协议）克隆并访问远程仓库，那么需要先在本地生成 <code>SSH key</code>，并添加到 <code>GitHub</code> 账号中。</p>\n<p><strong>Step 1.</strong> 执行 <code>ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code> 命令生成 <code>SSH key</code></p>\n<p>后面的 <code>your_email@youremail.com</code> 改为你在 <code>Github</code> 上注册的邮箱。之后会要求确认路径和输入密码，我们这使用默认的一路回车就行。</p>\n<p>成功的话会在 <code>~/</code> 下生成 <code>.ssh</code> 文件夹，进去并打开 <code>id_rsa.pub</code>，复制里面的 <code>key</code>。</p>\n<p><img src=\"@source/zkq/hnap/images/dev-note/12.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>Step 2.</strong> 登陆 <code>github</code> ，进入 <code>Account</code> -&gt; <code>Settings</code>（账户配置）</p>\n<p><img src=\"@source/zkq/hnap/images/dev-note/13.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>Step 3.</strong> 左边选择 <code>SSH and GPG keys</code>，然后点击 <code>New SSH key</code> 按钮。</p>\n<p><code>title</code> 设置标题，可以随便填，粘贴在你电脑上生成的 <code>key</code>。</p>\n<p><img src=\"@source/zkq/hnap/images/dev-note/14.png\" alt=\"\" loading=\"lazy\"></p>\n<p><img src=\"@source/zkq/hnap/images/dev-note/15.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>Step 4.</strong> 添加成功后界面如下所示</p>\n<p><img src=\"@source/zkq/hnap/images/dev-note/16.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>Step 5.</strong> 为了验证是否成功，输入以下命令：</p>\n<p><img src=\"@source/zkq/hnap/images/dev-note/17.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_11-创建-github-远程仓库\" tabindex=\"-1\"> 11. 创建 <code>GitHub</code> 远程仓库</h2>\n<p><strong>Step 1.</strong> 登录 <code>GitHub</code>，点击 &quot;<code>New repository</code>&quot; 如下图所示：</p>\n<p><img src=\"@source/zkq/hnap/images/dev-note/18.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>Step 2.</strong> 在 <code>Repository name</code> 填入 <code>runoob-git-test</code> (远程仓库名)，其他保持默认设置，点击 &quot;<code>Create repository</code>&quot; 按钮，就成功地创建了一个新的 <code>Git</code> 仓库：</p>\n<blockquote>\n<p>注意：如果要创建私有仓库，选中 ”<code>Private</code>“。</p>\n</blockquote>\n<p><img src=\"@source/zkq/hnap/images/dev-note/19.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>Step 3.</strong> 创建成功后，显示如下信息：</p>\n<p><img src=\"@source/zkq/hnap/images/dev-note/20.png\" alt=\"\" loading=\"lazy\"></p>\n<p>以上信息告诉我们：</p>\n<ol>\n<li>\n<p>可以从这个远程仓库在本地克隆出新的仓库；</p>\n</li>\n<li>\n<p>也可以把本地仓库的内容推送到这个 <code>GitHub</code> 远程仓库。</p>\n</li>\n</ol>\n<h2 id=\"_12-透明主题\" tabindex=\"-1\"> 12. 透明主题</h2>\n<p>当启动时间较长且无法继续优化的情况下，通常会为 <code>App</code> 的启动页设置一个背景图，或者将启动页设置成透明主题。从而避免 <code>App</code> 在启动时出现白屏或黑屏现象。</p>\n<p><strong>Step 1. 给 Application 配置主题样式</strong></p>\n<div><pre><code><span>&lt;!-- res/values/themes.xml --></span>\n\n<span><span><span>&lt;</span>resources</span> <span><span>xmlns:</span>tools</span><span><span>=</span><span>\"</span>http://schemas.android.com/tools<span>\"</span></span><span>></span></span>\n    <span>&lt;!-- Base application theme. --></span>\n    <span><span><span>&lt;</span>style</span> <span>name</span><span><span>=</span><span>\"</span>Theme.FlashVPN<span>\"</span></span> <span>parent</span><span><span>=</span><span>\"</span>Theme.MaterialComponents.Light.NoActionBar<span>\"</span></span><span>></span></span>\n        <span>&lt;!-- Primary brand color. --></span>\n        <span><span><span>&lt;</span>item</span> <span>name</span><span><span>=</span><span>\"</span>colorPrimary<span>\"</span></span><span>></span></span>@color/purple_500<span><span><span>&lt;/</span>item</span><span>></span></span>\n        <span><span><span>&lt;</span>item</span> <span>name</span><span><span>=</span><span>\"</span>colorPrimaryVariant<span>\"</span></span><span>></span></span>@color/purple_700<span><span><span>&lt;/</span>item</span><span>></span></span>\n        <span><span><span>&lt;</span>item</span> <span>name</span><span><span>=</span><span>\"</span>colorOnPrimary<span>\"</span></span><span>></span></span>@color/white<span><span><span>&lt;/</span>item</span><span>></span></span>\n        <span>&lt;!-- Secondary brand color. --></span>\n        <span><span><span>&lt;</span>item</span> <span>name</span><span><span>=</span><span>\"</span>colorSecondary<span>\"</span></span><span>></span></span>@color/teal_200<span><span><span>&lt;/</span>item</span><span>></span></span>\n        <span><span><span>&lt;</span>item</span> <span>name</span><span><span>=</span><span>\"</span>colorSecondaryVariant<span>\"</span></span><span>></span></span>@color/teal_700<span><span><span>&lt;/</span>item</span><span>></span></span>\n        <span><span><span>&lt;</span>item</span> <span>name</span><span><span>=</span><span>\"</span>colorOnSecondary<span>\"</span></span><span>></span></span>@color/black<span><span><span>&lt;/</span>item</span><span>></span></span>\n        <span>&lt;!-- Status bar color. --></span>\n        <span><span><span>&lt;</span>item</span> <span>name</span><span><span>=</span><span>\"</span>android:statusBarColor<span>\"</span></span><span>></span></span>@android:color/transparent<span><span><span>&lt;/</span>item</span><span>></span></span>\n        <span>&lt;!-- Customize your theme here. --></span>\n\n        <span>&lt;!-- 为所有的 Activity 设置统一的转场动画 --></span>\n        <span><span><span>&lt;</span>item</span> <span>name</span><span><span>=</span><span>\"</span>android:windowAnimationStyle<span>\"</span></span><span>></span></span>@style/TransitionStyle<span><span><span>&lt;/</span>item</span><span>></span></span>\n\n        <span><span><span>&lt;</span>item</span> <span>name</span><span><span>=</span><span>\"</span>android:windowNoTitle<span>\"</span></span><span>></span></span>true<span><span><span>&lt;/</span>item</span><span>></span></span>\n\n        <span>&lt;!-- 为所有的 TextView 设置统一的字体 --></span>\n        <span><span><span>&lt;</span>item</span> <span>name</span><span><span>=</span><span>\"</span>android:fontFamily<span>\"</span></span><span>></span></span>@font/aileron_black<span><span><span>&lt;/</span>item</span><span>></span></span>\n    <span><span><span>&lt;/</span>style</span><span>></span></span>\n<span><span><span>&lt;/</span>resources</span><span>></span></span>\n</code></pre></div><div><pre><code><span>&lt;!-- res/values-v23/themes.xml --></span>\n<span><span><span>&lt;</span>resources</span><span>></span></span>\n    <span><span><span>&lt;</span>style</span> <span>name</span><span><span>=</span><span>\"</span>Theme.FlashVPN<span>\"</span></span> <span>parent</span><span><span>=</span><span>\"</span>Theme.MaterialComponents.Light.NoActionBar<span>\"</span></span><span>></span></span>\n        <span>&lt;!-- Primary brand color. --></span>\n        <span><span><span>&lt;</span>item</span> <span>name</span><span><span>=</span><span>\"</span>colorPrimary<span>\"</span></span><span>></span></span>@color/purple_500<span><span><span>&lt;/</span>item</span><span>></span></span>\n        <span><span><span>&lt;</span>item</span> <span>name</span><span><span>=</span><span>\"</span>colorPrimaryVariant<span>\"</span></span><span>></span></span>@color/purple_700<span><span><span>&lt;/</span>item</span><span>></span></span>\n        <span><span><span>&lt;</span>item</span> <span>name</span><span><span>=</span><span>\"</span>colorOnPrimary<span>\"</span></span><span>></span></span>@color/white<span><span><span>&lt;/</span>item</span><span>></span></span>\n        <span>&lt;!-- Secondary brand color. --></span>\n        <span><span><span>&lt;</span>item</span> <span>name</span><span><span>=</span><span>\"</span>colorSecondary<span>\"</span></span><span>></span></span>@color/teal_200<span><span><span>&lt;/</span>item</span><span>></span></span>\n        <span><span><span>&lt;</span>item</span> <span>name</span><span><span>=</span><span>\"</span>colorSecondaryVariant<span>\"</span></span><span>></span></span>@color/teal_700<span><span><span>&lt;/</span>item</span><span>></span></span>\n        <span><span><span>&lt;</span>item</span> <span>name</span><span><span>=</span><span>\"</span>colorOnSecondary<span>\"</span></span><span>></span></span>@color/black<span><span><span>&lt;/</span>item</span><span>></span></span>\n        <span>&lt;!-- Status bar color. --></span>\n        <span><span><span>&lt;</span>item</span> <span>name</span><span><span>=</span><span>\"</span>android:statusBarColor<span>\"</span></span><span>></span></span>@android:color/transparent<span><span><span>&lt;/</span>item</span><span>></span></span>\n        <span>&lt;!-- Customize your theme here. --></span>\n\n        <span>&lt;!-- 为所有的 Activity 设置统一的转场动画 --></span>\n        <span><span><span>&lt;</span>item</span> <span>name</span><span><span>=</span><span>\"</span>android:windowAnimationStyle<span>\"</span></span><span>></span></span>@style/TransitionStyle<span><span><span>&lt;/</span>item</span><span>></span></span>\n\n        <span><span><span>&lt;</span>item</span> <span>name</span><span><span>=</span><span>\"</span>android:windowNoTitle<span>\"</span></span><span>></span></span>true<span><span><span>&lt;/</span>item</span><span>></span></span>\n\n        <span>&lt;!-- 为所有的 TextView 设置统一的字体 --></span>\n        <span><span><span>&lt;</span>item</span> <span>name</span><span><span>=</span><span>\"</span>fontFamily<span>\"</span></span><span>></span></span>@font/aileron_black<span><span><span>&lt;/</span>item</span><span>></span></span>\n\n\n\n        <span>&lt;!-- 以上跟 values/themes.xml 一样 --></span>\n\n\n        <span>&lt;!-- Android 6.0 (API 23) 以上设置 windowLightStatusBar 为 true，从而为亮背景的状态栏配置黑色字体 --></span>\n        <span><span><span>&lt;</span>item</span> <span>name</span><span><span>=</span><span>\"</span>android:windowLightStatusBar<span>\"</span></span><span>></span></span>true<span><span><span>&lt;/</span>item</span><span>></span></span>\n    <span><span><span>&lt;/</span>style</span><span>></span></span>\n<span><span><span>&lt;/</span>resources</span><span>></span></span>\n</code></pre></div><div><pre><code><span>&lt;!-- res/values/styles.xml --></span>\n\n<span>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?></span>\n<span><span><span>&lt;</span>resources</span><span>></span></span>\n    <span><span><span>&lt;</span>style</span> <span>name</span><span><span>=</span><span>\"</span>TransitionStyle<span>\"</span></span> <span>mce_bogus</span><span><span>=</span><span>\"</span>1<span>\"</span></span> <span>parent</span><span><span>=</span><span>\"</span>@android:style/Animation.Activity<span>\"</span></span><span>></span></span>\n        <span><span><span>&lt;</span>item</span> <span>name</span><span><span>=</span><span>\"</span>android:activityOpenEnterAnimation<span>\"</span></span><span>></span></span>@anim/open_enter<span><span><span>&lt;/</span>item</span><span>></span></span>\n        <span><span><span>&lt;</span>item</span> <span>name</span><span><span>=</span><span>\"</span>android:activityOpenExitAnimation<span>\"</span></span><span>></span></span>@anim/open_exit<span><span><span>&lt;/</span>item</span><span>></span></span>\n        <span><span><span>&lt;</span>item</span> <span>name</span><span><span>=</span><span>\"</span>android:activityCloseEnterAnimation<span>\"</span></span><span>></span></span>@anim/close_enter<span><span><span>&lt;/</span>item</span><span>></span></span>\n        <span><span><span>&lt;</span>item</span> <span>name</span><span><span>=</span><span>\"</span>android:activityCloseExitAnimation<span>\"</span></span><span>></span></span>@anim/close_exit<span><span><span>&lt;/</span>item</span><span>></span></span>\n\n        <span><span><span>&lt;</span>item</span> <span>name</span><span><span>=</span><span>\"</span>android:taskOpenEnterAnimation<span>\"</span></span><span>></span></span>@anim/open_enter<span><span><span>&lt;/</span>item</span><span>></span></span>\n        <span><span><span>&lt;</span>item</span> <span>name</span><span><span>=</span><span>\"</span>android:taskOpenExitAnimation<span>\"</span></span><span>></span></span>@anim/open_exit<span><span><span>&lt;/</span>item</span><span>></span></span>\n        <span><span><span>&lt;</span>item</span> <span>name</span><span><span>=</span><span>\"</span>android:taskCloseEnterAnimation<span>\"</span></span><span>></span></span>@anim/close_enter<span><span><span>&lt;/</span>item</span><span>></span></span>\n        <span><span><span>&lt;</span>item</span> <span>name</span><span><span>=</span><span>\"</span>android:taskCloseExitAnimation<span>\"</span></span><span>></span></span>@anim/close_exit<span><span><span>&lt;/</span>item</span><span>></span></span>\n        <span><span><span>&lt;</span>item</span> <span>name</span><span><span>=</span><span>\"</span>android:taskToFrontEnterAnimation<span>\"</span></span><span>></span></span>@anim/open_enter<span><span><span>&lt;/</span>item</span><span>></span></span>\n        <span><span><span>&lt;</span>item</span> <span>name</span><span><span>=</span><span>\"</span>android:taskToFrontExitAnimation<span>\"</span></span><span>></span></span>@anim/open_exit<span><span><span>&lt;/</span>item</span><span>></span></span>\n        <span><span><span>&lt;</span>item</span> <span>name</span><span><span>=</span><span>\"</span>android:taskToBackEnterAnimation<span>\"</span></span><span>></span></span>@anim/close_enter<span><span><span>&lt;/</span>item</span><span>></span></span>\n        <span><span><span>&lt;</span>item</span> <span>name</span><span><span>=</span><span>\"</span>android:taskToBackExitAnimation<span>\"</span></span><span>></span></span>@anim/close_exit<span><span><span>&lt;/</span>item</span><span>></span></span>\n    <span><span><span>&lt;/</span>style</span><span>></span></span>\n<span><span><span>&lt;/</span>resources</span><span>></span></span>\n</code></pre></div><p><strong>Step 2. 给启动 Activity 配置主题样式</strong></p>\n<p><strong>注意：</strong></p>\n<p>在有的手机上，只是设置 <code>&lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt;</code> 无法实现透明主题，</p>\n<p>还需要加上 <code>&lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/bg_launch&lt;/item&gt;</code>，其中背景图片为一个透明的 <code>shape</code> 图。</p>\n<div><pre><code><span>&lt;!-- res/values/styles.xml --></span>\n\n<span>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?></span>\n<span><span><span>&lt;</span>resources</span><span>></span></span>\n    <span><span><span>&lt;</span>style</span> <span>name</span><span><span>=</span><span>\"</span>LaunchTheme<span>\"</span></span> <span>parent</span><span><span>=</span><span>\"</span>Theme.MaterialComponents.Light.NoActionBar<span>\"</span></span><span>></span></span>\n        <span><span><span>&lt;</span>item</span> <span>name</span><span><span>=</span><span>\"</span>android:windowBackground<span>\"</span></span><span>></span></span>@drawable/bg_launch<span><span><span>&lt;/</span>item</span><span>></span></span>\n        <span><span><span>&lt;</span>item</span> <span>name</span><span><span>=</span><span>\"</span>android:windowIsTranslucent<span>\"</span></span><span>></span></span>true<span><span><span>&lt;/</span>item</span><span>></span></span>\n        <span><span><span>&lt;</span>item</span> <span>name</span><span><span>=</span><span>\"</span>android:statusBarColor<span>\"</span></span><span>></span></span>@android:color/transparent<span><span><span>&lt;/</span>item</span><span>></span></span>\n        <span><span><span>&lt;</span>item</span> <span>name</span><span><span>=</span><span>\"</span>android:navigationBarColor<span>\"</span></span><span>></span></span>@android:color/transparent<span><span><span>&lt;/</span>item</span><span>></span></span>\n        <span><span><span>&lt;</span>item</span> <span>name</span><span><span>=</span><span>\"</span>fontFamily<span>\"</span></span><span>></span></span>@font/aileron_black<span><span><span>&lt;/</span>item</span><span>></span></span>\n    <span><span><span>&lt;/</span>style</span><span>></span></span>\n<span><span><span>&lt;/</span>resources</span><span>></span></span>\n</code></pre></div><div><pre><code><span>&lt;!-- res/drawable/bg_launch.xml --></span>\n\n<span>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?></span>\n<span><span><span>&lt;</span>shape</span> <span><span>xmlns:</span>android</span><span><span>=</span><span>\"</span>http://schemas.android.com/apk/res/android<span>\"</span></span><span>></span></span>\n    <span><span><span>&lt;</span>solid</span> <span><span>android:</span>color</span><span><span>=</span><span>\"</span>@color/transparent<span>\"</span></span><span>/></span></span>\n<span><span><span>&lt;/</span>shape</span><span>></span></span>\n</code></pre></div><p><strong>Step 3. 在 AndroidManifest.xml 中使用透明主题</strong></p>\n<div><pre><code><span>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?></span>\n<span><span><span>&lt;</span>manifest</span> <span><span>xmlns:</span>android</span><span><span>=</span><span>\"</span>http://schemas.android.com/apk/res/android<span>\"</span></span>\n    <span><span>xmlns:</span>tools</span><span><span>=</span><span>\"</span>http://schemas.android.com/tools<span>\"</span></span><span>></span></span>\n\n    <span><span><span>&lt;</span>application</span>\n        <span>...</span>\n        <span><span>android:</span>theme</span><span><span>=</span><span>\"</span>@style/Theme.FlashVPN<span>\"</span></span>\n        <span>...</span><span>></span></span>\n\n        <span><span><span>&lt;</span>activity</span> <span><span>android:</span>name</span><span><span>=</span><span>\"</span>com.cfos.vpn.ui.launch.LaunchUI<span>\"</span></span>\n            <span><span>android:</span>theme</span><span><span>=</span><span>\"</span>@style/LaunchTheme<span>\"</span></span>\n            <span><span>android:</span>exported</span><span><span>=</span><span>\"</span>true<span>\"</span></span>\n            <span><span>android:</span>launchMode</span><span><span>=</span><span>\"</span>singleTask<span>\"</span></span><span>></span></span>\n            <span><span><span>&lt;</span>intent-filter</span><span>></span></span>\n                <span><span><span>&lt;</span>action</span> <span><span>android:</span>name</span><span><span>=</span><span>\"</span>android.intent.action.MAIN<span>\"</span></span> <span>/></span></span>\n                <span><span><span>&lt;</span>category</span> <span><span>android:</span>name</span><span><span>=</span><span>\"</span>android.intent.category.LAUNCHER<span>\"</span></span> <span>/></span></span>\n            <span><span><span>&lt;/</span>intent-filter</span><span>></span></span>\n        <span><span><span>&lt;/</span>activity</span><span>></span></span>\n\n    <span><span><span>&lt;/</span>application</span><span>></span></span>\n\n<span><span><span>&lt;/</span>manifest</span><span>></span></span>\n</code></pre></div><h2 id=\"_13-build-gradle-中配置签名文件\" tabindex=\"-1\"> 13. <code>build.gradle</code> 中配置签名文件</h2>\n<div><pre><code><span>/* Module build.gradle */</span>\nandroid <span>{</span>\n    signingConfigs <span>{</span>\n        release <span>{</span>\n            v1SigningEnabled <span>true</span>\n            v2SigningEnabled <span>true</span>\n            keyAlias <span>'xxx'</span>\n            keyPassword <span>'xxx'</span>\n            storeFile <span>file</span><span>(</span><span>'sign/xxx.jks'</span><span>)</span> <span>// 路径为 &lt;Module>/sign/xxx.jks</span>\n            storePassword <span>'xxx'</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre></div><h2 id=\"_14-build-gradle-中配置混淆\" tabindex=\"-1\"> 14. <code>build.gradle</code> 中配置混淆</h2>\n<div><pre><code>android <span>{</span>\n    buildTypes <span>{</span>\n        release <span>{</span>\n            minifyEnabled <span>true</span>\n            shrinkResources <span>true</span>\n            proguardFiles <span>getDefaultProguardFile</span><span>(</span><span>'proguard-android-optimize.txt'</span><span>)</span><span>,</span> <span>'proguard-rules.pro'</span>\n\n            <span>// TODO 设置是否要自动上传 mapping.txt 文件到 Firebase（默认为true，要自动上传），正式环境注释掉</span>\n            firebaseCrashlytics <span>{</span>\n                mappingFileUploadEnabled <span>false</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre></div><h2 id=\"_16-在一台设备上管理多个不同-github-账号的仓库\" tabindex=\"-1\"> 16. 在一台设备上管理多个不同 <code>GitHub</code> 账号的仓库</h2>\n<blockquote>\n<p>参考：<a href=\"https://blog.csdn.net/weixin_38214171/article/details/95080746\" target=\"_blank\" rel=\"noopener noreferrer\">彻底解决github push failed问题（remote: Permission to userA/repo.git denied to userB）<ExternalLinkIcon/></a></p>\n<p>参考：<a href=\"https://blog.csdn.net/qazwsxrx/article/details/125554433\" target=\"_blank\" rel=\"noopener noreferrer\">git clone private repo remote: Repository not found. | git新电脑上clone私有库<ExternalLinkIcon/></a></p>\n<p>参考：<a href=\"https://blog.csdn.net/wzy901213/article/details/84334163\" target=\"_blank\" rel=\"noopener noreferrer\">Git配置credential helper<ExternalLinkIcon/></a></p>\n</blockquote>\n<p><strong><code>Mac</code> 上管理多个不同 <code>GitHub</code> 账号的仓库时，可能会出现如下问题：</strong></p>\n<div><pre><code>zkqcom@zkqcomdeMac-mini JavaGuide % <span>git</span> push\nremote: Permission to zengkaiqiang562/JavaGuide.git denied to HarrietCeda.\nfatal: unable to access <span>'https://github.com/zengkaiqiang562/JavaGuide.git/'</span><span>:</span> The requested URL returned error: <span>403</span>\n</code></pre></div><p>出现以上问题的原因是 <code>Mac</code> 上存在一个 <code>HarrietCeda</code> 账号下的 <code>FlashVPN</code> 仓库，和一个 <code>zengkaiqiang562</code> 账号下的 <code>JavaGuide</code> 仓库，\n而 <code>Mac</code> 的钥匙访问串中只为 <code>HarrietCeda</code> 保存了 <code>GitHub</code> 账号密码，所以当在 <code>zengkaiqiang562</code> 账号下的 <code>JavaGuide</code> 仓库中执行 <code>git push</code> 命令时，默认就会使用钥匙访问串中的 <code>HarrietCeda</code> 账号来访问 <code>zengkaiqiang562</code> 账号下的 <code>JavaGuide</code> 仓库，从而报错：</p>\n<div><pre><code>Permission to zengkaiqiang562/JavaGuide.git denied to HarrietCeda.\n</code></pre></div><p><strong>另一个问题如下：</strong></p>\n<div><pre><code>zkqcom@zkqcomdeMac-mini FlashVPN % <span>git</span> push\nremote: Repository not found.\nfatal: repository <span>'https://github.com/HarrietCeda/FlashVPN.git/'</span> not found\n</code></pre></div><p>出现以上问题的原因是在解决上一个问题时，将 <code>Mac</code> 的钥匙访问串中为 <code>HarrietCeda</code> 保存的 <code>GitHub</code> 账号密码给删除了，并且由于 <code>HarrietCeda</code> 账号下的 <code>FlashVPN</code> 仓库是私有的（<code>Private</code>），从而 <code>Git</code> 无法在 <code>GitHub</code> 上找到私有仓库 <code>FlashVPN</code> 了。</p>\n<p><strong>解决方式：</strong></p>\n<p>将这两个仓库的 <code>https</code> 地址都改成 <code>https://&lt;账号名&gt;@github.com/&lt;账号名&gt;/&lt;仓库名&gt;.git/</code> 的形式。</p>\n<p>已 <code>FalshVPN</code> 为例，编辑 <code>FalshVPN</code> 仓库下的 <code>.git/config</code> 文件，</p>\n<p>将第 <code>9</code> 行的 <code>https://github.com/HarrietCeda/FlashVPN.git/</code> 改为 <code>https://HarrietCeda@github.com/HarrietCeda/FlashVPN.git</code></p>\n<div><pre><code>zkqcom@zkqcomdeMac-mini FlashVPN % <span>vim</span> .git/config    \n</code></pre></div><p><img src=\"@source/zkq/hnap/images/dev-note/21.png\" alt=\"\" loading=\"lazy\"></p>\n<p>于是，执行 <code>git push</code> 访问远程仓库时就会要求重新输入密码。</p>\n<p>以同样的方式修改 <code>zengkaiqiang562</code> 账号下的 <code>JavaGuide</code> 仓库关联的远程 <code>GitHub</code> 仓库地址即可。</p>\n<p>于是，在 <code>Mac</code> 的钥匙访问串中，就会为这两个 <code>GitHub</code> 账号分别生成对应的钥匙串项目，如下图所示：</p>\n<p><img src=\"@source/zkq/hnap/images/dev-note/22.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>通过 <code>Credential Helper</code> 保存密码</strong></p>\n<p>可以通过 <code>Credential Helper</code> 保存 <code>Git</code> 仓库的密码，避免每次访问远程仓库时都要求输入密码。</p>\n<p>以 <code>FlashVPN</code> 为例，执行如下指令：</p>\n<div><pre><code>zkqcom@zkqcomdeMac-mini FlashVPN % <span>git</span> config <span>--local</span> credential.helper store\nzkqcom@zkqcomdeMac-mini FlashVPN % <span>git</span> config <span>--local</span> <span>--list</span>                 \n<span>..</span>.\n<span>user.name</span><span>=</span>HarrietCeda\n<span>user.email</span><span>=</span>HarrietCeda@outlook.com\n<span>credential.helper</span><span>=</span>store\nzkqcom@zkqcomdeMac-mini FlashVPN % \n</code></pre></div><blockquote>\n<p>因为存在多个 <code>GitHub</code> 账号下的仓库，所以使用选项 <code>--local</code> 单独的为一个仓库进行配置。</p>\n</blockquote>\n<p>设置了 <code>credential.helper=store</code> 之后，在执行 <code>git push</code> 命令访问远程仓库并输入密码后，就会把密码保存在 <code>~/.git-credentials</code> 文件中。</p>\n<div><pre><code>zkqcom@zkqcomdeMac-mini FlashVPN % <span>cat</span> ~/.git-credentials   \nhttps://HarrietCeda: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@github.com\nhttps://zengkaiqiang562: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@github.com\n</code></pre></div><blockquote>\n<p>以上为 <code>HarrietCeda</code> 和 <code>zengkaiqiang562</code> 这两个账号保存了密码（密码就是 <code>token</code>，一个账号的所有仓库可以共用一个 <code>token</code> 作为密码）。</p>\n</blockquote>\n<p><strong>注意：<code>Credential Helper</code> 保存多个账号的不同 <code>Token</code>，会导致 <code>Token</code> 被 <code>Github</code> 检测为不安全的，从而删除掉。</strong></p>\n",
      "date_published": "2022-10-20T05:55:38.000Z",
      "date_modified": "2023-05-04T15:57:35.000Z",
      "authors": [],
      "tags": [
        "HNAP"
      ]
    },
    {
      "title": "Linux",
      "url": "https://zengkaiqiang562.github.io/zkq/linux/",
      "id": "https://zengkaiqiang562.github.io/zkq/linux/",
      "content_html": "",
      "date_published": "2022-10-01T13:16:41.000Z",
      "date_modified": "2022-10-01T13:16:41.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "命令行-shell-bash特点",
      "url": "https://zengkaiqiang562.github.io/zkq/linux/_1_basic/_03_shell_bash_trait.html",
      "id": "https://zengkaiqiang562.github.io/zkq/linux/_1_basic/_03_shell_bash_trait.html",
      "content_html": "<h2 id=\"_1-bash-shell-基本概念\" tabindex=\"-1\"> 1. <code>Bash Shell</code> 基本概念</h2>\n<p><strong>什么是 <code>Bash Shell</code>（壳）：</strong></p>\n<div><pre><code>Bash Shell 是一个命令解释器，主要负责用户程序与内核进行交互操作的一种接口。\n将用户输入的命令翻译给内核，由内核驱动硬件，最终将处理后的结果输出至 Bash Shell 屏幕终端。\n</code></pre></div><p><strong><code>Bash Shell</code> 能干什么：</strong></p>\n<div><pre><code>使用 Shell 实现对 Linux 系统的大部分管理，如：\n1. 文件管理\n2. 权限管理\n3. 用户管理\n4. 磁盘管理\n5. 网络管理\n6. 软件管理\n...\n</code></pre></div><p><strong>使用 <code>Shell</code> 的两种方式：</strong></p>\n<ol>\n<li>\n<p>输入命令：效率低，适合少量的工作。</p>\n</li>\n<li>\n<p><code>Shell Script</code>（<code>Shell</code> 脚本）：效率高，适合重复性的工作。</p>\n</li>\n</ol>\n<h2 id=\"_2-bash-shell-提示符\" tabindex=\"-1\"> 2. <code>Bash Shell</code> 提示符</h2>\n<p><img src=\"@source/zkq/linux/_1_basic/images/_03_shell_bash_trait/01.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>以上添加用户的命令前的 Bash Shell 提示符如下：\n[root@web ~]#\n其中：\n1. root: 表示当前登录系统的用户名称（root 表示用户为超级管理员）\n2. web: 主机名称（在安装系统时可设定，默认为 localhost）\n3. ~: 当前用户的家目录。每个用户都有自己的家目录\n4. #: 表示当前登录用户为超级管理员。一般不修改该提示符。\n   $: 表示当前登录用户为普通用户。一般不修改该提示符。\n</code></pre></div><h2 id=\"_3-bash-shell-基础语法\" tabindex=\"-1\"> 3. <code>Bash Shell</code> 基础语法</h2>\n<div><pre><code><span># 命令    选项    参数</span>\n<span>command</span> <span>[</span>-options<span>]</span> <span>[</span>arguments<span>]</span>\n</code></pre></div><p><strong>示例：</strong></p>\n<p><img src=\"@source/zkq/linux/_1_basic/images/_03_shell_bash_trait/02.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>命令：整条 Shell 命令的主体。\n选项：用于调节命令的具体功能，其中：\n    1. 以 \"-\" 引导短格式选项（单个字符），例如 \"-a\"；\n    2. 以 \"--\" 引导长格式选项（多个字符），例如 \"--all\"；\n    3. 多个短格式选项可以写在一起，只用一个 \"-\" 引导，例如 \"-la\"\n参数：命令操作的对象，如文件、目录等。\n\n注意：命令必须写在开头，选项和参数的位置可以发生变化。\n</code></pre></div><h2 id=\"_4-bash-shell-特性\" tabindex=\"-1\"> 4. <code>Bash Shell</code> 特性</h2>\n<h3 id=\"_4-1-命令补全-路径补全-tab\" tabindex=\"-1\"> 4.1 命令补全 &amp; 路径补全：<code>tab</code></h3>\n<div><pre><code>tab 键可以实现命令补全，路径补全，在实现生产中，tab 补全往往是我们使用最多的，因为可以减少执行命令以及路径出错率。\n</code></pre></div><h3 id=\"_4-2-快捷键\" tabindex=\"-1\"> 4.2 快捷键</h3>\n<h4 id=\"_4-2-1-光标移动到行首-ctrl-a\" tabindex=\"-1\"> 4.2.1 光标移动到行首：<code>Ctrl + A</code></h4>\n<h4 id=\"_4-2-2-光标移动到行尾-ctrl-e\" tabindex=\"-1\"> 4.2.2 光标移动到行尾：<code>Ctrl + E</code></h4>\n<h4 id=\"_4-2-3-清屏-对应命令-clear-ctrl-l\" tabindex=\"-1\"> 4.2.3 清屏（对应命令 <code>clear</code>）：<code>Ctrl + L</code></h4>\n<h4 id=\"_4-2-4-结束当前任务-ctrl-c\" tabindex=\"-1\"> 4.2.4 结束当前任务：<code>Ctrl + C</code></h4>\n<h4 id=\"_4-2-5-删除光标以后的所有内容-ctrl-k\" tabindex=\"-1\"> 4.2.5 删除光标以后的所有内容：<code>Ctrl + K</code></h4>\n<h4 id=\"_4-2-6-删除光标以前的所有内容-ctrl-u\" tabindex=\"-1\"> 4.2.6 删除光标以前的所有内容：<code>Ctrl + U</code></h4>\n<h4 id=\"_4-2-7-按单词删除光标以前的内容-ctrl-w\" tabindex=\"-1\"> 4.2.7 按单词删除光标以前的内容：<code>Ctrl + W</code></h4>\n<h4 id=\"_4-2-8-退出当前的-bash-会话-ctrl-d\" tabindex=\"-1\"> 4.2.8 退出当前的 <code>Bash</code> 会话：<code>Ctrl + D</code></h4>\n<div><pre><code>并不影响服务器运行的后台程序\n</code></pre></div><h4 id=\"_4-2-9-按单词进行跳跃-ctrl-左右\" tabindex=\"-1\"> 4.2.9 按单词进行跳跃：<code>Ctrl + 左右</code></h4>\n<div><pre><code>Mac OS 的快捷键为 ALT + 左右\n</code></pre></div><h3 id=\"_4-3-命令的历史记录-history\" tabindex=\"-1\"> 4.3 命令的历史记录：<code>history</code></h3>\n<div><pre><code><span># 查看命令历史记录 history</span>\n<span>history</span>\n\n<span># 保存命令历史记录</span>\n<span>history</span> <span>-w</span>\n\n<span># 清空命令历史记录（不会清空文件）</span>\n<span>history</span> <span>-c</span>\n\n<span># 删除命令历史记录中的第 N 条记录</span>\n<span>history</span> <span>-d</span>\n</code></pre></div><div><pre><code><span># 使用 !! 可执行上一条执行过的命令</span>\n<span>!</span><span>!</span>\n\n<span># 输入 !6 执行 history 命令历史记录中的第 6 条记录</span>\n<span>!</span><span>6</span>\n\n<span># 使用 !cat 调用 history 命令历史记录中最近一次执行过的 cat 命令</span>\n<span>!</span>cat\n</code></pre></div><div><pre><code>~/.bash_history 文件就是历史记录文件\n</code></pre></div><h3 id=\"_4-4-命令别名-alias\" tabindex=\"-1\"> 4.4 命令别名：<code>alias</code></h3>\n<p><strong>设置别名：</strong></p>\n<div><pre><code><span>alias</span> <span>net</span><span>=</span><span>'cat /etc/sysconfig/network-scripts/ifcfg-ens32'</span>\n</code></pre></div><p><strong>取消别名：</strong></p>\n<div><pre><code><span>unalias</span> net\n</code></pre></div><p><strong>查看已设置的所有别名：</strong></p>\n<div><pre><code><span>alias</span>\n</code></pre></div><p><strong>永久保存别名：</strong></p>\n<div><pre><code>在 A 窗口设置的别名，在 B 窗口是无法使用的。除非将别名保存为永久别名。\n\n别名需要写入到 ~/.bashrc 文件中才能永久保存。\n</code></pre></div><div><pre><code><span>echo</span> <span>\"alias net='cat /etc/sysconfig/network-scripts/ifcfg-ens32'\"</span> <span>>></span> .bashrc\n</code></pre></div><div><pre><code>echo 命令的特点是 “所见即所得”，即该命令会输出该命令后跟随的内容。\n\">>\" 追加操作符的作用是往文件中追加内容。\n通过 echo 命令和追加操作符 \">>\" 即可将别名保存到 \">>\" 后的文件 .bashrc 中。\n</code></pre></div>",
      "date_published": "2022-10-01T13:16:41.000Z",
      "date_modified": "2022-11-29T11:59:16.000Z",
      "authors": [],
      "tags": [
        "linux"
      ]
    },
    {
      "title": "linux文件管理",
      "url": "https://zengkaiqiang562.github.io/zkq/linux/_1_basic/_04_linux_file_manage.html",
      "id": "https://zengkaiqiang562.github.io/zkq/linux/_1_basic/_04_linux_file_manage.html",
      "content_html": "<h2 id=\"_1-linux-目录结构\" tabindex=\"-1\"> 1. <code>linux</code> 目录结构</h2>\n<p><img src=\"@source/zkq/linux/_1_basic/images/_04_linux_file_manage/01.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_1-1-命令目录-bin-usr-bin、-sbin-usr-sbin\" tabindex=\"-1\"> 1.1 命令目录：<code>/bin --&gt; /usr/bin</code>、<code>/sbin --&gt; /usr/sbin</code></h3>\n<div><pre><code>/bin --> /usr/bin\n存放命令，一般来说，普通用户和 root 用户都可以运行。\n\n/sbin --> /usr/sbin\n存在特殊命令，一般来说，root 用户才可以运行。当然，普通用户可以申请操作的权限。\n</code></pre></div><h3 id=\"_1-2-用户家目录-home、-root\" tabindex=\"-1\"> 1.2 用户家目录：<code>/home</code>、<code>/root</code></h3>\n<div><pre><code>/home\n是普通用户的家目录\n\n/root\n是超级管理员的家目录\n</code></pre></div><h3 id=\"_1-3-配置文件目录-etc\" tabindex=\"-1\"> 1.3 配置文件目录：<code>/etc</code></h3>\n<div><pre><code>/etc\n用于存储配置文件的命令，如：\n1. 修改 IP 地址：/etc/sysconfig/network-scripts/ifcfg-xxx\n2. 修改主机名称：/etc/hostname\n\n修改完配置文件后如何生效？\n1. 有的配置在修改后立即生效，即运行命令程序时即可生效。\n2. 有的配置在修改后需要重启系统才能生效。\n</code></pre></div><h3 id=\"_1-4-启动目录-boot\" tabindex=\"-1\"> 1.4 启动目录：<code>/boot</code></h3>\n<div><pre><code>/boot\n存储系统启动时加载的文件，比如：内核文件、Grub 菜单、救援内核系统等\n注意：如果删除启动目录中的文件，可能会造成无法启动系统的问题。\n</code></pre></div><h3 id=\"_1-5-设备目录-dev\" tabindex=\"-1\"> 1.5 设备目录：<code>/dev</code></h3>\n<div><pre><code>/dev\n设备目录中主要存放：键盘、光盘、磁盘、终端、/dev/null、/dev/random 等设备文件。\n</code></pre></div><h4 id=\"_1-5-1-黑洞-dev-null\" tabindex=\"-1\"> 1.5.1 黑洞：<code>/dev/null</code></h4>\n<div><pre><code>黑洞文件，存储在这个设备文件中的数据都会丢失。\n</code></pre></div><h4 id=\"_1-5-2-产生随机数-dev-random\" tabindex=\"-1\"> 1.5.2 产生随机数：<code>dev/random</code></h4>\n<div><pre><code>产生随机数。\n</code></pre></div><h3 id=\"_1-6-临时目录-tmp\" tabindex=\"-1\"> 1.6 临时目录：<code>/tmp</code></h3>\n<div><pre><code>/tmp\n谁都可以存储数据在该临时目录中。但是自己的数据只能自己移除，别人只能看却无法移除。\n</code></pre></div><h3 id=\"_1-7-可变目录-var\" tabindex=\"-1\"> 1.7 可变目录：<code>/var</code></h3>\n<div><pre><code>/var\n可变是指会随着系统的运行（运行会产生一些数据、记录）而不断地发生变化。\n\n/var/log\n存储日志的目录，如：启动日志、系统操作日志、系统登录日志等。\n</code></pre></div><h3 id=\"_1-8-运行时目录-proc\" tabindex=\"-1\"> 1.8 运行时目录：<code>/proc</code></h3>\n<div><pre><code>/proc\n记录设备（如 CPU、内存、磁盘）运行状态。\n</code></pre></div><h3 id=\"_1-9-系统目录-usr\" tabindex=\"-1\"> 1.9 系统目录：<code>/usr</code></h3>\n<div><pre><code>/usr\n和 windows 中的 C:\\program files 目录类似。\n\n/usr/lib, /usr/lib64\n存放的是库文件\n\n/usr/local\n存放自行安装软件的路径（安装后的位置）。注：现在不用这种方式了\n\n/usr/src\n存放安装包（安装前的软件存储路径）。注：现在不用这种方式了\n</code></pre></div><h2 id=\"_2-文件路径\" tabindex=\"-1\"> 2. 文件路径</h2>\n<div><pre><code>绝对路径：一定是从 / 开始的。即从 / 开始的路径都是绝对路径。\n相对路径：相对于当前所在目录的路径。\n</code></pre></div><div><pre><code>.\n表示当前目录\n\n..\n表示上一级目录\n</code></pre></div>",
      "date_published": "2022-10-01T13:16:41.000Z",
      "date_modified": "2022-11-30T09:21:18.000Z",
      "authors": [],
      "tags": [
        "linux"
      ]
    },
    {
      "title": "linux基础命令",
      "url": "https://zengkaiqiang562.github.io/zkq/linux/_1_basic/_05_linux_basic_cmd.html",
      "id": "https://zengkaiqiang562.github.io/zkq/linux/_1_basic/_05_linux_basic_cmd.html",
      "content_html": "<h2 id=\"_1-文件管理命令\" tabindex=\"-1\"> 1. 文件管理命令</h2>\n<h3 id=\"_1-1-创建命令-mkdir、touch\" tabindex=\"-1\"> 1.1 创建命令：<code>mkdir</code>、<code>touch</code></h3>\n<p><strong>创建目录命令：<code>mkdir</code></strong></p>\n<div><pre><code>-p: 递归创建目录\n-v: 显示过程\n</code></pre></div><div><pre><code><span># 在根目录下创建 linux-76 目录</span>\n<span>mkdir</span> /linux-76\n\n<span># 递归创建多个不存在的目录，并显示创建的过程</span>\n<span>mkdir</span> <span>-pv</span> /linux-76/11/22/33/44/55\n</code></pre></div><p><strong>创建目文件命令：<code>touch</code></strong></p>\n<div><pre><code>touch 可用于创建空文件，或者改变已创建文件的时间戳属性\n</code></pre></div><div><pre><code><span># 创建一个文件</span>\n<span>touch</span> /tmp/file.txt\n\n<span># 创建多个文件</span>\n<span>touch</span> /tmp/file1.txt /tmp/file2.txt\n\n<span># 通过 {} 生成序列，并创建多个文件</span>\n<span>touch</span> /tmp/file<span>{</span><span>1</span><span>..</span><span>10</span><span>}</span>.txt\n\n<span># {} 中可以是数字序列，也可以是字母序列</span>\n<span>touch</span> /tmp/file<span>{</span>a<span>..</span>z<span>}</span>.txt\n</code></pre></div><h3 id=\"_1-2-删除命令-rm\" tabindex=\"-1\"> 1.2 删除命令：<code>rm</code></h3>\n<div><pre><code>-r: 删除目录以及目录下的文件，并且采用递归方式\n-f: force 强制删除，不提示\n-i: 提示是否删除。（系统已为我们添加好别名，所以每次删除时都会提示）\n</code></pre></div><div><pre><code><span># 删除 /student.txt 文件</span>\n<span>rm</span> <span>-f</span> /student.txt\n\n<span># 删除 /linux-76 目录。该目录下有很多子目录，希望递归删除</span>\n<span>rm</span> <span>-rf</span> /linux-76/\n</code></pre></div><h3 id=\"_1-3-复制命令-cp\" tabindex=\"-1\"> 1.3 复制命令：<code>cp</code></h3>\n<div><pre><code>-p: 保持源文件的属性在拷贝的过程中不发生变化\n-d: 保持软连接在拷贝的过程中不发生变化\n-r: 递归\n-i: 提示\n-v: 显示拷贝的过程\n-a: 相当于 -pdr\n\n语法：\ncp 源文件 目标位置\ncp 源文件1 源文件2 ... 源文件n 目标位置\n</code></pre></div><div><pre><code><span># 拷贝 /etc/hosts 文件到 /tmp 目录中</span>\n<span>cp</span> /etc/hosts /tmp/\n</code></pre></div><div><pre><code>注意：目标位置是一个目录时，\n建议写成 /tmp/，此时，如果目录不存在，会报错提示。\n如果写成 /tmp，那么当目录不存在时，会将源文件拷贝至 / 下，并改名为 tmp 文件。\n</code></pre></div><div><pre><code><span># 拷贝 /etc 目录到 /tmp 目录中，并改目录名为 etc_back</span>\n<span>cp</span> <span>-r</span> /etc /tmp/etc_back\n</code></pre></div><div><pre><code>注意：如果源目录中包含子目录，需要使用 -r 选项进行递归拷贝。\n</code></pre></div><div><pre><code><span># 拷贝多个文件：/etc/hostname /etc/fstab /var/ /home/ /tmp/ /root/ --> /backup/</span>\n<span>\\</span>cp <span>-r</span> /etc/hostname /etc/fstab /var/ /home/ /tmp/ /root/ /backup/\n</code></pre></div><div><pre><code>cp 命令是系统为 \"cp -i\" 命令起的别名，所以执行 cp -r 相当于执行 cp -i -r，于是若存在覆盖的情况，会提示用户。\n如果不想用系统别名，可以写成 \\cp -r，即去掉了选项 -i，此时，即使存在文件覆盖，也不会提示。\n\n多文件拷贝需注意：\n1. /backup/ 目录必须存在\n2. cp 命令中的最后一个目录一定是目标位置\n</code></pre></div><h3 id=\"_1-4-移动命令-mv\" tabindex=\"-1\"> 1.4 移动命令：<code>mv</code></h3>\n<div><pre><code><span># 在用户家目录创建 test 目录，然后移动到 /tmp 目录</span>\n<span>cd</span>\n<span>mkdir</span> <span>test</span>\n<span>mv</span> test/ /tmp/\n\n<span># mv 还可以用来改名字，如：</span>\n<span># 1. 将当前目录下的 test 目录重命名为 abc 文件夹</span>\n<span>mv</span> test/ abc\n<span># 2. 将将当前目录下的 file1.txt 文件重命名为 file2.txt 文件</span>\n<span>mv</span> file1.txt file2.txt\n\n<span># 移动多个目录到 /tmp 目录</span>\n<span>mkdir</span> <span>{</span>a<span>..</span>z<span>}</span>\n<span>mkdir</span> <span>{</span><span>1</span><span>..</span><span>100</span><span>}</span>_pdf\n<span>mv</span> 源 源 源 <span>..</span>. 源 目标\n</code></pre></div><div><pre><code>touch {1..100}.pdf 命令表示创建 1.pdf 至 100.pdf 的多个文件\n</code></pre></div><h2 id=\"_2-查看文件类命令\" tabindex=\"-1\"> 2. 查看文件类命令：</h2>\n<h3 id=\"_2-1-cat\" tabindex=\"-1\"> 2.1 <code>cat</code></h3>\n<div><pre><code>cat 命令用于查看文件内容。\n\n选项如下：\n-n: 显示文件的行数。\n-A: 显示文件中的特殊字符。（如果从 windows 拷贝配置文件到 linux，很容易出现多了一些特殊字符的情况，造成服务启动失败）\n</code></pre></div><p><img src=\"@source/zkq/linux/_1_basic/images/_05_linux_basic_cmd/01.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_2-1-1-向文件中追加内容-cat-file-txt-eof\" tabindex=\"-1\"> 2.1.1 向文件中追加内容：<code>cat &gt;&gt; file.txt &lt;&lt; EOF</code></h4>\n<p><img src=\"@source/zkq/linux/_1_basic/images/_05_linux_basic_cmd/03.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>注意：\n1. 如果 file.txt 文件不存在会自动创建；\n2. 该命令用于向文件中追加内容，不会覆盖已存在的内容；\n3. 输入 EOF 表示结束输入。\n</code></pre></div><h3 id=\"_2-2-less、more\" tabindex=\"-1\"> 2.2 <code>less</code>、<code>more</code></h3>\n<div><pre><code>less、more 命令用于查看内容比较多的文件。\nless、more 都是采用分页的方式查看文件内容，区别是 more 会显示百分比\n\n快捷键：\nf 下翻页\nb 上翻页\nq 退出\ng 文件第 1 行\nG 文件最后 1 行\n\n注：空格也可以下翻页。\n</code></pre></div><h3 id=\"_2-3-head、tail、tailf\" tabindex=\"-1\"> 2.3 <code>head</code>、<code>tail</code>、<code>tailf</code></h3>\n<p><strong>查看文件首部内容：<code>head</code></strong></p>\n<div><pre><code>默认打印文件前 10 行内容。\n也可以通过选项 -&lt;N> 指定打印文件前 &lt;N> 行内容。\n\n注：如果 -&lt;N> 不起作用，可以尝试用 -n&lt;N>。如打印前 5 行: -5 或 -n5\n</code></pre></div><div><pre><code><span># 默认打印文件前 10 行内容</span>\n<span>head</span> /etc/passwd\n\n<span># 指定打印文件前 5 行内容</span>\n<span>head</span> <span>-5</span> /etc/passwd\n</code></pre></div><p><strong>查看文件尾部内容：<code>tail</code>、<code>tailf</code></strong></p>\n<div><pre><code>默认打印文件最后 <span>10</span> 行内容。\n也可以通过选项 -<span>&lt;</span>N<span>></span> 指定打印文件最后 <span>&lt;</span>N<span>></span> 行内容。\n\n注：如果 -<span>&lt;</span>N<span>></span> 不起作用，可以尝试用 -n<span>&lt;</span>N<span>></span>。如打印最后 <span>5</span> 行: <span>-5</span> 或 <span>-n5</span>\n</code></pre></div><div><pre><code><span># 默认打印文件最后 10 行内容</span>\n<span>tail</span> /etc/passwd\n\n<span># 指定打印文件最后 20 行内容</span>\n<span>tail</span> <span>-20</span> /etc/passwd\n\n<span># 打印文件最后 20 行内容，并通过管道 | 传递给 head 命令处理，打印出最后 20 行内容中的前 10 行内容</span>\n<span>tail</span> <span>-20</span> /etc/passwd <span>|</span> <span>head</span>\n\n<span># 实时追踪文件尾部的内容变化</span>\n<span>tail</span> <span>-f</span> /etc/passwd\n</code></pre></div><div><pre><code>tail -f 相当于 tailf 命令。\n</code></pre></div><h2 id=\"_3-查找可执行文件-命令-所在位置的命令-which、whereis\" tabindex=\"-1\"> 3. 查找可执行文件（命令）所在位置的命令：<code>which</code>、<code>whereis</code></h2>\n<div><pre><code>which 和 whereis 命令都可以用来查看命令（可执行文件）的所在位置。\n</code></pre></div><p><img src=\"@source/zkq/linux/_1_basic/images/_05_linux_basic_cmd/02.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_4-下载类命令\" tabindex=\"-1\"> 4. 下载类命令</h2>\n<h3 id=\"_4-1-从网络下载-wget、curl\" tabindex=\"-1\"> 4.1 从网络下载：<code>wget</code>、<code>curl</code></h3>\n<p><strong><code>wget</code></strong></p>\n<div><pre><code><span># 默认最小化系统没有 wget 命令，需要安装</span>\nyum <span>install</span> <span>wget</span> <span>-y</span>\n\n<span># 下载资源到当前目录下</span>\n<span>wget</span> http://nginx.org/download/nginx-1.19.7.tar.gz\n\n<span># 下载资源到指定路径下，同时对下载的文件进行重命名</span>\n<span>wget</span> <span>-O</span> /tmp/test.repo http://mirrors.aliyun.com/repo/Centos-7.repo\n</code></pre></div><p><strong><code>curl</code></strong></p>\n<div><pre><code><span># 下载资源到指定路径下，同时对下载的文件进行重命名</span>\n<span>curl</span> <span>-o</span> /tmp/curl.repo http://mirrors.aliyun.com/repo/Centos-7.repo\n</code></pre></div><div><pre><code>注意：\n1. wget 指定路径的选项是 -O（大写 O）；curl 指定路径的选项是 -o（小写 o）\n2. curl 还可以用来获取网页的源码信息\n</code></pre></div><h3 id=\"_4-2-本地-windows-与远程-linux-互传-sz、rz\" tabindex=\"-1\"> 4.2 本地 Windows 与远程 Linux 互传：<code>sz</code>、<code>rz</code></h3>\n<p><strong><code>sz</code></strong></p>\n<div><pre><code>sz 命令用于从 linux 服务器下载资源到 windows 系统本地。\n\n注意：\n1. 下载的资源只可以是文件，不可以是文件夹；\n2. 不支持超过 4G 的文件；\n3. 不支持断点续传；\n4. 如果必须下载文件夹，可以先压缩。\n</code></pre></div><p><strong><code>rz</code></strong></p>\n<div><pre><code>rz 命令用于将 windows 的内容上传到 linux 服务器。\n\n注意：\n1. 一般直接将文件拖拽到 linux 服务器中；\n2. 上传的资源只可以是文件，不可以是文件夹。\n</code></pre></div><h2 id=\"_5-字符文件内容处理类命令\" tabindex=\"-1\"> 5. 字符文件内容处理类命令</h2>\n<h3 id=\"_5-1-排序-去重-sort-uniq\" tabindex=\"-1\"> 5.1 排序 &amp; 去重：<code>sort</code> &amp; <code>uniq</code></h3>\n<p><strong><code>sort</code></strong></p>\n<div><pre><code>sort 命令用于对文件内容按行排序。\n\n-t: 指定每行内容的分割符。（默认以空格作为分割符）\n-r: 反转顺序\n-n: 按数字大小排序。（默认按字符顺序排列，即：先比较两行的第 1 个字符，再比较第 2 个字符，以此类比...）\n-k: 指定分割后的列\n</code></pre></div><div><pre><code><span># -k3.1,3.1 表示按第 3 列的第 1 个字符到第 3 列的第 1 个字符排序（即仅仅只按第 3 列的第 1 个字符排序）</span>\n<span># -k4.1,4.3 表示按第 4 列的第 1 个字符到第 4 列的第 3 个字符排序（即按第 4 列的前 3 个字符排序）</span>\n<span>sort</span> <span>-t</span> <span>\".\"</span> -k3.1,3.1 -k4.1,4.3 <span>-n</span> ip.txt\n</code></pre></div><p><strong><code>uniq</code></strong></p>\n<div><pre><code>uniq 命令用于对相同且连续的多行内容进行去重。（注：不连续的相同行无法去重）\n因此，在使用 uniq 去重之前，需要通过 sort 命令进行排序，使重复的行连续排列。\n\nuniq -c 可以统计重复个数\n</code></pre></div><h4 id=\"_5-1-1-示例代码一\" tabindex=\"-1\"> 5.1.1 示例代码一</h4>\n<p><img src=\"@source/zkq/linux/_1_basic/images/_05_linux_basic_cmd/04.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_5-1-2-示例代码二-打印出访问最高的前-10-个-ip\" tabindex=\"-1\"> 5.1.2 示例代码二：打印出访问最高的前 <code>10</code> 个 <code>IP</code></h4>\n<p><img src=\"@source/zkq/linux/_1_basic/images/_05_linux_basic_cmd/05.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_5-1-3-示例代码三-找出工资最高的前-5-人-awk-和-sort-结合使用\" tabindex=\"-1\"> 5.1.3 示例代码三：找出工资最高的前 <code>5</code> 人（<code>awk</code> 和 <code>sort</code> 结合使用）</h4>\n<p><img src=\"@source/zkq/linux/_1_basic/images/_05_linux_basic_cmd/06.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_5-2-统计文件的行数-wc\" tabindex=\"-1\"> 5.2 统计文件的行数：<code>wc</code></h3>\n<div><pre><code>wc 命令用来统计文件的行数。当然也可以用来统计控制台输出的行数。\n\nwc [OPTION]... [FILE]...\n\n-l: 显示文件行数\n-c: 显示文件字节\n-w: 显示文件单词\n</code></pre></div><div><pre><code><span># 统计 /etc/services 文件的函数</span>\n<span>wc</span> <span>-l</span> /etc/services\n</code></pre></div><h4 id=\"_5-2-1-示例代码-统计-etc-passwd-文件中以-nologin-结尾的行数\" tabindex=\"-1\"> 5.2.1 示例代码：统计 <code>/etc/passwd</code> 文件中以 <code>nologin</code> 结尾的行数</h4>\n<p><img src=\"@source/zkq/linux/_1_basic/images/_05_linux_basic_cmd/07.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_5-2-2-统计文件行号的几种方法\" tabindex=\"-1\"> 5.2.2 统计文件行号的几种方法</h4>\n<p><img src=\"@source/zkq/linux/_1_basic/images/_05_linux_basic_cmd/08.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_5-3-过滤行-过滤列-grep-awk\" tabindex=\"-1\"> 5.3 过滤行 &amp; 过滤列：<code>grep</code> &amp; <code>awk</code></h3>\n<div><pre><code>过滤列时要想到 awk 命令；\n过滤行时要想到 grep 命令。\n</code></pre></div><p><strong><code>grep</code></strong></p>\n<div><pre><code><span># 在 /etc/passwd 文件中过滤出包含 root 的行</span>\n<span>grep</span> <span>\"root\"</span> /etc/passwd\n\n<span># 在 /etc/passwd 文件中过滤出以 root 开头的行</span>\n<span># 这里需要用到正则表达式符号 ^</span>\n<span>grep</span> <span>\"^root\"</span> /etc/passwd\n\n<span># 在 /etc/passwd 文件中过滤出以 bash 结尾的行</span>\n<span># 这里需要用到正则表达式符号 $</span>\n<span>grep</span> <span>\"bash$\"</span> /etc/passwd\n\n<span># 在 /etc/passwd 文件中过滤出包含 ftp 的行，且忽略大小写的匹配。</span>\n<span>grep</span> <span>-i</span> <span>\"ftp\"</span> /etc/passwd\n\n<span># 在 /etc/passwd 文件中过滤出排除了包含 ftp 之外的其他行</span>\n<span>grep</span> <span>-v</span> <span>\"ftp\"</span> /etc/passwd\n\n<span># 在 /etc/passwd 文件中过滤出包含 ftp，或者以 sync 结尾的行，且忽略大小写的匹配。</span>\n<span># grep 使用正则表达式中的或符号 \"|\" 时，需要加选项 -E，否则无法识别。</span>\n<span># 也可以使用 egrep 命令代码 grep -E</span>\n<span>grep</span> <span>-Ei</span> <span>\"sync$|ftp\"</span> /etc/passwd\n\n<span># 在 /var/log/secure 文件中过滤出包含 Failed 的行，并打印它的下面 2 行。</span>\n<span>grep</span> <span>-n</span> <span>-A</span> <span>2</span> <span>\"Failed\"</span> /var/log/secure\n\n<span># 在 /var/log/secure 文件中过滤出包含 Failed 的行，并打印它的上面 2 行。</span>\n<span>grep</span> <span>-n</span> <span>-B</span> <span>2</span> <span>\"Failed\"</span> /var/log/secure\n\n<span># 在 /var/log/secure 文件中过滤出包含 Failed 的行，并打印它的上下 2 行。</span>\n<span>grep</span> <span>-n</span> <span>-C</span> <span>2</span> <span>\"Failed\"</span> /var/log/secure\n</code></pre></div><p><strong><code>awk</code></strong></p>\n<div><pre><code>awk 命令中只能使用单引号。\n\n-F \n指定分割符，如 awk -F ':' 指定分割符为 :\n\nawk '{print $&lt;N>}' \n打印第 &lt;N> 列，如 awk '{print $1}' 打印第 1 列\n\nawk '{print $NF}'\n打印最后一列\n\nawk 'NR==&lt;N>'\n打印第 &lt;N> 行，如 awk 'NR==1' 打印第 1 行\n</code></pre></div><h4 id=\"_5-3-1-使用-ifconfig-命令需要安装-net-tools-软件\" tabindex=\"-1\"> 5.3.1 使用 <code>ifconfig</code> 命令需要安装 <code>net-tools</code> 软件</h4>\n<div><pre><code>yum <span>install</span> net-tools <span>-y</span>\n</code></pre></div><div><pre><code><span># 执行 ifconfig 命令查看 en1 的信息</span>\nzkqcom@zkqcomdeMac-mini _1_basic % <span>ifconfig</span> en1\nen1: <span>flags</span><span>=</span><span>886</span><span><span>3</span>&lt;</span>UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST<span>></span> mtu <span>1500</span>\n    <span>options</span><span>=</span><span>646</span><span><span>3</span>&lt;</span>RXCSUM,TXCSUM,TSO4,TSO6,CHANNEL_IO,PARTIAL_CSUM,ZEROINVERT_CSUM<span>></span>\n    ether 00:8a:76:e7:a9:44 \n    inet6 fe80::88a:fe05:6f03:e3c0%en1 prefixlen <span>64</span> secured scopeid 0xc \n    inet <span>192.168</span>.101.10 netmask 0xffffff00 broadcast <span>192.168</span>.101.255\n    nd6 <span>options</span><span>=</span><span>20</span><span><span>1</span>&lt;</span>PERFORMNUD,DAD<span>></span>\n    media: autoselect\n    status: active\n</code></pre></div><h4 id=\"_5-3-2-将系统-ip-地址打印出来-grep-命令取行-awk-命令取列\" tabindex=\"-1\"> 5.3.2 将系统 <code>IP</code> 地址打印出来（<code>grep</code> 命令取行，<code>awk</code> 命令取列）</h4>\n<div><pre><code>zkqcom@zkqcomdeMac-mini _1_basic % <span>ifconfig</span> en1 <span>|</span> <span>grep</span> <span>\"inet \"</span> <span>|</span> <span>awk</span> <span>'{print $2}'</span>\n<span>192.168</span>.101.10\n</code></pre></div><h4 id=\"_5-3-3-将系统-ip-地址打印出来-awk-命令取行-取列\" tabindex=\"-1\"> 5.3.3 将系统 <code>IP</code> 地址打印出来（<code>awk</code> 命令取行 &amp; 取列）</h4>\n<div><pre><code><span># awk 'NR==5' 命令表示取第 5 行（索引从 1 开始）。NR 可以理解为 number of row</span>\nzkqcom@zkqcomdeMac-mini _1_basic % <span>ifconfig</span> en1 <span>|</span> <span>awk</span> <span>'NR==5'</span> <span>|</span> <span>awk</span> <span>'{print $2}'</span>\n<span>192.168</span>.101.10\n\n<span># awk 'NR==5' | awk '{print $2}' 可以合并写成 awk 'NR==5 {print $2}'</span>\nzkqcom@zkqcomdeMac-mini _1_basic % <span>ifconfig</span> en1 <span>|</span> <span>awk</span> <span>'NR==5 {print $2}'</span>\n<span>192.168</span>.101.10\n</code></pre></div><h4 id=\"_5-3-4-打印-etc-passwd-文件中的用户名与-uid-awk-的分割符设置\" tabindex=\"-1\"> 5.3.4 打印 <code>/etc/passwd</code> 文件中的用户名与 <code>UID</code>（<code>awk</code> 的分割符设置）</h4>\n<div><pre><code>/etc/passwd 文件中用户名与用户的 UID 分别在以 ':' 为分割符的第 1 列和第 3 列。\n此时，需要使用 -F 选项设置 awk 命令的分割符。\n</code></pre></div><div><pre><code><span># awk 命令默认以空格作为分割符。也可以使用选项 -F 自定义分割符，如 -F ':' 表示定义分割符为 :</span>\n<span>awk</span> <span>-F</span> <span>':'</span> <span>'{print $1,$3}'</span> /etc/passwd \n</code></pre></div><h2 id=\"_6-其他常用命令\" tabindex=\"-1\"> 6. 其他常用命令</h2>\n<h3 id=\"_6-1-显示目录下的内容及相关属性信息-ls\" tabindex=\"-1\"> 6.1 显示目录下的内容及相关属性信息：<code>ls</code></h3>\n<div><pre><code>-l: 详细信息\n-a: 所有文件（包含隐藏文件）\n-d: 显示目录本身的信息，而不是目录内容\n-h: 一般与 -l 一起使用，表示以人类可读的形式显示文件大小\n-r: 逆序排序\n-t: 按照文件修改时间排序\n</code></pre></div><h3 id=\"_6-2-切换目录-cd\" tabindex=\"-1\"> 6.2 切换目录：<code>cd</code></h3>\n<div><pre><code>cd 即 change directory\n\n切换到家目录: cd 或 cd ~\n切换到上一级目录: cd ..\n切换到上一次所在目录: cd -\n</code></pre></div><h3 id=\"_6-3-显示当前所在的位置-pwd\" tabindex=\"-1\"> 6.3 显示当前所在的位置：<code>pwd</code></h3>\n<div><pre><code>pwd 即 print working directory\n</code></pre></div><h3 id=\"_6-4-以树形结构显示目录下的内容-tree\" tabindex=\"-1\"> 6.4 以树形结构显示目录下的内容：<code>tree</code></h3>\n<h3 id=\"_6-5-将-dos-格式文件转换为-unix-格式-dos2unix\" tabindex=\"-1\"> 6.5 将 <code>DOS</code> 格式文件转换为 UNIX 格式：<code>dos2unix</code></h3>\n<div><pre><code>即：将 windows 系统中拷贝过来的带 DOS 格式的文件转换为 Linux 系统中的 UNIX 格式的文件。\n</code></pre></div><h3 id=\"_6-6-自动化-rpm-包管理工具-yum\" tabindex=\"-1\"> 6.6 自动化 <code>RPM</code> 包管理工具：<code>yum</code></h3>\n<div><pre><code>yum 即 Yellow Dog （黄狗）\n\n示例：同时安装 3 个软件。其中 -y 表示安装时默认选择 yes\nyum install -y tree wget vim\n</code></pre></div>",
      "date_published": "2022-10-01T13:16:41.000Z",
      "date_modified": "2022-11-30T09:21:18.000Z",
      "authors": [],
      "tags": [
        "linux"
      ]
    },
    {
      "title": "三剑客命令",
      "url": "https://zengkaiqiang562.github.io/zkq/linux/_1_basic/_07_linux_swordsmen_cmd.html",
      "id": "https://zengkaiqiang562.github.io/zkq/linux/_1_basic/_07_linux_swordsmen_cmd.html",
      "content_html": "",
      "date_published": "2022-10-01T13:16:41.000Z",
      "date_modified": "2022-10-01T13:16:41.000Z",
      "authors": [],
      "tags": [
        "linux"
      ]
    },
    {
      "title": "文本编辑器-vim",
      "url": "https://zengkaiqiang562.github.io/zkq/linux/_1_basic/_08_vim.html",
      "id": "https://zengkaiqiang562.github.io/zkq/linux/_1_basic/_08_vim.html",
      "content_html": "",
      "date_published": "2022-10-01T13:16:41.000Z",
      "date_modified": "2022-10-01T13:16:41.000Z",
      "authors": [],
      "tags": [
        "linux"
      ]
    },
    {
      "title": "find与压缩",
      "url": "https://zengkaiqiang562.github.io/zkq/linux/_1_basic/_14_find_compress.html",
      "id": "https://zengkaiqiang562.github.io/zkq/linux/_1_basic/_14_find_compress.html",
      "content_html": "",
      "date_published": "2022-10-01T13:16:41.000Z",
      "date_modified": "2022-10-01T13:16:41.000Z",
      "authors": [],
      "tags": [
        "linux"
      ]
    },
    {
      "title": "shell脚本",
      "url": "https://zengkaiqiang562.github.io/zkq/linux/_3_shell_swordsmen/_01_shell.html",
      "id": "https://zengkaiqiang562.github.io/zkq/linux/_3_shell_swordsmen/_01_shell.html",
      "content_html": "",
      "date_published": "2022-10-01T13:16:41.000Z",
      "date_modified": "2022-10-01T13:16:41.000Z",
      "authors": [],
      "tags": [
        "linux"
      ]
    },
    {
      "title": "正则表达式",
      "url": "https://zengkaiqiang562.github.io/zkq/linux/_3_shell_swordsmen/_02_regx.html",
      "id": "https://zengkaiqiang562.github.io/zkq/linux/_3_shell_swordsmen/_02_regx.html",
      "content_html": "",
      "date_published": "2022-10-01T13:16:41.000Z",
      "date_modified": "2022-10-01T13:16:41.000Z",
      "authors": [],
      "tags": [
        "linux"
      ]
    },
    {
      "title": "grep & sed & awk",
      "url": "https://zengkaiqiang562.github.io/zkq/linux/_3_shell_swordsmen/_03_grep_sed_awk.html",
      "id": "https://zengkaiqiang562.github.io/zkq/linux/_3_shell_swordsmen/_03_grep_sed_awk.html",
      "content_html": "",
      "date_published": "2022-10-01T13:16:41.000Z",
      "date_modified": "2022-10-01T13:16:41.000Z",
      "authors": [],
      "tags": [
        "linux"
      ]
    },
    {
      "title": "Web",
      "url": "https://zengkaiqiang562.github.io/zkq/web/",
      "id": "https://zengkaiqiang562.github.io/zkq/web/",
      "content_html": "<p><strong><code>2021</code> 黑马前端 <code>v6.5</code></strong></p>\n",
      "date_published": "2022-09-04T14:20:41.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "HTML",
      "url": "https://zengkaiqiang562.github.io/zkq/web/_1_web-dev-basic/_1_html.html",
      "id": "https://zengkaiqiang562.github.io/zkq/web/_1_web-dev-basic/_1_html.html",
      "content_html": "<blockquote>\n<p>相关案例：<a href=\"https://github.com/zengkaiqiang562/JavaGuide-Demo/tree/main/docs/zkq/web/_1_web-dev-basic/_1_html\" target=\"_blank\" rel=\"noopener noreferrer\">前端基础HTML<ExternalLinkIcon/></a></p>\n</blockquote>\n<h2 id=\"_1-网页\" tabindex=\"-1\"> 1. 网页</h2>\n<h3 id=\"_1-1-什么是网页\" tabindex=\"-1\"> 1.1 什么是网页</h3>\n<p>网页是构成网站的基本元素，它通常由图片、链接、文字、声音、视频等元素组成。通常我们看到的网页，常见以 <code>.htm</code> 或 <code>.html</code> 后缀结尾的文件，因此将其俗称为 <code>HTML</code> 文件。</p>\n<h3 id=\"_1-2-什么是-html\" tabindex=\"-1\"> 1.2 什么是 <code>HTML</code></h3>\n<p><code>HTML</code> 指的是超文本标记语言 (<code>Hyper Text Markup Language</code>) ，它是用来描述网页的一种语言。</p>\n<p><code>HTML</code> 不是一种编程语言，而是一种标记语言 (<code>markup language</code>)。</p>\n<p>标记语言是一套标记标签 (<code>markup tag</code>)。</p>\n<p><strong>所谓超文本，有 <code>2</code> 层含义：</strong></p>\n<ol>\n<li>\n<p>它（超文本）可以加入图片、声音、动画、多媒体等内容（超越了文本限制）</p>\n</li>\n<li>\n<p>它（超文本）还可以从一个文件跳转到另一个文件，与世界各地主机的文件连接（超级链接文本）</p>\n</li>\n</ol>\n<h3 id=\"_1-3-网页的形成\" tabindex=\"-1\"> 1.3 网页的形成</h3>\n<p>网页是由网页元素组成的，这些元素是利用 <code>html</code> 标签描述出来，然后通过浏览器解析来显示给用户的。</p>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_1_html/01.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>前端人员开发代码 -&gt; 浏览器显示代码（解析、渲染）-&gt; 生成最后的 <code>Web</code> 页面</p>\n</blockquote>\n<h3 id=\"_1-4-总结\" tabindex=\"-1\"> 1.4 总结</h3>\n<p>网页是图片、链接、文字、声音、视频等元素组成，其实就是一个 <code>html</code> 文件（后缀名为 <code>html</code>）。</p>\n<p>网页生成制作: 由前端人员书写 <code>HTML</code> 文件，然后浏览器打开，就能看到了网页。</p>\n<p><code>HTML</code>: 超文本标记语言，用来制作网页的一门语言。由标签组成的，比如：图片标签、链接标签、视频标签等。</p>\n<h2 id=\"_2-浏览器\" tabindex=\"-1\"> 2. 浏览器</h2>\n<h3 id=\"_2-1-常用浏览器\" tabindex=\"-1\"> 2.1 常用浏览器</h3>\n<p>浏览器是网页显示、运行的平台。</p>\n<p>常用的浏览器有 <code>IE</code>、火狐（<code>Firefox</code>）、谷歌（<code>Chrome</code>）、<code>Safari</code> 和 <code>Opera</code> 等。</p>\n<blockquote>\n<p>称为五大浏览器。</p>\n</blockquote>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_1_html/02.png\" alt=\"\" loading=\"lazy\"></p>\n<p>查看浏览器市场份额：<a href=\"http://tongji.baidu.com/data/browser\" target=\"_blank\" rel=\"noopener noreferrer\">http://tongji.baidu.com/data/browser<ExternalLinkIcon/></a></p>\n<h3 id=\"_2-2-浏览器内核\" tabindex=\"-1\"> 2.2 浏览器内核</h3>\n<p>浏览器内核（渲染引擎）：负责读取网页内容，整理讯息，计算网页的显示方式并显示页面。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>浏览器</strong></th>\n<th style=\"text-align:left\"><strong>内核</strong></th>\n<th style=\"text-align:left\"><strong>备注</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>IE</code></td>\n<td style=\"text-align:left\"><code>Trident</code></td>\n<td style=\"text-align:left\"><code>IE</code>、猎豹安全、<code>360</code> 极速浏览器、百度浏览器</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>firefox</code></td>\n<td style=\"text-align:left\"><code>Gecko</code></td>\n<td style=\"text-align:left\">火狐浏览器内核</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>Safari</code></td>\n<td style=\"text-align:left\"><code>Webkit</code></td>\n<td style=\"text-align:left\">苹果浏览器内核</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>chrome</code>/<code>Opera</code></td>\n<td style=\"text-align:left\"><code>Blink</code></td>\n<td style=\"text-align:left\"><code>chrome</code>/<code>opera</code> 浏览器内核。<code>Blink</code> 其实是 <code>WebKit</code> 的分支</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>目前国内一般浏览器都会采用 <code>Webkit</code>/<code>Blink</code> 内核，如 <code>360</code>、<code>UC</code>、<code>QQ</code>、搜狗等。</p>\n</blockquote>\n<h2 id=\"_3-web-标准\" tabindex=\"-1\"> 3. <code>Web</code> 标准</h2>\n<p><code>Web</code> 标准是由 <code>W3C</code> 组织和其他标准化组织制定的一系列标准的集合。</p>\n<blockquote>\n<p><code>W3C</code>（万维网联盟）是国际最著名的标准化组织。</p>\n</blockquote>\n<h3 id=\"_3-1-为什么需要-web-标准\" tabindex=\"-1\"> 3.1 为什么需要 <code>Web</code> 标准</h3>\n<p>浏览器不同，它们显示页面或者排版就有些许差异。</p>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_1_html/03.png\" alt=\"\" loading=\"lazy\"></p>\n<p>遵循 <code>Web</code> 标准，除了可以让不同的开发人员写出的页面更标准、更统一外，还有以下优点：</p>\n<ol>\n<li>\n<p>让 <code>Web</code> 的发展前景更广阔。</p>\n</li>\n<li>\n<p>内容能被更广泛的设备访问。</p>\n</li>\n<li>\n<p>更容易被搜寻引擎搜索。</p>\n</li>\n<li>\n<p>降低网站流量费用。</p>\n</li>\n<li>\n<p>使网站更易于维护。</p>\n</li>\n<li>\n<p>提高页面浏览速度。</p>\n</li>\n</ol>\n<h3 id=\"_3-2-web-标准的构成\" tabindex=\"-1\"> 3.2 <code>Web</code> 标准的构成</h3>\n<p>主要包括：结构（<code>Structure</code>）、表现（<code>Presentation</code>）和行为（<code>Behavior</code>）三个方面。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>标准</strong></th>\n<th style=\"text-align:left\"><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">结构</td>\n<td style=\"text-align:left\">结构用于对<strong>网页元素</strong>进行整理和分类，现阶段主要学的是 <code>HTML</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">表现</td>\n<td style=\"text-align:left\">表现用于设置网页元素的版式、颜色、大小等<strong>外观样式</strong>，主要指的是 <code>CSS</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">行为</td>\n<td style=\"text-align:left\">行为是指网页模型的定义及<strong>交互</strong>的编写，现阶段主要学的是 <code>JavaScript</code></td>\n</tr>\n</tbody>\n</table>\n<p><code>Web</code> 标准提出的最佳体验方案：结构、样式、行为相分离。</p>\n<p>简单理解：结构写到 <code>HTML</code> 文件中，表现写到 <code>CSS</code> 文件中，行为写到 <code>JavaScript</code> 文件中。</p>\n<h2 id=\"_4-html-语法规范\" tabindex=\"-1\"> 4. <code>HTML</code> 语法规范</h2>\n<p><strong>基本语法概述：</strong></p>\n<ol>\n<li>\n<p><code>HTML</code> 标签是由尖括号包围的关键词，例如 <code>&lt;html&gt;</code>。</p>\n</li>\n<li>\n<p><code>HTML</code> 标签通常是成对出现的，例如 <code>&lt;html&gt;</code> 和 <code>&lt;/html&gt;</code> ，我们称为双标签。标签对中的第一个标签是开始标签，第二个标签是结束标签。</p>\n</li>\n<li>\n<p>有些特殊的标签必须是单个标签（极少情况），例如 <code>&lt;br/&gt;</code>，我们称为单标签。</p>\n</li>\n</ol>\n<p><strong>双标签关系可以分为两类：</strong></p>\n<ol>\n<li>\n<p>包含关系</p>\n<div><pre><code><span><span><span>&lt;</span>head</span><span>></span></span> \n    <span><span><span>&lt;</span>title</span><span>></span></span> <span><span><span>&lt;/</span>title</span><span>></span></span> \n<span><span><span>&lt;/</span>head</span><span>></span></span>\n</code></pre></div></li>\n<li>\n<p>并列关系</p>\n<div><pre><code><span><span><span>&lt;</span>head</span><span>></span></span> <span><span><span>&lt;/</span>head</span><span>></span></span>\n<span><span><span>&lt;</span>body</span><span>></span></span> <span><span><span>&lt;/</span>body</span><span>></span></span>\n</code></pre></div></li>\n</ol>\n<h2 id=\"_5-html-基本结构标签\" tabindex=\"-1\"> 5. <code>HTML</code> 基本结构标签</h2>\n<p>每个网页都会有一个基本的结构标签（也称为骨架标签），页面内容也是在这些基本标签上书写。</p>\n<blockquote>\n<p><code>HTML</code> 页面也称为 <code>HTML</code> 文档。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>标签名</strong></th>\n<th style=\"text-align:left\"><strong>定义</strong></th>\n<th style=\"text-align:left\"><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>&lt;html&gt;&lt;/html&gt;</code></td>\n<td style=\"text-align:left\"><code>HTML</code> 标签</td>\n<td style=\"text-align:left\">页面中最大的标签，我们称为<strong>根标签</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>&lt;head&gt;&lt;/head&gt;</code></td>\n<td style=\"text-align:left\">文档的头部</td>\n<td style=\"text-align:left\">注意在 <code>head</code> 标签中我们必须要设置的标签是 <code>title</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>&lt;title&gt;&lt;/title&gt;</code></td>\n<td style=\"text-align:left\">文档的标题</td>\n<td style=\"text-align:left\">让页面拥有一个属于自己的网页标题</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>&lt;body&gt;&lt;/body&gt;</code></td>\n<td style=\"text-align:left\">文档的主体</td>\n<td style=\"text-align:left\">元素包含文档的所有内容，页面内容基本都是放到 <code>body</code> 里面的</td>\n</tr>\n</tbody>\n</table>\n<p><strong>示例代码：</strong></p>\n<div><pre><code><span><span><span>&lt;</span>html</span><span>></span></span> \n    <span><span><span>&lt;</span>head</span><span>></span></span> \n        <span><span><span>&lt;</span>title</span><span>></span></span>我的第一个页面<span><span><span>&lt;/</span>title</span><span>></span></span>\n    <span><span><span>&lt;/</span>head</span><span>></span></span>\n    <span><span><span>&lt;</span>body</span><span>></span></span>\n        你我之间，黑马洗练，月薪过万，一飞冲天 \n    <span><span><span>&lt;/</span>body</span><span>></span></span>\n<span><span><span>&lt;/</span>html</span><span>></span></span>\n</code></pre></div><p><code>HTML</code> 文档的的后缀名必须是 <code>.html</code> 或 <code>.htm</code>。</p>\n<p>浏览器的作用是读取 <code>HTML</code> 文档，并以网页的形式显示出它们。此时，用浏览器打开这个网页，我们就可以预览我们写的第一个 <code>HTML</code> 文件了。</p>\n<p><strong>总结：</strong></p>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_1_html/04.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_6-网页开发工具\" tabindex=\"-1\"> 6. 网页开发工具</h2>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_1_html/05.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_6-1-vscode-的使用\" tabindex=\"-1\"> 6.1 <code>VSCode</code> 的使用</h3>\n<p>注意事项：</p>\n<ol>\n<li>\n<p>一定要保存为 <code>.html</code> 文件</p>\n</li>\n<li>\n<p>生成页面骨架结构的快捷方式：输入 <code>!</code> 按下 <code>Tab</code> 键。</p>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_1_html/06.png\" alt=\"\" loading=\"lazy\"></p>\n</li>\n<li>\n<p>利用插件（<code>open in browser</code>）在浏览器中预览页面的方式：单击鼠标右键，在弹出窗口中点击 &quot;<code>Open In Default Browser</code>&quot;。</p>\n</li>\n</ol>\n<h3 id=\"_6-2-vscode-生成骨架标签中的三个重要代码\" tabindex=\"-1\"> 6.2 <code>VSCode</code> 生成骨架标签中的三个重要代码</h3>\n<h4 id=\"_6-2-1-文档类型声明标签-doctype\" tabindex=\"-1\"> 6.2.1 文档类型声明标签：<code>&lt;!DOCTYPE&gt;</code></h4>\n<p><code>&lt;!DOCTYPE&gt;</code> 文档类型声明，作用就是告诉浏览器使用哪种 <code>HTML</code> 版本来显示网页。</p>\n<div><pre><code><span>&lt;!-- 这句代码的意思是: 当前页面采取的是 HTML5 版本来显示网页 --></span>\n<span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>\n</code></pre></div><p>注意:</p>\n<ol>\n<li>\n<p><code>&lt;!DOCTYPE&gt;</code> 声明位于文档中的最前面的位置，处于 <code>&lt;html&gt;</code> 标签之前。</p>\n</li>\n<li>\n<p><code>&lt;!DOCTYPE&gt;</code> 不是一个 <code>HTML</code> 标签，它就是文档类型声明标签。</p>\n</li>\n</ol>\n<h4 id=\"_6-2-2-语言种类-lang\" tabindex=\"-1\"> 6.2.2 语言种类：<code>lang</code></h4>\n<div><pre><code><span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>\"</span>en<span>\"</span></span><span>></span></span>\n</code></pre></div><p><code>lang</code> 用来定义当前文档显示的语言：</p>\n<ol>\n<li>\n<p><code>en</code> 定义语言为英语</p>\n</li>\n<li>\n<p><code>zh-CN</code> 定义语言为中文</p>\n</li>\n</ol>\n<p>简单来说：定义为 <code>en</code> 就是英文网页, 定义为 <code>zh-CN</code> 就是中文网页。</p>\n<blockquote>\n<p>其实对于文档显示来说，定义成 <code>en</code> 的文档也可以显示中文，定义成 <code>zh-CN</code> 的文档也可以显示英文。</p>\n<p>这个属性对浏览器和搜索引擎（百度、谷歌等）还是有作用的。</p>\n</blockquote>\n<h4 id=\"_6-2-3-字符集-charset\" tabindex=\"-1\"> 6.2.3 字符集：<code>charset</code></h4>\n<div><pre><code><span><span><span>&lt;</span>head</span><span>></span></span>\n    <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>\"</span>UTF-8<span>\"</span></span><span>></span></span>\n<span><span><span>&lt;/</span>head</span><span>></span></span>\n</code></pre></div><p>字符集（<code>Character set</code>）是多个字符的集合。以便计算机能够识别和存储各种文字。</p>\n<p>在 <code>&lt;head&gt;</code> 标签内，可以通过 <code>&lt;meta&gt;</code> 标签的 <code>charset</code> 属性来规定 <code>HTML</code> 文档应该使用哪种字符编码。</p>\n<p><code>charset</code> 常用的值有：<code>GB2312</code>、<code>BIG5</code>、<code>GBK</code> 和 <code>UTF-8</code>。其中 <code>UTF-8</code> 也被称为<strong>万国码</strong>，即：基本包含了全世界所有国家需要用到的字符。</p>\n<p>注意：必须要在 <code>html</code> 文档中指定字符集，否则可能引起乱码的情况。一般情况下，统一使用 &quot;<code>UTF-8</code>&quot; 编码。</p>\n<blockquote>\n<p>尽量统一写成标准的 &quot;<code>UTF-8</code>&quot;，不要写成 <code>&quot;utf8</code>&quot; 或 &quot;<code>UTF8</code>&quot;。</p>\n</blockquote>\n<h2 id=\"_7-html-常用标签\" tabindex=\"-1\"> 7. <code>HTML</code> 常用标签</h2>\n<h3 id=\"_7-1-标签语义\" tabindex=\"-1\"> 7.1 标签语义</h3>\n<p>标签的语义简单理解就是指标签的含义，即这个标签是用来干嘛的。</p>\n<p>根据标签的语义，在合适的地方给一个最为合理的标签，可以让页面结构更清晰。</p>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_1_html/07.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_7-2-标题标签-h1-h6\" tabindex=\"-1\"> 7.2 标题标签：<code>&lt;h1&gt; - &lt;h6&gt;</code></h3>\n<p>为了使网页更具有语义化，我们经常会在页面中用到标题标签。<code>HTML</code> 提供了 <code>6</code> 个等级的网页标题， 即 <code>&lt;h1&gt; - &lt;h6&gt;</code>。</p>\n<div><pre><code><span><span><span>&lt;</span>h1</span><span>></span></span> 我是一级标题 <span><span><span>&lt;/</span>h1</span><span>></span></span>\n</code></pre></div><blockquote>\n<p><code>h</code> 是单词 <code>head</code> 的缩写，意为头部、标题。</p>\n</blockquote>\n<div><pre><code>标签语义：作为标题使用，并且依据重要性递减。\n</code></pre></div><div><pre><code>特点：\n1. 加了标题的文字会变的加粗，字号也会依次变大。\n2. 一个标题独占一行。\n</code></pre></div><h3 id=\"_7-3-段落和换行标签-p-br\" tabindex=\"-1\"> 7.3 段落和换行标签：<code>&lt;p&gt;</code> &amp; <code>&lt;br/&gt;</code></h3>\n<p><strong>段落标签：<code>&lt;p&gt;</code></strong></p>\n<p>在网页中，要把文字有条理地显示出来，就需要将这些文字分段显示。</p>\n<p>在 <code>HTML</code> 标签中，<code>&lt;p&gt;</code> 标签用于定义段落，它可以将整个网页分为若干个段落。</p>\n<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span> 我是一个段落标签 <span><span><span>&lt;/</span>p</span><span>></span></span>\n</code></pre></div><blockquote>\n<p>单词 <code>paragraph [ˈpærəgræf]</code> 的缩写，意为段落。</p>\n</blockquote>\n<div><pre><code>标签语义：可以把 HTML 文档分割为若干段落\n</code></pre></div><div><pre><code>特点：\n1. 文本在一个段落中会根据浏览器窗口的大小自动换行。\n2. 段落和段落之间保有空隙。\n</code></pre></div><p><strong>换行标签：<code>&lt;br/&gt;</code></strong></p>\n<p>在 <code>HTML</code> 中，一个段落中的文字会从左到右依次排列，直到浏览器窗口的右端，然后才自动换行。</p>\n<p>如果希望某段文本强制换行显示，就需要使用换行标签 <code>&lt;br/&gt;</code>。</p>\n<div><pre><code><span><span><span>&lt;</span>br</span><span>/></span></span>\n</code></pre></div><blockquote>\n<p>单词 <code>break</code> 的缩写，意为打断、换行。</p>\n</blockquote>\n<div><pre><code>标签语义：强制换行。\n</code></pre></div><div><pre><code>特点：\n1. &lt;br/> 是个单标签。\n2. &lt;br/> 标签只是简单地开始新的一行，跟段落不一样，段落之间会插入一些垂直的间距。\n</code></pre></div><h3 id=\"_7-4-文本格式化标签-strong-b-、-em-i-、-del-s-、-ins-u\" tabindex=\"-1\"> 7.4 文本格式化标签：<code>&lt;strong&gt;|&lt;b&gt;</code>、<code>&lt;em&gt;|&lt;i&gt;</code>、<code>&lt;del&gt;|&lt;s&gt;</code>、<code>&lt;ins&gt;|&lt;u&gt;</code></h3>\n<p>在网页中，有时需要为文字设置粗体、斜体或下划线等效果，这时就需要用到 <code>HTML</code> 中的文本格式化标签，使文字以特殊的方式显示。</p>\n<div><pre><code>标签语义: 突出重要性，比普通文字更重要。\n</code></pre></div><table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>语义</strong></th>\n<th style=\"text-align:left\"><strong>标签</strong></th>\n<th style=\"text-align:left\"><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">加粗</td>\n<td style=\"text-align:left\"><code>&lt;strong&gt;&lt;/strong&gt;</code> 或 <code>&lt;b&gt;&lt;/b&gt;</code></td>\n<td style=\"text-align:left\">加粗更推荐使用 <code>&lt;strong&gt;</code> 标签，语义更强烈</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">倾斜</td>\n<td style=\"text-align:left\"><code>&lt;em&gt;&lt;/em&gt;</code> 或者 <code>&lt;i&gt;&lt;/i&gt;</code></td>\n<td style=\"text-align:left\">倾斜更推荐使用 <code>&lt;em&gt;</code> 标签，语义更强烈</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">删除线</td>\n<td style=\"text-align:left\"><code>&lt;del&gt;&lt;/del&gt;</code> 或者 <code>&lt;s&gt;&lt;/s&gt;</code></td>\n<td style=\"text-align:left\">删除线更推荐使用 <code>&lt;del&gt;</code> 标签，语义更强烈</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">下划线</td>\n<td style=\"text-align:left\"><code>&lt;ins&gt;&lt;/ins&gt;</code> 或者 <code>&lt;u&gt;&lt;/u&gt;</code></td>\n<td style=\"text-align:left\">下划线更推荐使用 <code>&lt;ins&gt;</code> 标签，语义更强烈</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>重点记住 <strong>加粗</strong> 和 <strong>倾斜</strong>。</p>\n</blockquote>\n<h3 id=\"_7-5-div-标签和-span-标签\" tabindex=\"-1\"> 7.5 <code>&lt;div&gt;</code> 标签和 <code>&lt;span&gt;</code> 标签</h3>\n<p><code>&lt;div&gt;</code> 和 <code>&lt;span&gt;</code> 是没有语义的，它们就是一个盒子，用来装内容的。</p>\n<div><pre><code><span><span><span>&lt;</span>div</span><span>></span></span> 这是头部 <span><span><span>&lt;/</span>div</span><span>></span></span> \n<span><span><span>&lt;</span>span</span><span>></span></span> 今日价格 <span><span><span>&lt;/</span>span</span><span>></span></span>\n</code></pre></div><blockquote>\n<p><code>div</code> 是 <code>division</code> 的缩写，表示分割、分区。</p>\n<p><code>span</code> 意为跨度、跨距。</p>\n</blockquote>\n<div><pre><code>特点：\n1. &lt;div> 标签用来布局，但是现在一行只能放一个 &lt;div>。（大盒子）\n2. &lt;span> 标签用来布局，一行上可以有多个 &lt;span>。（小盒子）\n</code></pre></div><h3 id=\"_7-6-图像标签-img\" tabindex=\"-1\"> 7.6 图像标签：<code>&lt;img&gt;</code></h3>\n<p>在 <code>HTML</code> 标签中，<code>&lt;img&gt;</code> 标签用于定义 <code>HTML</code> 页面中的图像。</p>\n<div><pre><code><span><span><span>&lt;</span>img</span> <span>src</span><span><span>=</span><span>\"</span>图像URL<span>\"</span></span><span>/></span></span>\n</code></pre></div><blockquote>\n<p>单词 <code>image</code> 的缩写，意为图像。</p>\n</blockquote>\n<div><pre><code>src 是 &lt;img> 标签的必须属性，它用于指定图像文件的路径和文件名。\n</code></pre></div><blockquote>\n<p>所谓 <strong>属性</strong> 简单理解就是属于这个图像标签的特性。</p>\n</blockquote>\n<p><strong>图像标签的常用属性：</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>属性</strong></th>\n<th style=\"text-align:left\"><strong>属性值</strong></th>\n<th style=\"text-align:left\"><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>src</code></td>\n<td style=\"text-align:left\">图片路径</td>\n<td style=\"text-align:left\">必须属性</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>alt</code></td>\n<td style=\"text-align:left\">文本</td>\n<td style=\"text-align:left\">替换文本。图像不能显示时所展示的文字</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>title</code></td>\n<td style=\"text-align:left\">文本</td>\n<td style=\"text-align:left\">提示文本。鼠标放到图像上时展示的文字</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>width</code></td>\n<td style=\"text-align:left\">像素</td>\n<td style=\"text-align:left\">设置图像的宽度</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>height</code></td>\n<td style=\"text-align:left\">像素</td>\n<td style=\"text-align:left\">设置图像的高度</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>border</code></td>\n<td style=\"text-align:left\">像素</td>\n<td style=\"text-align:left\">设置图像的边框粗细</td>\n</tr>\n</tbody>\n</table>\n<p><strong>图像标签属性注意点：</strong></p>\n<ol>\n<li>\n<p>图像标签可以拥有多个属性，必须写在标签名的后面。</p>\n</li>\n<li>\n<p>属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开。</p>\n</li>\n<li>\n<p>属性采取键值对的格式，即 <code>key=&quot;value&quot;</code> 的格式（属性=&quot;属性值&quot;）。</p>\n</li>\n</ol>\n<h3 id=\"_7-7-路径\" tabindex=\"-1\"> 7.7 路径</h3>\n<p><strong>相对路径：</strong></p>\n<p>以引用文件所在位置为参考基础，而建立出的目录路径。</p>\n<blockquote>\n<p>这里简单来说，图片相对于 <code>HTML</code> 页面的位置。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>相对路径分类</strong></th>\n<th style=\"text-align:left\"><strong>符号</strong></th>\n<th style=\"text-align:left\"><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">同一级路径</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">图像文件位于 <code>HTML</code> 文件同一级，如：<code>&lt;img src=&quot;baidu.gif&quot;/&gt;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">下一级路径</td>\n<td style=\"text-align:left\"><code>/</code></td>\n<td style=\"text-align:left\">图像文件位于 <code>HTML</code> 文件下一级，如：<code>&lt;img src=&quot;images/baidu.gif&quot;/&gt;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">上一级路径</td>\n<td style=\"text-align:left\"><code>../</code></td>\n<td style=\"text-align:left\">图像文件位于 <code>HTML</code> 文件上一级，如：<code>&lt;img src=&quot;../baidu.gif&quot;/&gt;</code></td>\n</tr>\n</tbody>\n</table>\n<p>相对路径是从代码所在的这个文件出发，去寻找目标文件的，而我们这里所说的上一级 、下一级和同一级就是图片相对于 <code>HTML</code> 页面的位置。</p>\n<p><strong>绝对路径：</strong></p>\n<p>是指目录下的绝对位置，直接到达目标位置，通常是从盘符开始的路径。</p>\n<p>例如，<code>&quot;D:\\web\\img\\logo.gif&quot;</code>，或完整的网络地址 <code>&quot;http://www.itcast.cn/images/logo.gif&quot;</code>。</p>\n<h3 id=\"_7-8-超链接标签-a\" tabindex=\"-1\"> 7.8 超链接标签：<code>&lt;a&gt;</code></h3>\n<p>在 <code>HTML</code> 标签中，<code>&lt;a&gt;</code> 标签用于定义超链接，作用是从一个页面链接到另一个页面。</p>\n<p><strong>链接的语法格式：</strong></p>\n<div><pre><code><span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>\"</span>跳转目标<span>\"</span></span> <span>target</span><span><span>=</span><span>\"</span>目标窗口的弹出方式<span>\"</span></span><span>></span></span> 文本或图像 <span><span><span>&lt;/</span>a</span><span>></span></span>\n</code></pre></div><blockquote>\n<p>单词 <code>anchor [ˈæŋkə(r)]</code> 的缩写，意为：锚。</p>\n</blockquote>\n<p><strong>两个属性的作用如下：</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><code>属性</code></th>\n<th style=\"text-align:left\"><code>作用</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>href</code></td>\n<td style=\"text-align:left\">用于指定链接目标的 <code>url</code> 地址，必须属性。当为标签引用 <code>href</code> 属性时，它就具有了超链接的功能</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>target</code></td>\n<td style=\"text-align:left\">用于指定链接页面的打开方式，其中 <code>_self</code> 为默认值，<code>_blank</code> 为在新窗口中打开方式</td>\n</tr>\n</tbody>\n</table>\n<p><strong>链接分类：</strong></p>\n<ol>\n<li>\n<p>外部链接:</p>\n<div><pre><code>例如 &lt;a href=\"http:// www.baidu.com\"> 百度 &lt;/a>\n</code></pre></div></li>\n<li>\n<p>内部链接：</p>\n<div><pre><code>网站内部页面之间的相互链接。直接链接内部页面名称即可。\n例如 &lt;a href=\"index.html\"> 首页 &lt;/a>\n</code></pre></div></li>\n<li>\n<p>空链接：</p>\n<div><pre><code>如果当时没有确定链接目标时。\n例如 &lt;a href=\"#\"> 首页 &lt;/a>\n</code></pre></div></li>\n<li>\n<p>下载链接：</p>\n<div><pre><code>如果 href 里面地址是一个文件或者压缩包，会下载这个文件。\n</code></pre></div></li>\n<li>\n<p>网页元素链接：</p>\n<div><pre><code>在网页中的各种网页元素，如文本、图像、表格、音频、视频等都可以添加超链接\n</code></pre></div></li>\n<li>\n<p>锚点链接：</p>\n<div><pre><code>当我们点击链接，可以快速定位到页面中的某个位置\n1. 在链接文本的 href 属性中，设置属性值为 \"#名字\" 的形式，如：&lt;a href=\"#two\"> 第2集 &lt;/a>\n2. 找到目标位置标签，里面添加一个 id 属性 = 刚才的名字 ，如：&lt;h3 id=\"two\"> 第2集介绍 &lt;/h3>\n</code></pre></div></li>\n</ol>\n<h2 id=\"_8-html-中的注释和特殊字符\" tabindex=\"-1\"> 8. <code>HTML</code> 中的注释和特殊字符</h2>\n<h3 id=\"_8-1-注释\" tabindex=\"-1\"> 8.1 注释：<code>&lt;!-- --&gt;</code></h3>\n<p>如果需要在 <code>HTML</code> 文档中添加一些便于阅读和理解但又不需要显示在页面中的注释文字，就需要使用注释标签。</p>\n<p><code>HTML</code> 中的注释以 &quot;<code>&lt;!--</code>&quot; 开头，以 &quot;<code>--&gt;</code>&quot; 结束。</p>\n<div><pre><code><span>&lt;!-- 注释语句 --></span>\n</code></pre></div><blockquote>\n<p>快捷键：<code>ctrl + /</code></p>\n</blockquote>\n<h3 id=\"_8-2-特殊字符\" tabindex=\"-1\"> 8.2 特殊字符</h3>\n<p>在 <code>HTML</code> 页面中，一些特殊的符号很难或者不方便直接使用，此时我们就可以使用下面的字符来替代：</p>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_1_html/08.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>重点记住：空格 、大于号、小于号</p>\n</blockquote>\n<h2 id=\"_9-表格标签-table\" tabindex=\"-1\"> 9. 表格标签：<code>&lt;table&gt;</code></h2>\n<p>表格主要用于显示、展示数据，因为它可以让数据显示的非常的规整，可读性非常好。</p>\n<blockquote>\n<p>表格不是用来布局页面的，而是用来展示数据的。</p>\n</blockquote>\n<h3 id=\"_9-1-表格的基本语法\" tabindex=\"-1\"> 9.1 表格的基本语法</h3>\n<div><pre><code><span><span><span>&lt;</span>table</span><span>></span></span>\n    <span><span><span>&lt;</span>tr</span><span>></span></span>\n        <span><span><span>&lt;</span>td</span><span>></span></span>单元格内的文字<span><span><span>&lt;/</span>td</span><span>></span></span>\n        ...\n    <span><span><span>&lt;/</span>tr</span><span>></span></span>\n    ...\n<span><span><span>&lt;/</span>table</span><span>></span></span>\n</code></pre></div><div><pre><code>1. &lt;table>&lt;/table> 是用于定义表格的标签。\n2. &lt;tr>&lt;/tr> 标签用于定义表格中的行，必须嵌套在 &lt;table>&lt;/table> 标签中。\n3. &lt;td>&lt;/td> 用于定义表格中的单元格，必须嵌套在 &lt;tr>&lt;/tr> 标签中。\n4. 字母 td 指表格数据（table data），即数据单元格的内容。\n</code></pre></div><h3 id=\"_9-2-表头单元格标签-th\" tabindex=\"-1\"> 9.2 表头单元格标签：<code>&lt;th&gt;</code></h3>\n<p>一般表头单元格位于表格的第一行或第一列，表头单元格里面的文本内容加粗居中显示。</p>\n<p><code>&lt;th&gt;</code> 标签表示 <code>HTML</code> 表格的表头部分（<code>table head</code> 的缩写）</p>\n<div><pre><code><span><span><span>&lt;</span>table</span><span>></span></span>\n    <span><span><span>&lt;</span>tr</span><span>></span></span>\n        <span><span><span>&lt;</span>th</span><span>></span></span>姓名<span><span><span>&lt;/</span>th</span><span>></span></span>\n        ...\n    <span><span><span>&lt;/</span>tr</span><span>></span></span>\n    ...\n<span><span><span>&lt;/</span>table</span><span>></span></span>\n</code></pre></div><p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_1_html/09.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>总结：</strong> 表头单元格也是单元格，常用于表格第一行，突出重要性，表头单元格里面的文字会加粗居中显示。</p>\n<h3 id=\"_9-3-表格属性\" tabindex=\"-1\"> 9.3 表格属性</h3>\n<p>表格标签这部分属性我们实际开发我们不常用，后面通过 <code>CSS</code> 来设置。</p>\n<p>目的有 <code>2</code> 个:</p>\n<ol>\n<li>\n<p>记住这些英语单词，后面 <code>CSS</code> 会使用。</p>\n</li>\n<li>\n<p>直观感受表格的外观形态。</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>属性名</strong></th>\n<th style=\"text-align:left\"><strong>属性值</strong></th>\n<th style=\"text-align:left\"><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>align</code></td>\n<td style=\"text-align:left\"><code>left</code>、<code>center</code>、<code>right</code></td>\n<td style=\"text-align:left\">规定表格相对周围元素的对齐方式</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>border</code></td>\n<td style=\"text-align:left\"><code>1</code> 或 <code>&quot;&quot;</code></td>\n<td style=\"text-align:left\">规定表格单元是否拥有边框，默认为 <code>&quot;&quot;</code>，表示没有边框</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>cellpadding</code></td>\n<td style=\"text-align:left\">像素值</td>\n<td style=\"text-align:left\">规定单元边沿与其内容之间的空白，默认 <code>1</code> 像素</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>cellspacing</code></td>\n<td style=\"text-align:left\">像素值</td>\n<td style=\"text-align:left\">规定单元格之间的空白，默认 <code>2</code> 像素</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>width</code></td>\n<td style=\"text-align:left\">像素值或百分比</td>\n<td style=\"text-align:left\">规定表格的宽度</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_9-4-案例分析\" tabindex=\"-1\"> 9.4 案例分析</h3>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_1_html/10.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>先制作表格的结构。\n1. 第一行里面是 th 表头单元格；\n2. 第二行开始里面是 td 普通单元格；\n3. 单元格里面可以放任何元素，文字链接图片等都可以。\n\n后书写表格属性。\n1. 用到宽度高度边框 cellpadding 和 cellspacing；\n2. 表格浏览器中对齐 align。\n</code></pre></div><h3 id=\"_9-5-表格结构标签-thead-tbody\" tabindex=\"-1\"> 9.5 表格结构标签：<code>&lt;thead&gt;</code> &amp; <code>&lt;tbody&gt;</code></h3>\n<p>使用场景：因为表格可能很长，为了更好的表示表格的语义，可以将表格分割成 <strong>表格头部</strong> 和 <strong>表格主体</strong> 两大部分。</p>\n<p>在表格标签中，分别用：<code>&lt;thead&gt;</code> 标签表示表格的头部区域、<code>&lt;tbody&gt;</code> 标签表示表格的主体区域。这样可以更好的分清表格结构。</p>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_1_html/11.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>1. &lt;thead>&lt;/thead>：用于定义表格的头部。&lt;thead> 内部必须拥有 &lt;tr> 标签。一般是位于第一行。\n2. &lt;tbody>&lt;/tbody>：用于定义表格的主体，主要用于放数据本体。\n3. 以上标签都是放在 &lt;table>&lt;/table> 标签中。\n</code></pre></div><h3 id=\"_9-6-合并单元格\" tabindex=\"-1\"> 9.6 合并单元格</h3>\n<p><strong>合并单元格方式：</strong></p>\n<ol>\n<li>\n<p>跨行合并：<code>rowspan=&quot;合并单元格的个数&quot;</code></p>\n</li>\n<li>\n<p>跨列合并：<code>colspan=&quot;合并单元格的个数&quot;</code></p>\n</li>\n</ol>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_1_html/12.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>确定目标单元格：</strong></p>\n<ol>\n<li>\n<p>跨行：最上侧单元格为目标单元格，写合并代码</p>\n</li>\n<li>\n<p>跨列：最左侧单元格为目标单元格，写合并代码</p>\n</li>\n</ol>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_1_html/13.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>合并单元格三步曲：</strong></p>\n<ol>\n<li>\n<p>先确定是跨行还是跨列合并。</p>\n</li>\n<li>\n<p>找到目标单元格，写上 <code>合并方式=合并的单元格数量</code>。比如：<code>&lt;td colspan=&quot;2&quot;&gt;&lt;/td&gt;</code></p>\n</li>\n<li>\n<p>删除多余的单元格。</p>\n</li>\n</ol>\n<h2 id=\"_10-列表标签\" tabindex=\"-1\"> 10. 列表标签</h2>\n<p>表格是用来显示数据的，那么列表就是用来布局的。</p>\n<p>列表最大的特点就是整齐、整洁、有序，它作为布局会更加自由和方便。</p>\n<p>根据使用情景不同，列表可以分为三大类：无序列表、有序列表和自定义列表。</p>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_1_html/14.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_10-1-无序列表-ul\" tabindex=\"-1\"> 10.1 无序列表：<code>&lt;ul&gt;</code></h3>\n<p><code>&lt;ul&gt;</code> 标签表示 <code>HTML</code> 页面中项目的无序列表，一般会以项目符号呈现列表项，而列表项使用 <code>&lt;li&gt;</code> 标签定义。</p>\n<p><strong>无序列表的基本语法格式如下：</strong></p>\n<div><pre><code><span><span><span>&lt;</span>ul</span><span>></span></span>\n    <span><span><span>&lt;</span>li</span><span>></span></span>列表项1<span><span><span>&lt;/</span>li</span><span>></span></span>\n    <span><span><span>&lt;</span>li</span><span>></span></span>列表项2<span><span><span>&lt;/</span>li</span><span>></span></span>\n    <span><span><span>&lt;</span>li</span><span>></span></span>列表项3<span><span><span>&lt;/</span>li</span><span>></span></span>\n    ...\n<span><span><span>&lt;/</span>ul</span><span>></span></span>\n</code></pre></div><div><pre><code>1. 无序列表的各个列表项之间没有顺序级别之分，是并列的。\n2. &lt;ul>&lt;/ul> 中只能嵌套 &lt;li>&lt;/li>，直接在 &lt;ul>&lt;/ul> 标签中输入其他标签或者文字的做法是不被允许的。\n3. &lt;li> 与 &lt;/li> 之间相当于一个容器，可以放任何标签。\n4. 无序列表会带有自己的样式属性，但在实际使用时，我们会使用 CSS 来设置。\n</code></pre></div><h3 id=\"_10-2-有序列表-ol\" tabindex=\"-1\"> 10.2 有序列表：<code>&lt;ol&gt;</code></h3>\n<p>有序列表即为有排列顺序的列表，其各个列表项会按照一定的顺序排列定义。</p>\n<p>在 <code>HTML</code> 标签中，<code>&lt;ol&gt;</code> 标签用于定义有序列表，列表排序以数字来显示，并且使用 <code>&lt;li&gt;</code> 标签来定义列表项。</p>\n<p><strong>有序列表的基本语法格式如下：</strong></p>\n<div><pre><code><span><span><span>&lt;</span>ol</span><span>></span></span>\n    <span><span><span>&lt;</span>li</span><span>></span></span>列表项1<span><span><span>&lt;/</span>li</span><span>></span></span>\n    <span><span><span>&lt;</span>li</span><span>></span></span>列表项2<span><span><span>&lt;/</span>li</span><span>></span></span>\n    <span><span><span>&lt;</span>li</span><span>></span></span>列表项3<span><span><span>&lt;/</span>li</span><span>></span></span>\n    ...\n<span><span><span>&lt;/</span>ol</span><span>></span></span>\n</code></pre></div><div><pre><code>1. &lt;ol>&lt;/ol> 中只能嵌套 &lt;li>&lt;/li>，直接在 &lt;ol>&lt;/ol> 标签中输入其他标签或者文字的做法是不被允许的。\n2. &lt;li> 与 &lt;/li> 之间相当于一个容器，可以放任何标签。\n3. 有序列表会带有自己样式属性，但在实际使用时，我们会使用 CSS 来设置。\n</code></pre></div><h3 id=\"_10-3-自定义列表-dl\" tabindex=\"-1\"> 10.3 自定义列表：<code>&lt;dl&gt;</code></h3>\n<p><strong>自定义列表的使用场景：</strong> 自定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。</p>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_1_html/15.png\" alt=\"\" loading=\"lazy\"></p>\n<p>在 <code>HTML</code> 标签中，<code>&lt;dl&gt;</code> 标签用于定义描述列表（或定义列表），该标签会与 <code>&lt;dt&gt;</code>（定义项目/名字）和 <code>&lt;dd&gt;</code>（描述每一个项目/名字）一起使用。</p>\n<p><strong>基本语法如下：</strong></p>\n<div><pre><code><span><span><span>&lt;</span>dl</span><span>></span></span>\n    <span><span><span>&lt;</span>dt</span><span>></span></span>名词1<span><span><span>&lt;/</span>dt</span><span>></span></span>\n    <span><span><span>&lt;</span>dd</span><span>></span></span>名词1解释1<span><span><span>&lt;/</span>dd</span><span>></span></span>\n    <span><span><span>&lt;</span>dd</span><span>></span></span>名词1解释2<span><span><span>&lt;/</span>dd</span><span>></span></span>\n<span><span><span>&lt;/</span>dl</span><span>></span></span>\n</code></pre></div><div><pre><code>1. &lt;dl>&lt;/dl> 里面只能包含 &lt;dt> 和 &lt;dd>。&lt;dt> 和 &lt;dd> 里面可以放任何标签。\n2. &lt;dt> 和 &lt;dd> 个数没有限制，经常是一个 &lt;dt> 对应多个 &lt;dd>。\n</code></pre></div><h2 id=\"_11-表单标签\" tabindex=\"-1\"> 11. 表单标签</h2>\n<p>使用表单目的是为了收集用户信息。在我们网页中， 我们也需要跟用户进行交互，收集用户资料，此时就需要表单。</p>\n<h3 id=\"_11-1-表单的组成-表单域、表单控件-表单元素-、提示信息\" tabindex=\"-1\"> 11.1 表单的组成：表单域、表单控件（表单元素）、提示信息</h3>\n<p>在 <code>HTML</code> 中，一个完整的表单通常由 <strong>表单域</strong>、<strong>表单控件</strong>（也称为表单元素）和 <strong>提示信息</strong> <code>3</code> 个部分构成。</p>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_1_html/16.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_11-1-1-表单域-form\" tabindex=\"-1\"> 11.1.1 表单域：<code>&lt;form&gt;</code></h4>\n<p>表单域是一个包含表单元素的区域。</p>\n<p>在 <code>HTML</code> 标签中，<code>&lt;form&gt;</code> 标签用于定义表单域，以实现用户信息的收集和传递。</p>\n<p><code>&lt;form&gt;</code> 会把它范围内的表单元素信息提交给服务器。</p>\n<div><pre><code><span><span><span>&lt;</span>form</span> <span>action</span><span><span>=</span><span>\"</span>url地址<span>\"</span></span> <span>method</span><span><span>=</span><span>\"</span>提交方式<span>\"</span></span> <span>name</span><span><span>=</span><span>\"</span>表单域名称<span>\"</span></span><span>></span></span>\n    各种表单元素控件\n<span><span><span>&lt;/</span>form</span><span>></span></span>\n</code></pre></div><p><strong>常用属性：</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>属性</strong></th>\n<th style=\"text-align:left\"><strong>属性值</strong></th>\n<th style=\"text-align:left\"><strong>作用</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>action</code></td>\n<td style=\"text-align:left\"><code>url</code> 地址</td>\n<td style=\"text-align:left\">用于指定接收并处理表单数据的服务器程序的 <code>url</code> 地址</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>method</code></td>\n<td style=\"text-align:left\"><code>get</code>/<code>post</code></td>\n<td style=\"text-align:left\">用于设置表单数据的提交方式，其取值为 <code>get</code> 或 <code>post</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>name</code></td>\n<td style=\"text-align:left\">名称</td>\n<td style=\"text-align:left\">用于指定表单的名称，以区分同一个页面中的多个表单域</td>\n</tr>\n</tbody>\n</table>\n<p>需要记住两点:</p>\n<ol>\n<li>\n<p>在我们写表单元素之前，应该有个表单域把他们进行包含。</p>\n</li>\n<li>\n<p>表单域是 <code>&lt;form&gt;</code> 标签。</p>\n</li>\n</ol>\n<h4 id=\"_11-1-2-表单控件-表单元素\" tabindex=\"-1\"> 11.1.2 表单控件（表单元素）</h4>\n<p>在表单域中可以定义各种表单元素，这些表单元素就是允许用户在表单中输入或者选择的内容控件。</p>\n<h5 id=\"_11-1-2-1-input-表单元素\" tabindex=\"-1\"> 11.1.2.1 <code>&lt;input&gt;</code> 表单元素</h5>\n<p>在英文单词中，<code>input</code> 是输入的意思，而在表单元素中 <strong><code>&lt;input&gt;</code> 标签用于收集用户信息</strong>。</p>\n<p>在 <code>&lt;input&gt;</code> 标签中，包含一个 <code>type</code> 属性，根据不同的 <code>type</code> 属性值，输入字段拥有很多种形式（可以是文本字段、复选框、掩码后的文本控件、单选按钮、按钮等）。</p>\n<div><pre><code><span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>\"</span>属性值<span>\"</span></span><span>/></span></span>\n</code></pre></div><div><pre><code>1. &lt;input/> 标签为单标签。\n2. type 属性设置不同的属性值用来指定不同的控件类型。\n</code></pre></div><p><strong><code>type</code> 属性的属性值及其描述如下：</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">属性值</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>button</code></td>\n<td style=\"text-align:left\">定义可点击按钮（多数情况下，用于通过 <code>JavaScript</code> 启动脚本）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>checkbox</code></td>\n<td style=\"text-align:left\">定义复选框</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>file</code></td>\n<td style=\"text-align:left\">定义输入字段和 “浏览” 按钮，供文件上传</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>hidden</code></td>\n<td style=\"text-align:left\">定义隐藏的输入字段</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>image</code></td>\n<td style=\"text-align:left\">定义图像形式的提交按钮</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>password</code></td>\n<td style=\"text-align:left\">定义密码字段。该字段中的字符被掩码</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>radio</code></td>\n<td style=\"text-align:left\">定义单选按钮</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>reset</code></td>\n<td style=\"text-align:left\">定义重置按钮。重置按钮会清除表单中的所有数据</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>submit</code></td>\n<td style=\"text-align:left\">定义提交按钮。提交按钮会把表单数据发送到服务器</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>text</code></td>\n<td style=\"text-align:left\">定义单行的输入字段，用户可在其中输入文本。默认宽度为 <code>20</code> 个字符</td>\n</tr>\n</tbody>\n</table>\n<p>除 <code>type</code> 属性外，<code>&lt;input&gt;</code> 标签还有其他很多属性。</p>\n<p><strong><code>&lt;input&gt;</code> 标签其他常用属性如下：</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>属性</strong></th>\n<th style=\"text-align:left\"><strong>属性值</strong></th>\n<th style=\"text-align:left\"><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>name</code></td>\n<td style=\"text-align:left\">由用户自定义</td>\n<td style=\"text-align:left\">定义 <code>input</code> 元素的名称</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>value</code></td>\n<td style=\"text-align:left\">由用户自定义</td>\n<td style=\"text-align:left\">规定 <code>input</code> 元素的值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>checked</code></td>\n<td style=\"text-align:left\"><code>checked</code></td>\n<td style=\"text-align:left\">规定此 <code>input</code> 元素首次加载时应当被选中</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>maxlength</code></td>\n<td style=\"text-align:left\">正整数</td>\n<td style=\"text-align:left\">规定输入字段的字符的最大长度</td>\n</tr>\n</tbody>\n</table>\n<div><pre><code>1. name 和 value 是每个表单元素都有的属性值，主要给后台人员使用。\n2. name 表单元素的名字, 要求单选按钮和复选框要有相同的 name 值。\n3. checked 属性主要针对于单选按钮和复选框，主要作用一打开页面，就要可以默认选中某个表单元素。\n4. maxlength 是用户可以在表单元素输入的最大字符数，一般较少使用。\n</code></pre></div><p><strong>注意事项：</strong></p>\n<ol>\n<li>\n<p>有些表单元素想刚打开页面就默认显示几个文字怎么做？</p>\n<blockquote>\n<p>答: 可以给这些表单元素设置 value 属性=&quot;值&quot;</p>\n</blockquote>\n<div><pre><code>用户名: <span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>\"</span>text<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>请输入用户名<span>\"</span></span><span>/></span></span>\n</code></pre></div></li>\n<li>\n<p>页面中的表单元素很多，如何区别不同的表单元素？</p>\n<blockquote>\n<p>答: 使用 <code>name</code> 属性来表示当前 <code>&lt;input&gt;</code> 表单的名字。</p>\n<p>后台可以通过这个 <code>name</code> 属性找到这个表单。页面中的表单很多，<code>name</code> 的主要作用就是用于区别不同的表单。</p>\n</blockquote>\n<div><pre><code>用户名: <span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>\"</span>text<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>请输入用户名<span>\"</span></span> <span>name</span><span><span>=</span><span>\"</span>username<span>\"</span></span> <span>/></span></span>\n</code></pre></div><blockquote>\n<p><code>name</code> 属性后面的值，是自定义的。</p>\n<p><code>radio</code>（或者 <code>checkbox</code>）如果是一组，我们必须给他们命名相同的名字</p>\n</blockquote>\n<div><pre><code><span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>\"</span>radio<span>\"</span></span> <span>name</span><span><span>=</span><span>\"</span>sex<span>\"</span></span><span>/></span></span>男 \n<span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>\"</span>radio<span>\"</span></span> <span>name</span><span><span>=</span><span>\"</span>sex<span>\"</span></span><span>/></span></span>女\n</code></pre></div></li>\n<li>\n<p>如果页面一打开就让某个单选按钮或者复选框是选中状态？</p>\n<blockquote>\n<p>答: 使用 <code>checked</code> 属性来表示默认选中状态。</p>\n<p>用于单选按钮和复选按钮。</p>\n</blockquote>\n<div><pre><code>性 别: \n<span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>\"</span>radio<span>\"</span></span> <span>name</span><span><span>=</span><span>\"</span>sex<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>男<span>\"</span></span> <span>checked</span><span><span>=</span><span>\"</span>checked<span>\"</span></span><span>/></span></span>男 \n<span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>\"</span>radio<span>\"</span></span> <span>name</span><span><span>=</span><span>\"</span>sex<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>女<span>\"</span></span><span>/></span></span>女    \n</code></pre></div></li>\n<li>\n<p>如何让 <code>&lt;input&gt;</code> 表单元素展示不同的形态？比如单选按钮或者文本框</p>\n<blockquote>\n<p>答: 使用 <code>type</code> 属性。<code>type</code> 属性可以让 <code>&lt;input&gt;</code> 表单元素设置不同的形态。</p>\n</blockquote>\n<div><pre><code><span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>\"</span>radio<span>\"</span></span> <span>name</span><span><span>=</span><span>\"</span>sex<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>男<span>\"</span></span> <span>checked</span><span><span>=</span><span>\"</span>checked<span>\"</span></span> <span>/></span></span>男 \n<span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>\"</span>text<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>请输入用户名<span>\"</span></span><span>></span></span>\n</code></pre></div></li>\n</ol>\n<h6 id=\"_11-1-2-1-1-label-标签\" tabindex=\"-1\"> 11.1.2.1.1 <code>&lt;label&gt;</code> 标签</h6>\n<p><code>&lt;label&gt;</code> 标签为 <code>&lt;input&gt;</code> 元素定义标注（标签）。</p>\n<p><code>&lt;label&gt;</code> 标签用于绑定一个表单元素，当点击 <code>&lt;label&gt;</code> 标签内的文本时，浏览器就会自动将焦点（光标）转到或者选择对应的表单元素上，用来增加用户体验。</p>\n<p><strong>语法：</strong></p>\n<div><pre><code><span><span><span>&lt;</span>label</span> <span>for</span><span><span>=</span><span>\"</span>sex<span>\"</span></span><span>></span></span>男<span><span><span>&lt;/</span>label</span><span>></span></span>\n<span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>\"</span>radio<span>\"</span></span> <span>name</span><span><span>=</span><span>\"</span>sex<span>\"</span></span> <span>id</span><span><span>=</span><span>\"</span>sex<span>\"</span></span><span>/></span></span>\n</code></pre></div><blockquote>\n<p>核心： <code>&lt;label&gt;</code> 标签的 <code>for</code> 属性应当与相关元素的 <code>id</code> 属性相同。</p>\n</blockquote>\n<h5 id=\"_11-1-2-2-select-表单元素\" tabindex=\"-1\"> 11.1.2.2 <code>&lt;select&gt;</code> 表单元素</h5>\n<p><strong>使用场景：</strong> 在页面中，如果有多个选项让用户选择，并且想要节约页面空间时，我们可以使用 <code>&lt;select&gt;</code> 标签控件定义下拉列表。</p>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_1_html/17.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>语法：</strong></p>\n<div><pre><code><span><span><span>&lt;</span>select</span><span>></span></span>\n    <span><span><span>&lt;</span>option</span><span>></span></span>选项1<span><span><span>&lt;/</span>option</span><span>></span></span>\n    <span><span><span>&lt;</span>option</span><span>></span></span>选项2<span><span><span>&lt;/</span>option</span><span>></span></span>\n    <span><span><span>&lt;</span>option</span><span>></span></span>选项3<span><span><span>&lt;/</span>option</span><span>></span></span>\n    ...\n<span><span><span>&lt;/</span>select</span><span>></span></span>\n</code></pre></div><div><pre><code>1. &lt;select> 中至少包含一对 &lt;option>。\n2. 在 &lt;option> 中定义 selected=\"selected\" 时，当前项即为默认选中项。\n</code></pre></div><h5 id=\"_11-1-2-3-textarea-表单元素\" tabindex=\"-1\"> 11.1.2.3 <code>&lt;textarea&gt;</code> 表单元素</h5>\n<p><strong>使用场景：</strong> 当用户输入内容较多的情况下，我们就不能使用文本框表单了，此时我们可以使用 <code>&lt;textarea&gt;</code> 标签。</p>\n<p>在表单元素中，<code>&lt;textarea&gt;</code> 标签是用于定义多行文本输入的控件。</p>\n<p>使用多行文本输入控件，可以输入更多的文字，该控件常见于留言板，评论。</p>\n<p><strong>语法：</strong></p>\n<div><pre><code><span><span><span>&lt;</span>textarea</span> <span>rows</span><span><span>=</span><span>\"</span>3<span>\"</span></span> <span>cols</span><span><span>=</span><span>\"</span>20<span>\"</span></span><span>></span></span>\n    文本内容\n<span><span><span>&lt;/</span>textarea</span><span>></span></span>\n</code></pre></div><div><pre><code>1. 通过 &lt;textarea> 标签可以轻松地创建多行文本输入框。\n2. cols=\"每行中的字符数\"，rows=\"显示的行数\"，我们在实际开发中不会使用，都是用 CSS 来改变大小。\n</code></pre></div><h3 id=\"_11-2-总结\" tabindex=\"-1\"> 11.2 总结</h3>\n<p>表单元素我们学习了三大组：</p>\n<ol>\n<li>\n<p><code>&lt;input&gt;</code> 输入表单元素；</p>\n</li>\n<li>\n<p><code>&lt;select&gt;</code> 下拉表单元素；</p>\n</li>\n<li>\n<p><code>&lt;textarea&gt;</code> 文本域表单元素。</p>\n</li>\n</ol>\n<p>这三组表单元素都应该包含在 <code>&lt;form&gt;</code> 表单域里面，并且有 <code>name</code> 属性：</p>\n<div><pre><code><span><span><span>&lt;</span>form</span><span>></span></span>\n    &lt;input type=“text\" name=“username”>\n    <span><span><span>&lt;</span>select</span> <span>name</span><span><span>=</span>“jiguan”</span><span>></span></span>\n        <span><span><span>&lt;</span>option</span><span>></span></span>北京<span><span><span>&lt;/</span>option</span><span>></span></span>\n    <span><span><span>&lt;/</span>select</span><span>></span></span> \n    <span><span><span>&lt;</span>textarea</span> <span>name</span><span><span>=</span> <span>\"</span>message<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>textarea</span><span>></span></span>\n<span><span><span>&lt;/</span>form</span><span>></span></span>\n</code></pre></div><p>有三个名字非常相似的标签：</p>\n<ol>\n<li>\n<p>表单域（<code>&lt;form&gt;</code>）</p>\n<blockquote>\n<p>使用场景：提交区域内表单元素给后台服务器。</p>\n</blockquote>\n</li>\n<li>\n<p>文件域（<code>file</code>）</p>\n<blockquote>\n<p>是 <code>&lt;input&gt;</code> 的 <code>type</code> 属性值。</p>\n</blockquote>\n<blockquote>\n<p>使用场景：上传文件</p>\n</blockquote>\n</li>\n<li>\n<p>文本域（<code>&lt;textarea&gt;</code>）</p>\n<blockquote>\n<p>使用场景：可以输入多行文字，比如留言板、网站介绍等。</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"_12-查阅文档\" tabindex=\"-1\"> 12. 查阅文档</h2>\n<p><strong>推荐的网址：</strong></p>\n<ol>\n<li>\n<p><code>W3C</code>：<a href=\"http://www.w3school.com.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">http://www.w3school.com.cn/<ExternalLinkIcon/></a></p>\n</li>\n<li>\n<p><code>MDN</code>：<a href=\"https://developer.mozilla.org/zh-CN/\" target=\"_blank\" rel=\"noopener noreferrer\">https://developer.mozilla.org/zh-CN/<ExternalLinkIcon/></a></p>\n</li>\n</ol>\n",
      "date_published": "2022-09-04T14:20:41.000Z",
      "date_modified": "2023-04-05T14:45:48.000Z",
      "authors": [],
      "tags": [
        "web"
      ]
    },
    {
      "title": "CSS",
      "url": "https://zengkaiqiang562.github.io/zkq/web/_1_web-dev-basic/_2_css.html",
      "id": "https://zengkaiqiang562.github.io/zkq/web/_1_web-dev-basic/_2_css.html",
      "content_html": "<blockquote>\n<p>相关案例：<a href=\"https://github.com/zengkaiqiang562/JavaGuide-Demo/tree/main/docs/zkq/web/_1_web-dev-basic/_2_css\" target=\"_blank\" rel=\"noopener noreferrer\">前端基础CSS<ExternalLinkIcon/></a></p>\n</blockquote>\n<h2 id=\"_1-css-简介\" tabindex=\"-1\"> 1. <code>CSS</code> 简介</h2>\n<p><code>CSS</code> 的主要使用场景就是美化网页，布局页面的。</p>\n<h3 id=\"_1-1-html-的局限性\" tabindex=\"-1\"> 1.1 <code>HTML</code> 的局限性</h3>\n<p>说起 <code>HTML</code>，这其实是个非常单纯的家伙，他只关注内容的语义。</p>\n<p>比如 <code>&lt;h1&gt;</code> 表明这是一个大标题，<code>&lt;p&gt;</code> 表明这是一个段落，<code>&lt;img&gt;</code> 表明这儿有一个图片，<code>&lt;a&gt;</code> 表示此处有链接。</p>\n<p>很早的时候，世界上的网站虽然很多，但是他们都有一个共同的特点：丑。</p>\n<p>虽然 <code>HTML</code> 可以做简单的样式，但是带来的是无尽的臃肿和繁琐。</p>\n<h3 id=\"_1-2-css-网页的美容师\" tabindex=\"-1\"> 1.2 <code>CSS</code> - 网页的美容师</h3>\n<p><code>CSS</code> 是层叠样式表（<code>Cascading Style Sheets</code>）的简称。</p>\n<blockquote>\n<p>有时我们也会称之为 <code>CSS</code> 样式表或级联样式表。</p>\n</blockquote>\n<p><code>CSS</code> 是也是一种标记语言。</p>\n<p><code>CSS</code> 主要用于设置 <code>HTML</code> 页面中的文本内容（字体、大小、对齐方式等）、图片的外形（宽高、边框样式、边距等）以及版面的布局和外观显示样式。</p>\n<p><code>CSS</code> 让我们的网页更加丰富多彩，布局更加灵活自如。</p>\n<p>简单理解：<code>CSS</code> 可以美化 <code>HTML</code>，让 <code>HTML</code> 更漂亮，让页面布局更简单。</p>\n<p><strong>总结：</strong></p>\n<ol>\n<li>\n<p><code>HTML</code> 主要做结构，显示元素内容。</p>\n</li>\n<li>\n<p><code>CSS</code> 美化 <code>HTML</code>，布局网页。</p>\n</li>\n<li>\n<p><code>CSS</code> 最大价值：由 <code>HTML</code> 专注去做结构呈现，样式交给 <code>CSS</code>，即 <strong>结构（<code>HTML</code>）与样式（<code>CSS</code>）相分离</strong>。</p>\n</li>\n</ol>\n<h3 id=\"_1-3-css-语法规范-选择器以及一条或多条声明\" tabindex=\"-1\"> 1.3 <code>CSS</code> 语法规范：选择器以及一条或多条声明</h3>\n<p>使用 <code>HTML</code> 时，需要遵从一定的规范，<code>CSS</code> 也是如此。要想熟练地使用 <code>CSS</code> 对网页进行修饰，首先需要了解 <code>CSS</code> 样式规则。</p>\n<p><code>CSS</code> 规则由两个主要的部分构成：<strong>选择器以及一条或多条声明</strong>。</p>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_2_css/01.png\" alt=\"\" loading=\"lazy\"></p>\n<p>如上图所示：</p>\n<div><pre><code>1. 选择器是用于指定 CSS 样式的 HTML 标签，花括号内是对该对象设置的具体样式；\n2. 属性和属性值以 “键值对” 的形式出现；\n3. 属性是对指定的对象设置的样式属性，例如字体大小、文本颜色等；\n4. 属性和属性值之间用英文 “:” 分开；\n5. 多个 “键值对” 之间用英文 “;” 进行区分。\n</code></pre></div><p>所有的样式，都包含在 <code>&lt;style&gt;</code> 标签内，表示是样式表。<code>&lt;style&gt;</code> 一般写到 <code>&lt;/head&gt;</code> 上方。示例如下：</p>\n<div><pre><code><span><span><span>&lt;</span>head</span><span>></span></span>\n    <span><span><span>&lt;</span>style</span><span>></span></span><span><span>\n        <span>h4</span> <span>{</span>\n            <span>color</span><span>:</span> blue<span>;</span>\n            <span>font-size</span><span>:</span> 100px<span>;</span>\n        <span>}</span>\n    </span></span><span><span><span>&lt;/</span>style</span><span>></span></span>\n<span><span><span>&lt;/</span>head</span><span>></span></span>\n</code></pre></div><h3 id=\"_1-4-css-代码规范\" tabindex=\"-1\"> 1.4 <code>CSS</code> 代码规范</h3>\n<p>以下代码书写规范不是强制规范，而是符合实际开发书写方式：</p>\n<ol>\n<li>\n<p>样式格式规范</p>\n<div><pre><code><span>/* 紧凑格式 */</span>\n<span>h3</span> <span>{</span> <span>color</span><span>:</span> deeppink<span>;</span> <span>font-size</span><span>:</span> 20px<span>;</span><span>}</span>\n</code></pre></div><div><pre><code><span>/* 展开格式 */</span>\n<span>h3</span> <span>{</span>\n    <span>color</span><span>:</span> pink<span>;</span>\n    <span>font-size</span><span>:</span> 20px<span>;</span> \n<span>}</span>\n</code></pre></div><blockquote>\n<p>强烈推荐 <strong>展开格式</strong>，因为更直观。</p>\n</blockquote>\n</li>\n<li>\n<p>样式大小写规范</p>\n<div><pre><code><span>h3</span> <span>{</span>\n    <span>color</span><span>:</span> pink<span>;</span>\n<span>}</span>\n</code></pre></div><div><pre><code><span>H3</span> <span>{</span>\n    <span>COLOR</span><span>:</span> PINK<span>;</span> \n<span>}</span>\n</code></pre></div><blockquote>\n<p>强烈推荐 <strong>样式选择器，属性名，属性值关键字全部使用小写字母</strong>，特殊情况除外。</p>\n</blockquote>\n</li>\n<li>\n<p>样式空格规范</p>\n<div><pre><code><span>h3</span> <span>{</span>\n    <span>color</span><span>:</span> pink<span>;</span> \n<span>}</span>\n</code></pre></div><blockquote>\n<p>属性值前面，冒号后面，保留一个空格；</p>\n<p>选择器（标签）和大括号中间保留空格。</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"_2-css-基础选择器\" tabindex=\"-1\"> 2. <code>CSS</code> 基础选择器</h2>\n<h3 id=\"_2-1-css-选择器的作用-选择标签\" tabindex=\"-1\"> 2.1 <code>CSS</code> 选择器的作用：选择标签</h3>\n<p>选择器（选择符）就是根据不同需求把不同的标签选出来这就是选择器的作用。 简单来说，就是 <strong>选择标签用的</strong>。</p>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_2_css/01.png\" alt=\"\" loading=\"lazy\"></p>\n<p>上图中 <code>CSS</code> 做了两件事：</p>\n<ol>\n<li>\n<p>找到所有的 <code>h1</code> 标签。选择器（选对人）。</p>\n</li>\n<li>\n<p>设置这些标签的样式，比如颜色为红色（做对事）。</p>\n</li>\n</ol>\n<h3 id=\"_2-2-选择器的分类-基础选择器-复合选择器\" tabindex=\"-1\"> 2.2 选择器的分类：基础选择器 &amp; 复合选择器</h3>\n<p>选择器分为基础选择器和复合选择器两个大类。</p>\n<p>我们这里先讲解一下基础选择器：</p>\n<ol>\n<li>\n<p>基础选择器是由单个选择器组成的；</p>\n</li>\n<li>\n<p>基础选择器又包括：标签选择器、类选择器、<code>id</code> 选择器和通配符选择器。</p>\n</li>\n</ol>\n<h3 id=\"_2-3-标签选择器-元素选择器-p-color-red\" tabindex=\"-1\"> 2.3 标签选择器（元素选择器）：<code>p {color: red;}</code></h3>\n<p>标签选择器（元素选择器）是指用 <code>HTML</code> 标签名称作为选择器，按标签名称分类，为页面中某一类标签指定统一的 <code>CSS</code> 样式。</p>\n<p><strong>语法：</strong></p>\n<div><pre><code>标签名 {\n    属性1: 属性值1; \n    属性2: 属性值2; \n    属性3: 属性值3; \n    ...\n}\n</code></pre></div><p><strong>作用：</strong></p>\n<p>标签选择器可以把某一类标签全部选择出来，比如所有的 <code>&lt;div&gt;</code> 标签和所有的 <code>&lt;span&gt;</code> 标签。</p>\n<p><strong>优点：</strong></p>\n<p>能快速为页面中同类型的标签统一设置样式。</p>\n<p><strong>缺点：</strong></p>\n<p>不能设计差异化样式，只能选择全部的当前标签。</p>\n<h3 id=\"_2-4-类选择器-nav-color-red\" tabindex=\"-1\"> 2.4 类选择器：<code>.nav {color: red;}</code></h3>\n<p>如果想要差异化选择不同的标签，单独选一个或者某几个标签，可以使用类选择器。</p>\n<p><strong>语法：</strong></p>\n<div><pre><code>.类名 {\n    属性1: 属性值1; \n    ...\n}\n</code></pre></div><p>例如，将所有拥有 <code>red</code> 类的 <code>HTML</code> 元素均为红色：</p>\n<div><pre><code><span>.red</span> <span>{</span>\n    <span>color</span><span>:</span> red<span>;</span>\n<span>}</span>\n</code></pre></div><p>结构需要用 <code>class</code> 属性来调用：</p>\n<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>red<span>\"</span></span><span>></span></span> 变红色 <span><span><span>&lt;/</span>div</span><span>></span></span>\n</code></pre></div><p>类选择器在 <code>HTML</code> 中以 <code>class</code> 属性表示，在 <code>CSS</code> 中，类选择器以一个点 “<code>.</code>” 号显示。</p>\n<p><strong>注意：</strong></p>\n<ol>\n<li>\n<p>类选择器使用 &quot;<code>.</code>&quot;（英文点号）进行标识，后面紧跟类名（自定义，我们自己命名的）。</p>\n</li>\n<li>\n<p>可以理解为给这个标签起了一个名字，来表示。</p>\n</li>\n<li>\n<p>长名称或词组可以使用中横线来为选择器命名。</p>\n</li>\n<li>\n<p>不要使用纯数字、中文等命名，尽量使用英文字母来表示。</p>\n</li>\n<li>\n<p>命名要有意义，尽量使别人一眼就知道这个类名的目的。</p>\n</li>\n</ol>\n<blockquote>\n<p>记忆口诀：样式 <strong>点</strong> 定义，结构 <strong>类</strong> 调用。一个或多个，开发最常用。</p>\n</blockquote>\n<h4 id=\"_2-4-1-类选择器-多类名\" tabindex=\"-1\"> 2.4.1 类选择器 - 多类名</h4>\n<p>我们可以给一个标签指定多个类名，从而达到更多的选择目的。</p>\n<p>这些类名都可以选出这个标签，简单理解就是：一个标签有多个名字。</p>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_2_css/02.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>多类名使用方式：</strong></p>\n<ol>\n<li>\n<p>在标签 <code>class</code> 属性中写多个类名；</p>\n</li>\n<li>\n<p>多个类名中间必须用空格分开；</p>\n</li>\n<li>\n<p>这个标签就可以分别具有这些类名的样式。</p>\n</li>\n</ol>\n<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>red font20<span>\"</span></span><span>></span></span>亚瑟<span><span><span>&lt;/</span>div</span><span>></span></span>\n</code></pre></div><p><strong>多类名开发中使用场景：</strong></p>\n<ol>\n<li>\n<p>可以把一些标签元素相同的样式（共同的部分）放到一个类里面；</p>\n</li>\n<li>\n<p>这些标签都可以调用这个公共的类，然后再调用自己独有的类；</p>\n</li>\n<li>\n<p>从而节省 <code>CSS</code> 代码，统一修改也非常方便。</p>\n</li>\n</ol>\n<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>pink fontWeight font20<span>\"</span></span><span>></span></span>亚瑟<span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>font20<span>\"</span></span><span>></span></span>刘备<span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>font14 pink<span>\"</span></span><span>></span></span>安其拉<span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>font14<span>\"</span></span><span>></span></span>貂蝉<span><span><span>&lt;/</span>div</span><span>></span></span>\n</code></pre></div><p><strong>总结：</strong></p>\n<ol>\n<li>\n<p>各个类名中间用空格隔开；</p>\n</li>\n<li>\n<p>简单理解：就是给某个标签添加了多个类，或者这个标签有多个名字；</p>\n</li>\n<li>\n<p>这个标签就可以分别具有这些类名的样式；</p>\n</li>\n<li>\n<p>从而节省 <code>CSS</code> 代码，统一修改也非常方便；</p>\n</li>\n<li>\n<p>多类名选择器在后期布局比较复杂的情况下，还是较多使用的。</p>\n</li>\n</ol>\n<h3 id=\"_2-5-id-选择器-nav-color-red\" tabindex=\"-1\"> 2.5 <code>id</code> 选择器：<code>#nav {color: red;}</code></h3>\n<p><code>id</code> 选择器可以为标有特定 <code>id</code> 的 <code>HTML</code> 元素指定特定的样式。</p>\n<p><code>HTML</code> 元素以 <code>id</code> 属性来设置 <code>id</code> 选择器，<code>CSS</code> 中 <code>id</code> 选择器以 &quot;<code>#</code>&quot; 来定义。</p>\n<p><strong>语法：</strong></p>\n<div><pre><code><span>#id名</span> <span>{</span>\n    <span>属性1</span><span>:</span> 属性值1<span>;</span> \n    ...\n<span>}</span>\n</code></pre></div><p><strong>示例：</strong></p>\n<div><pre><code><span>#nav</span> <span>{</span>\n    <span>color</span><span>:</span>red<span>;</span> \n<span>}</span>\n</code></pre></div><blockquote>\n<p>注意：<code>id</code> 属性只能在每个 <code>HTML</code> 文档中出现一次。</p>\n<p>口诀：样式 <code>#</code> 定义，结构 <code>id</code> 调用。只能调用一次，别人切勿使用。（“调用” 就是指在 <code>HTML</code> 标签中使用）</p>\n</blockquote>\n<h4 id=\"_2-5-1-id-选择器和类选择器的区别\" tabindex=\"-1\"> 2.5.1 <code>id</code> 选择器和类选择器的区别</h4>\n<ol>\n<li>\n<p>类选择器（<code>class</code>）好比人的名字，一个人可以有多个名字，同时一个名字也可以被多个人使用。</p>\n</li>\n<li>\n<p><code>id</code> 选择器好比人的身份证号码，全中国是唯一的，不得重复。</p>\n</li>\n<li>\n<p><code>id</code> 选择器和类选择器最大的不同在于使用次数上。</p>\n</li>\n<li>\n<p>类选择器在修改样式中用的最多，<code>id</code> 选择器一般用于页面唯一性的元素上，经常和 <code>JavaScript</code> 搭配使用。</p>\n</li>\n</ol>\n<h3 id=\"_2-6-通配符选择器-color-red\" tabindex=\"-1\"> 2.6 通配符选择器：<code>* {color: red;}</code></h3>\n<p>在 <code>CSS</code> 中，通配符选择器使用 &quot;<code>*</code>&quot; 定义，它表示选取页面中所有元素（标签）。</p>\n<p><strong>语法：</strong></p>\n<div><pre><code><span>*</span> <span>{</span>\n    <span>属性1</span><span>:</span> 属性值1<span>;</span> \n    ...\n<span>}</span>\n</code></pre></div><blockquote>\n<p>通配符选择器不需要调用， 自动就给所有的元素使用样式。</p>\n</blockquote>\n<p>特殊情况才使用通配符选择器。以下是清除所有的元素标签的内外边距：</p>\n<div><pre><code><span>*</span> <span>{</span>\n    <span>margin</span><span>:</span> 0<span>;</span>\n    <span>padding</span><span>:</span> 0<span>;</span>\n<span>}</span>\n</code></pre></div><h3 id=\"_2-7-基础选择器总结\" tabindex=\"-1\"> 2.7 基础选择器总结</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>基础选择器</strong></th>\n<th style=\"text-align:left\"><strong>作用</strong></th>\n<th style=\"text-align:left\"><strong>特点</strong></th>\n<th style=\"text-align:left\"><strong>使用情况</strong></th>\n<th style=\"text-align:left\"><strong>用法</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">标签选择器</td>\n<td style=\"text-align:left\">可以选出所有相同的标签</td>\n<td style=\"text-align:left\">不能差异化选择</td>\n<td style=\"text-align:left\">较多</td>\n<td style=\"text-align:left\"><code>p {color: red;}</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">类选择器</td>\n<td style=\"text-align:left\">可以选出 <code>1</code> 个或多个标签</td>\n<td style=\"text-align:left\">可以根据需求选择</td>\n<td style=\"text-align:left\">非常多</td>\n<td style=\"text-align:left\"><code>.nav {color: red;}</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>id</code> 选择器</td>\n<td style=\"text-align:left\">一次只能选择 <code>1</code> 个标签</td>\n<td style=\"text-align:left\">id 属性只能在每个 <code>HTML</code> 文档中出现一次</td>\n<td style=\"text-align:left\">一般和 <code>js</code> 搭配</td>\n<td style=\"text-align:left\"><code>#nav {color: red;}</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">通配符选择器</td>\n<td style=\"text-align:left\">选择所有的标签</td>\n<td style=\"text-align:left\">选择的太多，有部分不需要</td>\n<td style=\"text-align:left\">特殊情况使用</td>\n<td style=\"text-align:left\"><code>* {color: red;}</code></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>如果是修改样式， 类选择器是使用最多的。</p>\n</blockquote>\n<h2 id=\"_3-css-字体属性\" tabindex=\"-1\"> 3. <code>CSS</code> 字体属性</h2>\n<p><code>CSS Fonts</code>（字体）属性用于定义字体系列、大小、粗细、和文字样式（如斜体）。</p>\n<h3 id=\"_3-1-字体系列-font-family\" tabindex=\"-1\"> 3.1 字体系列：<code>font-family</code></h3>\n<p><code>CSS</code> 使用 <code>font-family</code> 属性定义文本的字体系列。</p>\n<div><pre><code><span>p</span> <span>{</span> <span>font-family</span><span>:</span> <span>\"微软雅黑\"</span><span>;</span><span>}</span> \n<span>div</span> <span>{</span><span>font-family</span><span>:</span> Arial<span>,</span> <span>\"Microsoft Yahei\"</span><span>,</span> <span>\"微软雅黑\"</span><span>;</span><span>}</span>\n</code></pre></div><ol>\n<li>\n<p>各种字体之间必须使用英文状态下的逗号隔开；</p>\n</li>\n<li>\n<p>一般情况下，如果有空格隔开的多个单词组成的字体，加引号；</p>\n</li>\n<li>\n<p>尽量使用系统默认自带字体，保证在任何用户的浏览器中都能正确显示；</p>\n</li>\n<li>\n<p>最常见的几个字体：<code>body {font-family: 'Microsoft YaHei', tahoma, arial, 'Hiragino Sans GB'; }</code></p>\n</li>\n</ol>\n<h3 id=\"_3-2-字体大小-font-size\" tabindex=\"-1\"> 3.2 字体大小：<code>font-size</code></h3>\n<p><code>CSS</code> 使用 <code>font-size</code> 属性定义字体大小。</p>\n<div><pre><code><span>p</span> <span>{</span> \n    <span>font-size</span><span>:</span> 20px<span>;</span> \n<span>}</span>\n</code></pre></div><ol>\n<li>\n<p><code>px</code>（像素）大小是我们网页的最常用的单位；</p>\n</li>\n<li>\n<p>谷歌浏览器默认的文字大小为 <code>16px</code>；</p>\n</li>\n<li>\n<p>不同浏览器可能默认显示的字号大小不一致，我们尽量给一个明确值大小，不要默认大小；</p>\n</li>\n<li>\n<p>可以给 <code>body</code> 指定整个页面文字的大小。</p>\n</li>\n</ol>\n<h3 id=\"_3-3-字体粗细-font-weight\" tabindex=\"-1\"> 3.3 字体粗细：<code>font-weight</code></h3>\n<p><code>CSS</code> 使用 <code>font-weight</code> 属性设置文本字体的粗细。</p>\n<div><pre><code><span>p</span> <span>{</span> \n    <span>font-weight</span><span>:</span> bold<span>;</span>\n<span>}</span>\n</code></pre></div><table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>属性值</strong></th>\n<th style=\"text-align:left\"><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>normal</code></td>\n<td style=\"text-align:left\">默认值（不加粗）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>bold</code></td>\n<td style=\"text-align:left\">定义粗体（加粗）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>100-900</code></td>\n<td style=\"text-align:left\"><code>400</code> 等同于 <code>normal</code>，而 <code>700</code> 等同于 <code>bold</code>。注意这个数字后面不跟单位</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>学会让加粗标签（比如 <code>h</code> 和 <code>strong</code> 等) 不加粗，或者其他标签加粗；</p>\n<p>实际开发时，我们更喜欢用数字表示粗细。</p>\n</blockquote>\n<h3 id=\"_3-4-文字样式-font-style\" tabindex=\"-1\"> 3.4 文字样式：<code>font-style</code></h3>\n<p><code>CSS</code> 使用 <code>font-style</code> 属性设置文本的风格。</p>\n<div><pre><code><span>p</span> <span>{</span> \n    <span>font-style</span><span>:</span> normal<span>;</span>\n<span>}</span>\n</code></pre></div><table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>属性值</strong></th>\n<th style=\"text-align:left\"><strong>作用</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>normal</code></td>\n<td style=\"text-align:left\">默认值，浏览器会显示标准的字体样式 <code>font-style: normal;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>italic</code></td>\n<td style=\"text-align:left\">浏览器会显示斜体的字体样式</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>注意：平时我们很少给文字加斜体，反而要给斜体标签（<code>em</code>，<code>i</code>）改为不倾斜字体。</p>\n</blockquote>\n<h3 id=\"_3-5-字体复合属性-font\" tabindex=\"-1\"> 3.5 字体复合属性：<code>font</code></h3>\n<p>字体属性可以把以上文字样式综合来写, 这样可以更节约代码：</p>\n<div><pre><code><span>body</span> <span>{</span> \n    <span>font</span><span>:</span> font-style font-weight font-size/line-height font-family<span>;</span> <span>}</span>\n</code></pre></div><blockquote>\n<p>使用 <code>font</code> 属性时，必须按上面语法格式中的顺序书写，<strong>不能更换顺序</strong>，并且各个属性间以空格隔开。</p>\n<p>不需要设置的属性可以省略（取默认值），但 <strong>必须保留 <code>font-size</code> 和 <code>font-family</code> 属性</strong>，否则 <code>font</code> 属性将不起作用。</p>\n</blockquote>\n<h3 id=\"_3-6-字体属性总结\" tabindex=\"-1\"> 3.6 字体属性总结</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>属性</strong></th>\n<th style=\"text-align:left\"><strong>表示</strong></th>\n<th style=\"text-align:left\"><strong>注意点</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>font-size</code></td>\n<td style=\"text-align:left\">字号</td>\n<td style=\"text-align:left\">我们通常用的单位是 <code>px</code> 像素，一定要跟上单位</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>font-family</code></td>\n<td style=\"text-align:left\">字体</td>\n<td style=\"text-align:left\">实际工作中按照团队约定来写字体</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>font-weight</code></td>\n<td style=\"text-align:left\">字体粗细</td>\n<td style=\"text-align:left\">记住加粗是 <code>700</code> 或者 <code>bold</code>，不加粗是 <code>normal</code> 或者 <code>400</code>。记住数字不要跟单位</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>font-style</code></td>\n<td style=\"text-align:left\">字体样式</td>\n<td style=\"text-align:left\">记住倾斜是 <code>italic</code>，不倾斜是 <code>normal</code> 。工作中我们最常用 <code>normal</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>font</code></td>\n<td style=\"text-align:left\">字体连写</td>\n<td style=\"text-align:left\">1. 字体连写是有顺序的，不能随意换位置；2. 其中字号和字体必须同时出现</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"_4-css-文本属性\" tabindex=\"-1\"> 4. <code>CSS</code> 文本属性</h2>\n<p><code>CSS Text</code>（文本）属性可定义文本的外观，比如文本的颜色、对齐文本、装饰文本、文本缩进、行间距等。</p>\n<h3 id=\"_4-1-文本颜色-color\" tabindex=\"-1\"> 4.1 文本颜色：<code>color</code></h3>\n<p><code>color</code> 属性用于定义文本的颜色。</p>\n<div><pre><code><span>div</span> <span>{</span> \n    <span>color</span><span>:</span> red<span>;</span>\n<span>}</span>\n</code></pre></div><table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>表示方式</strong></th>\n<th style=\"text-align:left\"><strong>属性值</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">预定义的颜色值</td>\n<td style=\"text-align:left\"><code>red</code>、<code>green</code>、<code>blue</code>、<code>pink</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">十六进制</td>\n<td style=\"text-align:left\"><code>#FF0000</code>、<code>#FF6600</code>、<code>#29D794</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>RGB</code> 代码</td>\n<td style=\"text-align:left\"><code>rgb(255, 0, 0)</code> 或 <code>rgb(100%, 0%, 0%)</code></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>开发中最常用的是十六进制。</p>\n</blockquote>\n<h3 id=\"_4-2-对齐文本-text-align\" tabindex=\"-1\"> 4.2 对齐文本：<code>text-align</code></h3>\n<p><code>text-align</code> 属性用于设置元素内文本内容的水平对齐方式。</p>\n<div><pre><code><span>div</span> <span>{</span> \n    <span>text-align</span><span>:</span> center<span>;</span>\n<span>}</span>\n</code></pre></div><table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>属性值</strong></th>\n<th style=\"text-align:left\"><strong>解释</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>left</code></td>\n<td style=\"text-align:left\">左对齐（默认值）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>right</code></td>\n<td style=\"text-align:left\">右对齐</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>center</code></td>\n<td style=\"text-align:left\">居中对齐</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_4-3-装饰文本-text-decoration\" tabindex=\"-1\"> 4.3 装饰文本：<code>text-decoration</code></h3>\n<p><code>text-decoration</code> 属性规定添加到文本的修饰。可以给文本添加下划线、删除线、上划线等。</p>\n<div><pre><code><span>div</span> <span>{</span> \n    text-decoration：underline<span>;</span>\n<span>}</span>\n</code></pre></div><table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>属性值</strong></th>\n<th style=\"text-align:left\"><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>none</code></td>\n<td style=\"text-align:left\">默认。没有装饰线（最常用）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>underline</code></td>\n<td style=\"text-align:left\">下划线。链接 <code>a</code> 自带下划线（常用）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>overline</code></td>\n<td style=\"text-align:left\">上划线（几乎不用）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>line-throught</code></td>\n<td style=\"text-align:left\">删除线。（不常用）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_4-4-文本缩进-text-indent\" tabindex=\"-1\"> 4.4 文本缩进：<code>text-indent</code></h3>\n<p><code>text-indent</code> 属性用来指定文本的第一行的缩进，通常是将段落的首行缩进。</p>\n<div><pre><code><span>div</span> <span>{</span> \n    <span>text-indent</span><span>:</span> 10px<span>;</span>\n<span>}</span>\n</code></pre></div><blockquote>\n<p>通过设置该属性，所有元素的第一行都可以缩进一个给定的长度，甚至该长度可以是负值。</p>\n</blockquote>\n<div><pre><code><span>p</span> <span>{</span> \n    <span>text-indent</span><span>:</span> 2em<span>;</span>\n<span>}</span>\n</code></pre></div><blockquote>\n<p><code>em</code> 是一个相对单位，就是当前元素（<code>font-size</code>) <code>1</code> 个文字的大小, 如果当前元素没有设置大小，则会按照父元\n素的 <code>1</code> 个文字大小。</p>\n</blockquote>\n<h3 id=\"_4-5-行间距-line-height\" tabindex=\"-1\"> 4.5 行间距：<code>line-height</code></h3>\n<p><code>line-height</code> 属性用于设置行间的距离（行高）。可以控制文字行与行之间的距离。</p>\n<div><pre><code><span>p</span> <span>{</span> \n    <span>line-height</span><span>:</span> 26px<span>;</span>\n<span>}</span>\n</code></pre></div><p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_2_css/03.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_4-6-文本属性总结\" tabindex=\"-1\"> 4.6 文本属性总结</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>属性</strong></th>\n<th style=\"text-align:left\"><strong>表示</strong></th>\n<th style=\"text-align:left\"><strong>注意点</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>color</code></td>\n<td style=\"text-align:left\">文本颜色</td>\n<td style=\"text-align:left\">我们通常用十六进制，而且是简写形式。比如：<code>#fff</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>text-align</code></td>\n<td style=\"text-align:left\">文本对齐</td>\n<td style=\"text-align:left\">可以设定文字水平的对齐方式</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>text-indent</code></td>\n<td style=\"text-align:left\">文本缩进</td>\n<td style=\"text-align:left\">通常我们用于段落首行缩进 <code>2</code> 个字的距离，即：<code>text-indent: 2em;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>line-height</code></td>\n<td style=\"text-align:left\">行高</td>\n<td style=\"text-align:left\">控制行与行之间的距离</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"_5-css-的引入方式\" tabindex=\"-1\"> 5. <code>CSS</code> 的引入方式</h2>\n<h3 id=\"_5-1-css-的三种样式表\" tabindex=\"-1\"> 5.1 <code>CSS</code> 的三种样式表</h3>\n<p>按照 <code>CSS</code> 样式书写的位置（或者引入的方式），<code>CSS</code> 样式表可以分为三大类：</p>\n<ol>\n<li>\n<p>行内样式表（行内式）</p>\n</li>\n<li>\n<p>内部样式表（嵌入式）</p>\n</li>\n<li>\n<p>外部样式表（链接式）</p>\n</li>\n</ol>\n<h4 id=\"_5-1-1-内部样式表-嵌入式\" tabindex=\"-1\"> 5.1.1 内部样式表（嵌入式）</h4>\n<p>内部样式表是写到 <code>html</code> 页面内部。是将所有的 <code>CSS</code> 代码抽取出来，单独放到一个 <code>&lt;style&gt;</code> 标签中。</p>\n<div><pre><code><span><span><span>&lt;</span>style</span><span>></span></span><span><span>\n    <span>div</span> <span>{</span>\n        <span>color</span><span>:</span> red<span>;</span>\n        <span>font-size</span><span>:</span> 12px<span>;</span>\n    <span>}</span>\n</span></span><span><span><span>&lt;/</span>style</span><span>></span></span>\n</code></pre></div><p><strong>注意：</strong></p>\n<ol>\n<li>\n<p><code>&lt;style&gt;</code> 标签理论上可以放在 <code>HTML</code> 文档的任何地方，但一般会放在文档的 <code>&lt;head&gt;</code> 标签中；</p>\n</li>\n<li>\n<p>通过此种方式，可以方便控制当前整个页面中的元素样式设置；</p>\n</li>\n<li>\n<p>代码结构清晰，但是并没有实现结构与样式完全分离；</p>\n</li>\n<li>\n<p>使用内部样式表设定 <code>CSS</code>，通常也被称为嵌入式引入，这种方式是我们练习时常用的方式。</p>\n</li>\n</ol>\n<h4 id=\"_5-1-2-行内样式表-行内式\" tabindex=\"-1\"> 5.1.2 行内样式表（行内式）</h4>\n<p>行内样式表是在元素标签内部的 <code>style</code> 属性中设定 <code>CSS</code> 样式。适合于修改简单样式。</p>\n<div><pre><code><span><span><span>&lt;</span>div</span> <span><span>style</span><span><span>=</span><span>\"</span><span><span>color</span><span>:</span> red<span>;</span> <span>font-size</span><span>:</span> 12px<span>;</span></span><span>\"</span></span></span><span>></span></span>青春不常在，抓紧谈恋爱<span><span><span>&lt;/</span>div</span><span>></span></span>\n</code></pre></div><ol>\n<li>\n<p><code>style</code> 其实就是标签的属性；</p>\n</li>\n<li>\n<p>在双引号中间，写法要符合 <code>CSS</code> 规范；</p>\n</li>\n<li>\n<p>可以控制当前的标签设置样式；</p>\n</li>\n<li>\n<p>由于书写繁琐，并且没有体现出结构与样式相分离的思想，所以不推荐大量使用，只有对当前元素添加简单样式的时候，可以考虑使用；</p>\n</li>\n<li>\n<p>使用行内样式表设定 <code>CSS</code>，通常也被称为行内式引入。</p>\n</li>\n</ol>\n<h4 id=\"_5-1-3-外部样式表-链接式\" tabindex=\"-1\"> 5.1.3 外部样式表（链接式）</h4>\n<p>实际开发都是外部样式表，适合于样式比较多的情况。</p>\n<p><strong>核心是：</strong> 样式单独写到 <code>CSS</code> 文件中，之后把 <code>CSS</code> 文件引入到 <code>HTML</code> 页面中使用。</p>\n<p><strong>引入外部样式表分为两步：</strong></p>\n<ol>\n<li>\n<p>新建一个后缀名为 <code>.css</code> 的样式文件，把所有 <code>CSS</code> 代码都放入此文件中。</p>\n</li>\n<li>\n<p>在 <code>HTML</code> 页面中，使用 <code>&lt;link&gt;</code> 标签引入这个文件。</p>\n</li>\n</ol>\n<div><pre><code><span><span><span>&lt;</span>link</span> <span>rel</span><span><span>=</span><span>\"</span>stylesheet<span>\"</span></span> <span>href</span><span><span>=</span><span>\"</span>css文件路径<span>\"</span></span><span>></span></span>\n</code></pre></div><table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>属性</strong></th>\n<th style=\"text-align:left\"><strong>作用</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>rel</code></td>\n<td style=\"text-align:left\">定义当前文档与被链接文档之间的关系。在这里需要指定为 <code>stylesheet</code>，表示被链接的文档是一个样式表文件。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>href</code></td>\n<td style=\"text-align:left\">定义所链接外部样式表文件的 <code>URL</code>，可以是相对路径，也可以是绝对路径。</td>\n</tr>\n</tbody>\n</table>\n<p>使用外部样式表设定 <code>CSS</code>，通常也被称为外链式或链接式引入，这种方式是开发中常用的方式。</p>\n<h3 id=\"_5-2-css-引入方式总结\" tabindex=\"-1\"> 5.2 <code>CSS</code> 引入方式总结</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>样式表</strong></th>\n<th style=\"text-align:left\"><strong>优点</strong></th>\n<th style=\"text-align:left\"><strong>缺点</strong></th>\n<th style=\"text-align:left\"><strong>使用情况</strong></th>\n<th style=\"text-align:left\"><strong>控制范围</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">行内样式表</td>\n<td style=\"text-align:left\">书写方便，权重高</td>\n<td style=\"text-align:left\">结构样式混写</td>\n<td style=\"text-align:left\">较少</td>\n<td style=\"text-align:left\">控制一个标签</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">内部样式表</td>\n<td style=\"text-align:left\">部分结构和样式相分离</td>\n<td style=\"text-align:left\">没有彻底分离</td>\n<td style=\"text-align:left\">较多</td>\n<td style=\"text-align:left\">控制一个页面</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">外部样式表</td>\n<td style=\"text-align:left\">完全实现结构和样式相分离</td>\n<td style=\"text-align:left\">需要引入</td>\n<td style=\"text-align:left\">最多，推荐使用</td>\n<td style=\"text-align:left\">控制多个页面</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"_6-chrome-调试工具\" tabindex=\"-1\"> 6. <code>Chrome</code> 调试工具</h2>\n<p><code>Chrome</code> 浏览器提供了一个非常好用的调试工具，可以用来调试我们的 <code>HTML</code> 结构和 <code>CSS</code> 样式。</p>\n<p><strong>打开调式工具：</strong></p>\n<p>打开 <code>Chrome</code> 浏览器，按下 <code>F12</code> 键或者右击页面空白处 <code>-&gt;</code> 检查。</p>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_2_css/04.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>使用调式工具：</strong></p>\n<ol>\n<li>\n<p><code>Ctrl</code> + 滚轮，可以放大开发者工具代码大小。</p>\n</li>\n<li>\n<p>左边是 <code>HTML</code> 元素结构，右边是 <code>CSS</code> 样式。</p>\n</li>\n<li>\n<p>右边 <code>CSS</code> 样式可以改动数值（左右箭头或者直接输入）和查看颜色。</p>\n</li>\n<li>\n<p><code>Ctrl</code> + <code>0</code> 复原浏览器大小。</p>\n</li>\n<li>\n<p>如果点击元素，发现右侧没有样式引入，极有可能是类名或者样式引入错误。</p>\n</li>\n<li>\n<p>如果有样式，但是样式前面有黄色叹号提示，则是样式属性书写错误。</p>\n</li>\n</ol>\n<h2 id=\"_7-emmet-语法\" tabindex=\"-1\"> 7. <code>Emmet</code> 语法</h2>\n<p><code>Emmet</code> 语法的前身是 <code>Zen codin</code>，它使用缩写来提高 <code>html/css</code> 的编写速度。</p>\n<blockquote>\n<p><code>Vscode</code> 内部已经集成该语法。</p>\n</blockquote>\n<h3 id=\"_7-1-快速生成-html-结构语法\" tabindex=\"-1\"> 7.1 快速生成 <code>HTML</code> 结构语法</h3>\n<ol>\n<li>\n<p>生成标签：直接输入标签名，按 <code>tab</code> 键即可。比如 <code>div</code> 然后 <code>tab</code> 键， 就可以生成 <code>&lt;div&gt;&lt;/div&gt;</code></p>\n</li>\n<li>\n<p>如果想要生成多个相同标签，加上 <code>*</code> 就可以了。比如 <code>div*3</code> 就可以快速生成 <code>3</code> 个 <code>div</code></p>\n</li>\n<li>\n<p>如果有父子级关系的标签，可以用 <code>&gt;</code>。比如 <code>ul &gt; li</code> 就可以了</p>\n</li>\n<li>\n<p>如果有兄弟关系的标签，用 <code>+</code> 就可以了。比如 <code>div+p </code></p>\n</li>\n<li>\n<p>如果生成带有类名或者 <code>id</code> 名字的， 直接写 <code>.demo</code> 或者 <code>#two tab</code> 键就可以了</p>\n</li>\n<li>\n<p>如果生成的 <code>div</code> 类名是有顺序的，可以用自增符号 <code>$</code></p>\n</li>\n<li>\n<p>如果想要在生成的标签内部写内容可以用 <code>{ }</code> 表示</p>\n</li>\n</ol>\n<h3 id=\"_7-2-快速生成-css-样式语法\" tabindex=\"-1\"> 7.2 快速生成 <code>CSS</code> 样式语法</h3>\n<p><code>CSS</code> 基本采取简写形式即可。</p>\n<ol>\n<li>\n<p>比如 <code>w200</code> 按 <code>tab</code> 可以生成 <code>width: 200px;</code></p>\n</li>\n<li>\n<p>比如 <code>lh26px</code> 按 <code>tab</code> 可以生成 <code>line-height: 26px;</code></p>\n</li>\n</ol>\n<h3 id=\"_7-3-快速格式化代码\" tabindex=\"-1\"> 7.3 快速格式化代码</h3>\n<p><code>Vscode</code> 快速格式化代码：<code>shift+alt+f</code></p>\n<p>也可以设置成：当我们保存页面的时候自动格式化代码，步骤如下：</p>\n<ol>\n<li>\n<p>文件 -&gt;【首选项】-&gt;【设置】；</p>\n</li>\n<li>\n<p>搜索 <code>emmet.include</code>；</p>\n</li>\n<li>\n<p>在 <code>settings.json</code> 下的【工作区设置】中添加以下语句：</p>\n<div><pre><code><span>\"editor.formatOnType\"</span><span>:</span> <span>true</span><span>,</span>\n<span>\"editor.formatOnSave\"</span><span>:</span> <span>true</span>\n</code></pre></div></li>\n</ol>\n<h2 id=\"_8-css-的复合选择器\" tabindex=\"-1\"> 8. <code>CSS</code> 的复合选择器</h2>\n<p>在 <code>CSS</code> 中，可以根据选择器的类型把选择器分为基础选择器和复合选择器。</p>\n<p>复合选择器可以更准确、更高效的选择目标元素（标签）。</p>\n<p>复合选择器是由两个或多个基础选择器，通过不同的方式组合而成的。</p>\n<p>常用的复合选择器包括：后代选择器、子选择器、并集选择器、伪类选择器等等。</p>\n<h3 id=\"_8-1-后代选择器\" tabindex=\"-1\"> 8.1 后代选择器</h3>\n<p>后代选择器又称为包含选择器，可以选择父元素里面子元素。</p>\n<p>其写法就是把外层标签写在前面，内层标签写在后面，中间用空格分隔。当标签发生嵌套时，内层标签就成为外层标签的后代。</p>\n<p><strong>语法：</strong></p>\n<div><pre><code>元素1 元素2 { 样式声明 }\n</code></pre></div><blockquote>\n<p>上述语法表示选择元素 <code>1</code> 里面的所有元素 <code>2</code>（后代元素）。</p>\n</blockquote>\n<p><strong>示例：</strong></p>\n<div><pre><code><span>ul li</span> <span>{</span> 样式声明 <span>}</span> <span>/* 选择 ul 里面所有的 li 标签元素 */</span>\n</code></pre></div><p><strong>注意：</strong></p>\n<ol>\n<li>\n<p>元素 <code>1</code> 和元素 <code>2</code> 中间用空格隔开；</p>\n</li>\n<li>\n<p>元素 <code>1</code> 是父级，元素 <code>2</code> 是子级，最终选择的是元素 <code>2</code>；</p>\n</li>\n<li>\n<p>元素 <code>2</code> 可以是儿子，也可以是孙子等，只要是元素 <code>1</code> 的后代即可；</p>\n</li>\n<li>\n<p>元素 <code>1</code> 和元素 <code>2</code> 可以是任意基础选择器。</p>\n</li>\n</ol>\n<h3 id=\"_8-2-子选择器\" tabindex=\"-1\"> 8.2 子选择器</h3>\n<p>子元素选择器（子选择器）只能选择作为某元素的最近一级子元素。简单理解就是选亲儿子元素。</p>\n<p><strong>语法：</strong></p>\n<div><pre><code>元素1 > 元素2 { 样式声明 }\n</code></pre></div><blockquote>\n<p>上述语法表示选择元素 <code>1</code> 里面的所有直接后代（子元素）元素 <code>2</code>。</p>\n</blockquote>\n<p><strong>示例：</strong></p>\n<div><pre><code><span>div > p</span> <span>{</span> 样式声明 <span>}</span> <span>/* 选择 div 里面所有最近一级 p 标签元素 */</span>\n</code></pre></div><p><strong>注意：</strong></p>\n<ol>\n<li>\n<p>元素 <code>1</code> 和元素 <code>2</code> 中间用大于号隔开；</p>\n</li>\n<li>\n<p>元素 <code>1</code> 是父级，元素 <code>2</code> 是子级，最终选择的是元素 <code>2</code> ；</p>\n</li>\n<li>\n<p><strong>元素 <code>2</code> 必须是亲儿子</strong>，其孙子、重孙之类都不归他管。你也可以叫他亲儿子选择器。</p>\n</li>\n</ol>\n<h3 id=\"_8-3-并集选择器\" tabindex=\"-1\"> 8.3 并集选择器</h3>\n<p>并集选择器可以选择多组标签，同时为他们定义相同的样式。通常用于集体声明。</p>\n<p>并集选择器是各选择器通过英文逗号 &quot;<code>,</code>&quot; 连接而成，任何形式的选择器都可以作为并集选择器的一部分。</p>\n<p><strong>语法：</strong></p>\n<div><pre><code>元素1,元素2 { 样式声明 }\n</code></pre></div><blockquote>\n<p>上述语法表示选择元素 <code>1</code> 和元素 <code>2</code>。</p>\n</blockquote>\n<p><strong>示例：</strong></p>\n<div><pre><code><span>ul,div</span> <span>{</span> 样式声明 <span>}</span> <span>/* 选择 ul 和 div标签元素 */</span>\n</code></pre></div><p><strong>注意：</strong></p>\n<ol>\n<li>\n<p>元素 <code>1</code> 和元素 <code>2</code> 中间用逗号隔开；</p>\n</li>\n<li>\n<p>逗号可以理解为和的意思；</p>\n</li>\n<li>\n<p>并集选择器通常用于集体声明。</p>\n</li>\n</ol>\n<h3 id=\"_8-4-伪类选择器\" tabindex=\"-1\"> 8.4 伪类选择器</h3>\n<p>伪类选择器用于向某些选择器添加特殊的效果，比如给链接添加特殊效果，或选择第 <code>1</code> 个，第 <code>n</code> 个元素。</p>\n<p>伪类选择器书写最大的特点是用冒号 &quot;<code>:</code>&quot; 表示，比如 <code>:hover</code>、<code>:first-child</code>。</p>\n<p>因为伪类选择器很多，比如有链接伪类、结构伪类等，所以这里先讲解常用的链接伪类选择器。</p>\n<h4 id=\"_8-4-1-链接伪类选择器\" tabindex=\"-1\"> 8.4.1 链接伪类选择器</h4>\n<p><strong>链接伪类选择器注意事项：</strong></p>\n<ol>\n<li>\n<p>为了确保生效，请按照 <code>LVHA</code> 的循顺序声明 <code>:link</code>－<code>:visited</code>－<code>:hover</code>－<code>:active</code>。</p>\n</li>\n<li>\n<p>记忆法：&quot;<code>love</code> <code>hate</code>&quot; 或者 &quot;<code>lv</code> 包包 <code>hao</code>” 。</p>\n</li>\n<li>\n<p>因为 <code>a</code> 链接在浏览器中具有默认样式，所以我们实际工作中都需要给链接单独指定样式。</p>\n</li>\n</ol>\n<p><strong>链接伪类选择器实际工作开发中的写法：</strong></p>\n<div><pre><code> <span>/* a 是标签选择器 所有的链接 */</span> \n <span>a</span> <span>{</span> \n    <span>color</span><span>:</span> gray<span>;</span>\n <span>}</span>\n\n <span>/* :hover 是链接伪类选择器 鼠标经过 */</span>\n <span>a:hover</span> <span>{</span> \n    <span>color</span><span>:</span> red<span>;</span> <span>/* 鼠标经过的时候，由原来的灰色 变成了红色 */</span>\n <span>}</span>\n</code></pre></div><h4 id=\"_8-4-2-focus-伪类选择器\" tabindex=\"-1\"> 8.4.2 <code>:focus</code> 伪类选择器</h4>\n<p><code>:focus</code> 伪类选择器用于选取获得 <strong>焦点</strong> 的表单元素。</p>\n<p>焦点就是光标，一般情况 <code>&lt;input&gt;</code> 类表单元素才能获取，因此这个选择器也主要针对于表单元素来说。</p>\n<div><pre><code><span>input:focus</span> <span>{</span> \n    <span>background-color</span><span>:</span>yellow<span>;</span>\n<span>}</span>\n</code></pre></div><h3 id=\"_8-5-复合选择器总结\" tabindex=\"-1\"> 8.5 复合选择器总结</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>选择器</strong></th>\n<th style=\"text-align:left\"><strong>作用</strong></th>\n<th style=\"text-align:left\"><strong>特征</strong></th>\n<th style=\"text-align:left\"><strong>使用情况</strong></th>\n<th style=\"text-align:left\"><strong>隔开符号及用法</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">后代选择器</td>\n<td style=\"text-align:left\">用来选择后代元素</td>\n<td style=\"text-align:left\">可以是子孙后代</td>\n<td style=\"text-align:left\">较多</td>\n<td style=\"text-align:left\">符号是空格，示例：<code>.nav a</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">子选择器</td>\n<td style=\"text-align:left\">选择最近一级元素</td>\n<td style=\"text-align:left\">只选亲儿子</td>\n<td style=\"text-align:left\">较少</td>\n<td style=\"text-align:left\">符号是大于，示例：<code>.nav&gt;p</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">并集选择器</td>\n<td style=\"text-align:left\">选择某些相同样式的元素</td>\n<td style=\"text-align:left\">可以用于集体声明</td>\n<td style=\"text-align:left\">较多</td>\n<td style=\"text-align:left\">符号是逗号，示例：<code>.nav,.header</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">链接伪类选择器</td>\n<td style=\"text-align:left\">选择不同状态的链接</td>\n<td style=\"text-align:left\">跟链接相关</td>\n<td style=\"text-align:left\">较多</td>\n<td style=\"text-align:left\">重点记住 <code>a{}</code> 和 <code>a:hover</code> 实际开发的写法</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>:focus</code> 选择器</td>\n<td style=\"text-align:left\">选择获得光标的表单</td>\n<td style=\"text-align:left\">跟表单相关</td>\n<td style=\"text-align:left\">较少</td>\n<td style=\"text-align:left\"><code>input:focus</code> 记住这个写法</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"_9-css-的元素显示模式\" tabindex=\"-1\"> 9. <code>CSS</code> 的元素显示模式</h2>\n<p>作用：网页的标签非常多，在不同地方会用到不同类型的标签，了解他们的特点可以更好的布局我们的网页。</p>\n<p>元素显示模式就是元素（标签）以什么方式进行显示，比如 <code>&lt;div&gt;</code> 自己占一行，比如一行可以放多个 <code>&lt;span&gt;</code>。</p>\n<h3 id=\"_9-1-元素显示模式的分类\" tabindex=\"-1\"> 9.1 元素显示模式的分类</h3>\n<p><code>HTML</code> 元素一般分为块元素和行内元素两种类型。</p>\n<h4 id=\"_9-1-1-块元素\" tabindex=\"-1\"> 9.1.1 块元素</h4>\n<p>常见的块元素有 <code>&lt;h1&gt;~&lt;h6&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;div&gt;</code>、<code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;li&gt;</code> 等，其中 <code>&lt;div&gt;</code> 标签是最典型的块元素。</p>\n<p><strong>块级元素的特点：</strong></p>\n<ol>\n<li>\n<p>比较霸道，自己独占一行。</p>\n</li>\n<li>\n<p>高度，宽度、外边距以及内边距都可以控制。</p>\n</li>\n<li>\n<p>宽度默认是容器（父级宽度）的 <code>100%</code>。</p>\n</li>\n<li>\n<p>是一个容器及盒子，里面可以放行内或者块级元素。</p>\n</li>\n</ol>\n<p><strong>注意：</strong></p>\n<ol>\n<li>\n<p>文字类的元素内不能使用块级元素；</p>\n</li>\n<li>\n<p><code>&lt;p&gt;</code> 标签主要用于存放文字，因此 <code>&lt;p&gt;</code> 里面不能放块级元素，特别是不能放 <code>&lt;div&gt;</code>；</p>\n</li>\n<li>\n<p>同理， <code>&lt;h1&gt;~&lt;h6&gt;</code> 等都是文字类块级标签，里面也不能放其他块级元素。</p>\n</li>\n</ol>\n<h4 id=\"_9-1-2-行内元素\" tabindex=\"-1\"> 9.1.2 行内元素</h4>\n<p>常见的行内元素有 <code>&lt;a&gt;</code>、<code>&lt;strong&gt;</code>、<code>&lt;b&gt;</code>、<code>&lt;em&gt;</code>、<code>&lt;i&gt;</code>、<code>&lt;del&gt;</code>、<code>&lt;s&gt;</code>、<code>&lt;ins&gt;</code>、<code>&lt;u&gt;</code>、<code>&lt;span&gt;</code> 等，</p>\n<p>其中 <code>&lt;span&gt;</code> 标签是最典型的行内元素。有的地方也将行内元素称为内联元素。</p>\n<p><strong>行内元素的特点：</strong></p>\n<ol>\n<li>\n<p>相邻行内元素在一行上，一行可以显示多个。</p>\n</li>\n<li>\n<p>高、宽直接设置是无效的。</p>\n</li>\n<li>\n<p>默认宽度就是它本身内容的宽度。</p>\n</li>\n<li>\n<p>行内元素只能容纳文本或其他行内元素。</p>\n</li>\n</ol>\n<p><strong>注意：</strong></p>\n<ol>\n<li>\n<p>链接里面不能再放链接；</p>\n</li>\n<li>\n<p>特殊情况链接 <code>&lt;a&gt;</code> 里面可以放块级元素，但是给 <code>&lt;a&gt;</code> 转换一下块级模式最安全。</p>\n</li>\n</ol>\n<h4 id=\"_9-1-3-行内块元素\" tabindex=\"-1\"> 9.1.3 行内块元素</h4>\n<p>在行内元素中有几个特殊的标签 —— <code>&lt;img/&gt;</code>、<code>&lt;input/&gt;</code>、<code>&lt;td&gt;</code>，它们同时具有块元素和行内元素的特点。有些资料称它们为行内块元素。</p>\n<p><strong>行内块元素的特点：</strong></p>\n<ol>\n<li>\n<p>和相邻行内元素（行内块）在一行上，但是他们之间会有空白缝隙。一行可以显示多个（行内元素特点）。</p>\n</li>\n<li>\n<p>默认宽度就是它本身内容的宽度（行内元素特点）。</p>\n</li>\n<li>\n<p>高度，行高、外边距以及内边距都可以控制（块级元素特点）。</p>\n</li>\n</ol>\n<h4 id=\"_9-1-4-元素显示模式总结\" tabindex=\"-1\"> 9.1.4 元素显示模式总结</h4>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>元素模式</strong></th>\n<th style=\"text-align:left\"><strong>元素排列</strong></th>\n<th style=\"text-align:left\"><strong>设置样式</strong></th>\n<th style=\"text-align:left\"><strong>默认宽度</strong></th>\n<th style=\"text-align:left\"><strong>包含</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">块级元素</td>\n<td style=\"text-align:left\">一行只能放一个块级元素</td>\n<td style=\"text-align:left\">可以设置宽度高度</td>\n<td style=\"text-align:left\">容器的 <code>100%</code></td>\n<td style=\"text-align:left\">容器级可以包含任何标签</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">行内元素</td>\n<td style=\"text-align:left\">一行可以放多个行内元素</td>\n<td style=\"text-align:left\">不可以直接设置宽度高度</td>\n<td style=\"text-align:left\">它本身内容的宽度</td>\n<td style=\"text-align:left\">容纳文本或其他行内元素</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">行内块元素</td>\n<td style=\"text-align:left\">一行放多个行内块元素</td>\n<td style=\"text-align:left\">可以设置宽度高度</td>\n<td style=\"text-align:left\">它本身内容的宽度</td>\n<td style=\"text-align:left\"></td>\n</tr>\n</tbody>\n</table>\n<p>学习元素显示模式的主要目的就是分清它们各自的特点，当我们网页布局的时候，在合适的地方用合适的标签元素。</p>\n<h3 id=\"_9-2-元素显示模式的转换\" tabindex=\"-1\"> 9.2 元素显示模式的转换</h3>\n<p>特殊情况下，我们需要元素模式的转换，简单理解: 一个模式的元素需要另外一种模式的特性。</p>\n<blockquote>\n<p>比如想要增加链接 <code>&lt;a&gt;</code> 的触发范围。</p>\n</blockquote>\n<p>转换为块元素：<code>display:block;</code></p>\n<p>转换为行内元素：<code>display:inline;</code></p>\n<p>转换为行内块：<code>display:inline-block;</code></p>\n<h3 id=\"_9-3-截图小工具-snipaste\" tabindex=\"-1\"> 9.3 截图小工具：<code>snipaste</code></h3>\n<p><code>Snipaste</code> 是一个简单但强大的截图工具，也可以让你将截图贴回到屏幕上。</p>\n<p><strong>常用快捷方式：</strong></p>\n<ol>\n<li>\n<p><code>F1</code> 可以截图。同时测量大小，设置箭头、书写文字等；</p>\n</li>\n<li>\n<p><code>F3</code> 在桌面置顶显示；</p>\n</li>\n<li>\n<p>点击图片，<code>alt</code> 可以取色（按下 <code>shift</code> 可以切换取色模式）；</p>\n</li>\n<li>\n<p>按下 <code>esc</code> 取消图片显示。</p>\n</li>\n</ol>\n<h3 id=\"_9-4-小技巧-单行文字垂直居中\" tabindex=\"-1\"> 9.4 小技巧：单行文字垂直居中</h3>\n<p><code>CSS</code> 没有给我们提供文字垂直居中的代码。这里我们可以使用一个小技巧来实现。</p>\n<p>解决方案：让文字的行高等于盒子的高度，就可以让文字在当前盒子内垂直居中。</p>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_2_css/05.png\" alt=\"\" loading=\"lazy\"></p>\n<p>简单理解：行高的上空隙和下空隙把文字挤到中间了。于是如果行高小于盒子高度，文字会偏上；如果行高大于盒子高度，则文字偏下。</p>\n<h2 id=\"_10-css-的背景\" tabindex=\"-1\"> 10. <code>CSS</code> 的背景</h2>\n<p>通过 <code>CSS</code> 背景属性，可以给页面元素添加背景样式。\n背景属性可以设置背景颜色、背景图片、背景平铺、背景图片位置、背景图像固定等。</p>\n<h3 id=\"_10-1-背景颜色-background-color\" tabindex=\"-1\"> 10.1 背景颜色：<code>background-color</code></h3>\n<p><code>background-color</code> 属性定义了元素的背景颜色。</p>\n<div><pre><code><span>background-color</span><span>:</span>颜色值<span>;</span>\n</code></pre></div><p>一般情况下元素背景颜色默认值是 <code>transparent</code>（透明），我们也可以手动指定背景颜色为透明色。</p>\n<div><pre><code><span>background-color</span><span>:</span>transparent<span>;</span>\n</code></pre></div><h3 id=\"_10-2-背景图片-background-image\" tabindex=\"-1\"> 10.2 背景图片：<code>background-image</code></h3>\n<p><code>background-image</code> 属性描述了元素的背景图像。</p>\n<p>实际开发常见于 <code>logo</code> 或者一些装饰性的小图片或者是超大的背景图片，优点是非常便于控制位置。（精灵图也是一种运用场景）</p>\n<div><pre><code><span>background-image</span> <span>:</span> none | url <span>(</span>url<span>)</span>\n</code></pre></div><table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>参数值</strong></th>\n<th style=\"text-align:left\"><strong>作用</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>none</code></td>\n<td style=\"text-align:left\">无背景图（默认的）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>url</code></td>\n<td style=\"text-align:left\">使用绝对或相对地址指定背景图像</td>\n</tr>\n</tbody>\n</table>\n<p><strong>注意：</strong> 背景图片后面的地址，千万不要忘记加 <code>URL</code>，同时里面的路径不要加引号。</p>\n<h3 id=\"_10-3-背景平铺-background-repeat\" tabindex=\"-1\"> 10.3 背景平铺：<code>background-repeat</code></h3>\n<p>如果需要在 <code>HTML</code> 页面上对背景图像进行平铺，可以使用 <code>background-repeat</code> 属性。</p>\n<div><pre><code><span>background-repeat</span><span>:</span> repeat | no-repeat | repeat-x | repeat-y\n</code></pre></div><table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>参数值</strong></th>\n<th style=\"text-align:left\"><strong>作用</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>repeat</code></td>\n<td style=\"text-align:left\">背景图像在纵向和横向上平铺（默认的）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>no-repeat</code></td>\n<td style=\"text-align:left\">背景图像不平铺</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>repeat-x</code></td>\n<td style=\"text-align:left\">背景图像在横向上平铺</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>repeat-y</code></td>\n<td style=\"text-align:left\">背景图像在纵向平铺</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_10-4-背景图片位置-background-position\" tabindex=\"-1\"> 10.4 背景图片位置：<code>background-position</code></h3>\n<p>利用 <code>background-position</code> 属性可以改变图片在背景中的位置。</p>\n<div><pre><code><span>background-position</span><span>:</span> x y<span>;</span>\n</code></pre></div><p>参数代表的意思是：<code>x</code> 坐标和 <code>y</code> 坐标。（可以使用 <strong>方位名词</strong> 或者 <strong>精确单位</strong>）</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>参数值</strong></th>\n<th style=\"text-align:left\"><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>length</code></td>\n<td style=\"text-align:left\">百分数，或由浮点数字和单位标识符组成的长度值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>position</code></td>\n<td style=\"text-align:left\"><code>top</code>、<code>center</code>、<code>bottom</code>、<code>left</code>、<code>right</code> 方位名词</td>\n</tr>\n</tbody>\n</table>\n<p><strong>参数是方位名词时：</strong></p>\n<ol>\n<li>\n<p>如果指定的两个值都是方位名词，则两个值前后顺序无关，比如 <code>left</code> <code>top</code> 和 <code>top</code> <code>left</code> 效果一致。</p>\n</li>\n<li>\n<p>如果只指定了一个方位名词，另一个值省略，则第二个值默认居中对齐。</p>\n</li>\n</ol>\n<p><strong>参数是精确单位时：</strong></p>\n<ol>\n<li>\n<p>如果参数值是精确坐标，那么第一个肯定是 <code>x</code> 坐标，第二个一定是 <code>y</code> 坐标；</p>\n</li>\n<li>\n<p>如果只指定一个数值，那该数值一定是 <code>x</code> 坐标，另一个默认垂直居中。</p>\n</li>\n</ol>\n<p><strong>参数是混合单位时：</strong></p>\n<ol>\n<li>如果指定的两个值是精确单位和方位名词混合使用，则第一个值是 <code>x</code> 坐标，第二个值是 <code>y</code> 坐标。</li>\n</ol>\n<h3 id=\"_10-5-背景图像固定-背景附着-background-attachment\" tabindex=\"-1\"> 10.5 背景图像固定（背景附着）：<code>background-attachment</code></h3>\n<p><code>background-attachment</code> 属性设置背景图像是否固定或者随着页面的其余部分滚动。</p>\n<p><code>background-attachment</code> 后期可以制作视差滚动的效果。</p>\n<div><pre><code><span>background-attachment</span> <span>:</span> scroll | fixed\n</code></pre></div><table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>参数值</strong></th>\n<th style=\"text-align:left\"><strong>作用</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>scroll</code></td>\n<td style=\"text-align:left\">背景图像是随对象内容滚动</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>fixed</code></td>\n<td style=\"text-align:left\">背景图像固定</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_10-6-背景复合写法\" tabindex=\"-1\"> 10.6 背景复合写法</h3>\n<p>为了简化背景属性的代码，我们可以将这些属性合并简写在同一个属性 <code>background</code> 中，从而节约代码量。</p>\n<p>当使用简写属性时，没有特定的书写顺序,一般习惯约定顺序为：</p>\n<div><pre><code><span>background</span><span>:</span> 背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置<span>;</span>\n</code></pre></div><blockquote>\n<p>这是实际开发中我们更提倡的写法。</p>\n</blockquote>\n<h3 id=\"_10-7-背景色半透明\" tabindex=\"-1\"> 10.7 背景色半透明</h3>\n<p><code>CSS3</code> 为我们提供了背景颜色半透明的效果。</p>\n<div><pre><code><span>background</span><span>:</span> <span>rgba</span><span>(</span>0<span>,</span> 0<span>,</span> 0<span>,</span> 0.3<span>)</span><span>;</span>\n</code></pre></div><p><strong>注意：</strong></p>\n<ol>\n<li>\n<p>最后一个参数是 <code>alpha</code> 透明度，取值范围在 <code>0~1</code> 之间；</p>\n</li>\n<li>\n<p>我们习惯把 <code>0.3</code> 的 <code>0</code> 省略掉，写为 <code>background: rgba(0, 0, 0, .3);</code></p>\n</li>\n<li>\n<p>背景半透明是指盒子背景半透明，盒子里面的内容不受影响；</p>\n</li>\n<li>\n<p><code>CSS3</code> 新增属性，是 <code>IE9+</code> 版本浏览器才支持的，但是现在实际开发我们不太关注兼容性写法了，可以放心使用。</p>\n</li>\n</ol>\n<h3 id=\"_10-8-背景总结\" tabindex=\"-1\"> 10.8 背景总结</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>属性</strong></th>\n<th style=\"text-align:left\"><strong>作用</strong></th>\n<th style=\"text-align:left\"><strong>值</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>background-color</code></td>\n<td style=\"text-align:left\">背景颜色</td>\n<td style=\"text-align:left\">预定义的颜色值，或十六进制，或 <code>RGB</code> 代码</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>background-image</code></td>\n<td style=\"text-align:left\">背景图片</td>\n<td style=\"text-align:left\"><code>url(图片路径)</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>background-repeat</code></td>\n<td style=\"text-align:left\">是否平铺</td>\n<td style=\"text-align:left\"><code>repeat</code>/<code>no-repeat</code>/<code>repeat-x</code>/<code>repeat-y</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>background-position</code></td>\n<td style=\"text-align:left\">背景位置</td>\n<td style=\"text-align:left\"><code>length</code>/<code>postion</code>；分别是 <code>x</code> 和 <code>y</code> 坐标</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>background-attachment</code></td>\n<td style=\"text-align:left\">背景附着</td>\n<td style=\"text-align:left\"><code>scroll</code>（背景滚动）/ <code>fixed</code>（背景固定）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">背景简写</td>\n<td style=\"text-align:left\">书写更简单</td>\n<td style=\"text-align:left\"><code>背景颜色 背景图片地址 背景平铺 背景滚动 背景位置;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">背景半透明</td>\n<td style=\"text-align:left\">背景颜色半透明</td>\n<td style=\"text-align:left\"><code>background:rgba(0,0,0,0.3);</code> 后面必须是 <code>4</code> 个值</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"_11-css-的三大特性\" tabindex=\"-1\"> 11. <code>CSS</code> 的三大特性</h2>\n<p><code>CSS</code> 有三个非常重要的三个特性：层叠性、继承性、优先级。</p>\n<h3 id=\"_11-1-层叠性\" tabindex=\"-1\"> 11.1 层叠性</h3>\n<p>相同选择器给设置相同的样式，此时一个样式就会覆盖（层叠）另一个冲突的样式。层叠性主要解决样式冲突的问题。</p>\n<p>层叠性原则：</p>\n<ol>\n<li>\n<p>样式冲突，遵循的原则是就近原则，哪个样式离结构近，就执行哪个样式；</p>\n</li>\n<li>\n<p>样式不冲突，不会层叠。</p>\n</li>\n</ol>\n<blockquote>\n<p><code>CSS</code> 层叠性口诀：长江后浪推前浪，前浪死在沙滩上。</p>\n</blockquote>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_2_css/06.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_11-2-继承性\" tabindex=\"-1\"> 11.2 继承性</h3>\n<p><code>CSS</code> 中的继承：子标签会继承父标签的某些样式，如文本颜色和字号。简单的理解就是：子承父业。</p>\n<p>恰当地使用继承可以简化代码，降低 <code>CSS</code> 样式的复杂性。</p>\n<p>子元素可以继承父元素的样式（<code>text-</code>，<code>font-</code>，<code>line-</code> 这些元素开头的可以继承，以及 <code>color</code> 属性）。</p>\n<blockquote>\n<p>继承性口诀：龙生龙，凤生凤，老鼠孩子会打洞。</p>\n</blockquote>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_2_css/07.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>行高的继承性：</strong></p>\n<div><pre><code><span>body</span> <span>{</span>\n    <span>font</span><span>:</span>12px/1.5 Microsoft YaHei<span>;</span>\n<span>}</span>\n</code></pre></div><ol>\n<li>\n<p>行高可以跟单位也可以不跟单位；</p>\n</li>\n<li>\n<p>如果子元素没有设置行高，则会继承父元素的行高为 <code>1.5</code>；</p>\n</li>\n<li>\n<p>此时子元素的行高是：<strong>当前子元素的文字大小 * <code>1.5</code></strong>；</p>\n</li>\n<li>\n<p><code>body</code> 行高 <code>1.5</code> 这样写法最大的优势就是里面子元素可以根据自己文字大小自动调整行高。</p>\n</li>\n</ol>\n<h3 id=\"_11-3-优先级\" tabindex=\"-1\"> 11.3 优先级</h3>\n<p>当同一个元素指定多个选择器，就会有优先级的产生。</p>\n<ol>\n<li>\n<p>选择器相同，则执行层叠性；</p>\n</li>\n<li>\n<p>选择器不同，则根据选择器权重执行。</p>\n</li>\n</ol>\n<p><strong>选择器权重如下表所示：</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>选择器</strong></th>\n<th style=\"text-align:left\"><strong>选择器权重</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">继承或者 <code>*</code></td>\n<td style=\"text-align:left\"><code>0,0,0,0</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">元素（标签）选择器</td>\n<td style=\"text-align:left\"><code>0,0,0,1</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">类选择器，伪类选择器</td>\n<td style=\"text-align:left\"><code>0,0,1,0</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>ID</code> 选择器</td>\n<td style=\"text-align:left\"><code>0,1,0,0</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">行内样式 <code>style=&quot;&quot;</code></td>\n<td style=\"text-align:left\"><code>1,0,0,0</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>!important</code> 重要的</td>\n<td style=\"text-align:left\"><code>∞</code> 无穷大</td>\n</tr>\n</tbody>\n</table>\n<p><strong>优先级注意点：</strong></p>\n<ol>\n<li>\n<p>权重是有 <code>4</code> 组数字组成，但是不会有进位。</p>\n</li>\n<li>\n<p>可以理解为类选择器永远大于元素选择器，<code>id</code> 选择器永远大于类选择器，以此类推；</p>\n</li>\n<li>\n<p>等级判断从左向右，如果某一位数值相同，则判断下一位数值。</p>\n</li>\n<li>\n<p>简单记忆法：通配符和继承权重为 <code>0</code>，标签选择器为 <code>1</code>，类(伪类)选择器为 <code>10</code>，<code>id</code> 选择器 <code>100</code>，行内样式表为 <code>1000</code>，<code>!important</code> 无穷大；</p>\n</li>\n<li>\n<p>继承的权重是 <code>0</code>， 如果该元素没有直接选中，不管父元素权重多高，子元素得到的权重都是 <code>0</code>。</p>\n</li>\n</ol>\n<p><strong>权重叠加：</strong> 如果是复合选择器，则会有权重叠加，需要计算权重。</p>\n<div><pre><code>div ul li  --> 0,0,0,3\n.nav ul li --> 0,0,1,2\na:hover    -—> 0,0,1,1\n.nav a     --> 0,0,1,1\n</code></pre></div><h2 id=\"_12-css-的注释\" tabindex=\"-1\"> 12. <code>CSS</code> 的注释</h2>\n<p>注释用于解释代码，它们会被浏览器忽略。<code>CSS</code> 中的注释以 &quot;<code>/*</code>&quot; 开头，以 &quot;<code>*/</code>&quot; 结尾。</p>\n<div><pre><code><span>/* 需要注释的内容 */</span>\n</code></pre></div><h2 id=\"_13-盒子模型-box-model\" tabindex=\"-1\"> 13. 盒子模型（<code>Box Model</code>）</h2>\n<p>页面布局要学习三大核心：盒子模型、浮动、定位。</p>\n<p>学习好盒子模型能非常好的帮助我们布局页面。</p>\n<h3 id=\"_13-1-看透网页布局的本质\" tabindex=\"-1\"> 13.1 看透网页布局的本质</h3>\n<p><strong>网页布局过程：</strong></p>\n<ol>\n<li>\n<p>先准备好相关的网页元素，网页元素基本都是盒子（<code>Box</code>）；</p>\n</li>\n<li>\n<p>利用 <code>CSS</code> 设置好盒子样式，然后摆放到相应位置；</p>\n</li>\n<li>\n<p>往盒子里面装内容。</p>\n</li>\n</ol>\n<p><strong>网页布局的核心本质：</strong> 就是利用 <code>CSS</code> 摆盒子。</p>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_2_css/08.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_13-2-盒子模型的组成\" tabindex=\"-1\"> 13.2 盒子模型的组成</h3>\n<p>所谓盒子模型：就是把 <code>HTML</code> 页面中的布局元素看作是一个矩形的盒子，也就是一个盛装内容的容器。</p>\n<p><code>CSS</code> 盒子模型本质上是一个盒子封装周围的 <code>HTML</code> 元素，盒子包括：边框、外边距、内边距、和实际内容。</p>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_2_css/09.png\" alt=\"\" loading=\"lazy\"></p>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_2_css/10.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_13-2-1-边框-border\" tabindex=\"-1\"> 13.2.1 边框：<code>border</code></h4>\n<p><code>border</code> 可以设置元素的边框。</p>\n<p><strong>边框有三部分组成：</strong> 边框宽度（粗细）、边框样式、边框颜色。</p>\n<p><strong>语法：</strong></p>\n<div><pre><code><span>border</span> <span>:</span> border-width || border-style || border-color\n</code></pre></div><table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>属性</strong></th>\n<th style=\"text-align:left\"><strong>作用</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>border-width</code></td>\n<td style=\"text-align:left\">定义边框粗细，单位是 <code>px</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>border-style</code></td>\n<td style=\"text-align:left\">边框的样式</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>border-color</code></td>\n<td style=\"text-align:left\">边框颜色</td>\n</tr>\n</tbody>\n</table>\n<p><strong>边框样式 <code>border-style</code> 可以设置如下值：</strong></p>\n<ol>\n<li>\n<p><code>none</code>：没有边框即忽略所有边框的宽度（默认值）；</p>\n</li>\n<li>\n<p><code>solid</code>：边框为单实线（最为常用的）；</p>\n</li>\n<li>\n<p><code>dashed</code>：边框为虚线；</p>\n</li>\n<li>\n<p><code>dotted</code>：边框为点线。</p>\n</li>\n</ol>\n<p><strong>边框简写：</strong></p>\n<div><pre><code><span>border</span><span>:</span> 1px solid red<span>;</span> <span>/* 没有顺序 */</span>\n</code></pre></div><p><strong>边框分开写法：</strong></p>\n<div><pre><code><span>border-top</span><span>:</span> 1px solid red<span>;</span> <span>/* 只设定上边框，其余同理 */</span>\n</code></pre></div><h5 id=\"_13-2-1-1-表格的细线边框-border-collapse\" tabindex=\"-1\"> 13.2.1.1 表格的细线边框：<code>border-collapse</code></h5>\n<p><code>border-collapse</code> 属性控制浏览器绘制表格边框的方式。它控制相邻单元格的边框。</p>\n<p><strong>语法：</strong></p>\n<div><pre><code><span>border-collapse</span><span>:</span>collapse<span>;</span>\n</code></pre></div><ol>\n<li>\n<p><code>collapse</code> 单词是合并的意思。</p>\n</li>\n<li>\n<p><code>border-collapse: collapse;</code> 表示相邻边框合并在一起。</p>\n</li>\n</ol>\n<h5 id=\"_13-2-1-2-边框会影响盒子的实际大小\" tabindex=\"-1\"> 13.2.1.2 边框会影响盒子的实际大小</h5>\n<p>边框会额外增加盒子的实际大小。因此我们有两种方案解决：</p>\n<ol>\n<li>\n<p>测量盒子大小的时候不量边框；</p>\n</li>\n<li>\n<p>如果测量的时候包含了边框，则需要 <code>width</code>/<code>height</code> 减去边框宽度。</p>\n</li>\n</ol>\n<h4 id=\"_13-2-2-内边距-padding\" tabindex=\"-1\"> 13.2.2 内边距：<code>padding</code></h4>\n<p><code>padding</code> 属性用于设置内边距，即边框与内容之间的距离。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>属性</strong></th>\n<th style=\"text-align:left\"><strong>作用</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>padding-left</code></td>\n<td style=\"text-align:left\">左内边距</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>padding-right</code></td>\n<td style=\"text-align:left\">右内边距</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>padding-top</code></td>\n<td style=\"text-align:left\">上内边距</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>padding-bottom</code></td>\n<td style=\"text-align:left\">下内边距</td>\n</tr>\n</tbody>\n</table>\n<p><strong><code>padding</code> 属性（简写属性）可以有一到四个值：</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>值的个数</strong></th>\n<th style=\"text-align:left\"><strong>表达意思</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>padding:5px;</code></td>\n<td style=\"text-align:left\"><code>1</code> 个值，代表上下左右都有 <code>5</code> 像素内边距</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>padding:5px 10px;</code></td>\n<td style=\"text-align:left\"><code>2</code> 个值，代表上下内边距是 <code>5</code> 像素，左右内边距是 <code>10</code> 像素</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>padding:5px 10px 20px;</code></td>\n<td style=\"text-align:left\"><code>3</code> 个值，代表上内边距 <code>5</code> 像素，左右内边距 <code>10</code> 像素，下内边距 <code>20</code> 像素</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>padding:5px 10px 20px 30px;</code></td>\n<td style=\"text-align:left\"><code>4</code> 个值，上是 <code>5</code> 像素，右 <code>10</code> 像素，下 <code>20</code> 像素，左 <code>30</code> 像素。（顺时针）</td>\n</tr>\n</tbody>\n</table>\n<p><strong>当我们给盒子指定 <code>padding</code> 值之后，发生了 <code>2</code> 件事情：</strong></p>\n<ol>\n<li>\n<p>内容和边框有了距离，添加了内边距；</p>\n</li>\n<li>\n<p><code>padding</code> 影响了盒子实际大小。</p>\n</li>\n</ol>\n<p>也就是说，如果盒子已经有了宽度和高度，此时再指定内边距，会撑大盒子。</p>\n<blockquote>\n<p>如何盒子本身没有指定 <code>width</code>/<code>height</code> 属性, 则此时 <code>padding</code> 不会撑开盒子大小.</p>\n</blockquote>\n<p><strong>解决方案：</strong></p>\n<p>如果保证盒子跟效果图大小保持一致，则让 <code>width</code>/<code>height</code> 减去多出来的内边距大小即可。</p>\n<h4 id=\"_13-2-3-外边距-margin\" tabindex=\"-1\"> 13.2.3 外边距：<code>margin</code></h4>\n<p><code>margin</code> 属性用于设置外边距，即控制盒子和盒子之间的距离。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>属性</strong></th>\n<th style=\"text-align:left\"><strong>作用</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>margin-left</code></td>\n<td style=\"text-align:left\">左外边距</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>margin-right</code></td>\n<td style=\"text-align:left\">右外边距</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>margin-top</code></td>\n<td style=\"text-align:left\">上外边距</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>margin-bottom</code></td>\n<td style=\"text-align:left\">下外边距</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p><code>margin</code> 简写方式代表的意义跟 <code>padding</code> 完全一致。</p>\n</blockquote>\n<h5 id=\"_13-2-3-1-外边距的典型应用\" tabindex=\"-1\"> 13.2.3.1 外边距的典型应用</h5>\n<p>外边距可以让块级盒子水平居中，但是必须满足两个条件：</p>\n<ol>\n<li>\n<p>盒子必须指定了宽度（<code>width</code>）；</p>\n</li>\n<li>\n<p>盒子左右的外边距都设置为 <code>auto</code>。</p>\n</li>\n</ol>\n<div><pre><code><span>.header</span><span>{</span> <span>width</span><span>:</span>960px<span>;</span> <span>margin</span><span>:</span>0 auto<span>;</span><span>}</span>\n</code></pre></div><p><strong>常见的写法，以下三种都可以：</strong></p>\n<ol>\n<li>\n<p><code>margin-left: auto; margin-right: auto;</code></p>\n</li>\n<li>\n<p><code>margin: auto;</code></p>\n</li>\n<li>\n<p><code>margin: 0 auto;</code></p>\n</li>\n</ol>\n<p><strong>注意：</strong></p>\n<p>以上方法是让块级元素水平居中，行内元素或者行内块元素水平居中给其父元素添加 <code>text-align:center</code> 即可。</p>\n<h5 id=\"_13-2-3-2-外边距合并\" tabindex=\"-1\"> 13.2.3.2 外边距合并</h5>\n<p>使用 <code>margin</code> 定义块元素的垂直外边距时，可能会出现外边距的合并。主要有两种情况：</p>\n<ol>\n<li>\n<p>相邻块元素垂直外边距的合并；</p>\n</li>\n<li>\n<p>嵌套块元素垂直外边距的塌陷。</p>\n</li>\n</ol>\n<h6 id=\"_13-2-3-2-1-相邻块元素垂直外边距的合并\" tabindex=\"-1\"> 13.2.3.2.1 相邻块元素垂直外边距的合并</h6>\n<p>当上下相邻的两个块元素（兄弟关系）相遇时，如果上面的元素有下外边距 <code>margin-bottom</code>，下面的元素有上外边距 <code>margin-top</code>，</p>\n<p>则他们之间的垂直间距不是<code> margin-bottom</code> 与 <code>margin-top</code> 之和，而是取两个值中的较大者。</p>\n<p>这种现象被称为相邻块元素垂直外边距的合并。</p>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_2_css/11.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>解决方案：</strong></p>\n<p>尽量只给一个盒子添加 <code>margin</code> 值。</p>\n<h6 id=\"_13-2-3-2-2-嵌套块元素垂直外边距的塌陷\" tabindex=\"-1\"> 13.2.3.2.2 嵌套块元素垂直外边距的塌陷</h6>\n<p>对于两个嵌套关系（父子关系）的块元素，父元素有上外边距，同时子元素也有上外边距。此时，父元素会塌陷较大的外边距值。</p>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_2_css/12.png\" alt=\"\" loading=\"lazy\"></p>\n<p>解决方案：</p>\n<ol>\n<li>\n<p>可以为父元素定义上边框；</p>\n</li>\n<li>\n<p>可以为父元素定义上内边距；</p>\n</li>\n<li>\n<p>可以为父元素添加 <code>overflow:hidden</code>。</p>\n</li>\n</ol>\n<blockquote>\n<p>还有其他方法，比如浮动、固定，绝对定位的盒子不会有塌陷问题。后面咱们再总结。</p>\n</blockquote>\n<h3 id=\"_13-3-清除内外边距\" tabindex=\"-1\"> 13.3 清除内外边距</h3>\n<p>网页元素很多都带有默认的内外边距，而且不同浏览器默认的也不一致。</p>\n<p>因此我们在布局前，首先要清除下网页元素的内外边距。</p>\n<div><pre><code><span>*</span> <span>{</span>\n    <span>padding</span><span>:</span>0<span>;</span> <span>/* 清除内边距 */</span>\n    <span>margin</span><span>:</span>0<span>;</span> <span>/* 清除外边距 */</span>\n<span>}</span>\n</code></pre></div><p><strong>注意：</strong></p>\n<p>行内元素为了照顾兼容性，尽量只设置左右内外边距，不要设置上下内外边距。</p>\n<p>但是转换为块级和行内块元素就可以了。</p>\n<h2 id=\"_14-ps-基本操作\" tabindex=\"-1\"> 14. <code>PS</code> 基本操作</h2>\n<p>因为网页美工大部分效果图都是利用 <code>PS</code>（<code>Photoshop</code>）来做的，所以以后我们大部分切图工作都是在 <code>PS</code> 里面完成。</p>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_2_css/13.png\" alt=\"\" loading=\"lazy\"></p>\n<ol>\n<li>\n<p>文件 -&gt; 打开：可以打开我们要测量的图片；</p>\n</li>\n<li>\n<p>视图 -&gt; 标尺（<code>Ctrl R</code>）：可以打开标尺；</p>\n</li>\n<li>\n<p>右击标尺，把里面的单位改为像素；</p>\n</li>\n<li>\n<p><code>Ctrl +</code> 可以放大视图，<code>Ctrl -</code> 可以缩小视图；</p>\n</li>\n<li>\n<p>按住空格键，鼠标可以变成小手，拖动 <code>PS</code> 视图；</p>\n</li>\n<li>\n<p>用选区拖动 可以测量大小；</p>\n</li>\n<li>\n<p><code>Ctrl D</code> 可以取消选区，或者在旁边空白处点击一下也可以取消选区。</p>\n</li>\n</ol>\n<h2 id=\"_15-综合案例\" tabindex=\"-1\"> 15. 综合案例</h2>\n<h3 id=\"_15-1-faq\" tabindex=\"-1\"> 15.1 <code>FAQ</code></h3>\n<h4 id=\"_15-1-1-布局为啥用不同盒子-我只想用-div\" tabindex=\"-1\"> 15.1.1 布局为啥用不同盒子，我只想用 <code>div</code>？</h4>\n<div><pre><code>标签都是有语义的，合理的地方用合理的标签。比如产品标题就用 h，大量文字段落就用 p。\n</code></pre></div><h4 id=\"_15-1-2-为啥用那么多类名\" tabindex=\"-1\"> 15.1.2 为啥用那么多类名？</h4>\n<div><pre><code>类名就是给每个盒子起了一个名字，可以更好的找到这个盒子，选取盒子更容易，后期维护也方便。\n</code></pre></div><h4 id=\"_15-1-3-到底用-margin-还是-padding\" tabindex=\"-1\"> 15.1.3 到底用 <code>margin</code> 还是 <code>padding</code>？</h4>\n<div><pre><code>大部分情况两个可以混用，两者各有优缺点，但是根据实际情况，总是有更简单的方法实现。\n</code></pre></div><h3 id=\"_15-2-小技巧-去掉-li-前面的项目符号-小圆点\" tabindex=\"-1\"> 15.2 小技巧：去掉 <code>li</code> 前面的项目符号（小圆点）</h3>\n<div><pre><code><span>list-style</span><span>:</span> none<span>;</span>\n</code></pre></div><h2 id=\"_16-圆角边框-border-radius\" tabindex=\"-1\"> 16. 圆角边框：<code>border-radius</code></h2>\n<p>在 <code>CSS3</code> 中，新增了圆角边框样式，这样我们的盒子就可以变圆角了。</p>\n<p><code>border-radius</code> 属性用于设置元素的外边框圆角。</p>\n<p><strong>语法：</strong></p>\n<div><pre><code><span>border-radius</span><span>:</span> length<span>;</span>\n</code></pre></div><p><strong>注意点：</strong></p>\n<ol>\n<li>\n<p>参数值可以为数值或百分比的形式；</p>\n</li>\n<li>\n<p>如果是正方形，想要设置为一个圆，把数值修改为高度或者宽度的一半即可，或者直接写为 <code>50%</code>；</p>\n</li>\n<li>\n<p>该属性是一个简写属性，可以跟四个值，分别代表左上角、右上角、右下角、左下角；</p>\n</li>\n<li>\n<p>分开写：<code>border-top-left-radius</code>、<code>border-top-right-radius</code>、<code>border-bottom-right-radius</code> 和 <code>border-bottom-left-radius</code>；</p>\n</li>\n<li>\n<p>兼容性 <code>ie9+</code> 浏览器支持，但是不会影响页面布局，可以放心使用。</p>\n</li>\n</ol>\n<h2 id=\"_17-盒子阴影-box-shadow\" tabindex=\"-1\"> 17. 盒子阴影：<code>box-shadow</code></h2>\n<p><code>CSS3</code> 中新增了盒子阴影，我们可以使用 <code>box-shadow</code> 属性为盒子添加阴影。</p>\n<p><strong>语法：</strong></p>\n<div><pre><code><span>box-shadow</span><span>:</span> h-shadow v-shadow blur spread color inset<span>;</span>\n</code></pre></div><table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>值</strong></th>\n<th style=\"text-align:left\"><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>h-shadow</code></td>\n<td style=\"text-align:left\">必需。水平阴影的位置。允许负值。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>v-shadow</code></td>\n<td style=\"text-align:left\">必需。垂直阴影的位置。允许负值。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>blur</code></td>\n<td style=\"text-align:left\">可选。模糊距离。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>spread</code></td>\n<td style=\"text-align:left\">可选。阴影的尺寸。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>color</code></td>\n<td style=\"text-align:left\">可选。阴影的颜色。请参阅 <code>CSS</code> 颜色值。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>inset</code></td>\n<td style=\"text-align:left\">可选。将外部阴影（<code>outset</code>）改为内部阴影。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>注意：</strong></p>\n<ol>\n<li>\n<p>默认的是外阴影（<code>outset</code>），但是不可以写这个单词，否则造成阴影无效；</p>\n</li>\n<li>\n<p>盒子阴影不占用空间，不会影响其他盒子排列。</p>\n</li>\n</ol>\n<h2 id=\"_18-文字阴影-text-shadow\" tabindex=\"-1\"> 18. 文字阴影：<code>text-shadow</code></h2>\n<p>在 <code>CSS3</code> 中，我们可以使用 <code>text-shadow</code> 属性将阴影应用于文本。</p>\n<p><strong>语法：</strong></p>\n<div><pre><code><span>text-shadow</span><span>:</span> h-shadow v-shadow blur color<span>;</span>\n</code></pre></div><table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>值</strong></th>\n<th style=\"text-align:left\"><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>h-shadow</code></td>\n<td style=\"text-align:left\">必需。水平阴影的位置。允许负值。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>v-shadow</code></td>\n<td style=\"text-align:left\">必需。垂直阴影的位置。允许负值。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>blur</code></td>\n<td style=\"text-align:left\">可选。模糊距离。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>color</code></td>\n<td style=\"text-align:left\">可选。阴影的颜色。请参阅 <code>CSS</code> 颜色值。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"_19-浮动\" tabindex=\"-1\"> 19. 浮动</h2>\n<h3 id=\"_19-1-网页的三种传统布局方式-标准流、浮动、定位\" tabindex=\"-1\"> 19.1 网页的三种传统布局方式：标准流、浮动、定位</h3>\n<p>网页布局的本质 —— 用 <code>CSS</code> 来摆放盒子。</p>\n<p><code>CSS</code> 提供了三种传统布局方式（简单说，就是提供了三种摆放盒子的方式）：</p>\n<ol>\n<li>\n<p>标准流（普通流）；</p>\n</li>\n<li>\n<p>浮动；</p>\n</li>\n<li>\n<p>定位；</p>\n</li>\n</ol>\n<p><strong>注意：</strong> 实际开发中，一个页面基本都包含了这三种布局方式（后面移动端学习新的布局方式）。</p>\n<h3 id=\"_19-2-标准流-普通流-文档流\" tabindex=\"-1\"> 19.2 标准流（普通流/文档流）</h3>\n<p>所谓的标准流：就是标签按照规定好默认方式排列，其中：</p>\n<ol>\n<li>\n<p>块级元素会独占一行，从上向下顺序排列。</p>\n<div><pre><code>常用元素：div、hr、p、h1~h6、ul、ol、dl、form、table\n</code></pre></div></li>\n<li>\n<p>行内元素会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行。</p>\n<div><pre><code>常用元素：span、a、i、em 等\n</code></pre></div></li>\n</ol>\n<p>以上都是标准流布局，我们前面学习的就是标准流，<strong>标准流是最基本的布局方式</strong>。</p>\n<h3 id=\"_19-3-为什么需要浮动\" tabindex=\"-1\"> 19.3 为什么需要浮动？</h3>\n<h4 id=\"_19-3-1-思考两个问题\" tabindex=\"-1\"> 19.3.1 思考两个问题：</h4>\n<h5 id=\"_19-3-1-1-如何让多个块级盒子-div-水平排列成一行\" tabindex=\"-1\"> 19.3.1.1 如何让多个块级盒子（<code>div</code>）水平排列成一行？</h5>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_2_css/14.png\" alt=\"\" loading=\"lazy\"></p>\n<p>比较难，虽然转换为行内块元素可以实现一行显示，但是他们之间会有大的空白缝隙，很难控制。</p>\n<h5 id=\"_19-3-1-2-如何实现两个盒子的左右对齐\" tabindex=\"-1\"> 19.3.1.2 如何实现两个盒子的左右对齐？</h5>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_2_css/15.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>总结：</strong> 有很多的布局效果，标准流没有办法完成，此时就可以利用浮动完成布局。因为浮动可以改变元素标签默认的排列方式。</p>\n<h4 id=\"_19-3-2-浮动最典型的应用-让多个块级元素在一行内排列显示\" tabindex=\"-1\"> 19.3.2 浮动最典型的应用：让多个块级元素在一行内排列显示</h4>\n<h4 id=\"_19-3-3-网页布局第一准则-多个块级元素纵向排列找标准流-多个块级元素横向排列找浮动\" tabindex=\"-1\"> 19.3.3 网页布局第一准则：多个块级元素纵向排列找标准流，多个块级元素横向排列找浮动</h4>\n<h3 id=\"_19-4-什么是浮动-浮动属性-float\" tabindex=\"-1\"> 19.4 什么是浮动？（浮动属性：<code>float</code>）</h3>\n<p><code>float</code> 属性用于创建浮动框，将其移动到一边，直到左边缘或右边缘触及包含块或另一个浮动框的边缘。</p>\n<p><strong>语法：</strong></p>\n<div><pre><code>选择器 { float: 属性值; }\n</code></pre></div><table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>属性值</strong></th>\n<th style=\"text-align:left\"><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>none</code></td>\n<td style=\"text-align:left\">元素不浮动（默认）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>left</code></td>\n<td style=\"text-align:left\">元素向左浮动</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>right</code></td>\n<td style=\"text-align:left\">元素向右浮动</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_19-5-浮动特性\" tabindex=\"-1\"> 19.5 浮动特性</h3>\n<h4 id=\"_19-5-1-浮动元素会脱离标准流-脱标-且不再保留原先的位置\" tabindex=\"-1\"> 19.5.1 浮动元素会脱离标准流（脱标），且不再保留原先的位置</h4>\n<p>设置了浮动（<code>float</code>）的元素会脱离标准流的控制（浮），移动到指定位置（动）。即：俗称脱标。</p>\n<p>浮动的盒子不再保留原先的位置。</p>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_2_css/16.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_19-5-2-浮动的元素会一行内显示并且元素顶部对齐\" tabindex=\"-1\"> 19.5.2 浮动的元素会一行内显示并且元素顶部对齐</h4>\n<p>如果多个盒子都设置了浮动，则它们会按照属性值在一行内显示，并且顶端对齐排列。</p>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_2_css/17.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>注意：</strong> 浮动的元素是互相贴靠在一起的（不会有缝隙）。如果父级宽度装不下这些浮动的盒子，多出的盒子会另起一行对齐。</p>\n<h4 id=\"_19-5-3-浮动的元素会具有行内块元素的特性\" tabindex=\"-1\"> 19.5.3 浮动的元素会具有行内块元素的特性</h4>\n<p>任何元素都可以浮动。不管原先是什么模式的元素，添加浮动之后具有行内块元素相似的特性，即：</p>\n<ol>\n<li>\n<p>如果块级盒子没有设置宽度，默认宽度和父级一样宽，但是添加浮动后，它的大小根据内容来决定；</p>\n</li>\n<li>\n<p>浮动的盒子中间是没有缝隙的，是紧挨着一起的；</p>\n</li>\n<li>\n<p>行内元素同理。</p>\n</li>\n</ol>\n<h3 id=\"_19-6-浮动布局注意点\" tabindex=\"-1\"> 19.6 浮动布局注意点</h3>\n<h4 id=\"_19-6-1-浮动元素经常和标准流的父盒子搭配使用\" tabindex=\"-1\"> 19.6.1 浮动元素经常和标准流的父盒子搭配使用</h4>\n<p>为了约束浮动元素位置, 我们网页布局一般采取的策略是：</p>\n<div><pre><code>先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置。\n</code></pre></div><blockquote>\n<p>该策略符合 。</p>\n</blockquote>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_2_css/18.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_19-6-2-网页布局第二准则-先设置盒子的大小-之后设置盒子的位置\" tabindex=\"-1\"> 19.6.2 网页布局第二准则：先设置盒子的大小，之后设置盒子的位置</h4>\n<h4 id=\"_19-6-3-一个元素浮动了-理论上其余的兄弟元素也要浮动\" tabindex=\"-1\"> 19.6.3 一个元素浮动了，理论上其余的兄弟元素也要浮动</h4>\n<p>一个盒子里面有多个子盒子，如果其中一个盒子浮动了，那么其他兄弟也应该浮动，以防止引起问题。</p>\n<h4 id=\"_19-6-4-浮动的盒子只会影响浮动盒子后面的标准流-不会影响前面的标准流\" tabindex=\"-1\"> 19.6.4 浮动的盒子只会影响浮动盒子后面的标准流，不会影响前面的标准流</h4>\n<h2 id=\"_20-常见网页布局\" tabindex=\"-1\"> 20. 常见网页布局</h2>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_2_css/19.png\" alt=\"\" loading=\"lazy\"></p>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_2_css/20.png\" alt=\"\" loading=\"lazy\"></p>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_2_css/21.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_21-清除浮动\" tabindex=\"-1\"> 21. 清除浮动</h2>\n<h3 id=\"_21-1-思考-浮动元素的标准流父盒子必须有高度吗\" tabindex=\"-1\"> 21.1 思考：浮动元素的标准流父盒子必须有高度吗？</h3>\n<p>我们前面浮动元素有一个标准流的父元素，他们有一个共同的特点：都是有高度的。</p>\n<p>但是，所有的父盒子都必须有高度吗？</p>\n<p>理想中的状态：让子盒子撑开父亲。即：有多少孩子，父盒子就有多高。</p>\n<p>但是不给父盒子高度会有问题吗？</p>\n<h3 id=\"_21-2-为什么需要清除浮动\" tabindex=\"-1\"> 21.2 为什么需要清除浮动？</h3>\n<p>由于父级盒子很多情况下，不方便给高度，但是子盒子浮动又不占有位置，最后父级盒子高度为 <code>0</code> 时，就会影响下面的标准流盒子。</p>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_2_css/22.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>由于浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响。</p>\n</blockquote>\n<h3 id=\"_21-3-清除浮动的本质-清除浮动元素脱离标准流造成的影响\" tabindex=\"-1\"> 21.3 清除浮动的本质：清除浮动元素脱离标准流造成的影响</h3>\n<p>清除浮动的本质是清除浮动元素造成的影响。</p>\n<p>清除浮动之后，父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了。</p>\n<p><strong>注意：</strong> 如果父盒子本身有高度，则不需要清除浮动。</p>\n<h3 id=\"_21-4-清除浮动的策略-闭合浮动\" tabindex=\"-1\"> 21.4 清除浮动的策略：闭合浮动</h3>\n<p>清除浮动策略是闭合浮动。即：只让浮动在父盒子内部影响，不影响父盒子外面的其他盒子。</p>\n<h3 id=\"_21-4-清除浮动的语法属性-clear\" tabindex=\"-1\"> 21.4 清除浮动的语法属性：<code>clear</code></h3>\n<p><strong>语法：</strong></p>\n<div><pre><code>选择器 { clear: 属性值; }\n</code></pre></div><table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>属性值</strong></th>\n<th style=\"text-align:left\"><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>left</code></td>\n<td style=\"text-align:left\">不允许左侧有浮动元素（清除左侧浮动的影响）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>right</code></td>\n<td style=\"text-align:left\">不允许右侧有浮动元素（清除右侧浮动的影响）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>both</code></td>\n<td style=\"text-align:left\">同时清除左右两侧浮动的影响</td>\n</tr>\n</tbody>\n</table>\n<p>我们实际工作中，几乎只用 <code>clear: both;</code></p>\n<h3 id=\"_21-5-清除浮动的方法\" tabindex=\"-1\"> 21.5 清除浮动的方法</h3>\n<h4 id=\"_21-5-1-额外标签法\" tabindex=\"-1\"> 21.5.1 额外标签法</h4>\n<p>额外标签法也称为隔墙法，是 <code>W3C</code> 推荐的做法。</p>\n<blockquote>\n<p>实际工作中可能会遇到，但是不常用。</p>\n</blockquote>\n<p>额外标签法就是在最后一个浮动的子元素后面添加一个额外的空标签，在空标签中添加清除浮动样式。</p>\n<p>例如 <code>&lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;</code>，或者其他标签（如 <code>&lt;br/&gt;</code> 等）。</p>\n<p><strong>优点：</strong> 通俗易懂，书写方便。</p>\n<p><strong>缺点：</strong> 添加许多无意义的标签，结构化较差。</p>\n<p><strong>注意：</strong> <strong>要求这个新的空标签必须是块级元素</strong>。</p>\n<h4 id=\"_21-5-2-父级添加-overflow-属性\" tabindex=\"-1\"> 21.5.2 父级添加 <code>overflow</code> 属性</h4>\n<p>可以给父级添加 <code>overflow</code> 属性，将其属性值设置为 <code>hidden</code>、<code>auto</code> 或 <code>scroll</code>。</p>\n<blockquote>\n<p>注意是给父元素添加 <code>overflow</code> 属性。</p>\n</blockquote>\n<p><strong>优点：</strong> 代码简洁。</p>\n<p><strong>缺点：</strong> 无法显示溢出的部分。</p>\n<h4 id=\"_21-5-3-父级添加-after-伪元素\" tabindex=\"-1\"> 21.5.3 父级添加 <code>:after</code> 伪元素</h4>\n<p><code>:after</code> 方式是额外标签法的升级版。<strong>也是给父元素添加</strong>。</p>\n<div><pre><code><span>.clearfix:after</span> <span>{</span> \n    <span>content</span><span>:</span> <span>\"\"</span><span>;</span> \n    <span>display</span><span>:</span> block<span>;</span> \n    <span>height</span><span>:</span> 0<span>;</span> \n    <span>clear</span><span>:</span> both<span>;</span> \n    <span>visibility</span><span>:</span> hidden<span>;</span> \n<span>}</span> \n\n<span>.clearfix</span> <span>{</span> <span>/* IE6、7 专有 */</span> \n    *<span>zoom</span><span>:</span> 1<span>;</span>\n<span>}</span>\n</code></pre></div><p><strong>优点：</strong> 没有增加标签，结构更简单。</p>\n<p><strong>缺点：</strong> 照顾低版本浏览器。</p>\n<p>代表网站：百度、淘宝网、网易等。</p>\n<h4 id=\"_21-5-4-父级添加-before、-after-双伪元素\" tabindex=\"-1\"> 21.5.4 父级添加 <code>:before</code>、<code>:after</code> 双伪元素</h4>\n<p><strong>也是给给父元素添加</strong>。</p>\n<div><pre><code><span>.clearfix:before,.clearfix:after</span> <span>{</span>\n    <span>content</span><span>:</span><span>\"\"</span><span>;</span>\n    <span>display</span><span>:</span>table<span>;</span> \n<span>}</span>\n\n<span>.clearfix:after</span> <span>{</span>\n    <span>clear</span><span>:</span>both<span>;</span> \n<span>}</span>\n\n<span>.clearfix</span> <span>{</span>\n    *<span>zoom</span><span>:</span>1<span>;</span>\n<span>}</span>\n</code></pre></div><p><strong>优点：</strong> 代码更简洁、</p>\n<p><strong>缺点：</strong> 照顾低版本浏览器。</p>\n<p>代表网站：小米、腾讯等。</p>\n<h3 id=\"_21-6-清除浮动总结\" tabindex=\"-1\"> 21.6 清除浮动总结</h3>\n<p><strong>为什么需要清除浮动？</strong></p>\n<p>由于父级没高度，当子盒子浮动后，就会影响下面的布局，因此需要清除浮动。</p>\n<p><strong>清除浮动的方式如下：</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>方式</strong></th>\n<th style=\"text-align:left\"><strong>优点</strong></th>\n<th style=\"text-align:left\"><strong>缺点</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">额外标签法（隔墙法）</td>\n<td style=\"text-align:left\">通俗易懂，书写方便</td>\n<td style=\"text-align:left\">添加许多无意义的标签，结构化较差。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">父级 <code>overflow:hidden;</code></td>\n<td style=\"text-align:left\">书写简单</td>\n<td style=\"text-align:left\">溢出隐藏</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">父级 <code>:after</code> 伪元素</td>\n<td style=\"text-align:left\">结构语义化正确</td>\n<td style=\"text-align:left\">由于 <code>IE6</code>、<code>IE7</code> 不支持 <code>:after</code>，因此存在兼容性问题</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">父级双伪元素</td>\n<td style=\"text-align:left\">结构语义化正确</td>\n<td style=\"text-align:left\">由于 <code>IE6</code>、<code>IE7</code> 不支持 <code>:after</code>，因此存在兼容性问题</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"_22-ps-切图\" tabindex=\"-1\"> 22. <code>PS</code> 切图</h2>\n<h3 id=\"_22-1-常见的图片格式-jpg、gif、png、psd\" tabindex=\"-1\"> 22.1 常见的图片格式：<code>jpg</code>、<code>gif</code>、<code>png</code>、<code>psd</code></h3>\n<ol>\n<li>\n<p><code>jpg</code> 图像格式</p>\n<div><pre><code>JPEG（.JPG）对色彩的信息保留较好，高清，颜色较多，我们产品类的图片经常用 jpg 格式的。\n</code></pre></div></li>\n<li>\n<p><code>gif</code> 图像格式</p>\n<div><pre><code>GIF 格式最多只能储存 256 色，所以通常用来显示简单图形及字体，但是可以保存透明背景和动画效果。\n实际经常用于一些图片小动画效果。\n</code></pre></div></li>\n<li>\n<p><code>png</code> 图像格式</p>\n<div><pre><code>PNG 格式是一种新兴的网络图形格式，结合了 GIF 和 JPEG 的优点，具有存储形式丰富的特点，能够保持透明背景。\n如果想要切成背景透明的图片，请选择 png 格式。\n</code></pre></div></li>\n<li>\n<p><code>psd</code> 图像格式</p>\n<div><pre><code>PSD 格式是 Photoshop 的专用格式，里面可以存放图层、通道、遮罩等多种设计稿。\n对前端人员来说，最大的优点是：我们可以直接从上面复制文字、获得图片、还可以测量大小和距离。\n</code></pre></div></li>\n</ol>\n<h3 id=\"_22-2-ps-的切图方式\" tabindex=\"-1\"> 22.2 <code>PS</code> 的切图方式</h3>\n<p><code>PS</code> 有很多的切图方式：图层切图、切片切图、<code>PS</code> 插件切图等。</p>\n<h4 id=\"_22-2-1-图层切图\" tabindex=\"-1\"> 22.2.1 图层切图</h4>\n<p>最简单的切图方式：右击图层 -&gt; 快速导出为 <code>PNG</code>。</p>\n<p>但是很多情况下，我们需要合并图层再导出：</p>\n<ol>\n<li>\n<p>选中需要的图层：图层菜单 -&gt; 合并图层（<code>Ctrl+E</code>）</p>\n</li>\n<li>\n<p>右击 -&gt; 快速导出为 <code>PNG</code></p>\n</li>\n</ol>\n<h4 id=\"_22-2-2-切片切图\" tabindex=\"-1\"> 22.2.2 切片切图</h4>\n<ol>\n<li>\n<p>利用切片选中图片。</p>\n<div><pre><code>利用切片工具手动划出\n</code></pre></div></li>\n<li>\n<p>导出选中的图片</p>\n<div><pre><code>文件菜单 -> 导出 -> 存储为 web 设备所用格式 -> 选择我们要的图片格式 -> 存储\n</code></pre></div></li>\n</ol>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_2_css/23.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_22-2-3-ps-插件切图\" tabindex=\"-1\"> 22.2.3 <code>PS</code> 插件切图</h4>\n<p><code>Cutterman</code> 是一款运行在 <code>Photoshop</code> 中的插件，能够自动将你需要的图层进行输出，以替代传统的手工 “导出 <code>web</code> 所用格式” 以及使用切片工具进行挨个切图的繁琐流程。</p>\n<p>官网：<a href=\"http://www.cutterman.cn/zh/cutterman\" target=\"_blank\" rel=\"noopener noreferrer\">http://www.cutterman.cn/zh/cutterman<ExternalLinkIcon/></a></p>\n<p><strong>注意：</strong> <code>Cutterman</code> 插件要求你的 <code>PS</code> 必须是完整版，不能是绿色版，所以大家需要安装完整版本。</p>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_2_css/24.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_23-学成在线案例\" tabindex=\"-1\"> 23. 学成在线案例</h2>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_2_css/25.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_23-1-准备素材和工具\" tabindex=\"-1\"> 23.1 准备素材和工具</h3>\n<ol>\n<li>\n<p>学成在线 <code>PSD</code> 源文件。</p>\n</li>\n<li>\n<p>开发工具 = <code>PS</code>（切图）/ <code>cutterman</code> 插件 + <code>vscode</code>（代码）+ <code>chrome</code>（测试）</p>\n</li>\n</ol>\n<h3 id=\"_23-2-案例准备工作\" tabindex=\"-1\"> 23.2 案例准备工作</h3>\n<p>采取结构与样式相分离思想：</p>\n<ol>\n<li>\n<p>创建 <code>study</code> 目录文件夹（用于存放我们这个页面的相关内容）；</p>\n</li>\n<li>\n<p>用 <code>vscode</code> 打开 <code>study</code> 目录文件夹；</p>\n</li>\n<li>\n<p><code>study</code> 目录内新建 <code>images</code> 文件夹，用于保存图片；</p>\n</li>\n<li>\n<p>新建首页文件 <code>index.html</code>（以后我们的网站首页统一规定为 <code>index.html</code>）；</p>\n</li>\n<li>\n<p>新建 <code>style.css</code> 样式文件（采用外链样式表）；</p>\n</li>\n<li>\n<p>将样式引入到我们的 <code>HTML</code> 页面文件中；</p>\n</li>\n<li>\n<p>样式表写入清除内外边距的样式，来检测样式表是否引入成功。</p>\n</li>\n</ol>\n<h3 id=\"_23-3-css-属性书写顺序\" tabindex=\"-1\"> 23.3 <code>CSS</code> 属性书写顺序</h3>\n<p>建议遵循以下顺序：</p>\n<ol>\n<li>\n<p>布局定位属性：<code>display</code> / <code>position</code> / <code>float</code> / <code>clear</code> / <code>visibility</code> / <code>overflow</code>（建议 <code>display</code> 第一个写，毕竟关系到模式）</p>\n</li>\n<li>\n<p>自身属性：<code>width</code> / <code>height</code> / <code>margin</code> / <code>padding</code> / <code>border</code> / <code>background</code></p>\n</li>\n<li>\n<p>文本属性：<code>color</code> / <code>font</code> / <code>text-decoration</code> / <code>text-align</code> / <code>vertical-align</code> / <code>white- space</code> / <code>break-word</code></p>\n</li>\n<li>\n<p>其他属性（<code>CSS3</code>）：<code>content</code> / <code>cursor</code> / <code>border-radius</code> / <code>box-shadow</code> / <code>text-shadow</code> / <code>background:linear-gradient</code> ...</p>\n</li>\n</ol>\n<div><pre><code><span>.jdc</span> <span>{</span>\n    <span>display</span><span>:</span> block<span>;</span>\n    <span>position</span><span>:</span> relative<span>;</span>\n    <span>float</span><span>:</span> left<span>;</span>\n    <span>width</span><span>:</span> 100px<span>;</span>\n    <span>height</span><span>:</span> 100px<span>;</span>\n    <span>margin</span><span>:</span> 0 10px<span>;</span>\n    <span>padding</span><span>:</span> 20px 0<span>;</span>\n    <span>font-family</span><span>:</span> Arial<span>,</span> <span>'Helvetica Neue'</span><span>,</span> Helvetica<span>,</span> sans-serif<span>;</span>\n    <span>color</span><span>:</span> #333<span>;</span>\n    <span>background</span><span>:</span> <span>rgba</span><span>(</span>0<span>,</span>0<span>,</span>0<span>,</span>.5<span>)</span><span>;</span>\n    <span>border-radius</span><span>:</span> 10px<span>;</span>\n<span>}</span>\n</code></pre></div><h3 id=\"_23-4-页面布局整体思路\" tabindex=\"-1\"> 23.4 页面布局整体思路</h3>\n<p>为了提高网页制作的效率，布局时通常有以下的布局流程：</p>\n<ol>\n<li>\n<p>必须确定页面的版心（可视区），我们测量可得知。</p>\n</li>\n<li>\n<p>分析页面中的行模块，以及每个行模块中的列模块。即：网页布局第一准则。</p>\n</li>\n<li>\n<p>一行中的列模块经常浮动布局，先确定每个列的大小，之后确定列的位置。即：网页布局第二准则。</p>\n</li>\n<li>\n<p>制作 <code>HTML</code> 结构。我们还是遵循：先有结构，后有样式的原则。结构永远最重要。</p>\n</li>\n<li>\n<p>所以，先理清楚布局结构，再写代码尤为重要。这需要我们多写多积累。</p>\n</li>\n</ol>\n<h2 id=\"_24-定位\" tabindex=\"-1\"> 24. 定位</h2>\n<h3 id=\"_24-1-为什么需要定位\" tabindex=\"-1\"> 24.1 为什么需要定位？</h3>\n<p>思考：以下情况使用标准流或者浮动能实现吗？</p>\n<ol>\n<li>\n<p>某个元素可以自由的在一个盒子内移动位置，并且压住其他盒子。</p>\n</li>\n<li>\n<p>当我们滚动窗口的时候，盒子是固定在屏幕某个位置的。</p>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_2_css/26.png\" alt=\"\" loading=\"lazy\"></p>\n</li>\n</ol>\n<p>以上效果，标准流或浮动都无法快速实现，此时需要定位来实现。由此可知：</p>\n<ol>\n<li>\n<p>浮动可以让多个块级盒子一行没有缝隙排列显示，经常用于横向排列盒子。</p>\n</li>\n<li>\n<p>定位则是可以让盒子自由的在某个盒子内移动位置或者固定屏幕中某个位置，并且可以压住其他盒子。</p>\n</li>\n</ol>\n<h3 id=\"_24-2-定位的组成-定位模式-边偏移\" tabindex=\"-1\"> 24.2 定位的组成：定位模式 + 边偏移</h3>\n<p>定位：将盒子定在某一个位置，所以定位也是在摆放盒子，按照定位的方式移动盒子。</p>\n<p>定位 = 定位模式 + 边偏移。</p>\n<p><strong>定位模式</strong> 用于指定一个元素在文档中的定位方式。</p>\n<p><strong>边偏移</strong> 则决定了该元素的最终位置。</p>\n<h4 id=\"_24-2-1-定位模式-position\" tabindex=\"-1\"> 24.2.1 定位模式：<code>position</code></h4>\n<p>定位模式决定元素的定位方式，它通过 <code>CSS</code> 的 <code>position</code> 属性来设置，其值可以分为四个：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>值</strong></th>\n<th style=\"text-align:left\"><strong>语义</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>static</code></td>\n<td style=\"text-align:left\">静态定位</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>relative</code></td>\n<td style=\"text-align:left\">相对定位</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>absolute</code></td>\n<td style=\"text-align:left\">绝对定位</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>fixed</code></td>\n<td style=\"text-align:left\">固定定位</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"_24-2-2-边偏移-top、bottom、left、right\" tabindex=\"-1\"> 24.2.2 边偏移：<code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code></h4>\n<p>边偏移就是定位的盒子移动到最终位置。有 <code>top</code>、<code>bottom</code>、<code>left</code> 和 <code>right</code> 这 <code>4</code> 个属性。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>边偏移</strong></th>\n<th style=\"text-align:left\"><strong>示例</strong></th>\n<th style=\"text-align:left\"><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>top</code></td>\n<td style=\"text-align:left\"><code>top: 80px</code></td>\n<td style=\"text-align:left\">顶端偏移量，定义元素相对于其父元素上边线的距离。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>bottom</code></td>\n<td style=\"text-align:left\"><code>bottom: 80px</code></td>\n<td style=\"text-align:left\">底部偏移量，定义元素相对于其父元素下边线的距离。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>left</code></td>\n<td style=\"text-align:left\"><code>left: 80px</code></td>\n<td style=\"text-align:left\">左部偏移量，定义元素相对于其父元素左边线的距离。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>right</code></td>\n<td style=\"text-align:left\"><code>right: 80px</code></td>\n<td style=\"text-align:left\">右部偏移量，定义元素相对于其父元素右边线的距离。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_24-3-静态定位-position-static\" tabindex=\"-1\"> 24.3 静态定位：<code>position: static;</code></h3>\n<p>静态定位是元素的默认定位方式，表示无定位的意思。</p>\n<p><strong>语法：</strong></p>\n<div><pre><code>选择器 { position: static; }\n</code></pre></div><p><strong>静态定位的特点：</strong></p>\n<ol>\n<li>静态定位按照标准流特性摆放位置，它没有边偏移。</li>\n</ol>\n<blockquote>\n<p>静态定位在布局时很少用到。</p>\n</blockquote>\n<h3 id=\"_24-4-相对定位-position-relative\" tabindex=\"-1\"> 24.4 相对定位：<code>position: relative;</code></h3>\n<p>相对定位是元素在移动位置的时候，是 <strong>相对于它原来的位置</strong> 来说的（自恋型）。</p>\n<p><strong>语法：</strong></p>\n<div><pre><code>选择器 { position: relative; }\n</code></pre></div><p><strong>相对定位的特点：</strong></p>\n<ol>\n<li>\n<p>它是相对于自己原来的位置来移动的（移动位置的时候参照点是自己原来的位置）；</p>\n</li>\n<li>\n<p>原来在标准流的位置继续占有，后面的盒子仍然以标准流的方式对待它。</p>\n</li>\n</ol>\n<p>因此，<strong>相对定位并没有脱标</strong>。它最典型的应用是给绝对定位当爹的。</p>\n<h3 id=\"_24-5-绝对定位-position-absolute\" tabindex=\"-1\"> 24.5 绝对定位：<code>position: absolute;</code></h3>\n<p>绝对定位是元素在移动位置的时候，是相对于它祖先元素来说的（拼爹型）。</p>\n<p><strong>语法：</strong></p>\n<div><pre><code>选择器 { position: absolute; }\n</code></pre></div><p><strong>绝对定位的特点：</strong></p>\n<ol>\n<li>\n<p>如果没有祖先元素或者祖先元素没有定位，则以浏览器为准定位（<code>Document</code> 文档）；</p>\n</li>\n<li>\n<p><strong>如果祖先元素有定位（相对、绝对、固定定位），则以最近一级的有定位祖先元素为参考点移动位置</strong>；</p>\n</li>\n<li>\n<p>绝对定位不再占有原先的位置。（脱标）</p>\n</li>\n</ol>\n<p>因此，<strong>绝对定位是脱离标准流的</strong>。</p>\n<h3 id=\"_24-6-子绝父相的由来\" tabindex=\"-1\"> 24.6 子绝父相的由来</h3>\n<p><strong>思考：</strong></p>\n<ol>\n<li>\n<p>绝对定位和相对定位到底有什么使用场景呢？</p>\n</li>\n<li>\n<p>为什么说相对定位给绝对定位当爹的呢？</p>\n</li>\n</ol>\n<p>弄清楚 <strong>子绝父相</strong> 这个口诀，就明白了绝对定位和相对定位的使用场景。</p>\n<p>子绝父相是我们学习定位的口诀，是定位中最常用的一种方式。这句话的意思是：子级是绝对定位的话，父级要用相对定位。</p>\n<p><strong>子绝父相的由来：</strong></p>\n<ol>\n<li>\n<p>子级绝对定位，不会占有位置，可以放到父盒子里面的任何一个地方，不会影响其他的兄弟盒子。</p>\n</li>\n<li>\n<p>父盒子需要加定位限制子盒子在父盒子内显示。</p>\n</li>\n<li>\n<p>父盒子布局时，需要占有位置，因此父亲只能是相对定位。</p>\n</li>\n</ol>\n<p><strong>总结：</strong></p>\n<p>因为父级需要占有位置，因此是相对定位；子盒子不需要占有位置，则是绝对定位。</p>\n<p>当然，子绝父相不是永远不变的，如果父元素不需要占有位置，子绝父绝也会遇到。</p>\n<h3 id=\"_24-7-固定定位-position-fixed\" tabindex=\"-1\"> 24.7 固定定位：<code>position: fixed;</code></h3>\n<p>固定定位是元素固定于浏览器可视区的位置。</p>\n<p>主要使用场景：可以在浏览器页面滚动时元素的位置不会改变。</p>\n<p><strong>语法：</strong></p>\n<div><pre><code>选择器 { position: fixed; }\n</code></pre></div><p><strong>固定定位的特点：</strong></p>\n<ol>\n<li>\n<p>以浏览器的可视窗口为参照点移动元素。</p>\n<blockquote>\n<p>跟父元素没有任何关系</p>\n<p>不随滚动条滚动</p>\n</blockquote>\n</li>\n<li>\n<p>固定定位不在占有原先的位置。</p>\n</li>\n</ol>\n<p><strong>固定定位也是脱标的</strong>。</p>\n<blockquote>\n<p>其实固定定位也可以看做是一种特殊的绝对定位。</p>\n</blockquote>\n<h4 id=\"_24-7-1-固定定位小技巧-固定在版心右侧位置\" tabindex=\"-1\"> 24.7.1 固定定位小技巧：固定在版心右侧位置</h4>\n<p>实现方式：</p>\n<ol>\n<li>\n<p>让固定定位的盒子 <code>left: 50%</code> 以走到浏览器可视区（也可以看做版心）的一半位置；</p>\n</li>\n<li>\n<p>让固定定位的盒子 <code>margin-left: 版心宽度的一半距离</code>，以多走版心宽度的一半位置。</p>\n</li>\n</ol>\n<p>于是，就可以让固定定位的盒子贴着版心右侧对齐了。</p>\n<h3 id=\"_24-8-粘性定位-position-sticky\" tabindex=\"-1\"> 24.8 粘性定位：<code>position: sticky;</code></h3>\n<p>粘性定位可以被认为是相对定位和固定定位的混合。</p>\n<p><strong>语法：</strong></p>\n<div><pre><code>选择器 { position: sticky; top: 10px; }\n</code></pre></div><p><strong>粘性定位的特点：</strong></p>\n<ol>\n<li>\n<p>以浏览器的可视窗口为参照点移动元素（固定定位特点）；</p>\n</li>\n<li>\n<p>粘性定位占有原先的位置（相对定位特点，即不脱标）；</p>\n</li>\n<li>\n<p>必须添加 <code>top</code>、<code>left</code>、<code>right</code>、<code>bottom</code> 其中一个才有效。</p>\n</li>\n</ol>\n<blockquote>\n<p>跟页面滚动搭配使用。兼容性较差，<code>IE</code> 不支持。</p>\n</blockquote>\n<h3 id=\"_24-9-定位总结\" tabindex=\"-1\"> 24.9 定位总结</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>定位模式</strong></th>\n<th style=\"text-align:left\"><strong>是否脱标</strong></th>\n<th style=\"text-align:left\"><strong>移动位置</strong></th>\n<th style=\"text-align:left\"><strong>是否常用</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>static</code> 静态定位</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">不能使用边偏移</td>\n<td style=\"text-align:left\">很少</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>relative</code> 相对定位</td>\n<td style=\"text-align:left\">否（占有位置）</td>\n<td style=\"text-align:left\">相对于自身位置移动</td>\n<td style=\"text-align:left\">常用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>absolute</code> 绝对定位</td>\n<td style=\"text-align:left\">是（不占有位置）</td>\n<td style=\"text-align:left\">带有定位的父级</td>\n<td style=\"text-align:left\">常用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>fixed</code> 固定定位</td>\n<td style=\"text-align:left\">是（不占有位置）</td>\n<td style=\"text-align:left\">浏览器可视区</td>\n<td style=\"text-align:left\">常用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>sticky</code> 粘性定位</td>\n<td style=\"text-align:left\">否（占有位置）</td>\n<td style=\"text-align:left\">浏览器可视区</td>\n<td style=\"text-align:left\">初学阶段少</td>\n</tr>\n</tbody>\n</table>\n<p>注意：</p>\n<ol>\n<li>\n<p>一定记住相对定位、固定定位、绝对定位它们的两大特点：</p>\n<div><pre><code>1. 是否占有位置（脱标否）； \n2. 以谁为基准点移动位置。\n</code></pre></div></li>\n<li>\n<p>学习定位重点学会子绝父相。</p>\n</li>\n</ol>\n<h3 id=\"_24-10-定位叠放次序-z-index\" tabindex=\"-1\"> 24.10 定位叠放次序：<code>z-index</code></h3>\n<p>在使用定位布局时，可能会出现盒子重叠的情况。此时，可以使用 <code>z-index</code> 来控制盒子的前后次序（<code>z</code> 轴）。</p>\n<p><strong>语法：</strong></p>\n<div><pre><code>选择器 { z-index: 1; }\n</code></pre></div><p><strong>注意：</strong></p>\n<ol>\n<li>\n<p>数值可以是正整数、负整数或 <code>0</code>，默认是 <code>auto</code>，数值越大，盒子越靠上；</p>\n</li>\n<li>\n<p>如果属性值相同，则按照书写顺序，后来居上；</p>\n</li>\n<li>\n<p>数字后面不能加单位；</p>\n</li>\n<li>\n<p>只有定位的盒子才有 <code>z-index</code> 属性；</p>\n</li>\n</ol>\n<h3 id=\"_24-11-定位的拓展\" tabindex=\"-1\"> 24.11 定位的拓展</h3>\n<h4 id=\"_24-11-1-绝对定位的盒子居中\" tabindex=\"-1\"> 24.11.1 绝对定位的盒子居中</h4>\n<p>加了绝对定位的盒子不能通过 <code>margin: 0 auto;</code> 水平居中，但是可以通过以下计算方法实现水平和垂直居中：</p>\n<ol>\n<li>\n<p><code>left: 50%;</code>：让盒子的左侧移动到父级元素的水平中心位置；</p>\n</li>\n<li>\n<p><code>margin-left: -100px;</code>：让盒子向左移动自身宽度的一半。</p>\n</li>\n</ol>\n<h4 id=\"_24-11-2-定位的特殊特性\" tabindex=\"-1\"> 24.11.2 定位的特殊特性</h4>\n<p>绝对定位和固定定位也和浮动类似：</p>\n<ol>\n<li>\n<p>行内元素添加绝对或者固定定位，可以直接设置高度和宽度；</p>\n</li>\n<li>\n<p>块级元素添加绝对或者固定定位，如果不给宽度或者高度，默认大小是内容的大小。</p>\n</li>\n</ol>\n<h4 id=\"_24-11-3-脱标的盒子不会触发外边距塌陷\" tabindex=\"-1\"> 24.11.3 脱标的盒子不会触发外边距塌陷</h4>\n<p>浮动元素、绝对定位（固定定位）元素的都不会触发外边距合并的问题。</p>\n<h4 id=\"_24-11-4-绝对定位-固定定位-会完全压住盒子\" tabindex=\"-1\"> 24.11.4 绝对定位（固定定位）会完全压住盒子</h4>\n<p>浮动元素不同，只会压住它下面标准流的盒子，但是不会压住下面标准流盒子里面的文字（图片）。</p>\n<p>但是绝对定位（固定定位）会压住下面标准流所有的内容。</p>\n<p>浮动之所以不会压住文字，因为浮动产生的目的最初是为了做文字环绕效果的（文字会围绕浮动元素）。</p>\n<h2 id=\"_25-网页布局总结\" tabindex=\"-1\"> 25. 网页布局总结</h2>\n<p>通过盒子模型，清楚知道大部分 <code>html</code> 标签是一个盒子。</p>\n<p>通过 <code>CSS</code> 浮动、定位 可以让每个盒子排列成为网页。</p>\n<p>一个完整的网页，是标准流、浮动、定位一起完成布局的，每个都有自己的专门用法。</p>\n<p><strong>标准流：</strong> 可以让盒子上下排列或者左右排列，垂直的块级盒子显示就用标准流布局。</p>\n<p><strong>浮动：</strong> 可以让多个块级元素一行显示或者左右对齐盒子，多个块级盒子水平显示就用浮动布局。</p>\n<p><strong>定位：</strong> 定位最大的特点是有层叠的概念，就是可以让多个盒子前后叠压来显示。如果元素自由在某个盒子内移动就用定位布局。</p>\n<h2 id=\"_26-元素的显示与隐藏\" tabindex=\"-1\"> 26. 元素的显示与隐藏</h2>\n<p>类似网站广告，当我们点击关闭就不见了，但是我们重新刷新页面，会重新出现！</p>\n<p>本质：让一个元素在页面中隐藏或者显示出来。</p>\n<h3 id=\"_26-1-display-显示隐藏\" tabindex=\"-1\"> 26.1 <code>display</code> 显示隐藏</h3>\n<p><code>display</code> 属性用于设置一个元素应如何显示。</p>\n<ol>\n<li>\n<p><code>display: none;</code> 隐藏对象。</p>\n</li>\n<li>\n<p><code>display: block;</code> 除了转换为块级元素之外，同时还有显示元素的意思。</p>\n</li>\n</ol>\n<p><strong>注意：</strong> <code>display</code> 隐藏元素后，不再占有原来的位置。</p>\n<blockquote>\n<p>后面应用及其广泛，搭配 <code>JS</code> 可以做很多的网页特效。</p>\n</blockquote>\n<h3 id=\"_26-2-visibility-显示隐藏\" tabindex=\"-1\"> 26.2 <code>visibility</code> 显示隐藏</h3>\n<p><code>visibility</code> 属性用于指定一个元素应可见还是隐藏。</p>\n<ol>\n<li>\n<p><code>visibility: visible;</code> 元素可视。</p>\n</li>\n<li>\n<p><code>visibility: hidden;</code> 元素隐藏。</p>\n</li>\n</ol>\n<p><strong>注意：</strong> <code>visibility</code> 隐藏元素后，继续占有原来的位置。</p>\n<blockquote>\n<p>如果隐藏元素想要原来位置，就用 <code>visibility: hidden</code></p>\n<p>如果隐藏元素不想要原来位置，就用 <code>display: none</code></p>\n</blockquote>\n<h3 id=\"_26-3-overflow-溢出显示隐藏\" tabindex=\"-1\"> 26.3 <code>overflow</code> 溢出显示隐藏</h3>\n<p><code>overflow</code> 属性指定了如果内容溢出一个元素的框（超过其指定高度及宽度）时，会发生什么。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>属性值</strong></th>\n<th style=\"text-align:left\"><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>visible</code></td>\n<td style=\"text-align:left\">不剪切内容，也不添加滚动条</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>hidden</code></td>\n<td style=\"text-align:left\">不显示超过对象尺寸的内容，超出的部分隐藏掉</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>scroll</code></td>\n<td style=\"text-align:left\">不管超出内容否，总是显示滚动条</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>auto</code></td>\n<td style=\"text-align:left\">超出自动显示滚动条，不超出时不显示滚动条</td>\n</tr>\n</tbody>\n</table>\n<p>一般情况下，我们都不想让溢出的内容显示出来，因为溢出的部分会影响布局。</p>\n<p>但是如果有定位的盒子，请慎用 <code>overflow:hidden</code> 因为它会隐藏多余的部分。</p>\n<h3 id=\"_26-4-总结\" tabindex=\"-1\"> 26.4 总结</h3>\n<p><code>display</code> 显示隐藏元素，但是不保留位置。</p>\n<p><code>visibility</code> 显示隐藏元素，但是保留原来的位置。</p>\n<p><code>overflow</code> 溢出显示隐藏，但是只是对于溢出的部分处理。</p>\n<h2 id=\"_27-精灵图-sprites\" tabindex=\"-1\"> 27. 精灵图（<code>sprites</code>）</h2>\n<h3 id=\"_27-1-为什么需要精灵图\" tabindex=\"-1\"> 27.1 为什么需要精灵图</h3>\n<p>一个网页中往往会应用很多小的背景图像作为修饰，当网页中的图像过多时，服务器就会频繁地接收和发送请求图片，造成服务器请求压力过大，这将大大降低页面的加载速度。</p>\n<p>因此，为了有效地减少服务器接收和发送请求的次数，提高页面的加载速度，出现了 <code>CSS</code> 精灵技术。</p>\n<blockquote>\n<p>也称 <code>CSS Sprites</code>、<code>CSS</code> 雪碧。</p>\n</blockquote>\n<p><strong>核心原理：</strong> 将网页中的一些小背景图像整合到一张大图中 ，这样服务器只需要一次请求就可以了。</p>\n<h3 id=\"_27-2-精灵图的使用\" tabindex=\"-1\"> 27.2 精灵图的使用</h3>\n<p><strong>使用精灵图核心：</strong></p>\n<ol>\n<li>\n<p>精灵图主要针对于小的背景图片使用。就是把多个小背景图片整合到一张大图片中；</p>\n</li>\n<li>\n<p>这个大图片也称为 <code>sprites</code> 精灵图或者雪碧图；</p>\n</li>\n<li>\n<p>主要借助于移动背景图片位置来实现，此时可以使用 <code>background-position</code>；</p>\n</li>\n<li>\n<p>移动的距离就是这个目标图片的 <code>x</code> 和 <code>y</code> 坐标。因为一般情况下都是往上往左移动，所以数值是负值。</p>\n<blockquote>\n<p>注意网页中的坐标：<code>x</code> 轴右边走是正值，左边走是负值，<code>y</code> 轴同理。</p>\n</blockquote>\n</li>\n<li>\n<p>使用精灵图的时候需要精确测量，每个小背景图片的大小和位置。</p>\n</li>\n</ol>\n<h2 id=\"_28-字体图标\" tabindex=\"-1\"> 28. 字体图标</h2>\n<h3 id=\"_28-1-字体图标的使用场景\" tabindex=\"-1\"> 28.1 字体图标的使用场景</h3>\n<p>主要用于显示网页中通用、常用的一些小图标。</p>\n<h3 id=\"_28-2-精灵图的缺点-字体图标的优点-二者的使用区分\" tabindex=\"-1\"> 28.2 精灵图的缺点 &amp; 字体图标的优点 &amp; 二者的使用区分</h3>\n<p><strong>精灵图的缺点：</strong></p>\n<ol>\n<li>\n<p>图片文件还是比较大的；</p>\n</li>\n<li>\n<p>图片本身放大和缩小会失真；</p>\n</li>\n<li>\n<p>一旦图片制作完毕想要更换非常复杂。</p>\n</li>\n</ol>\n<p>此时，有一种技术的出现很好的解决了以上问题，就是 <strong>字体图标 <code>iconfont</code></strong>。</p>\n<p>字体图标可以为前端工程师提供一种方便高效的图标使用方式，<strong>展示的是图标，本质属于字体</strong>。</p>\n<p><strong>字体图标的优点：</strong></p>\n<ol>\n<li>\n<p>轻量级：一个图标字体要比一系列的图像要小。一旦字体加载了，图标就会马上渲染出来，减少了服务器请求。</p>\n</li>\n<li>\n<p>灵活性：本质其实是文字，可以很随意的改变颜色、产生阴影、透明效果、旋转等。</p>\n</li>\n<li>\n<p>兼容性：几乎支持所有的浏览器，请放心使用。</p>\n</li>\n</ol>\n<blockquote>\n<p>注意： 字体图标不能替代精灵技术，只是对工作中图标部分技术的提升和优化。</p>\n</blockquote>\n<p><strong>二者的使用区分：</strong></p>\n<ol>\n<li>\n<p>如果遇到一些结构和样式比较简单的小图标，就用字体图标。</p>\n</li>\n<li>\n<p>如果遇到一些结构和样式复杂一点的小图片，就用精灵图。</p>\n</li>\n</ol>\n<h3 id=\"_28-3-字体文件格式\" tabindex=\"-1\"> 28.3 字体文件格式</h3>\n<p>不同浏览器所支持的字体格式是不一样的，字体图标之所以兼容，就是因为包含了主流浏览器支持的字体文件：</p>\n<ol>\n<li>\n<p><code>TureType(.ttf)</code> 格式</p>\n<div><pre><code>ttf 字体是 Windows 和 Mac 的最常见的字体，支持这种字体的浏览器有：\nIE9+、Firefox3.5+、Chrome4+、Safari3+、Opera10+、iOS Mobile、Safari4.2+\n</code></pre></div></li>\n<li>\n<p><code>Web Open Font Format(.woff)</code> 格式</p>\n<div><pre><code>woff 字体，支持这种字体的浏览器有：\nIE9+、Firefox3.5+、Chrome6+、Safari3.6+、Opera11.1+\n</code></pre></div></li>\n<li>\n<p><code>Embedded Open Type(.eot)</code> 格式</p>\n<div><pre><code>eot 字体是 IE 专用字体，支持这种字体的浏览器有：IE4+\n</code></pre></div></li>\n<li>\n<p><code>SVG(.svg)</code> 格式</p>\n<div><pre><code>svg 字体是基于 SVG 字体渲染的一种格式，支持这种字体的浏览器有：\nChrome4+、Safari3.1+、Opera10.0+、iOS Mobile Safari3.2+\n</code></pre></div></li>\n</ol>\n<h3 id=\"_28-4-字体图标的使用步骤\" tabindex=\"-1\"> 28.4 字体图标的使用步骤</h3>\n<h4 id=\"_28-4-1-下载字体图标\" tabindex=\"-1\"> 28.4.1 下载字体图标</h4>\n<p>推荐下载网站：</p>\n<ol>\n<li>\n<p><code>icomoon</code> 字库 <a href=\"http://icomoon.io\" target=\"_blank\" rel=\"noopener noreferrer\">http://icomoon.io<ExternalLinkIcon/></a></p>\n<div><pre><code>IcoMoon 成立于 2011 年，推出了第一个自定义图标字体生成器，它允许用户选择所需要的图标，使它们成一字型。\n该字库内容种类繁多，非常全面，唯一的遗憾是国外服务器，打开网速较慢。\n</code></pre></div></li>\n<li>\n<p>阿里 <code>iconfont</code> 字库 <a href=\"http://www.iconfont.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">http://www.iconfont.cn/<ExternalLinkIcon/></a></p>\n<div><pre><code>这个是阿里妈妈 M2UX 的一个 iconfont 字体图标字库，包含了淘宝图标库和阿里妈妈图标库。\n可以使用 AI 制作图标上传生成。 重点是，免费！\n</code></pre></div></li>\n</ol>\n<h4 id=\"_28-4-2-引入字体图标\" tabindex=\"-1\"> 28.4.2 引入字体图标</h4>\n<p><strong>Step1. 把下载包里面的 <code>fonts</code> 文件夹放入页面根目录下</strong></p>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_2_css/27.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>注意：下载完毕之后，注意原先的文件不要删，后面会用。</p>\n</blockquote>\n<p><strong>Step2. 在 <code>CSS</code> 样式中全局声明字体</strong></p>\n<div><pre><code>简单理解就是把这些字体文件通过 css 引入到我们的 html 页面中。\n一定注意字体文件路径的问题。\n</code></pre></div><div><pre><code><span><span>@font-face</span></span> <span>{</span>\n    <span>font-family</span><span>:</span> <span>'icomoon'</span><span>;</span>\n    <span>src</span><span>:</span> <span><span>url</span><span>(</span><span>'fonts/icomoon.eot?7kkyc2'</span><span>)</span></span><span>;</span>\n    <span>src</span><span>:</span> <span><span>url</span><span>(</span><span>'fonts/icomoon.eot?7kkyc2#iefix'</span><span>)</span></span> <span>format</span><span>(</span><span>'embedded-opentype'</span><span>)</span><span>,</span>\n    <span><span>url</span><span>(</span><span>'fonts/icomoon.ttf?7kkyc2'</span><span>)</span></span> <span>format</span><span>(</span><span>'truetype'</span><span>)</span><span>,</span>\n    <span><span>url</span><span>(</span><span>'fonts/icomoon.woff?7kkyc2'</span><span>)</span></span> <span>format</span><span>(</span><span>'woff'</span><span>)</span><span>,</span>\n    <span><span>url</span><span>(</span><span>'fonts/icomoon.svg?7kkyc2#icomoon'</span><span>)</span></span> <span>format</span><span>(</span><span>'svg'</span><span>)</span><span>;</span>\n    <span>font-weight</span><span>:</span> normal<span>;</span>\n    <span>font-style</span><span>:</span> normal<span>;</span>\n<span>}</span>\n</code></pre></div><p><strong>Step3. 在 <code>html</code> 标签内添加小图标</strong></p>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_2_css/28.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code><span><span><span>&lt;</span>span</span><span>></span></span> <span><span><span>&lt;/</span>span</span><span>></span></span>\n</code></pre></div><p><strong>Step4. 给标签定义字体</strong></p>\n<div><pre><code><span>span</span> <span>{</span>\n    <span>font-family</span><span>:</span> <span>\"icomoon\"</span><span>;</span>\n<span>}</span>\n</code></pre></div><blockquote>\n<p>务必保证这个字体和上面 <code>Step2</code> 中的 <code>@font-face</code> 里面的字体保持一致。</p>\n</blockquote>\n<h4 id=\"_28-4-3-追加字体图标\" tabindex=\"-1\"> 28.4.3 追加字体图标</h4>\n<p>如果工作中，原来的字体图标不够用了，我们需要添加新的字体图标到原来的字体文件中。那么把压缩包里面的 <code>selection.json</code> 从新上传，然后选中自己想要新的图标，从新下载压缩包，并替换原来的文件即可。</p>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_2_css/29.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_29-css-三角\" tabindex=\"-1\"> 29. <code>CSS</code> 三角</h2>\n<p>网页中常见一些三角形，使用 <code>CSS</code> 直接画出来就可以，不必做成图片或者字体图标。</p>\n<p>一张图， 你就知道 <code>CSS</code> 三角是怎么来的了, 做法如下：</p>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_2_css/30.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code><span>div</span> <span>{</span>\n    <span>width</span><span>:</span> 0<span>;</span>\n    <span>height</span><span>:</span> 0<span>;</span>\n    <span>line-height</span><span>:</span> 0<span>;</span>\n    <span>font-size</span><span>:</span> 0<span>;</span>\n    <span>border</span><span>:</span> 50px solid transparent<span>;</span>\n    <span>border-left-color</span><span>:</span> pink<span>;</span>\n<span>}</span>\n</code></pre></div><p><strong>课堂案例：</strong> 完成如下图像</p>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_2_css/31.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_30-css-用户界面样式\" tabindex=\"-1\"> 30. <code>CSS</code> 用户界面样式</h2>\n<p>所谓的界面样式，就是更改一些用户操作样式，以便提高更好的用户体验。如：</p>\n<ol>\n<li>\n<p>更改用户的鼠标样式；</p>\n</li>\n<li>\n<p>表单轮廓；</p>\n</li>\n<li>\n<p>防止表单域拖拽。</p>\n</li>\n</ol>\n<h3 id=\"_30-1-鼠标样式-cursor\" tabindex=\"-1\"> 30.1 鼠标样式：<code>cursor</code></h3>\n<div><pre><code>设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状。\n</code></pre></div><p><strong>示例：</strong></p>\n<div><pre><code><span>li</span> <span>{</span><span>cursor</span><span>:</span> pointer<span>;</span> <span>}</span>\n</code></pre></div><table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>属性值</strong></th>\n<th style=\"text-align:left\"><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>default</code></td>\n<td style=\"text-align:left\">小白（默认）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>pointer</code></td>\n<td style=\"text-align:left\">小手</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>move</code></td>\n<td style=\"text-align:left\">移动</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>text</code></td>\n<td style=\"text-align:left\">文本</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>not-allowed</code></td>\n<td style=\"text-align:left\">禁止</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_30-2-表单轮廓线-outline\" tabindex=\"-1\"> 30.2 表单轮廓线：<code>outline</code></h3>\n<p><strong>示例：</strong></p>\n<div><pre><code><span>input</span> <span>{</span><span>outline</span><span>:</span> none<span>;</span> <span>}</span>\n</code></pre></div><div><pre><code>给表单添加 outline: 0; 或者 outline: none; 样式之后，就可以去掉默认的蓝色边框。\n</code></pre></div><h3 id=\"_30-3-防止拖拽文本域-resize\" tabindex=\"-1\"> 30.3 防止拖拽文本域：<code>resize</code></h3>\n<p><strong>示例：</strong></p>\n<div><pre><code><span>textarea</span><span>{</span> <span>resize</span><span>:</span> none<span>;</span><span>}</span>\n</code></pre></div><div><pre><code>实际开发中，我们文本域右下角是不可以拖拽的。\n</code></pre></div><h2 id=\"_31-vertical-align-属性应用\" tabindex=\"-1\"> 31. <code>vertical-align</code> 属性应用</h2>\n<p><strong><code>CSS</code> 的 <code>vertical-align</code> 属性使用场景：</strong> 经常用于设置图片或者表单（行内块元素）和文字垂直对齐。</p>\n<p><strong>官方解释：</strong> 用于设置一个元素的垂直对齐方式，但是它只针对于行内元素或者行内块元素有效。</p>\n<p><strong>语法：</strong></p>\n<div><pre><code>vertical-align : baseline | top | middle | bottom\n</code></pre></div><table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>值</strong></th>\n<th style=\"text-align:left\"><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>baseline</code></td>\n<td style=\"text-align:left\">默认。元素放置在父元素的基线上</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>top</code></td>\n<td style=\"text-align:left\">把元素的顶端与行中最高元素的顶端对齐</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>middle</code></td>\n<td style=\"text-align:left\">把此元素放置在父元素的中部</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>bottom</code></td>\n<td style=\"text-align:left\">把元素的顶端与行中最低的元素的顶端对齐</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_2_css/32.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_31-1-图片、表单和文字对齐\" tabindex=\"-1\"> 31.1 图片、表单和文字对齐</h3>\n<p>图片、表单都属于行内块元素，默认的 <code>vertical-align</code> 是基线对齐。</p>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_2_css/33.png\" alt=\"\" loading=\"lazy\"></p>\n<p>此时可以给图片、表单这些行内块元素的 <code>vertical-align</code> 属性设置为 <code>middle</code> 就可以让文字和图片垂直居中对齐了。</p>\n<h3 id=\"_31-2-解决图片底部默认空白缝隙问题\" tabindex=\"-1\"> 31.2 解决图片底部默认空白缝隙问题</h3>\n<p><strong><code>Bug</code>：</strong> 图片底侧会有一个空白缝隙，原因是行内块元素会和文字的基线对齐。</p>\n<p><strong>主要解决方法有两种：</strong></p>\n<ol>\n<li>\n<p>给图片添加 <code>vertical-align:middle|top|bottom</code> 等。（提倡使用的）</p>\n</li>\n<li>\n<p>把图片转换为块级元素 <code>display: block;</code></p>\n</li>\n</ol>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_2_css/34.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_32-溢出的文字省略号显示\" tabindex=\"-1\"> 32. 溢出的文字省略号显示</h2>\n<h3 id=\"_32-1-单行文本溢出显示省略号\" tabindex=\"-1\"> 32.1 单行文本溢出显示省略号</h3>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_2_css/35.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code><span>/* 必须满足三个条件 */</span>\n\n<span>/*1. 先强制一行内显示文本*/</span>\n <span>white-space</span><span>:</span> nowrap<span>;</span> （默认 normal 自动换行）\n <span>/*2. 超出的部分隐藏*/</span>\n <span>overflow</span><span>:</span> hidden<span>;</span>\n <span>/*3. 文字用省略号替代超出的部分*/</span>\n <span>text-overflow</span><span>:</span> ellipsis<span>;</span>\n</code></pre></div><h3 id=\"_32-2-多行文本溢出显示省略号\" tabindex=\"-1\"> 32.2 多行文本溢出显示省略号</h3>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_2_css/36.png\" alt=\"\" loading=\"lazy\"></p>\n<p>多行文本溢出显示省略号，有较大兼容性问题。适合于 <code>webKit</code> 浏览器或移动端（移动端大部分是 <code>webkit</code> 内核）</p>\n<div><pre><code><span>overflow</span><span>:</span> hidden<span>;</span>\n<span>text-overflow</span><span>:</span> ellipsis<span>;</span>\n<span>/* 弹性伸缩盒子模型显示 */</span>\n<span>display</span><span>:</span> -webkit-box<span>;</span>\n<span>/* 限制在一个块元素显示的文本的行数 */</span>\n<span>-webkit-line-clamp</span><span>:</span> 2<span>;</span>\n<span>/* 设置或检索伸缩盒对象的子元素的排列方式 */</span>\n<span>-webkit-box-orient</span><span>:</span> vertical<span>;</span>\n</code></pre></div><blockquote>\n<p>更推荐让后台人员来做这个效果，因为后台人员可以设置显示多少个字，操作更简单。</p>\n</blockquote>\n<h2 id=\"_33-常见布局技巧\" tabindex=\"-1\"> 33. 常见布局技巧</h2>\n<h3 id=\"_33-1-margin-负值运用\" tabindex=\"-1\"> 33.1 <code>margin</code> 负值运用</h3>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_2_css/37.png\" alt=\"\" loading=\"lazy\"></p>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_2_css/38.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>1. 让每个盒子 margin 往左侧移动 -1px 正好压住相邻盒子边框；\n2. 鼠标经过某个盒子的时候，提高当前盒子的层级即可（如果没有有定位，则加相对定位（保留位置），如果有定位，则加 z-index）\n</code></pre></div><h3 id=\"_33-2-文字围绕浮动元素\" tabindex=\"-1\"> 33.2 文字围绕浮动元素</h3>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_2_css/39.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_33-3-行内块巧妙运用\" tabindex=\"-1\"> 33.3 行内块巧妙运用</h3>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_2_css/40.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>页码在页面中间显示：</strong></p>\n<div><pre><code>1. 把这些链接盒子转换为行内块，之后给父级指定 text-align:center;\n2. 利用行内块元素中间有缝隙，并且给父级添加 text-align:center; 行内块元素会水平会居中。\n</code></pre></div><h3 id=\"_33-4-css-三角强化\" tabindex=\"-1\"> 33.4 <code>CSS</code> 三角强化</h3>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_2_css/41.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>原理：</strong></p>\n<p><img src=\"@source/zkq/web/_1_web-dev-basic/images/_2_css/42.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>代码：</strong></p>\n<div><pre><code><span>width</span><span>:</span> 0<span>;</span>\n<span>height</span><span>:</span> 0<span>;</span>\n<span>border-color</span><span>:</span> transparent red transparent transparent<span>;</span>\n<span>border-style</span><span>:</span> solid<span>;</span>\n<span>border-width</span><span>:</span> 22px 8px 0 0<span>;</span>\n</code></pre></div><h2 id=\"_34-css-初始化\" tabindex=\"-1\"> 34. <code>CSS</code> 初始化</h2>\n<p>不同浏览器对有些标签的默认值是不同的，为了消除不同浏览器对 <code>HTML</code> 文本呈现的差异，照顾浏览器的兼容，我们需要对 <code>CSS</code> 初始化。</p>\n<p><strong>简单理解：</strong> <code>CSS</code> 初始化是指重设浏览器的样式。（也称为 <code>CSS reset</code>）</p>\n<blockquote>\n<p>每个网页都必须首先进行 <code>CSS</code> 初始化。</p>\n</blockquote>\n<h2 id=\"_35-unicode-编码字体\" tabindex=\"-1\"> 35. <code>Unicode</code> 编码字体</h2>\n<p>把中文字体的名称用相应的 <code>Unicode</code> 编码来代替，这样就可以有效的避免浏览器解释 <code>CSS</code> 代码时候出现乱码的问题。</p>\n<p><strong>比如：</strong></p>\n<div><pre><code>黑体 \\9ED1\\4F53\n宋体 \\5B8B\\4F53\n微软雅黑 \\5FAE\\8F6F\\96C5\\9ED1\n</code></pre></div>",
      "date_published": "2022-09-04T14:20:41.000Z",
      "date_modified": "2023-04-05T14:45:48.000Z",
      "authors": [],
      "tags": [
        "web"
      ]
    }
  ]
}