{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "Android Guide",
  "home_page_url": "https://zengkaiqiang562.github.io/",
  "feed_url": "https://zengkaiqiang562.github.io/feed.json",
  "description": "Android 学习 && 面试指南",
  "items": [
    {
      "title": "应用开发指引",
      "url": "https://zengkaiqiang562.github.io/lango-tech/develop_guide/app_develop_guide.html",
      "id": "https://zengkaiqiang562.github.io/lango-tech/develop_guide/app_develop_guide.html",
      "content_html": "<h2 id=\"_1-软件工具\" tabindex=\"-1\"> 1. 软件工具</h2>\n<h3 id=\"软件工具包的下载地址\" tabindex=\"-1\"> 软件工具包的下载地址</h3>\n<p>链接：<a href=\"https://pan.baidu.com/s/1q62nxZ8muZoZdXsrEo2_rg\" target=\"_blank\" rel=\"noopener noreferrer\">https://pan.baidu.com/s/1q62nxZ8muZoZdXsrEo2_rg<ExternalLinkIcon/></a>\n提取码：<code>1234</code></p>\n<h3 id=\"_1-1-朗国办公软件\" tabindex=\"-1\"> 1.1 朗国办公软件</h3>\n<h4 id=\"_1-1-1-企业微信-企业邮箱\" tabindex=\"-1\"> 1.1.1 企业微信 &amp; 企业邮箱</h4>\n<p><strong>企业微信下载地址：</strong> <a href=\"https://work.weixin.qq.com/#indexDownload\" target=\"_blank\" rel=\"noopener noreferrer\">https://work.weixin.qq.com/#indexDownload<ExternalLinkIcon/></a></p>\n<blockquote>\n<p>入职时 <code>HR</code> 会将你加入到企业微信。</p>\n</blockquote>\n<p><strong>企业邮箱：</strong> 在企业微信中联系运维工程师（谭俊英）申请企业邮箱账号和密码。</p>\n<p>申请到企业邮箱的账号密码后，在企业微信的【邮件】中进行添加。</p>\n<h4 id=\"_1-1-2-朗国电子安全助手\" tabindex=\"-1\"> 1.1.2 朗国电子安全助手</h4>\n<blockquote>\n<p>双击软件工具包中的 <code>lva_setupnet_20231101173114.exe</code> 进行安装。</p>\n</blockquote>\n<p>界面如下所示，账号会在加入企业微信后自动创建，用户名为首字母大写的姓名拼音。初始密码 <code>123456</code>，首次登录需要修改密码。</p>\n<blockquote>\n<p>如果没有自动创建，可以联系运维工程师（肖平）</p>\n</blockquote>\n<p><img src=\"@source/lango-tech/develop_guide/images/app_develop_guide/01.png\" alt=\"\" loading=\"lazy\"></p>\n<p>输入用户名和密码后，点击登录网络，成功后会自动连接名为 <code>LANGO-5G</code> 的 <code>WIFI</code>。</p>\n<h4 id=\"_1-1-3-代码加密软件\" tabindex=\"-1\"> 1.1.3 代码加密软件</h4>\n<blockquote>\n<p>双击软件工具包中的 <code>Client_Setup23.exe</code> 进行安装。</p>\n</blockquote>\n<blockquote>\n<p>参考：<a href=\"https://drive.weixin.qq.com/s?k=ABUAPgfAABADCLO5ju\" target=\"_blank\" rel=\"noopener noreferrer\">加密软件常用问题以及故障<ExternalLinkIcon/></a></p>\n</blockquote>\n<p><strong>注意：</strong> ：</p>\n<ol>\n<li>在访问 <code>Gerrit</code> 代码仓库时（如 <code>clone</code>/<code>pull</code>/<code>push</code> 等操作），需要切换业务模式为 <strong>工作模式</strong>；</li>\n<li>在登录 <code>SVN</code> 服务器时，需要切换业务模式为 <strong>个人模式</strong>；</li>\n<li>如果 <code>AndroidStudio</code> 中的项目代码乱码，请先确认当前是否处于工作模式，如果不是，关闭 <code>AndroidStudio</code>，切到工作模式成功后，再重新打开 <code>AndroidStudio</code>。</li>\n</ol>\n<h3 id=\"_1-2-jdk\" tabindex=\"-1\"> 1.2 <code>JDK</code></h3>\n<blockquote>\n<p>双击 <code>jdk-8u201-windows-x64.exe</code> 安装 <code>JDK 1.8</code></p>\n<p>解压 <code>openjdk-11.0.2_windows-x64_bin.zip</code> 即可得到 <code>JDK 11</code></p>\n<p>解压 <code>openjdk-17.0.2_windows-x64_bin.zip</code> 即可得到 <code>JDK 17</code></p>\n</blockquote>\n<p><strong>环境变量配置：</strong></p>\n<ol>\n<li>新增 <code>JAVA_HOME</code> 环境变量，变量值是 <code>JDK 1.8</code> 的安装目录，或 <code>JDK 11/17</code> 的解压目录。（当前想在命令行中使用哪个版本的，就是配置哪个版本的）</li>\n<li>将 <code>%JAVA_HOME%\\bin</code> 添加到环境变量 <code>Path</code> 中。</li>\n<li>重新打开命令行生效。</li>\n</ol>\n<p><strong>注意：</strong></p>\n<p>目前的项目代码中，使用的 <code>Gradle</code> 版本和 <code>JDK</code> 版本的对应关系大致如下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><code>Gradle</code> 版本</th>\n<th style=\"text-align:left\"><code>JDK</code> 版本</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Gradle 4+</td>\n<td style=\"text-align:left\">JDK 1.8</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Gradle 6+、7+</td>\n<td style=\"text-align:left\">JDK 11</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Gradle 8+</td>\n<td style=\"text-align:left\">JDK 17</td>\n</tr>\n</tbody>\n</table>\n<p>如果 <code>JDK</code> 版本与 <code>Gradle</code> 版本不兼容，<code>AndroidStudio</code> 中执行 <code>Gradle Sync</code> 时会报错，此时根据错误提示，选择正确的 <code>JDK</code> 版本即可。</p>\n<p><code>AndroidStudio</code> 中切换 <code>JDK</code> 版本的方式如下所示：</p>\n<p><img src=\"@source/lango-tech/develop_guide/images/app_develop_guide/02.png\" alt=\"\" loading=\"lazy\"></p>\n<p><img src=\"@source/lango-tech/develop_guide/images/app_develop_guide/03.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_1-3-androidstudio\" tabindex=\"-1\"> 1.3 <code>AndroidStudio</code></h3>\n<blockquote>\n<p>最新版本的 <code>AndroidStudio</code> 下载地址：https://developer.android.com/studio?hl=zh-cn</p>\n<p>也可以直接使用软件工具包中已下载的 <code>AndroidStudio</code>，双击 <code>android-studio-2023.2.1.24-windows.exe</code> 安装即可。</p>\n</blockquote>\n<p><strong>注意：</strong></p>\n<p>下载过程中会自动安装 <code>sdk manager</code>，记住 <code>sdk manager</code> 的安装目录，并将其安装目录下的 <code>platform-tools</code> 文件夹添加到环境变量 <code>Path</code> 中，以便在命令行中使用 <code>adb</code> 命令。</p>\n<h4 id=\"_1-3-1-adb-常用命令\" tabindex=\"-1\"> 1.3.1 <code>adb</code> 常用命令</h4>\n<div><pre><code><span># 设备的 连接/断开连接。（也可以不指定端口号，即省略 \":5555\"）</span>\nadb connect <span>192.168</span>.120.89:5555\nadb disconnect <span>192.168</span>.120.89:5555\n\n<span># 查看已连接的设备</span>\nadb devices\n</code></pre></div><div><pre><code><span># 安装 app</span>\nadb <span>install</span> -r <span>&lt;</span>apk 文件路径<span>></span>\n<span># 卸载指定包名的 app</span>\nadb uninstall <span>&lt;</span>包名<span>></span>\n<span># 查看指定包名的 app 所对应的 apk 的安装路径</span>\nadb shell pm path <span>\"&lt;包名>\"</span>\n</code></pre></div><div><pre><code><span># 将电脑上的文件推送到设备的已存在目录中，如果是指定的设备目录是一个文件路径，那么还会进行重命名</span>\nadb push <span>&lt;</span>电脑上的文件路径<span>></span> <span>&lt;</span>设备上的文件路径/目录路径<span>></span>\n<span># 将设备中的指定文件/目录 保存到电脑的当前目录中</span>\nadb pull <span>&lt;</span>设备上的文件路径/目录路径<span>></span> ./\n</code></pre></div><div><pre><code><span># 获取指定包名的 app 进程的 PID</span>\nadb shell <span>ps</span> -ef <span>|</span> <span>grep</span> <span>\"com.xbh.systemui\"</span>\n<span># 杀掉指定的 app 进程</span>\nadb shell <span>kill</span> <span>&lt;</span>PID<span>></span> \n</code></pre></div><div><pre><code><span>##################</span>\n<span># 系统应用的安装（方式一）</span>\n<span>##################</span>\n<span># 以安装 XbhSystemUI 为例</span>\n\n<span># step1. 找到 XbhSystemUI.apk 的所在目录</span>\nadb shell pm path <span>\"&lt;包名>\"</span>\n<span># step2. 将电脑中预安装的 apk 推送到设备中 XbhSystemUI.apk 的所在目录，并重命名为 XbhSystemUI.apk</span>\nadb push D:<span>\\</span>work<span>\\</span>lang<span>\\</span>project<span>\\</span>tmp<span>\\</span>XbhSystemUI<span>\\</span>out<span>\\</span>release<span>\\</span>XbhSystemUI_xbh_1.0.257.145_e1891f1a.apk /system/app/XbhSystemUI/XbhSystemUI.apk\n<span># step3. 获取 XbhSystemUI 的进程 PID</span>\nadb shell <span>ps</span> -ef <span>|</span> <span>grep</span> <span>\"com.xbh.systemui\"</span>\n<span># step4. 杀掉当前的 XbhSystemUI 进程</span>\nadb shell <span>kill</span> <span>&lt;</span>PID<span>></span> \n\n<span># 当再次启动 XbhSystemUI 时，就是新安装的 apk</span>\n</code></pre></div><div><pre><code><span># 打印 tag 为 AndroidRuntime 和 System.err 的日志</span>\n<span># 如果想添加 tag，在 -s 后添加即可，空格分开</span>\nadb logcat -s AndroidRuntime System.err -v color\n\n<span># 打印所有日志</span>\nadb logcat -v color\n\n<span># 将打印日志保存到当前目录的 log.txt 文件中</span>\nadb logcat -v color <span>></span> log.txt\n</code></pre></div><div><pre><code><span># adb 启动 Activity</span>\n<span># 如下命令启动一个包名为 com.xbh.langofct 中的类全路径名为 com.xbh.langofct.ui.MainActivity 的 MainActivity</span>\n<span># 注意：MainActivity 在清单文件中要配置 export=true，全路径名中的包名部分可省略不写。</span>\nadb shell am start -n com.xbh.langofct/.ui.MainActivity\n\n<span># adb 启动 Service</span>\n<span># 如下命令启动一个包名为 com.xbh.systemui 中的类全路径名为 com.xbh.systemui.SysUIService 的 SysUIService，并携带 Action 参数为 ACTION_REGION_SCREENSHOT</span>\nadb shell am startservice -n com.xbh.systemui/.SysUIService -a ACTION_REGION_SCREENSHOT\n</code></pre></div><div><pre><code><span># 通过 adb 查看系统属性 persist.wm.debug.caption_on_shell</span>\nadb shell getprop persist.wm.debug.caption_on_shell\n<span># 通过 adb 设置系统属性 persist.wm.debug.caption_on_shell 为 false</span>\nadb shell setprop persist.wm.debug.caption_on_shell <span>false</span>\n</code></pre></div><div><pre><code><span>##################</span>\n<span># 获取 root 权限（方式一）</span>\n<span>##################</span>\nadb root\nadb remount\n\n<span>##################</span>\n<span># 获取 root 权限（方式二）</span>\n<span>##################</span>\nadb shell <span># 进入设备的命令终端</span>\n<span>su</span>        <span># 如果找不到 su 命令，执行 xbhsu</span>\nremount\n</code></pre></div><div><pre><code><span># 重启设备</span>\nadb <span>reboot</span>\n</code></pre></div><div><pre><code><span># 发送返回按键</span>\nadb shell input keyevent <span>4</span>\n<span># 发送 HOME 按键</span>\nadb shell input keyevent <span>3</span>\n<span># 发送 打开最近任务（KEYCODE_APP_SWITCH） 按钮</span>\nadb shell input keyevent <span>187</span>\n</code></pre></div><div><pre><code><span># 显示布局边界（当前 app 需要重新打开才能生效）</span>\nadb shell setprop debug.layout <span>true</span>\n</code></pre></div><div><pre><code><span># 查看屏幕分辨率</span>\nadb shell wm size\n\n<span># 查看屏幕密度（DPI）</span>\nadb shell wm density\n</code></pre></div><div><pre><code><span># 清除指定包名的数据和缓存</span>\nadb shell pm <span>clear</span>  <span>&lt;</span>包名<span>></span>\n</code></pre></div><div><pre><code><span># adb 命令进入工厂菜单</span>\nadb shell am startservice -n com.xbh.factory.menu/.app.TvMenuWindowManagerService -e com.xbh.factory.menu.commmand com.xbh.factory.menu.commmand.factory_men\n</code></pre></div><h3 id=\"_1-4-git-与-gerrit\" tabindex=\"-1\"> 1.4 <code>Git</code> 与 <code>Gerrit</code></h3>\n<p><code>Git</code> 是代码版本管理工具；</p>\n<p>而 <code>Gerrit</code> 是一个 <code>Web</code> 端的代码评审工具，在多人协作开发时，用来相互 <code>review</code> 代码的。可以理解为：</p>\n<div><pre><code>代码首先提交到 Gerrit，经过 Reviewer 审阅通过后，才能 submit 到 Git 远程仓库中。\n</code></pre></div><h4 id=\"_1-4-1-gerrit-概述-项目代码仓库\" tabindex=\"-1\"> 1.4.1 <code>Gerrit</code> 概述 &amp; 项目代码仓库</h4>\n<p>应用开发的所有项目仓库，都可以在 <code>Gerrit</code> 上看到，<code>Gerrit</code> 的地址为：<a href=\"http://192.168.1.194:8092/\" target=\"_blank\" rel=\"noopener noreferrer\">http://192.168.1.194:8092/<ExternalLinkIcon/></a></p>\n<h5 id=\"_1-4-1-1-配置-gerrit\" tabindex=\"-1\"> 1.4.1.1 配置 <code>Gerrit</code></h5>\n<p>配置步骤如下：</p>\n<ol>\n<li>\n<p>找管理员（邓嘉俊）申请 <code>Gerrit</code> 的账号/密码；</p>\n</li>\n<li>\n<p>登录 Gerrit 网页端：<a href=\"http://192.168.1.194:8092/\" target=\"_blank\" rel=\"noopener noreferrer\">http://192.168.1.194:8092/<ExternalLinkIcon/></a></p>\n</li>\n<li>\n<p>在 <code>Gerrit</code> 网页端中进行邮箱验证：</p>\n<div><pre><code>邮箱就是 1.1.1 小节中介绍的企业邮箱。验证步骤如下图所示：\n</code></pre></div><blockquote>\n<p>点击 <code>Gerrit</code> 网页右上角的设置按钮进入以下界面。</p>\n</blockquote>\n<p><img src=\"@source/lango-tech/develop_guide/images/primer/01.png\" alt=\"\" loading=\"lazy\"></p>\n<p><img src=\"@source/lango-tech/develop_guide/images/primer/02.png\" alt=\"\" loading=\"lazy\"></p>\n<p><img src=\"@source/lango-tech/develop_guide/images/primer/03.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>注意：不要直接点击邮箱验证链接，如果链接中的端口号为 <code>8091</code>，那么需要手动改成 <code>8092</code> 后再进行验证</p>\n</blockquote>\n<p><img src=\"@source/lango-tech/develop_guide/images/primer/04.png\" alt=\"\" loading=\"lazy\"></p>\n</li>\n<li>\n<p>在 <code>Gerrit</code> 网页端中生成 <code>Token</code></p>\n<div><pre><code>当我们在本地访问 Gerrit 仓库时（如 clone 仓库），会用到这个 Token（相当于密码）。\nToken 的生成方式如下图所示：\n</code></pre></div><p><img src=\"@source/lango-tech/develop_guide/images/primer/05.png\" alt=\"\" loading=\"lazy\"></p>\n</li>\n</ol>\n<h5 id=\"_1-4-1-2-gerrit-界面介绍\" tabindex=\"-1\"> 1.4.1.2 <code>Gerrit</code> 界面介绍</h5>\n<p><code>Gerrit</code> 上的仓库列表如下图所示：</p>\n<blockquote>\n<p>新账号可能只有 <code>All-Users</code> 和 <code>testing</code> 这两个测试仓库。其他项目仓库需要申请仓库权限才能访问。</p>\n</blockquote>\n<p><img src=\"@source/lango-tech/develop_guide/images/app_develop_guide/04.png\" alt=\"\" loading=\"lazy\"></p>\n<p>上图中，点击仓库列表中的某个仓库名称，可进入该仓库的详情页，如下图所示：</p>\n<p><img src=\"@source/lango-tech/develop_guide/images/app_develop_guide/05.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p><strong>注意：</strong> 较长的 <code>clone</code> 命令中有两个 <code>8091</code> 端口值，都要改成 <code>8089</code>。</p>\n</blockquote>\n<p>本地 <code>Git</code> 仓库中执行 <code>git push origin HEAD:refs/for/远端分支名</code> 命令，会将代码推送到 <code>Gerrit</code> 中，在 <code>Dashboard</code> 界面中可以看到推送的提交记录，如下图所示：</p>\n<p><img src=\"@source/lango-tech/develop_guide/images/app_develop_guide/06.png\" alt=\"\" loading=\"lazy\"></p>\n<p>另外，在 <code>Gerrit</code> 的 <code>CHANGES</code> 栏下可以看到所有仓库（获取了权限的仓库）的各个协同开发人员的提交信息：</p>\n<p><img src=\"@source/lango-tech/develop_guide/images/app_develop_guide/07.png\" alt=\"\" loading=\"lazy\"></p>\n<p>在 <code>YOUR -&gt; Dashboard</code> 下，点击某次提交，会进入该次提交的详情页面，如下所示：</p>\n<p><img src=\"@source/lango-tech/develop_guide/images/app_develop_guide/08.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_1-4-2-git-概述-常用的-git-命令\" tabindex=\"-1\"> 1.4.2 <code>Git</code> 概述 &amp; 常用的 <code>Git</code> 命令</h4>\n<blockquote>\n<p>双击软件工具包中的 <code>Git-2.16.1.2-64-bit.exe</code> 安装 <code>Git</code> 客户端。</p>\n<p>注意：必须使用此版本的 <code>Git</code>。</p>\n</blockquote>\n<p>安装成功后，将 <code>Git</code> 安装目录下 <code>bin</code> 目录配置到环境变量中。</p>\n<p>可以在 <code>AndroidStudio</code> 中通过图形化界面使用 <code>Git</code>，也可以在 <code>Git Bash</code> 终端中通过 <code>Git</code> 命令使用 <code>Git</code>。以下介绍 <code>Git Bash</code> 中常用的 <code>Git</code> 命令。</p>\n<h5 id=\"_1-4-2-1-常用的-git-命令\" tabindex=\"-1\"> 1.4.2.1 常用的 <code>Git</code> 命令</h5>\n<div><pre><code><span># 配置用户名和邮箱</span>\n<span>git</span> config --global user.name <span>\"用户名\"</span>\n<span>git</span> config --global user.email <span>\"邮箱\"</span>\n\n<span># 配置 git 的默认编辑器为 vim</span>\n<span>git</span> config --global core.editor <span>vim</span>\n\n<span># clone 远程仓库，clone 时直接复制 1.4.1.2 小节中介绍的仓库详情页中的较长的 clone 命令，并修改端口号即可。</span>\n<span>git</span> clone\n\n<span># 查看本地和远程仓库的所有分支列表</span>\n<span>git</span> branch -a\n<span># 仅查看本地的分支列表</span>\n<span>git</span> branch\n\n<span># 切换分支</span>\n<span>git</span> checkout 分支名\n\n<span># 拉取远程仓库的最新代码，并以 rebase 的方式进行合并</span>\n<span># 注意：</span>\n<span># 在执行 git pull --rebase 前本地仓库中不能有未提交的修改</span>\n<span># 如果存在未提交的修改，需要先 git stash 暂存起来，</span>\n<span># 当执行完 git pull --rebase 后，</span>\n<span># 再 执行 git stash pop 还原。（还原后，如果修改与拉取的代码存在冲突，需要解决冲突）</span>\n<span>git</span> pull --rebase\n\n<span># 查看本地仓库的状态（会显示工作区、暂存区的修改信息；存在冲突时的冲突信息；未加入到版本管理的文件信息等）</span>\n<span>git</span> status\n\n<span># 查看工作区中的修改内容</span>\n<span>git</span> <span>diff</span>\n<span># 查看暂存区中的修改内容</span>\n<span>git</span> <span>diff</span> --cached\n\n<span># 将工作区的所有修改都 add 到暂存区</span>\n<span>git</span> <span>add</span> <span>.</span>\n<span># 将工作区中指定目录下的所有修改都 add 到暂存区</span>\n<span>git</span> <span>add</span> xx/yy/*\n<span># 将工作区中指定的文件 add 到暂存区</span>\n<span>git</span> <span>add</span> <span>1</span>.txt <span>2</span>.txt <span>3</span>.txt\n\n<span># 将工作区中的所有修改都还原</span>\n<span>git</span> checkout -- <span>.</span>\n<span># 将工作区中指定文件的修改还原</span>\n<span>git</span> checkout -- <span>1</span>.txt <span>2</span>.txt <span>3</span>.txt\n\n<span># 将暂存区中的所有修改都放回到工作区</span>\n<span>git</span> reset HEAD <span>.</span>\n<span># 将暂存区中指定文件的修改放回到工作区</span>\n<span>git</span> reset HEAD <span>1</span>.txt <span>2</span>.txt <span>3</span>.txt\n\n<span># 将暂存区中的修改提交到本地版本库中</span>\n<span># 该命令执行后会唤起 vim 编辑器，需要在编辑器中根据 1.4.2.2 小节的格式规范编写 message 信息</span>\n<span># 编写完成后，输入 :wq 保存信息并退出编辑器后，暂存区中的修改就会提交到本地版本库中</span>\n<span>git</span> commit\n\n<span># 将未推送到 Gerrit 仓库中的本地 commit 提交推送到 Gerrit 仓库的指定分支上。</span>\n<span># 执行该命令成功后，就可以在 Gerrit 网页端的 YOUR -> Dashboard 界面中看到推送的提交记录</span>\n<span>git</span> push origin HEAD:refs/for/远端分支名\n\n<span># 查看当前分支的提交记录</span>\n<span>git</span> log\n<span># 查看当前分支的提交记录，并显示每次提交的修改内容</span>\n<span>git</span> log -p\n<span># 查看当前分支的提交记录，并显示每次提交的修改文件</span>\n<span>git</span> log --stat\n</code></pre></div><h5 id=\"_1-4-2-2-提交信息的格式规范\" tabindex=\"-1\"> 1.4.2.2 提交信息的格式规范</h5>\n<p>根据 <code>ones</code> 工作管理平台上的工作项类型，提交信息 <code>Message</code> 的格式规范分两种：<strong>需求类型的格式</strong> 和 <strong><code>BUG</code> 类型的格式</strong>：</p>\n<ol>\n<li>\n<p>需求类型的格式</p>\n<div><pre><code>STORY-339583:&lt;ones 上的需求标题>  // 339583 是需求编号；需求标题中如果有中文的 \"【】\"，要改成 \"[]\"\n\nhttps://ones.lango-tech.com:7000/project/#/team/N1EEt2Js/task/3FxjUwmFNBvp3AZx  // ones 需求链接\n\nGroup:\n自研app\n\nWhy:\n需求开发\n\nHow:\n&lt;需求内容>\n</code></pre></div></li>\n<li>\n<p><code>BUG</code> 类型的格式</p>\n<div><pre><code>BUG-339583:&lt;ones 上的BUG标题>  // 339583 是BUG编号；BUG标题中如果有中文的 \"【】\"，要改成 \"[]\"\n\nhttps://ones.lango-tech.com:7000/project/#/team/N1EEt2Js/task/3FxjUwmFNBvp3AZx  // ones BUG链接\n\nGroup:\n自研app\n\nWhy:\nBUG 原因\n\nHow:\nBUG 解决方案\n</code></pre></div></li>\n</ol>\n<blockquote>\n<p>注意：</p>\n<ol>\n<li>\n<p>标题、链接、<code>Group</code>、<code>Why</code>、<code>How</code> 之间都要空一行；</p>\n</li>\n<li>\n<p><code>BUG/STORY</code> 和编号之间用 &quot;-&quot; 连接；</p>\n</li>\n<li>\n<p>编号和标题之间用 &quot;:&quot; 分隔；</p>\n</li>\n<li>\n<p>标题中存在 &quot;【】&quot; 时要改成 &quot;[]&quot;。</p>\n</li>\n<li>\n<p>当针对同一个工作项进行多次提交时，从第 2 次提交开始，在标题后面加 <code>Part&lt;N&gt;</code>，如第 2 次提交加 <code>Part2</code>，第 3 次提交加 <code>Part3</code>。</p>\n</li>\n<li>\n<p><code>ones</code> 标题和链接可以在 <code>ones</code> 管理平台上复制获取，如下所示：</p>\n<p><img src=\"@source/lango-tech/develop_guide/images/app_develop_guide/09.png\" alt=\"\" loading=\"lazy\"></p>\n</li>\n</ol>\n</blockquote>\n<h5 id=\"_1-4-2-3-示例-记一次代码提交流程\" tabindex=\"-1\"> 1.4.2.3 示例：记一次代码提交流程</h5>\n<div><pre><code><span># clone 仓库 XBHWhiteBoard4.0</span>\n<span># 第一次 clone 仓库可能会要求输入 username 和 password</span>\n<span># username 就是你的 Gerrit 登录账号</span>\n<span># password 就是在 1.4.1.1 小节中生成的 token（注意：不是 Gerrit 的登录密码）</span>\n<span>git</span> clone <span>\"http://zengkaiqiang@192.168.1.194:8089/a/XBHWhiteBoard4.0\"</span> <span>&amp;&amp;</span> <span>(</span>cd <span>\"XBHWhiteBoard4.0\"</span> <span>&amp;&amp;</span> <span>mkdir</span> -p .git/hooks <span>&amp;&amp;</span> <span>curl</span> -Lo <span><span>`</span><span>git</span> rev-parse --git-dir<span>`</span></span>/hooks/commit-msg http://zengkaiqiang@192.168.1.194:8089/tools/hooks/commit-msg<span>;</span> <span>chmod</span> +x <span><span>`</span><span>git</span> rev-parse --git-dir<span>`</span></span>/hooks/commit-msg<span>)</span>\n</code></pre></div><div><pre><code><span># 查看该仓库下的所有分支</span>\n<span>git</span> branch -a\n\n<span># 切换到 developer_common 分支</span>\n<span>git</span> checkout developer_common\n</code></pre></div><div><pre><code><span># 经过一段时间后，你对该仓库进行了大量修改</span>\n<span># 查看仓库状态，可以看到修改的文件信息</span>\n<span>git</span> status\n</code></pre></div><p><img src=\"@source/lango-tech/develop_guide/images/app_develop_guide/10.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code><span># 此时，你需要提交代码了，但是远程仓库的最新代码可能已经更新了，所以你需要先拉取远程仓库的代码</span>\n<span># 在拉取远程代码前，要临时保存下你修改的内容，执行如下命令进行临时保存</span>\n<span>git</span> stash\n</code></pre></div><p><img src=\"@source/lango-tech/develop_guide/images/app_develop_guide/11.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code><span># 修改的内容临时保存成功后，再执行如下命令拉取远程仓库的代码</span>\n<span>git</span> pull --rebase\n</code></pre></div><p><img src=\"@source/lango-tech/develop_guide/images/app_develop_guide/12.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code><span># 代码拉取完成后，执行如下命令将临时保存的修改内容还原</span>\n<span>git</span> stash pop\n\n<span># 还原后，如果你修改的内容与拉取的代码存在冲突，那么需要先解决冲突</span>\n</code></pre></div><p><img src=\"@source/lango-tech/develop_guide/images/app_develop_guide/13.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code><span># 现在，你可以开始提交代码了</span>\n<span>git</span> <span>add</span> <span>.</span>  <span># 将工作区的所有修改都添加到暂存区（注意：如果有不需求提交的文件，那么应该指定目录或指定文件进行添加）</span>\n<span>git</span> commit <span># 将暂存区的所有修改提交到本地版本库中（注意：这里会打开 vim 编辑器编写提交信息）</span>\n<span>git</span> push origin HEAD:refs/for/developer_common\n</code></pre></div><p><img src=\"@source/lango-tech/develop_guide/images/app_develop_guide/14.png\" alt=\"\" loading=\"lazy\"></p>\n<h5 id=\"_1-4-2-4-示例-创建新分支\" tabindex=\"-1\"> 1.4.2.4 示例：创建新分支</h5>\n<div><pre><code>step1. 先在 Gerrit 网页端创建新分支\n</code></pre></div><p><img src=\"@source/lango-tech/develop_guide/images/app_develop_guide/15.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>点击仓库详情页左侧的 <code>Branches</code> 分支栏进入上图所示界面。</p>\n</blockquote>\n<div><pre><code><span># step2. 然后在本地仓库中执行如下命令拉取线上创建的新分支</span>\n<span>git</span> pull --rebase\n\n<span># step3. 本地仓库中执行如下命令创建本地新分支。</span>\n<span>git</span> checkout -b <span>&lt;</span>newBranch<span>></span>\n\n<span># step4. 执行如下命令关联本地和远程的新分支</span>\n<span>git</span> branch --set-upstream-to<span>=</span>origin/<span>&lt;</span>newBranch<span>></span> <span>&lt;</span>newBranch<span>></span>\n\n<span># step5. </span>\n<span># 跟之前一样编写代码，并 git add 和 git commit 后，</span>\n<span># 也是一样的执行 git push origin HEAD:refs/for/&lt;newBranch> 就可以把代码推送到远程新分支了</span>\n</code></pre></div><h5 id=\"_1-4-2-5-示例-合并-gerrit-上的冲突\" tabindex=\"-1\"> 1.4.2.5 示例：合并 <code>Gerrit</code> 上的冲突</h5>\n<p>当看到 <code>Gerrit</code> 上的某次提交记录中出现 <code>Merged Conflict</code> 时表示代码有冲突，此时：</p>\n<div><pre><code><span># step1. 执行如下命令拉取线上的冲突代码</span>\n<span>git</span> pull --rebase\n\n<span># step2. 执行如下命令查看冲突文件，并合并冲突</span>\n<span>git</span> status\n\n<span># step3. 执行如下命令提交合并冲突的代码</span>\n<span>git</span> <span>add</span> <span>.</span>\n<span>git</span> rebase --continue\n\n<span># step4. 执行如下命令推送到远程仓库</span>\n<span>git</span> push origin HEAD:refs/for/<span>&lt;</span>远程分支<span>></span>\n</code></pre></div><h5 id=\"_1-4-2-6-示例-未拉取最新代码前进行-push-操作后的纠正处理\" tabindex=\"-1\"> 1.4.2.6 示例：未拉取最新代码前进行 <code>push</code> 操作后的纠正处理</h5>\n<div><pre><code>问题场景：\n远程仓库中已新增了一次提交，但本地未先执行 \"git pull --rebase\" 拉取最新代码，\n此时，本地在未拉取代码的情况下，修改了代码并提交，然后执行 \"git push origin HEAD:refs/for/远端分支名\" 推送到了远程仓库。\n接着，又想起来远程可能有未拉取的新代码，于是在将本地的修改提交并 push 后，才执行 \"git pull --rebase\" 拉取远程的最新代码，于是报错如下：\n</code></pre></div><p><img src=\"@source/lango-tech/develop_guide/images/app_develop_guide/16.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>执行 git status 查看报错情况下的本地仓库状态如下：\n</code></pre></div><p><img src=\"@source/lango-tech/develop_guide/images/app_develop_guide/17.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>此时，如果按提示执行 \"git pull\" 命令，就会进行 merge 合并，而不是 rebase 合并。\n如下所示 执行 \"git pull\" 命令，自动进行 merge 合并，因为不想这么做，所有没有写 merge 提交信息，于是 merge 提交失败，如下所示：\n</code></pre></div><p><img src=\"@source/lango-tech/develop_guide/images/app_develop_guide/18.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>此时，虽然没有提交 merge，但是已经进行了 merge，于是 git status 查看本地仓库的状态如下：\n</code></pre></div><p><img src=\"@source/lango-tech/develop_guide/images/app_develop_guide/19.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>因为我们想执行的是 rebase 合并，而现在又处于 merge 合并中，\n所以现在得先取消并回退到 merge 合并前的状态，即执行命令： git reset --merge，\n然后 git status 查看本地仓库的状态如下：\n</code></pre></div><p><img src=\"@source/lango-tech/develop_guide/images/app_develop_guide/20.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>此时，回到了 执行 git pull 之前的状态，也就是执行 git pull --rebase 后的状态。\n这个时候，需要执行 git rebase 命令，手动进行 rebase 合并。如下所示\n（git rebase 表示手动变基远程分支到本地分支，如果执行后有冲突，再进行解决）\n</code></pre></div><p><img src=\"@source/lango-tech/develop_guide/images/app_develop_guide/21.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>由于没有冲突，也就相当于成功完成了 rebase 合并。执行 git status 查看状态如下：\n</code></pre></div><p><img src=\"@source/lango-tech/develop_guide/images/app_develop_guide/22.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>此时，这里的 2 次提交，就是本地在未拉取远程最新代码前 push 到 Gerrit 上的提交，\n等 Gerrit 上进行了 review 和 submit 操作后，再执行 git pull --rebase 就可以了。\n\n执行 git log 也可以看到，之前未拉取的远程的最新提交也成功 rebase 到本地仓库了，如下所示：\n</code></pre></div><p><img src=\"@source/lango-tech/develop_guide/images/app_develop_guide/23.png\" alt=\"\" loading=\"lazy\"></p>\n<h5 id=\"_1-4-2-7-在-windows-凭据管理器中查看和编辑-gerrit-账号和-token\" tabindex=\"-1\"> 1.4.2.7 在 <code>Windows</code> 凭据管理器中查看和编辑 <code>Gerrit</code> 账号和 <code>Token</code></h5>\n<p>如果你所使用的电脑，之前已经登录过其他人的 <code>Gerrit</code> 账号，那么你可能需要将 <code>Windows</code> 中保存的其他人的 <code>Gerrit</code> 账号信息修改成你自己的，如下图所示，在 <code>Windows</code> 的凭据管理器中进行修改即可：</p>\n<p><img src=\"@source/lango-tech/develop_guide/images/app_develop_guide/24.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_1-5-svn-apk-管理\" tabindex=\"-1\"> 1.5 <code>SVN</code> &amp; <code>Apk</code> 管理</h3>\n<blockquote>\n<p>双击软件工具包中的 <code>TortoiseSVN-1.9.6.27867-x64-svn-1.9.6.msi</code> 安装 <code>SVN</code>。</p>\n</blockquote>\n<p>安装后打开 <code>TortoiseSVN Repository Browser</code>，如下图所示：</p>\n<blockquote>\n<p>注意：</p>\n<ol>\n<li>\n<p>按 <code>win</code> 键，搜索 <code>TortoiseSVN Repository Browser</code> 即可打开；</p>\n</li>\n<li>\n<p>打开前需要将加密软件中的业务模式切换到个人模式。</p>\n</li>\n<li>\n<p><code>SVN</code> 的登录账号和密码和 <code>Gerrit</code> 的一样。</p>\n</li>\n</ol>\n</blockquote>\n<p><img src=\"@source/lango-tech/develop_guide/images/app_develop_guide/25.png\" alt=\"\" loading=\"lazy\"></p>\n<p>如上所示，在个人模式下输入地址 <a href=\"http://192.168.1.182:8088/scm/svn/ReleaseApk/xbh2\" target=\"_blank\" rel=\"noopener noreferrer\">http://192.168.1.182:8088/scm/svn/ReleaseApk/xbh2<ExternalLinkIcon/></a>，点击 <code>OK</code> 按钮，即可打开 <code>SVN</code> 上保存的所有项目的 <code>Apk</code> 文件：</p>\n<p><img src=\"@source/lango-tech/develop_guide/images/app_develop_guide/26.png\" alt=\"\" loading=\"lazy\"></p>\n<p>上传 <code>apk</code> 文件到 <code>SVN</code> 的方式如下图所示：</p>\n<p><img src=\"@source/lango-tech/develop_guide/images/app_develop_guide/27.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>右击某个 <code>apk</code> 文件，依次点击 <code>Copy to clipboard</code> -&gt; <code>Urls</code> 即可复制该 <code>apk</code> 文件在 <code>SVN</code> 上的链接地址。</p>\n</blockquote>\n<h3 id=\"_1-6-串口调试\" tabindex=\"-1\"> 1.6 串口调试</h3>\n<h4 id=\"_1-6-1-xshell-串口日志打印\" tabindex=\"-1\"> 1.6.1 <code>Xshell</code> &amp; 串口日志打印</h4>\n<p>除了通过 <code>adb</code> 无线连接设备打印日志外，我们还可以通过 <code>Xshell</code> 串口连接设备来打印日志。另外，当设备无法启动 <code>Android</code> 系统时，也可以通过 <code>Xshell</code> 串口连接设备来查看是否有错误日志。并且，在设备刷固件的过程中，也会通过 <code>Xshell</code> 串口连接设备来输入某些指令。</p>\n<p>通过 <code>Xshell</code> 串口连接设备的步骤如下：</p>\n<ol>\n<li>\n<p>首先需要申请一根串口线（<code>USB</code> 转 <code>RS232</code> 的接口线），并连接电脑（<code>USB</code>）和设备（<code>RS232</code>）。</p>\n</li>\n<li>\n<p>查看串口线连接时所占用的端口号</p>\n<p><img src=\"@source/lango-tech/develop_guide/images/app_develop_guide/28.png\" alt=\"\" loading=\"lazy\"></p>\n</li>\n<li>\n<p>解压软件工具包中的 <code>XshellPlus 6.0.0026.7z</code> 压缩文件，双击 <code>Xshell.exe</code> 打开 <code>Xshell</code> 程序。</p>\n</li>\n<li>\n<p>在 <code>Xshell</code> 中配置串口的方式如下图所示：</p>\n<p><img src=\"@source/lango-tech/develop_guide/images/app_develop_guide/29.png\" alt=\"\" loading=\"lazy\"></p>\n<p><img src=\"@source/lango-tech/develop_guide/images/app_develop_guide/30.png\" alt=\"\" loading=\"lazy\"></p>\n</li>\n</ol>\n<p>当串口连接设备成功后，<code>Xshell</code> 中的会话就处于设备的终端上了，如下图所示：</p>\n<p><img src=\"@source/lango-tech/develop_guide/images/app_develop_guide/31.png\" alt=\"\" loading=\"lazy\"></p>\n<p>此时，1.4.1 小节介绍的 <code>adb</code> 命令中：</p>\n<div><pre><code>1. 以 \"adb shell\" 开头的命令，去掉开头的 \"adb shell\"，就是可以在设备终端上执行的命令；\n2. 以 \"adb logcat\" 开头的日志打印命令，去掉开头的 \"adb\"，就是可以在设备终端上执行的日志打印命令。\n3. 设备终端上获取 root 权限的命令如下：\n    su # 找不到此命令，执行 xbhsu\n    remount\n</code></pre></div><blockquote>\n<p>注意：</p>\n<ol>\n<li>\n<p>可以通过快捷键 <code>Crtl+Shift+R</code> 连接设备的串口；</p>\n</li>\n<li>\n<p>可以通过快捷键 <code>Alt+C</code> 断开设备的串口连接。</p>\n</li>\n</ol>\n</blockquote>\n<h4 id=\"_1-6-2-多功能串行口调试助手-串口指令下发\" tabindex=\"-1\"> 1.6.2 多功能串行口调试助手 &amp; 串口指令下发</h4>\n<blockquote>\n<p>双击软件工具包中的 <code>多功能串行口调试助手.exe</code> 即可打开使用。</p>\n<p><strong>注意：</strong> 在多功能串行口调试助手中连接串口前，要先断开 <code>Xshell</code> 中的串口连接。</p>\n</blockquote>\n<p>多功能串行口调试助手的界面如下图所示：</p>\n<p><img src=\"@source/lango-tech/develop_guide/images/app_develop_guide/32.png\" alt=\"\" loading=\"lazy\"></p>\n<p>常用的串口指令可以参考文档：<a href=\"https://doc.weixin.qq.com/sheet/e3_AToAmAYMAE8dPMux4W8Ta6EWnv3Xw?scode=ABUAPgfAABA4CFZrLk\" target=\"_blank\" rel=\"noopener noreferrer\">《V100-RS232指令》<ExternalLinkIcon/></a></p>\n<p>如当系统的电源状态中的上电状态设置为上电待机时，断电重启不会进入 <code>Android</code> 系统，而是屏幕白屏，此时在没有按键板的条件下，可以通过多功能串行口调试助手连接串口，下发开机的串口指令即可进入 <code>Android</code> 系统。</p>\n<blockquote>\n<p>开机的串口指令见文档 《<code>V100-RS232</code>指令》，即：</p>\n<p><img src=\"@source/lango-tech/develop_guide/images/app_develop_guide/33.png\" alt=\"\" loading=\"lazy\"></p>\n<p>设备的上电状态可以在系统设置中查看，如下所示：</p>\n<p><img src=\"@source/lango-tech/develop_guide/images/app_develop_guide/34.png\" alt=\"\" loading=\"lazy\"></p>\n</blockquote>\n<h3 id=\"_1-7-投屏工具-scrcpy\" tabindex=\"-1\"> 1.7 投屏工具 <code>scrcpy</code></h3>\n<blockquote>\n<p>解压软件工具包中的 <code>scrcpy-win64-v2.4.zip</code>，并将解压目录添加到环境变量 <code>Path</code> 中即可。</p>\n<p>注意：解压目录中包含 <code>adb.exe</code>，为了优先使用 <code>sdk manager</code> 中的 <code>adb</code>，在环境变量 <code>Path</code> 中，解压目录应该添加到 <code>sdk\\platform-tools</code> 后面。</p>\n</blockquote>\n<p>将解压目录添加到环境变量中后，打开 <code>windows</code> 命令行终端，输入 <code>scrcpy</code> 按回车即可打开投屏工具。</p>\n<p><strong>注意：</strong> 打开投屏工具前，确保 <code>adb</code> 已经成功连接了设备。</p>\n<p><strong>投屏工具的使用场景：</strong></p>\n<ol>\n<li>多人共用一台设备时，因为设备可能不在自己工位旁，此时如果需要与设备进行交互，使用投屏工具在电脑上访问设备进行交互即可。</li>\n<li>当要在设备中输入文本时，如输入邮箱，使用投屏工具在电脑上访问设备，用键盘输入会更快些。</li>\n</ol>\n<h3 id=\"_1-8-工作管理平台-ones\" tabindex=\"-1\"> 1.8 工作管理平台 <code>ones</code></h3>\n<p>在企业微信的【邮件】中添加了企业邮箱后，访问 <code>ones</code> 激活链接：<a href=\"https://ones.lango-tech.com:7000/project/#/auth/login/email\" target=\"_blank\" rel=\"noopener noreferrer\">https://ones.lango-tech.com:7000/project/#/auth/login/email<ExternalLinkIcon/></a></p>\n<p><img src=\"@source/lango-tech/develop_guide/images/app_develop_guide/35.png\" alt=\"\" loading=\"lazy\"></p>\n<p><code>ones</code> 工作管理平台的相关介绍如下图所示：</p>\n<p><img src=\"@source/lango-tech/develop_guide/images/app_develop_guide/36.png\" alt=\"\" loading=\"lazy\"></p>\n<hr>\n<p><img src=\"@source/lango-tech/develop_guide/images/app_develop_guide/37.png\" alt=\"\" loading=\"lazy\"></p>\n<p>我们在处理某个需求或 <code>BUG</code> 任务时，在 <code>ones</code> 上的大致操作流程描述如下：</p>\n<div><pre><code>1. 当前状态：\n    新 -> 待处理 -> 处理中 -> 已解决\n                          -> 继续跟踪\n                          -> Backlog\n\n    一个 BUG 指派给你时，状态为 \"新\"，如果你要处理，但还未开始处理，状态改为 \"待处理\"；\n    一个 \"待处理\" 的 BUG 在开始处理时，状态改为 \"处理中\"；（注意：此时如果该 BUG 还未预估工时，请联系尚生达帮你预估工时）\n    一个 \"处理中\" 的 BUG 处理完成后，状态改为 \"已解决\"；（注意：此时需要登录工时，一般填写预估的工时即可）\n    一个 \"处理中\" 的 BUG 无法复现时，状态改为 \"继续跟踪\"；\n    \"Backlog\" 状态表示将 BUG 打回，不进行处理。使用场景较少，设置此状态时先跟你的上级沟通下。\n\n    对于需求任务来说，不存在 \"继续跟踪\" 的状态。其他跟处理 BUG 任务类似。\n\n2. 关联内容：\n    当 BUG 任务与其他 BUG 描述的问题重复时，应该将其他重复了的 BUG 添加到关联内容中来。\n\n3. 文件：\n    测试在提 BUG 时，会将 BUG 相关的日志、视频、图片等相关文件上传到此处。\n\n4. 工时：\n    查看该需求或 BUG 任务下的预估工时、已登记工时、剩余工时。\n\n5. 评论：\n    编写与该需求或 BUG 任务相关的评论。\n    如你在解决了 BUG 后，可以将上传到 SVN 上的 apk 链接地址复制到评论中。\n    又如，当 BUG 需要转给其他人处理时，你需要在评论中写下转出的原因。\n</code></pre></div><p><img src=\"@source/lango-tech/develop_guide/images/app_develop_guide/38.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_2-项目介绍\" tabindex=\"-1\"> 2. 项目介绍</h2>\n<h3 id=\"_2-1-平台介绍-刷固件\" tabindex=\"-1\"> 2.1 平台介绍 &amp; 刷固件</h3>\n<p>所谓的平台其实就是设备的板卡型号，目前，本人所接触到的板卡型号大概有如下几种：</p>\n<div><pre><code>1. G6780\n2. 311D2\n3. 8195\n4. 9679\n</code></pre></div><blockquote>\n<p>其中，<code>G6780</code> 平台和 <code>G6760</code> 平台又统称为 <code>V100</code> 平台。</p>\n</blockquote>\n<p>刷固件简单理解就是更新 <code>Android</code> 系统。目前，本人仅了解 <code>6780</code> 平台和 <code>311D2</code> 平台上刷固件的方式，介绍如下。</p>\n<h4 id=\"_2-1-1-在-g6780-平台上刷固件\" tabindex=\"-1\"> 2.1.1 在 <code>G6780</code> 平台上刷固件</h4>\n<p>当需要你在 <code>G6780</code> 平台上刷固件时，会提供一份 <code>bin</code> 文件给你。接下来的步骤如下：</p>\n<ol>\n<li>\n<p>将 <code>bin</code> 文件下载并拷贝到 U 盘，插入 U 盘到设备的板卡上。</p>\n</li>\n<li>\n<p>在设备上依次操作：进入系统设置 -&gt; 关于本机 -&gt; 点击 10 下</p>\n<p><img src=\"@source/lango-tech/develop_guide/images/app_develop_guide/39.png\" alt=\"\" loading=\"lazy\"></p>\n</li>\n<li>\n<p>在弹窗中依次点击 <code>UPGRADE AND BURN</code> -&gt; <code>FW Local Upgrade</code> 即可：</p>\n<p><img src=\"@source/lango-tech/develop_guide/images/app_develop_guide/40.png\" alt=\"\" loading=\"lazy\"></p>\n</li>\n</ol>\n<p>以上 3 步骤操作后，设备会自动读取 U 盘中的 <code>bin</code> 文件，并重启升级。当升级完成后，会自动重启并进入升级后的 <code>Android</code> 系统。</p>\n<p><strong>注意：</strong></p>\n<p>升级后的屏幕可能会出现重影，需要再次进入系统设置 -&gt; 关于本机 -&gt; 点击 10 下，在 <code>FactoryMenu</code> 弹窗中点击 <code>DEBUG</code> 进入 <code>DEBUG</code> 弹窗，将 <code>Panel Index</code> 由 1 改为 0 即可。</p>\n<blockquote>\n<p>9679 平台的屏参出现问题时，注意看 <code>DEBUG</code> 弹窗中的 <code>Panel Single / Duo</code> 是否设置为 <code>Single</code>。</p>\n</blockquote>\n<h4 id=\"_2-1-2-在-311d2-平台上刷固件\" tabindex=\"-1\"> 2.1.2 在 <code>311D2</code> 平台上刷固件</h4>\n<p><code>311D2</code> 平台刷固件时，要确认下固件是几 <code>G</code> 内存的，应该不能混刷，比如固件是 <code>8G</code> 内存的,板子也要找 <code>8G</code> 内存的板子。</p>\n<p>查看板子的版本信息：</p>\n<div><pre><code>进入系统设置 -> 关于本机 -> 点击 10 下，在 Factory Menu 弹窗中的 SW Model Name 就是版本信息。\n其中， xxx_xxx_xxx_A311D2_8192M_128G_xxx_xxx_xxx 表示 8G 内存，128G 硬盘\n</code></pre></div><p><code>311D2</code> 平台提供的固件文件是 <code>zip</code> 压缩文件。刷固件步骤如下：</p>\n<ol>\n<li>解压 <code>zip</code> 包，得到 <code>img</code> 文件，拷贝到 U 盘，插入板子；</li>\n<li>断开电源，然后插入电源的同时，在 <code>Xshell</code> 的串口终端上不断按 <code>enter</code> 键，直到从 <code>log</code> 日志输出进入命令输入模式，然后执行命令 <code>run custar</code> 即可。</li>\n</ol>\n<h3 id=\"_2-2-app-项目的仓库-分支-渠道介绍\" tabindex=\"-1\"> 2.2 <code>App</code> 项目的仓库 &amp; 分支 &amp; 渠道介绍</h3>\n<p><strong>常见的 <code>App</code> 名称和仓库名称的对照表如下所示：</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">App 名称</th>\n<th style=\"text-align:left\">仓库名称</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Launcher3.0</td>\n<td style=\"text-align:left\">Launcher3.0</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Launcher5.0</td>\n<td style=\"text-align:left\">Launcher5.0</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">XbhSystemUI（SUI）</td>\n<td style=\"text-align:left\">XbhSystemUI</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">侧边栏</td>\n<td style=\"text-align:left\">NavigationEdu2.0</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">罗盘</td>\n<td style=\"text-align:left\">XbhFloatMenu</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">系统设置</td>\n<td style=\"text-align:left\">SystemSetting_Edu2.0</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">快捷设置</td>\n<td style=\"text-align:left\">XbhQuickSettings</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">文件管理器</td>\n<td style=\"text-align:left\">XBHFM</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">白板</td>\n<td style=\"text-align:left\">XBHWhiteBoard4.0</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">白板浏览器</td>\n<td style=\"text-align:left\">XbhBrowser</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">中间件3.0</td>\n<td style=\"text-align:left\">MiddleWare3.0、CusSdk3.0</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">中间件4.0</td>\n<td style=\"text-align:left\">MiddleWare4.0、CusSdk4.0</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">中间件5.0</td>\n<td style=\"text-align:left\">MiddleWare5.0、CusSdk5.0</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">DMS</td>\n<td style=\"text-align:left\">XbhAdverPlayer3.0</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">欢迎页面</td>\n<td style=\"text-align:left\">XbhWelcome2.0</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">日历</td>\n<td style=\"text-align:left\">XbhCalendar</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">工厂测试</td>\n<td style=\"text-align:left\">LangoFCT_Edison</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">工具类组件</td>\n<td style=\"text-align:left\">XbhBaseAbility</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">快速开发框架</td>\n<td style=\"text-align:left\">XbhBase</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>注意：</p>\n<ol>\n<li>\n<p>如上所示，根据仓库名称在 <code>Gerrit</code> 上的 <code>BROWSE -&gt; Repositories</code> 界面中搜索仓库即可。如果未搜索到，那么就是你没有访问权限，联系负责人开通权限即可。</p>\n</li>\n<li>\n<p>中间件有 3.0、4.0、5.0 这几个版本，每个版本对应两个仓库，其中 <code>CusSdk</code> 可以理解为将中间件封装成 <code>SDK</code> 给外部使用，而 <code>MiddleWare3</code> 则可以理解为中间件内部的具体实现。</p>\n</li>\n<li>\n<p><code>DMS</code> 具体地是对应 <code>XbhAdverPlayer3.0</code> 仓库的 <code>develop-dms</code> 分支。</p>\n</li>\n<li>\n<p>工具类组件和快速开发框架的介绍，参考文档 <a href=\"https://ones.lango-tech.com:7000/wiki/#/team/N1EEt2Js/space/2cDdkWBW/page/W3otPXok\" target=\"_blank\" rel=\"noopener noreferrer\">组件规范<ExternalLinkIcon/></a>、<a href=\"https://ones.lango-tech.com:7000/wiki/#/team/N1EEt2Js/space/2cDdkWBW/page/Tb7L2roY\" target=\"_blank\" rel=\"noopener noreferrer\">工具类组件<ExternalLinkIcon/></a>、<a href=\"https://ones.lango-tech.com:7000/wiki/#/team/N1EEt2Js/space/2cDdkWBW/page/63u6SwNZ\" target=\"_blank\" rel=\"noopener noreferrer\">快速开发框架<ExternalLinkIcon/></a></p>\n</li>\n<li>\n<p>还有部分未列举的 <code>App</code> 项目，可以在文档 <a href=\"https://doc.weixin.qq.com/sheet/e3_m_IQuvijjMwcfR?scode=ABUAPgfAABANzMo2x2AU8A5gaLAP8&amp;tab=vsk2t3\" target=\"_blank\" rel=\"noopener noreferrer\">APP项目提测版本号统计表<ExternalLinkIcon/></a> 中看到。</p>\n</li>\n</ol>\n</blockquote>\n<p><strong>下面简单地介绍下仓库的分支。</strong></p>\n<p>如下图所示，列举了部分仓库的所有分支，可以看到，有的仓库下存在大量的不同分支。</p>\n<p><img src=\"@source/lango-tech/develop_guide/images/app_develop_guide/41.png\" alt=\"\" loading=\"lazy\"></p>\n<p>一开始，不需要你一个一个去理清每个分支的使用场景，只需要大概知道以下几点：</p>\n<ol>\n<li>\n<p>仓库分支，原则上是根据板卡型号（平台）来创建的，比如：</p>\n<div><pre><code>release-g6780-common 分支对应 G6780 平台的公版\nrelease-a311d2-android13 分支对应 311D2 平台的公版\nrelease-edla-common 分支对应 8195 平台的公版\ndevelop-5.0 分支对应 9679 平台的公版\n</code></pre></div></li>\n<li>\n<p>第 1 点中提到了公版的概念，这是因为在同一个平台上，面对不同的客户可能需要做定制（即客制化）。原则上，客制化不应该新建分支，而是在分支中以渠道的形式来区分。但是，有的客制化改动较大，项目代码很难以渠道的形式兼容，所以才新建了分支。</p>\n<blockquote>\n<p>也就是说，不同分支，可能是对应不同平台，也可能是对应同一平台下的不同客制化。当然，也可能还存在其他的情况。</p>\n</blockquote>\n</li>\n<li>\n<p>因此，当你需要修改某个项目的代码时，首先要跟负责人确认清楚是在哪个分支上开发。</p>\n</li>\n</ol>\n<p><strong>下面再简单地介绍下渠道</strong></p>\n<p>在上面介绍分支时，已经说明了渠道的作用是兼容同一平台（板卡型号）下不同的客制化需求。渠道一般配置在 <code>Application</code> 模块的 <code>build.gradle</code> 文件中，如下图所示：</p>\n<blockquote>\n<p>有的项目可能会配置在 <code>Application</code> 模块的 <code>apkInfo.gradle</code> 文件中，如 <code>XbhAdverPlayer3.0</code> 仓库下 <code>develop</code> 分支 。</p>\n</blockquote>\n<p><img src=\"@source/lango-tech/develop_guide/images/app_develop_guide/42.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>注意：</strong></p>\n<p>如果在 <code>AndroidStudio</code> 右侧的 <code>Gradle</code> 面板中没有显示 <code>build/assembleXxx</code> 任务，那么需要在设置中勾选如下：</p>\n<p><img src=\"@source/lango-tech/develop_guide/images/app_develop_guide/43.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_3-常见问题\" tabindex=\"-1\"> 3. 常见问题</h2>\n<h3 id=\"_3-1-apk-文件的命名规则\" tabindex=\"-1\"> 3.1 <code>Apk</code> 文件的命名规则</h3>\n<p><code>apk</code> 的命名规则大致如下：</p>\n<div><pre><code>&lt;apkName>_&lt;flavor>_&lt;tag>.&lt;基于该 tag 的提交次数>_&lt;最新提交的 commit id>.apk\n</code></pre></div><blockquote>\n<p><code>apk</code> 命名的生成代码可以参考各个项目代码中的 <code>Application</code> 模块中的 <code>apkInfo.gradle</code> 脚本文件。</p>\n</blockquote>\n<h3 id=\"_3-2-如何查看设备中-app-的版本信息\" tabindex=\"-1\"> 3.2 如何查看设备中 <code>App</code> 的版本信息</h3>\n<div><pre><code>通过查看设备中 /system/apkInfos.properties 文件可以知道该设备的固件中所安装的 apk 文件名，\n通过 apk 文件名可以知道对应的仓库，分支，和哪次提交时打的包（因为 apk 文件名最后一串字符串表示提交的 commit id）。\n如：\n    apkVersion=develop-common/XbhScreenRecorder_xbh_1.0.121.33_4d6bb23.apk\n    其中，分支为 develop-common，渠道 flavor 为 xbh，最后提交记录 commit id 为 4d6bb23\n</code></pre></div><blockquote>\n<p>如果仓库分支下找不到 <code>commit id</code> 对应的提交记录，那么应该是在 <code>rebase</code> 合并代码时对 <code>commit id</code> 进行了自动修改。</p>\n</blockquote>\n<h3 id=\"_3-3-adb-install-安装-launcher-5-0-提示-persistent-apps-are-not-updateable\" tabindex=\"-1\"> 3.3 <code>adb install</code> 安装 <code>Launcher 5.0</code> 提示 <code>Persistent apps are not updateable</code></h3>\n<div><pre><code>原因：\n之前 push 到 /system/app/XbhLauncher/ 下的是 apk，\n是清单文件中设置了 android:persistent=\"true\" 的 apk，该属性决定了不允许 apk 通过 install 的方式进行更新。\n\n解决方式：\n在清单文件中将 android:persistent 改为 false，重新打个 apk 包 push 到 /system/app/XbhLauncher/ 中，\n之后就可以通过 adb install 安装了。\n\n注意：\n将 android:persistent 改为 false 只是为了 push 一个非 persistent 的 app 到 system/app 下，\n方面通过 adb install 安装或者在 AndroidStudio 中直接运行 app，简化调试步骤。\n但是 android:persistent 一定要还原成 true 后才能提交代码，不能将 false 提交到远程仓库中。\n</code></pre></div><h3 id=\"_3-4-app-模块-和-lib-模块的命名空间相同时-r-资源文件访问异常\" tabindex=\"-1\"> 3.4 <code>app</code> 模块 和 <code>lib</code> 模块的命名空间相同时，<code>R</code> 资源文件访问异常</h3>\n<div><pre><code>首先，需要明确一点，不同模块的命名空间不应该相同。如果相同，需要进行修改。\n\n如果要已当前模块的命名空间中的 R 来访问依赖模块中的资源，\n需要在 gradle.properties 文件中设置 android.nonTransitiveRClass = false，\n表示当前模块的 R 可以引用依赖模块中的资源。\n</code></pre></div><h3 id=\"_3-5-adb-无法连接-提示-could-not-read-ok-from-adb-server\" tabindex=\"-1\"> 3.5 <code>adb</code> 无法连接，提示 <code>could not read ok from ADB Server</code></h3>\n<p>执行 <code>adb devices</code> 提示：</p>\n<div><pre><code>List of devices attached\n* daemon not running; starting now at tcp:5037\ncould not read ok from ADB Server\n* failed to start daemon\n</code></pre></div><p>此时，需要查看 5037 端口是否被占用，并杀掉占用的进程。</p>\n<div><pre><code><span>netstat</span> -aon<span>|</span>findstr <span>\"5037\"</span>  <span># 查找 5037 端口是否被占用</span>\ntasklist<span>|</span>findstr <span>\"28576\"</span>     <span># 列出占用 5037 端口的进程 id 的应用程序</span>\ntaskkill -f -im xxx.exe      <span># 杀掉占用 5037 端口的应用程序</span>\n</code></pre></div><h3 id=\"_3-6-使用-webview-报异常-for-security-reasons-webview-is-not-allowed-in-privileged\" tabindex=\"-1\"> 3.6 使用 <code>WebView</code> 报异常：<code>For security reasons, WebView is not allowed in privileged</code></h3>\n<div><pre><code>这是因为使用 WebView 的 App 是系统级别的，即在 AndroidManifest.xml 中添加了 android:sharedUserId=\"android.uid.system\"。\n此时，Google 基于安全问题考虑，限制了 webview 控件在系统级别的 App 中使用。\n\n解决方式是在将 WebView 相关的功能模块抽离出来，放到其他非系统级别的 App 中，这也是白板浏览器 XbhBrowser 项目存在的原因 ~\n</code></pre></div>",
      "date_published": "2024-05-29T12:19:28.000Z",
      "date_modified": "2024-05-30T07:26:07.000Z",
      "authors": [],
      "tags": [
        "朗国科技"
      ]
    },
    {
      "title": "入门指南",
      "url": "https://zengkaiqiang562.github.io/lango-tech/develop_guide/primer.html",
      "id": "https://zengkaiqiang562.github.io/lango-tech/develop_guide/primer.html",
      "content_html": "<h2 id=\"_1-软件介绍\" tabindex=\"-1\"> 1. 软件介绍</h2>\n<h3 id=\"_1-1-代码管理-——-gerrit\" tabindex=\"-1\"> 1.1 代码管理 —— <code>Gerrit</code></h3>\n<p><strong>准备工作</strong></p>\n<ol>\n<li>\n<p>安装 <code>Git-2.16.1.2-64-bit</code> 版本的 <code>Git</code> 客户端</p>\n</li>\n<li>\n<p>找管理员（邓嘉俊）申请 <code>Gerrit</code> 的账号/密码</p>\n</li>\n<li>\n<p>登录 <a href=\"http://192.168.1.194:8092/\" target=\"_blank\" rel=\"noopener noreferrer\"><code>Gerrit</code> 网页端<ExternalLinkIcon/></a></p>\n</li>\n<li>\n<p>在 <code>Gerrit</code> 网页端中进行邮箱验证</p>\n<div><pre><code>邮箱的账号/密码找谭俊英申请。验证步骤如下图所示：\n</code></pre></div><p><img src=\"@source/lango-tech/develop_guide/images/primer/01.png\" alt=\"\" loading=\"lazy\"></p>\n<p><img src=\"@source/lango-tech/develop_guide/images/primer/02.png\" alt=\"\" loading=\"lazy\"></p>\n<p><img src=\"@source/lango-tech/develop_guide/images/primer/03.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>注意：不要直接点击邮箱验证链接，如果链接中的端口号为 <code>8091</code>，那么需要手动改成 <code>8092</code> 后再进行验证</p>\n</blockquote>\n<p><img src=\"@source/lango-tech/develop_guide/images/primer/04.png\" alt=\"\" loading=\"lazy\"></p>\n</li>\n<li>\n<p>在 <code>Gerrit</code> 网页端中生成 <code>Token</code></p>\n<div><pre><code>当我们在本地访问 Gerrit 仓库时（如 clone 仓库），会用到这个 Token（相当于密码）。\nToken 的生成方式如下图所示：\n</code></pre></div><p><img src=\"@source/lango-tech/develop_guide/images/primer/05.png\" alt=\"\" loading=\"lazy\"></p>\n</li>\n</ol>\n<p><strong>克隆仓库代码</strong></p>\n<p>依次点击 <code>Gerrit</code> 网页端顶部导航栏：<code>BROWSE -&gt; Respositories</code> 进入仓库列表。</p>\n<blockquote>\n<p>如果仓库列表中除了 <code>testing</code> 和 <code>AllUser</code> 外无其他仓库，找何仲春申请代码仓库权限。</p>\n</blockquote>\n<p>下面以 Launcher3.0 为例介绍仓库的克隆步骤</p>\n<div><pre><code>\n</code></pre></div><h3 id=\"_1-2-apk-管理-——-svn\" tabindex=\"-1\"> 1.2 Apk 管理 —— <code>SVN</code></h3>\n<h3 id=\"_1-3-串口调试终端-——-xshell\" tabindex=\"-1\"> 1.3 串口调试终端 —— <code>Xshell</code></h3>\n<h3 id=\"_1-4-需求-bug-管理-——-ones\" tabindex=\"-1\"> 1.4 需求 / <code>BUG</code> 管理 —— <code>ones</code></h3>\n<h3 id=\"_1-5-网络环境-——-朗国电子助手-讯软-des-客户端\" tabindex=\"-1\"> 1.5 网络环境 —— 朗国电子助手 &amp; 讯软 <code>DES</code> 客户端</h3>\n<h3 id=\"_1-6-adb-调试终端-——-cmder\" tabindex=\"-1\"> 1.6 ADB 调试终端 —— <code>Cmder</code></h3>\n<h2 id=\"_2-项目介绍\" tabindex=\"-1\"> 2. 项目介绍</h2>\n<h3 id=\"_2-1-板卡型号-项目分支\" tabindex=\"-1\"> 2.1 板卡型号 &amp; 项目分支</h3>\n<h3 id=\"_2-2-客制化-项目渠道\" tabindex=\"-1\"> 2.2 客制化 &amp; 项目渠道</h3>\n<h3 id=\"_2-3-如何刷固件\" tabindex=\"-1\"> 2.3 如何刷固件</h3>\n<h3 id=\"_2-4-apk-的编译安装\" tabindex=\"-1\"> 2.4 <code>Apk</code> 的编译安装</h3>\n<h2 id=\"_3-注意事项\" tabindex=\"-1\"> 3. 注意事项</h2>\n",
      "date_published": "2024-05-29T12:19:28.000Z",
      "date_modified": "2024-05-29T12:19:28.000Z",
      "authors": [],
      "tags": [
        "朗国科技"
      ]
    },
    {
      "title": "开发指引",
      "url": "https://zengkaiqiang562.github.io/lango-tech/develop_guide/",
      "id": "https://zengkaiqiang562.github.io/lango-tech/develop_guide/",
      "content_html": "",
      "date_published": "2024-05-29T12:19:28.000Z",
      "date_modified": "2024-05-29T12:19:28.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "上传下载组件",
      "url": "https://zengkaiqiang562.github.io/lango-tech/module_mgr/file_transfer.html",
      "id": "https://zengkaiqiang562.github.io/lango-tech/module_mgr/file_transfer.html",
      "content_html": "<p>上传下载组件作为 <code>Android Library</code> 模块写在仓库 <code>XbhBaseAbility</code> 的分支 <code>develop_transfer</code> 中，模块名为 <code>lib_transfer</code>。</p>\n<p>提供文件上传和文件下载的功能。</p>\n<h2 id=\"_1-下载模块\" tabindex=\"-1\"> 1. 下载模块</h2>\n<p>基于开源项目 <a href=\"https://github.com/lingochamp/FileDownloader\" target=\"_blank\" rel=\"noopener noreferrer\">FileDownloader<ExternalLinkIcon/></a> 进行封装。</p>\n<p>对于需求：</p>\n<div><pre><code>1、支持断点续传\n2、支持进度回调\n3、支持暂停和继续\n4、支持多线程下载\n</code></pre></div><p><code>FileDownloader</code> 都能满足。</p>\n<p><code>FileDownloader</code> 大致可分为如下几个模块：</p>\n<h3 id=\"_1-1-下载任务的构建模块\" tabindex=\"-1\"> 1.1 下载任务的构建模块</h3>\n<p>构建模块是面向用户的，用户只需关心如何构建下载任务，最后调用 <code>start</code> 方法即可进行下载。</p>\n<p>构建模块涉及到的类主要有如下三个：</p>\n<p><img src=\"@source/lango-tech/module_mgr/images/file_transfer/01.png\" alt=\"\" loading=\"lazy\"></p>\n<p><code>Xbh</code> 为前缀的接口是对开源项目 <code>FileDownloader</code> 进行了二次封装，对外屏蔽了不必要的 API。</p>\n<blockquote>\n<p>API 方法的功能描述参考：<a href=\"https://github.com/lingochamp/FileDownloader/blob/master/README-zh.md\" target=\"_blank\" rel=\"noopener noreferrer\">FileDownloader 的说明文档<ExternalLinkIcon/></a></p>\n</blockquote>\n<p>使用示例：</p>\n<div><pre><code><span>XbhFileDownloader</span><span>.</span><span>setup</span><span>(</span>cotext<span>)</span><span>;</span>\n<span>XbhFileDownloader</span> fileDownloader <span>=</span> <span>FileDownloader</span><span>.</span><span>getImpl</span><span>(</span><span>)</span><span>;</span>\n\n<span>XbhDownloadTask</span> downloadTask <span>=</span> fileDownloader<span>.</span><span>create</span><span>(</span>url<span>)</span><span>;</span>\ndownloadTask<span>.</span><span>setPath</span><span>(</span>path<span>)</span><span>;</span> <span>// 下载文件的存储绝对路径</span>\ndownloadTask<span>.</span><span>setCallbackProgressMinInterval</span><span>(</span><span>1000</span><span>)</span><span>;</span> <span>// 设置每个 FileDownloadListener#progress 之间回调间隔(ms)</span>\ndownloadTask<span>.</span><span>setAutoRetryTimes</span><span>(</span><span>3</span><span>)</span><span>;</span> <span>// 下载失败时自动重连 3 次</span>\ndownloadTask<span>.</span><span>setTag</span><span>(</span>KEY_1<span>,</span> obj1<span>)</span><span>;</span> <span>// 用于存储任意的变量方便回调中使用，以 key 作为索引</span>\ndownloadTask<span>.</span><span>setTag</span><span>(</span>KEY_2<span>,</span> obj2<span>)</span><span>;</span>\n\ndownloadTask<span>.</span><span>setListener</span><span>(</span><span>new</span> <span>XbhFileDownloadListener</span><span>(</span><span>)</span> <span>{</span>\n    <span>@Override</span>\n    <span>protected</span> <span>void</span> <span>pending</span><span>(</span><span>BaseDownloadTask</span> task<span>,</span> <span>int</span> soFarBytes<span>,</span> <span>int</span> totalBytes<span>)</span> <span>{</span><span>}</span>\n\n    <span>@Override</span>\n    <span>protected</span> <span>void</span> <span>connected</span><span>(</span><span>BaseDownloadTask</span> task<span>,</span> <span>String</span> etag<span>,</span> <span>boolean</span> isContinue<span>,</span> <span>int</span> soFarBytes<span>,</span> <span>int</span> totalBytes<span>)</span> <span>{</span><span>}</span>\n\n    <span>@Override</span>\n    <span>protected</span> <span>void</span> <span>progress</span><span>(</span><span>BaseDownloadTask</span> task<span>,</span> <span>int</span> soFarBytes<span>,</span> <span>int</span> totalBytes<span>)</span> <span>{</span>\n\n    <span>@Override</span>\n    <span>protected</span> <span>void</span> <span>blockComplete</span><span>(</span><span>BaseDownloadTask</span> task<span>)</span> <span>{</span><span>}</span>\n\n    <span>@Override</span>\n    <span>protected</span> <span>void</span> <span>retry</span><span>(</span><span>final</span> <span>BaseDownloadTask</span> task<span>,</span> <span>final</span> <span>Throwable</span> ex<span>,</span> <span>final</span> <span>int</span> retryingTimes<span>,</span> <span>final</span> <span>int</span> soFarBytes<span>)</span> <span>{</span><span>}</span>\n\n    <span>@Override</span>\n    <span>protected</span> <span>void</span> <span>completed</span><span>(</span><span>BaseDownloadTask</span> task<span>)</span> <span>{</span><span>}</span>\n\n    <span>@Override</span>\n    <span>protected</span> <span>void</span> <span>paused</span><span>(</span><span>BaseDownloadTask</span> task<span>,</span> <span>int</span> soFarBytes<span>,</span> <span>int</span> totalBytes<span>)</span> <span>{</span><span>}</span>\n\n    <span>@Override</span>\n    <span>protected</span> <span>void</span> <span>error</span><span>(</span><span>BaseDownloadTask</span> task<span>,</span> <span>Throwable</span> e<span>)</span> <span>{</span><span>}</span>\n\n    <span>@Override</span>\n    <span>protected</span> <span>void</span> <span>warn</span><span>(</span><span>BaseDownloadTask</span> task<span>)</span> <span>{</span><span>}</span>\n<span>}</span><span>)</span><span>;</span>\n\ndownloadTask<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><h3 id=\"_1-2-下载任务的分发模块\" tabindex=\"-1\"> 1.2 下载任务的分发模块</h3>\n<p>构建好的下载任务，在执行 <code>start()</code> 方法后，就会通过 <code>FileDownloadTaskLauncher</code> 分发到线程池中等待处理。线程池中最多允许三个线程并行执行，未立即执行的下载任务保存到工作队列中等待执行。线程池代码如下：</p>\n<div><pre><code><span>/* com.liulishuo.filedownloader.FileDownloadTaskLauncher.LaunchTaskPool */</span>\n<span>private</span> <span>void</span> <span>init</span><span>(</span><span>)</span> <span>{</span>\n    mWorkQueue <span>=</span> <span>new</span> <span>LinkedBlockingQueue</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    mPool <span>=</span> <span>FileDownloadExecutors</span><span>.</span><span>newDefaultThreadPool</span><span>(</span><span>3</span><span>,</span> mWorkQueue<span>,</span> <span>\"LauncherTask\"</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>分发模块的时序图如下：</p>\n<p><img src=\"@source/lango-tech/module_mgr/images/file_transfer/02.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_1-3-下载服务模块\" tabindex=\"-1\"> 1.3 下载服务模块</h3>\n<p><code>FileDownloader</code> 会启动一个服务组件 <code>FileDownloadService</code>， 并在 <code>App</code> 退到后台时，设置为前台服务，以保证下载任务所在的 <code>App</code> 界面退到后台时进程也不容易被杀掉。\n在 <code>FileDownloadService</code> 服务启动前，下载任务会被再次保存到 <code>LostServiceConnectedHandler</code> 的 <code>mWaitingList</code> 队列中。当服务启动后，再执行下载任务。</p>\n<p>基于 <code>FileDownloadService</code> 服务的下载任务处理时序图如下：</p>\n<p><img src=\"@source/lango-tech/module_mgr/images/file_transfer/03.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p><code>FileDownloader</code> 支持在单独的进程中执行下载任务，但会增加 <code>IPC</code> 回调带来的 <code>IO</code> 负担。实际使用场景中很少有在单独进程中执行下载任务的需求，因此暂不考虑在单独进程中进行下载在场景。</p>\n</blockquote>\n<blockquote>\n<p>在 <code>FileDownloadManager</code> 中会开始准备下载数据模型 <code>FileDownloadModel</code>，并更新到 <code>SQLite</code> 数据库 <code>RemitDatabase</code> 中。然后根据下载任务中配置的参数构建 <code>DownloadLaunchRunnable</code>，并提交到线程池中等待处理，相关时序图如下：</p>\n</blockquote>\n<p><img src=\"@source/lango-tech/module_mgr/images/file_transfer/04.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_1-4-下载核心模块\" tabindex=\"-1\"> 1.4 下载核心模块</h3>\n<p>该模块是真正处理下载过程的核心，下载过程可大致分为如下几个步骤：</p>\n<div><pre><code>step1. 检查网络环境，\n当设置了只允许在 Wifi 环境中下载时（isWifiRequired），检查到非 wifi 环境就取消下载。\n\nstep2. 建立网络连接\n配置用户自定义的请求头，以及断点下载所需要的请求头信息，然后通过 URLConnection 建立网络连接。\n获取响应状态吗，etag 信息，以及文件大小的字节数据\n\nstep3. \n从数据库中恢复之前已下载的字节数。\n对于断点下载的情况，若之前已有部分字节数据下载过了，则要从数据库中进行恢复，以便后面计算剩余的未下载字节数。\n\nstep4. \n判断存储空间是否足够下载剩余的字节数。\n如果本地存储空间不够保存剩余未下载的字节数，则会抛出异常，取消下载。\n\nstep5. 根据 totalLength 计算分块下载时的分块个数\nFileDownloadManager 不但支持断点下载，还支持分块下载，以提高大文件的下载速度。\n\nstep6. \n真正开始下载文件。\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>下载核心过程的时序图如下：</p>\n<p><img src=\"@source/lango-tech/module_mgr/images/file_transfer/05.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_2-上传模块\" tabindex=\"-1\"> 2. 上传模块</h2>\n<p>基于开源项目 <a href=\"https://github.com/gotev/android-upload-service\" target=\"_blank\" rel=\"noopener noreferrer\">android-upload-service<ExternalLinkIcon/></a> 进行封装。</p>\n<h2 id=\"_3-二次封装\" tabindex=\"-1\"> 3. 二次封装</h2>\n<h3 id=\"_3-1-下载模块的封装\" tabindex=\"-1\"> 3.1 下载模块的封装</h3>\n<ol>\n<li>\n<p><code>FileDownloader</code> 开源项目对外暴露了一些基本上用不到的 <code>API</code> 接口，二次封装时，会将这些 <code>API</code> 接口都先隐藏掉，后续再根据实际需要开放出来，或进行自定义扩展。减少用户初次使用时的学习成本。</p>\n</li>\n<li>\n<p>尽量减少对外暴露的接口。第一版计划只对外暴露三个接口：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">二次封装接口</th>\n<th style=\"text-align:left\">对应的开源项目中的接口</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">XbhFileDownloader</td>\n<td style=\"text-align:left\">FileDownloader</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">XbhFileDownloadTask</td>\n<td style=\"text-align:left\">FileDownloadTask</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">XbhFileDownloadListener</td>\n<td style=\"text-align:left\">FileDownloadListener</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>考虑到之前有同事可能使用过 <code>FileDownloader</code> 开源项目。二次封装的接口只是加前缀 &quot;<code>Xbh</code>&quot;，并隐藏原来的一些基本上用不到的 <code>API</code>。</p>\n</blockquote>\n</li>\n<li>\n<p><code>FileDownloader</code> 开源项目中对大文件（&gt;=1.99GB）要求使用 <code>FileDownloadLargeFileListener</code> 进行监听，并提供专门的 <code>getLargeFileSofarBytes/getLargeFileTotalBytes</code> 方法获取字节数据。二次封装时，计划对监听器和获取字节数据的方法进行统一，另外提供配置方法对是否是大文件进行标识。</p>\n</li>\n</ol>\n<h3 id=\"_3-2-上传模块的封装\" tabindex=\"-1\"> 3.2 上传模块的封装</h3>\n<p>上传模块使用的开源项目不同于下载模块，但二次封装时，计划基于下载模块的封装风格进行处理，即提供二次封装接口：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">二次封装接口</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">XbhFileUploader</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">XbhFileUploadTask</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">XbhFileUploadListener</td>\n</tr>\n</tbody>\n</table>\n<p>用于实现上传功能。</p>\n<p>封装原则也是基于接口隔离原则，第一版只提供必要的 API 接口，开源项目的中非必要接口后续再根据实际情况进行更新。</p>\n",
      "date_published": "2024-05-25T01:06:23.000Z",
      "date_modified": "2024-05-25T01:06:23.000Z",
      "authors": [],
      "tags": [
        "朗国科技"
      ]
    },
    {
      "title": "组件管理",
      "url": "https://zengkaiqiang562.github.io/lango-tech/module_mgr/",
      "id": "https://zengkaiqiang562.github.io/lango-tech/module_mgr/",
      "content_html": "",
      "date_published": "2024-05-25T01:06:23.000Z",
      "date_modified": "2024-05-25T01:06:23.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "项目管理",
      "url": "https://zengkaiqiang562.github.io/lango-tech/project_mgr/",
      "id": "https://zengkaiqiang562.github.io/lango-tech/project_mgr/",
      "content_html": "",
      "date_published": "2024-05-25T01:06:23.000Z",
      "date_modified": "2024-05-25T01:06:23.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "概览",
      "url": "https://zengkaiqiang562.github.io/lango-tech/project_mgr/summary.html",
      "id": "https://zengkaiqiang562.github.io/lango-tech/project_mgr/summary.html",
      "content_html": "<h2 id=\"_1-发行版\" tabindex=\"-1\"> 1. 发行版</h2>\n<blockquote>\n<p>参考：<a href=\"https://doc.weixin.qq.com/sheet/e3_m_IQuvijjMwcfR?scode=ABUAPgfAABAfPPjIU8\" target=\"_blank\" rel=\"noopener noreferrer\">APP项目提测版本号统计表<ExternalLinkIcon/></a></p>\n</blockquote>\n<h3 id=\"_1-1-公版-app-5-0\" tabindex=\"-1\"> 1.1 公版 App 5.0</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">APP</th>\n<th style=\"text-align:left\">APP名称</th>\n<th style=\"text-align:left\">仓库</th>\n<th style=\"text-align:left\">分支</th>\n<th style=\"text-align:left\">渠道</th>\n<th style=\"text-align:left\">最近的 APK 存储路径</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Launcher</td>\n<td style=\"text-align:left\">XbhLauncher</td>\n<td style=\"text-align:left\">Launcher5.0</td>\n<td style=\"text-align:left\">master</td>\n<td style=\"text-align:left\">xbh</td>\n<td style=\"text-align:left\">xbh2/XbhLauncher5/develop-5.0/XbhLauncher5_xbh_1.0.0.27_e05b2f8.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">快传</td>\n<td style=\"text-align:left\">XbhQuickPass</td>\n<td style=\"text-align:left\">Quickpass</td>\n<td style=\"text-align:left\">develop-5.0</td>\n<td style=\"text-align:left\">xbh</td>\n<td style=\"text-align:left\">xbh2/XbhQuickPass/develop-5.0/XbhQuickPass_xbh_1.0.0.0.96.19_fdae61c.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">欢迎页面</td>\n<td style=\"text-align:left\">XbhWelcome</td>\n<td style=\"text-align:left\">XbhWelcome2.0</td>\n<td style=\"text-align:left\">develop-5.0</td>\n<td style=\"text-align:left\">xbh</td>\n<td style=\"text-align:left\">xbh2/XbhWelcome/develop-5.0/XbhWelcome_xbh_560.2.0.2.2.35.50_57e2c57.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">侧边栏</td>\n<td style=\"text-align:left\">XbhNaviSetting</td>\n<td style=\"text-align:left\">NavigationEdu2.0</td>\n<td style=\"text-align:left\">develop-5.0</td>\n<td style=\"text-align:left\">xbh</td>\n<td style=\"text-align:left\">xbh2/XbhNaviSetting/develop-5.0/XbhNaviSetting_xbh_3.0.0.38.238_6504fbd2.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">白板批注</td>\n<td style=\"text-align:left\">XbhWhiteBoard</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">xbh2/XbhWhiteBoard4.0/dev_haier/XbhWhiteBoard_xbhSdk5_common_4.0.1.735_6cdc153c.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">罗盘</td>\n<td style=\"text-align:left\">XbhFloatMenu</td>\n<td style=\"text-align:left\">XbhFloatMenu</td>\n<td style=\"text-align:left\">develop-5.0</td>\n<td style=\"text-align:left\">xbh</td>\n<td style=\"text-align:left\">xbh2/XbhFloatMenu/develop-5.0/XbhFloatMenu_xbh_1.31.46_23e1e13.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">聚光灯</td>\n<td style=\"text-align:left\">XbhSpotlight</td>\n<td style=\"text-align:left\">XbhSpotlight</td>\n<td style=\"text-align:left\">develop-5.0</td>\n<td style=\"text-align:left\">xbh5</td>\n<td style=\"text-align:left\">xbh2/XbhSpotlight/develop-5.0/XbhSpotlight_xbh5_1.0.10.19_bc06b7d.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">SystemUI</td>\n<td style=\"text-align:left\">XbhSystemUI</td>\n<td style=\"text-align:left\">XbhSystemUI</td>\n<td style=\"text-align:left\">develop-5.0</td>\n<td style=\"text-align:left\">xbh</td>\n<td style=\"text-align:left\">xbh2/XbhSystemUI/develop-5.0/XbhSystemUI_xbh_1.0.257.139_76d1849c.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">白板内置浏览器</td>\n<td style=\"text-align:left\">XbhBrowser</td>\n<td style=\"text-align:left\">XbhBrowser</td>\n<td style=\"text-align:left\">master</td>\n<td style=\"text-align:left\">mt8195</td>\n<td style=\"text-align:left\">xbh2/XbhBrowser/master/XbhWhiteBoardBrowser_8195_1.0.0.18_826ade4.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">投票器</td>\n<td style=\"text-align:left\">XbhVoteKit</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">快捷设置</td>\n<td style=\"text-align:left\">XbhQuickSettings</td>\n<td style=\"text-align:left\">XbhQuickSettings</td>\n<td style=\"text-align:left\">develop-5.0</td>\n<td style=\"text-align:left\">xbh</td>\n<td style=\"text-align:left\">xbh2/XbhQuickSettings/develop-5.0/XbhQuickSettings_xbh_1.0.0.69_7e7278a.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">云盘服务</td>\n<td style=\"text-align:left\">CloudDisk</td>\n<td style=\"text-align:left\">XbhCloudDisk</td>\n<td style=\"text-align:left\">develop-common</td>\n<td style=\"text-align:left\">xbh</td>\n<td style=\"text-align:left\">xbh2/XbhCloudDisk/develop-common/XbhCloudDisk_xbh_1.0.0.1_b743a59.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">中间件5.0服务</td>\n<td style=\"text-align:left\">XbhPlatformMiddleware</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">xbh2/XbhPlatformMiddleWare5.0/develop_common/XbhPlatformMiddleWare_mt9679_5.0.0.96_e85a11e7.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">中间件插件</td>\n<td style=\"text-align:left\">XbhMWPlugin</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">xbh2/XbhMWPlugin/develop_common/XbhMWPlugin_xbh_4.0.0.414_ca51c40f.apk</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_1-2-3588-5k\" tabindex=\"-1\"> 1.2 3588 5K</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">APP</th>\n<th style=\"text-align:left\">APP名称</th>\n<th style=\"text-align:left\">仓库</th>\n<th style=\"text-align:left\">分支</th>\n<th style=\"text-align:left\">渠道</th>\n<th style=\"text-align:left\">最近的 APK 存储路径</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Launcher</td>\n<td style=\"text-align:left\">XbhLauncher</td>\n<td style=\"text-align:left\">Launcher5.0</td>\n<td style=\"text-align:left\">master</td>\n<td style=\"text-align:left\">xbh5k</td>\n<td style=\"text-align:left\">xbh2/XbhLauncher5/develop-5.0/XbhLauncher5_xbh5k_1.0.0.37_fd75612.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">快传</td>\n<td style=\"text-align:left\">XbhQuickPass</td>\n<td style=\"text-align:left\">Quickpass</td>\n<td style=\"text-align:left\">develop-5.0</td>\n<td style=\"text-align:left\">xbh</td>\n<td style=\"text-align:left\">xbh2/XbhQuickPass/develop-5.0/XbhQuickPass_xbh_1.0.0.0.96.19_fdae61c.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">欢迎页面</td>\n<td style=\"text-align:left\">XbhWelcome</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">侧边栏</td>\n<td style=\"text-align:left\">XbhNaviSetting</td>\n<td style=\"text-align:left\">NavigationEdu2.0</td>\n<td style=\"text-align:left\">develop-5.0</td>\n<td style=\"text-align:left\">xbh</td>\n<td style=\"text-align:left\">xbh2/XbhNaviSetting/develop-5.0/XbhNaviSetting_xbh_3.0.0.38.238_6504fbd2.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">白板批注</td>\n<td style=\"text-align:left\">XbhWhiteBoard</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">罗盘</td>\n<td style=\"text-align:left\">XbhFloatMenu</td>\n<td style=\"text-align:left\">XbhFloatMenu</td>\n<td style=\"text-align:left\">develop-5.0</td>\n<td style=\"text-align:left\">xbh</td>\n<td style=\"text-align:left\">xbh2/XbhFloatMenu/develop-5.0/XbhFloatMenu_xbh_1.31.46_23e1e13.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">聚光灯</td>\n<td style=\"text-align:left\">XbhSpotlight</td>\n<td style=\"text-align:left\">XbhSpotlight</td>\n<td style=\"text-align:left\">develop-5.0</td>\n<td style=\"text-align:left\">xbh5</td>\n<td style=\"text-align:left\">xbh2/XbhSpotlight/develop-5.0/XbhSpotlight_xbh5_1.0.10.19_bc06b7d.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">SystemUI</td>\n<td style=\"text-align:left\">XbhSystemUI</td>\n<td style=\"text-align:left\">XbhSystemUI</td>\n<td style=\"text-align:left\">develop-5.0</td>\n<td style=\"text-align:left\">xbh</td>\n<td style=\"text-align:left\">xbh2/XbhSystemUI/develop-5.0/XbhSystemUI_xbh_1.0.257.140_0d69608e.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">白板内置浏览器</td>\n<td style=\"text-align:left\">XbhBrowser</td>\n<td style=\"text-align:left\">XbhBrowser</td>\n<td style=\"text-align:left\">master</td>\n<td style=\"text-align:left\">mt8195</td>\n<td style=\"text-align:left\">xbh2/XbhBrowser/master/XbhWhiteBoardBrowser_8195_1.0.0.18_826ade4.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">投票器</td>\n<td style=\"text-align:left\">XbhVoteKit</td>\n<td style=\"text-align:left\">Votekit</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">快捷设置</td>\n<td style=\"text-align:left\">XbhQuickSettings</td>\n<td style=\"text-align:left\">XbhQuickSettings</td>\n<td style=\"text-align:left\">develop-5.0</td>\n<td style=\"text-align:left\">xbh</td>\n<td style=\"text-align:left\">xbh2/XbhQuickSettings/develop-5.0/XbhQuickSettings_xbh_1.0.0.69_7e7278a.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">云盘服务</td>\n<td style=\"text-align:left\">CloudDisk</td>\n<td style=\"text-align:left\">XbhCloudDisk</td>\n<td style=\"text-align:left\">develop-common</td>\n<td style=\"text-align:left\">xbh</td>\n<td style=\"text-align:left\">xbh2/XbhCloudDisk/develop-common/XbhCloudDisk_xbh_1.0.0.1_b743a59.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">中间件5.0服务</td>\n<td style=\"text-align:left\">XbhPlatformMiddleware</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">中间件插件</td>\n<td style=\"text-align:left\">XbhMWPlugin</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_1-3-2024-ise\" tabindex=\"-1\"> 1.3 2024-ISE</h3>\n<h4 id=\"_1-3-1-a311d2-a-android-13-aosp\" tabindex=\"-1\"> 1.3.1 A311D2.A   Android 13 AOSP</h4>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">APP</th>\n<th style=\"text-align:left\">APP名称</th>\n<th style=\"text-align:left\">仓库</th>\n<th style=\"text-align:left\">分支</th>\n<th style=\"text-align:left\">渠道</th>\n<th style=\"text-align:left\">最近的 APK 存储路径</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">DMS</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">XbhAdverPlayer3.0</td>\n<td style=\"text-align:left\">develop-dms</td>\n<td style=\"text-align:left\">dmsMW3</td>\n<td style=\"text-align:left\">xbh2/XbhDms/develop-dms/LangoDms_dmsMW3_3.3.20240127_822389a2.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">投屏</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">xbh2/XbhShare/develop311d2/AirgoCast_Server_V3.0.1.65.B_Lango_20240126.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">侧边栏</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">NavigationEdu2.0</td>\n<td style=\"text-align:left\">release-haier</td>\n<td style=\"text-align:left\">ise</td>\n<td style=\"text-align:left\">xbh2/XbhNaviSetting/release-haier/XbhNaviSetting_ise_3.0.0.38.215_37968fca.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">罗盘</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">XbhFloatMenu</td>\n<td style=\"text-align:left\">release-a311d2-android13</td>\n<td style=\"text-align:left\">ise</td>\n<td style=\"text-align:left\">xbh2/XbhFloatMenu/release-a311d2-android13/XbhFloatMenu_ise_1.31.30_ccd761e.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Launcher</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">Launcher3.0</td>\n<td style=\"text-align:left\">release-g6780-common</td>\n<td style=\"text-align:left\">xbh</td>\n<td style=\"text-align:left\">xbh2/XbhLauncher3/release-g6780-common/XbhLauncher3_xbh_1.0.0.15_54313c0.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">设置</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">xbh2/XbhSetting/release-a311d2-android13/XbhSetting_xbh_3.1.185.174_e6ec6b40.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">白板</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">xbh2/XbhWhiteBoard4.0/developer_common/XbhWhiteBoard_common_xbh_4.0.1.656_062cea55.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">文件管理器</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">XBHFM</td>\n<td style=\"text-align:left\">develop-common-newversion</td>\n<td style=\"text-align:left\">xbh</td>\n<td style=\"text-align:left\">xbh2/XbhFileManager/develop-common-newversion/XbhFileManager_xbh_560.2.1.0.85.150_d40bf971.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CloudDisk</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">XbhCloudDisk</td>\n<td style=\"text-align:left\">develop-common</td>\n<td style=\"text-align:left\">xbh</td>\n<td style=\"text-align:left\">xbh2/XbhCloudDisk/develop-common/XbhCloudDisk_xbh_1.0_7164e68_ISE.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">白板浏览器</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">XbhBrowser</td>\n<td style=\"text-align:left\">master</td>\n<td style=\"text-align:left\">common</td>\n<td style=\"text-align:left\">xbh2/XbhBrowser/master/XbhWhiteBoardBrowser_common_1.0.0.15_4a54be9.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">XbhSystemUI</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">XbhSystemUI</td>\n<td style=\"text-align:left\">release-a311d2-android13</td>\n<td style=\"text-align:left\">ise</td>\n<td style=\"text-align:left\">xbh2/XbhSystemUI/release-a311d2-android13/XbhSystemUI_ise_1.0.257.158_a5eaba66.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">锁屏</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">Keyguard_Edu2.0</td>\n<td style=\"text-align:left\">release-a311d2-android13</td>\n<td style=\"text-align:left\">xbh</td>\n<td style=\"text-align:left\">xbh2/XbhKeyguard/release-a311d2-android13/XbhKeyguard_xbh_2.1.35.17_7091105.apk</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"_1-3-2-a311d2-u-android-13-edla\" tabindex=\"-1\"> 1.3.2 A311D2.U   Android 13 EDLA</h4>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">APP</th>\n<th style=\"text-align:left\">APP名称</th>\n<th style=\"text-align:left\">仓库</th>\n<th style=\"text-align:left\">分支</th>\n<th style=\"text-align:left\">渠道</th>\n<th style=\"text-align:left\">最近的 APK 存储路径</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">白板</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">xbh2/XbhWhiteBoard4.0/developer_common/XbhWhiteBoard_xbhSdk4_common_4.0.1.724_7cb7c455.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">DMS</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">XbhAdverPlayer3.0</td>\n<td style=\"text-align:left\">develop-dms</td>\n<td style=\"text-align:left\">dmsMW3</td>\n<td style=\"text-align:left\">xbh2/XbhDms/develop-dms/LangoDms_dmsMW3_3.3.20240323_a0c9eda1_311d2EDLA_ISE.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">投屏</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">xbh2/XbhShare/develop311d2/AirgoCast_Server_V3.0.1.65.B_Lango_20240126.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">侧边栏</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">NavigationEdu2.0</td>\n<td style=\"text-align:left\">release-edla-common</td>\n<td style=\"text-align:left\">xbh_a311d2</td>\n<td style=\"text-align:left\">xbh2/XbhNaviSetting/release-edla-common/XbhNaviSetting_xbh_a311d2_3.0.0.38.230_015b1332.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Launcher</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">Launcher5.0</td>\n<td style=\"text-align:left\">master</td>\n<td style=\"text-align:left\">xbh</td>\n<td style=\"text-align:left\">xbh2/XbhLauncher5/master/XbhLauncher5_xbh_311d2u_temp.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CloudDisk</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">XbhCloudDisk</td>\n<td style=\"text-align:left\">develop-common</td>\n<td style=\"text-align:left\">xbh</td>\n<td style=\"text-align:left\">xbh2/XbhCloudDisk/develop-common/XbhCloudDisk_xbh_1.0_7164e68_ISE.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">白板浏览器</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">XbhBrowser</td>\n<td style=\"text-align:left\">master</td>\n<td style=\"text-align:left\">common</td>\n<td style=\"text-align:left\">xbh2/XbhBrowser/master/XbhWhiteBoardBrowser_common_1.0.0.18_826ade4.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">罗盘</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">XbhFloatMenu</td>\n<td style=\"text-align:left\">release-edla-common</td>\n<td style=\"text-align:left\">xbh_a311d2</td>\n<td style=\"text-align:left\">xbh2/XbhFloatMenu/release-edla-common/XbhFloatMenu_xbh_a311d2_1.31.45_c577d3f.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">聚光灯</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">XbhSpotlight</td>\n<td style=\"text-align:left\">release-edla-common</td>\n<td style=\"text-align:left\">xbh_a311d2</td>\n<td style=\"text-align:left\">xbh2/XbhSpotlight/release-edla-common/XbhSpotlight_xbh_a311d2_1.0.10.18_ee96bd7.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">QuickSettings</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">XbhQuickSettings</td>\n<td style=\"text-align:left\">release-common</td>\n<td style=\"text-align:left\">xbh</td>\n<td style=\"text-align:left\">xbh2/XbhQuickSettings/release-common/XbhQuickSettings_xbh_temp.apk</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"_1-3-3-6780v1-a-android-14-aosp\" tabindex=\"-1\"> 1.3.3 6780V1.A   Android 14 AOSP</h4>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">APP</th>\n<th style=\"text-align:left\">APP名称</th>\n<th style=\"text-align:left\">仓库</th>\n<th style=\"text-align:left\">分支</th>\n<th style=\"text-align:left\">渠道</th>\n<th style=\"text-align:left\">最近的 APK 存储路径</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">白板</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">xbh2/XbhWhiteBoard4.0/developer_common/XbhWhiteBoard_common_xbh_4.0.1.656_062cea55.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">DMS</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">XbhAdverPlayer3.0</td>\n<td style=\"text-align:left\">develop-dms</td>\n<td style=\"text-align:left\">dmsMW4</td>\n<td style=\"text-align:left\">xbh2/XbhDms/develop-dms/LangoDms_dmsMW4_3.3.20240127_822389a2.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">投屏</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">xbh2/XbhShare/develop311d2/AirgoCast_Server_V3.0.1.65.B_Lango_20240126.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">侧边栏</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">NavigationEdu2.0</td>\n<td style=\"text-align:left\">release-haier</td>\n<td style=\"text-align:left\">ise</td>\n<td style=\"text-align:left\">xbh2/XbhNaviSetting/release-haier/XbhNaviSetting_ise_3.0.0.38.215_37968fca.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">罗盘</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">XbhFloatMenu</td>\n<td style=\"text-align:left\">release-g6780-common</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">xbh2/XbhFloatMenu/release-g6780-common/XbhFloatMenu_ise_1.31.48_6fb81ea.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Launcher</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">Launcher3.0</td>\n<td style=\"text-align:left\">release-g6780-common</td>\n<td style=\"text-align:left\">xbh</td>\n<td style=\"text-align:left\">xbh2/XbhLauncher3/release-g6780-common/XbhLauncher3_xbh_1.0.0.15_54313c0.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">文件管理器</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">XBHFM</td>\n<td style=\"text-align:left\">develop-common-newversion</td>\n<td style=\"text-align:left\">xbh</td>\n<td style=\"text-align:left\">xbh2/XbhFileManager/develop-common-newversion/XbhFileManager_xbh_560.2.1.0.85.150_d40bf971.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CloudDisk</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">XbhCloudDisk</td>\n<td style=\"text-align:left\">develop-common</td>\n<td style=\"text-align:left\">xbh</td>\n<td style=\"text-align:left\">xbh2/XbhCloudDisk/develop-common/XbhCloudDisk_xbh_1.0_7164e68_ISE.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">白板浏览器</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">XbhBrowser</td>\n<td style=\"text-align:left\">master</td>\n<td style=\"text-align:left\">common</td>\n<td style=\"text-align:left\">xbh2/XbhBrowser/master/XbhWhiteBoardBrowser_common_1.0.0.15_4a54be9.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">系统设置</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">xbh2/XbhSetting/release-g6780-common/XbhSetting_xbh_3.1.243.382_181eb8e5.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">XbhSystemUI</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">XbhSystemUI</td>\n<td style=\"text-align:left\">release-g6780-common</td>\n<td style=\"text-align:left\">ise</td>\n<td style=\"text-align:left\">xbh2/XbhSystemUI/release-g6780-common/XbhSystemUI_ise_1.0.315.302_504c7f77.apk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">锁屏</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">Keyguard_Edu2.0</td>\n<td style=\"text-align:left\">release-g6780-common</td>\n<td style=\"text-align:left\">xbh</td>\n<td style=\"text-align:left\">xbh2/XbhKeyguard/release-g6780-common/XbhKeyguard_xbh_2.1.35.79_b5cfc4f.apk</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_1-4-公版-m6780-a-android12-14\" tabindex=\"-1\"> 1.4 公版-M6780.A-Android12&amp;14</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">APP</th>\n<th style=\"text-align:left\">APP名称</th>\n<th style=\"text-align:left\">仓库</th>\n<th style=\"text-align:left\">分支</th>\n<th style=\"text-align:left\">渠道</th>\n<th style=\"text-align:left\">最近的 APK 存储路径</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">launcher</td>\n<td style=\"text-align:left\">XbhLauncher</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">文件管理器</td>\n<td style=\"text-align:left\">XbhFileManager</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">欢迎页面</td>\n<td style=\"text-align:left\">XbhWelcome</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">侧边栏</td>\n<td style=\"text-align:left\">XbhNaviSetting</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">中间件</td>\n<td style=\"text-align:left\">XbhPlatformMiddleWare</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">系统设置</td>\n<td style=\"text-align:left\">XbhSetting</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">白板批注</td>\n<td style=\"text-align:left\">XbhWhiteBoard</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">罗盘</td>\n<td style=\"text-align:left\">XbhFloatMenu</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">锁屏</td>\n<td style=\"text-align:left\">XbhKeyguard</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">壁纸服务</td>\n<td style=\"text-align:left\">XbhWallpaperService</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">硬件检测</td>\n<td style=\"text-align:left\">Hardware_Detect</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">计算器</td>\n<td style=\"text-align:left\">XbhCalculator</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">开机向导</td>\n<td style=\"text-align:left\">XbhSetupWizard</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">计时器</td>\n<td style=\"text-align:left\">XbhTimer</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">日历</td>\n<td style=\"text-align:left\">XbhCalendar</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">OTA</td>\n<td style=\"text-align:left\">XbhOta</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">OTAUI</td>\n<td style=\"text-align:left\">XbhOtaUi</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">输入法</td>\n<td style=\"text-align:left\">XbhPinyinIme</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">SUI</td>\n<td style=\"text-align:left\">XbhSystemUI</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">图库</td>\n<td style=\"text-align:left\">XbhGallery</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">投票器</td>\n<td style=\"text-align:left\">XbhVoteKit</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">快传</td>\n<td style=\"text-align:left\">XbhQuickPass</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">录屏</td>\n<td style=\"text-align:left\">XbhScreenRecorder</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">聚光灯</td>\n<td style=\"text-align:left\">XbhSpotlight</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">护眼</td>\n<td style=\"text-align:left\">XbhEyeProtection</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">中间件4.0</td>\n<td style=\"text-align:left\">MiddleWare4.0</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">投屏</td>\n<td style=\"text-align:left\">XbhShare</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">云盘服务</td>\n<td style=\"text-align:left\">XbhCloudDisk</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">白板浏览器</td>\n<td style=\"text-align:left\">XbhBrowser</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_1-5-xmg6780c-安卓14\" tabindex=\"-1\"> 1.5 XMG6780C-安卓14</h3>\n<h3 id=\"_1-6-公版-m6780-a\" tabindex=\"-1\"> 1.6 公版-M6780.A</h3>\n<h3 id=\"_1-7-文香6780v1-g-14\" tabindex=\"-1\"> 1.7 文香6780V1.G-14</h3>\n<h3 id=\"_1-8-康佳vs-6780v-a-14\" tabindex=\"-1\"> 1.8 康佳VS-6780V.A-14</h3>\n<h3 id=\"_1-9-康佳cnx-6780-a-14\" tabindex=\"-1\"> 1.9 康佳CNX-6780.A-14</h3>\n<h3 id=\"_1-10-海尔6780-e\" tabindex=\"-1\"> 1.10 海尔6780.E</h3>\n<h3 id=\"_1-11-海尔6780-a\" tabindex=\"-1\"> 1.11 海尔6780.A</h3>\n<h3 id=\"_1-12-onescreen-m6780-a\" tabindex=\"-1\"> 1.12 OneScreen-M6780.A</h3>\n<h3 id=\"_1-13-onescreen-ops\" tabindex=\"-1\"> 1.13 OneScreen-OPS</h3>\n<h3 id=\"_1-14-康佳pl-m6760a\" tabindex=\"-1\"> 1.14 康佳PL-M6760A</h3>\n<h3 id=\"_1-15-东方中原6780\" tabindex=\"-1\"> 1.15 东方中原6780</h3>\n<h3 id=\"_1-16-可视xg6780\" tabindex=\"-1\"> 1.16 可视XG6780</h3>\n<h3 id=\"_1-17-可视xg6780-14\" tabindex=\"-1\"> 1.17 可视XG6780-14</h3>\n<h3 id=\"_1-18-iiyama-311d2w\" tabindex=\"-1\"> 1.18 IIYAMA-311D2W</h3>\n<h3 id=\"_1-19-iiyama-k版\" tabindex=\"-1\"> 1.19 IIYAMA-K版</h3>\n<h3 id=\"_1-20-广告机-v100\" tabindex=\"-1\"> 1.20 广告机-V100</h3>\n<h3 id=\"_1-21-公版-mt8195a\" tabindex=\"-1\"> 1.21 公版-MT8195A</h3>\n<h3 id=\"_1-22-公版-mt8195c\" tabindex=\"-1\"> 1.22 公版-MT8195C</h3>\n<h3 id=\"_1-23-aha-8195c\" tabindex=\"-1\"> 1.23 AHA-8195C</h3>\n<h3 id=\"_1-24-公版-311d2-edla\" tabindex=\"-1\"> 1.24 公版-311D2-EDLA</h3>\n<h3 id=\"_1-25-三星-311d2-u-edla\" tabindex=\"-1\"> 1.25 三星-311D2.U-EDLA</h3>\n<h3 id=\"_1-26-vs-311d2q-edla\" tabindex=\"-1\"> 1.26 VS-311D2Q-EDLA</h3>\n<h3 id=\"_1-27-vs-mt8195a\" tabindex=\"-1\"> 1.27 VS-MT8195A</h3>\n<h3 id=\"_1-28-公版-m9666-a\" tabindex=\"-1\"> 1.28 公版-M9666.A</h3>\n<h3 id=\"_1-29-创维-tcl-m9630\" tabindex=\"-1\"> 1.29 创维_TCL-M9630</h3>\n<h3 id=\"_1-30-aoc-m9630-a\" tabindex=\"-1\"> 1.30 AOC-M9630.A</h3>\n<h3 id=\"_1-31-蛙声-311d2-h\" tabindex=\"-1\"> 1.31 蛙声-311D2.H</h3>\n<h3 id=\"_1-32-ctouch-311d2a\" tabindex=\"-1\"> 1.32 CTouch-311D2A</h3>\n<h3 id=\"_1-33-公版-311d2\" tabindex=\"-1\"> 1.33 公版-311D2</h3>\n<h3 id=\"_1-34-公版-311d2-android13\" tabindex=\"-1\"> 1.34 公版-311D2-Android13</h3>\n<h3 id=\"_1-35-可视-311d2-android13\" tabindex=\"-1\"> 1.35 可视-311D2-Android13</h3>\n<h3 id=\"_1-36-可视中性-311d2迭代\" tabindex=\"-1\"> 1.36 可视中性-311D2迭代</h3>\n<h3 id=\"_1-37-可视-311d2选代\" tabindex=\"-1\"> 1.37 可视-311D2选代</h3>\n<h3 id=\"_1-38-0506-ise展会\" tabindex=\"-1\"> 1.38 0506-ISE展会</h3>\n<h2 id=\"launcher5-0\" tabindex=\"-1\"> Launcher5.0</h2>\n<div><pre><code><span>git</span> clone <span>\"http://zengkaiqiang@192.168.1.194:8089/a/Launcher5.0\"</span> <span>&amp;&amp;</span> <span>(</span>cd <span>\"Launcher5.0\"</span> <span>&amp;&amp;</span> <span>mkdir</span> -p .git/hooks <span>&amp;&amp;</span> <span>curl</span> -Lo <span><span>`</span><span>git</span> rev-parse --git-dir<span>`</span></span>/hooks/commit-msg http://zengkaiqiang@192.168.1.194:8089/tools/hooks/commit-msg<span>;</span> <span>chmod</span> +x <span><span>`</span><span>git</span> rev-parse --git-dir<span>`</span></span>/hooks/commit-msg<span>)</span>\n</code></pre></div><h2 id=\"quickpass\" tabindex=\"-1\"> Quickpass</h2>\n<div><pre><code><span>git</span> clone <span>\"http://zengkaiqiang@192.168.1.194:8089/a/Quickpass\"</span> <span>&amp;&amp;</span> <span>(</span>cd <span>\"Quickpass\"</span> <span>&amp;&amp;</span> <span>mkdir</span> -p .git/hooks <span>&amp;&amp;</span> <span>curl</span> -Lo <span><span>`</span><span>git</span> rev-parse --git-dir<span>`</span></span>/hooks/commit-msg http://zengkaiqiang@192.168.1.194:8089/tools/hooks/commit-msg<span>;</span> <span>chmod</span> +x <span><span>`</span><span>git</span> rev-parse --git-dir<span>`</span></span>/hooks/commit-msg<span>)</span>\n</code></pre></div><h2 id=\"xbhwelcome2-0\" tabindex=\"-1\"> XbhWelcome2.0</h2>\n<div><pre><code><span>git</span> clone <span>\"http://zengkaiqiang@192.168.1.194:8089/a/XbhWelcome2.0\"</span> <span>&amp;&amp;</span> <span>(</span>cd <span>\"XbhWelcome2.0\"</span> <span>&amp;&amp;</span> <span>mkdir</span> -p .git/hooks <span>&amp;&amp;</span> <span>curl</span> -Lo <span><span>`</span><span>git</span> rev-parse --git-dir<span>`</span></span>/hooks/commit-msg http://zengkaiqiang@192.168.1.194:8089/tools/hooks/commit-msg<span>;</span> <span>chmod</span> +x <span><span>`</span><span>git</span> rev-parse --git-dir<span>`</span></span>/hooks/commit-msg<span>)</span>\n</code></pre></div><h2 id=\"xbhwhiteboard-v2-note-v2\" tabindex=\"-1\"> XBHWhiteBoard_V2_NOTE_V2</h2>\n<div><pre><code><span>git</span> clone <span>\"http://zengkaiqiang@192.168.1.194:8089/a/XBHWhiteBoard_V2_NOTE_V2\"</span> <span>&amp;&amp;</span> <span>(</span>cd <span>\"XBHWhiteBoard_V2_NOTE_V2\"</span> <span>&amp;&amp;</span> <span>mkdir</span> -p .git/hooks <span>&amp;&amp;</span> <span>curl</span> -Lo <span><span>`</span><span>git</span> rev-parse --git-dir<span>`</span></span>/hooks/commit-msg http://zengkaiqiang@192.168.1.194:8089/tools/hooks/commit-msg<span>;</span> <span>chmod</span> +x <span><span>`</span><span>git</span> rev-parse --git-dir<span>`</span></span>/hooks/commit-msg<span>)</span>\n</code></pre></div><h2 id=\"xbhfloatmenu\" tabindex=\"-1\"> XbhFloatMenu</h2>\n<div><pre><code><span>git</span> clone <span>\"http://zengkaiqiang@192.168.1.194:8089/a/XbhFloatMenu\"</span> <span>&amp;&amp;</span> <span>(</span>cd <span>\"XbhFloatMenu\"</span> <span>&amp;&amp;</span> <span>mkdir</span> -p .git/hooks <span>&amp;&amp;</span> <span>curl</span> -Lo <span><span>`</span><span>git</span> rev-parse --git-dir<span>`</span></span>/hooks/commit-msg http://zengkaiqiang@192.168.1.194:8089/tools/hooks/commit-msg<span>;</span> <span>chmod</span> +x <span><span>`</span><span>git</span> rev-parse --git-dir<span>`</span></span>/hooks/commit-msg<span>)</span>\n</code></pre></div><h2 id=\"xbhspotlight\" tabindex=\"-1\"> XbhSpotlight</h2>\n<div><pre><code><span>git</span> clone <span>\"http://zengkaiqiang@192.168.1.194:8089/a/XbhSpotlight\"</span> <span>&amp;&amp;</span> <span>(</span>cd <span>\"XbhSpotlight\"</span> <span>&amp;&amp;</span> <span>mkdir</span> -p .git/hooks <span>&amp;&amp;</span> <span>curl</span> -Lo <span><span>`</span><span>git</span> rev-parse --git-dir<span>`</span></span>/hooks/commit-msg http://zengkaiqiang@192.168.1.194:8089/tools/hooks/commit-msg<span>;</span> <span>chmod</span> +x <span><span>`</span><span>git</span> rev-parse --git-dir<span>`</span></span>/hooks/commit-msg<span>)</span>\n</code></pre></div><h2 id=\"xbhsystemui\" tabindex=\"-1\"> XbhSystemUI</h2>\n<div><pre><code><span>git</span> clone <span>\"http://zengkaiqiang@192.168.1.194:8089/a/XbhSystemUI\"</span> <span>&amp;&amp;</span> <span>(</span>cd <span>\"XbhSystemUI\"</span> <span>&amp;&amp;</span> <span>mkdir</span> -p .git/hooks <span>&amp;&amp;</span> <span>curl</span> -Lo <span><span>`</span><span>git</span> rev-parse --git-dir<span>`</span></span>/hooks/commit-msg http://zengkaiqiang@192.168.1.194:8089/tools/hooks/commit-msg<span>;</span> <span>chmod</span> +x <span><span>`</span><span>git</span> rev-parse --git-dir<span>`</span></span>/hooks/commit-msg<span>)</span>\n</code></pre></div><h2 id=\"xbhbrowser\" tabindex=\"-1\"> XbhBrowser</h2>\n<div><pre><code><span>git</span> clone <span>\"http://zengkaiqiang@192.168.1.194:8089/a/XbhBrowser\"</span> <span>&amp;&amp;</span> <span>(</span>cd <span>\"XbhBrowser\"</span> <span>&amp;&amp;</span> <span>mkdir</span> -p .git/hooks <span>&amp;&amp;</span> <span>curl</span> -Lo <span><span>`</span><span>git</span> rev-parse --git-dir<span>`</span></span>/hooks/commit-msg http://zengkaiqiang@192.168.1.194:8089/tools/hooks/commit-msg<span>;</span> <span>chmod</span> +x <span><span>`</span><span>git</span> rev-parse --git-dir<span>`</span></span>/hooks/commit-msg<span>)</span>\n</code></pre></div><h2 id=\"votekit\" tabindex=\"-1\"> Votekit</h2>\n<div><pre><code><span>git</span> clone <span>\"http://zengkaiqiang@192.168.1.194:8089/a/Votekit\"</span> <span>&amp;&amp;</span> <span>(</span>cd <span>\"Votekit\"</span> <span>&amp;&amp;</span> <span>mkdir</span> -p .git/hooks <span>&amp;&amp;</span> <span>curl</span> -Lo <span><span>`</span><span>git</span> rev-parse --git-dir<span>`</span></span>/hooks/commit-msg http://zengkaiqiang@192.168.1.194:8089/tools/hooks/commit-msg<span>;</span> <span>chmod</span> +x <span><span>`</span><span>git</span> rev-parse --git-dir<span>`</span></span>/hooks/commit-msg<span>)</span>\n</code></pre></div><h2 id=\"xbhquicksettings\" tabindex=\"-1\"> XbhQuickSettings</h2>\n<div><pre><code><span>git</span> clone <span>\"http://zengkaiqiang@192.168.1.194:8089/a/XbhQuickSettings\"</span> <span>&amp;&amp;</span> <span>(</span>cd <span>\"XbhQuickSettings\"</span> <span>&amp;&amp;</span> <span>mkdir</span> -p .git/hooks <span>&amp;&amp;</span> <span>curl</span> -Lo <span><span>`</span><span>git</span> rev-parse --git-dir<span>`</span></span>/hooks/commit-msg http://zengkaiqiang@192.168.1.194:8089/tools/hooks/commit-msg<span>;</span> <span>chmod</span> +x <span><span>`</span><span>git</span> rev-parse --git-dir<span>`</span></span>/hooks/commit-msg<span>)</span>\n</code></pre></div><h2 id=\"xbhclouddisk\" tabindex=\"-1\"> XbhCloudDisk</h2>\n<div><pre><code><span>git</span> clone <span>\"http://zengkaiqiang@192.168.1.194:8089/a/XbhCloudDisk\"</span> <span>&amp;&amp;</span> <span>(</span>cd <span>\"XbhCloudDisk\"</span> <span>&amp;&amp;</span> <span>mkdir</span> -p .git/hooks <span>&amp;&amp;</span> <span>curl</span> -Lo <span><span>`</span><span>git</span> rev-parse --git-dir<span>`</span></span>/hooks/commit-msg http://zengkaiqiang@192.168.1.194:8089/tools/hooks/commit-msg<span>;</span> <span>chmod</span> +x <span><span>`</span><span>git</span> rev-parse --git-dir<span>`</span></span>/hooks/commit-msg<span>)</span>\n</code></pre></div><h2 id=\"middlewaresdk\" tabindex=\"-1\"> MiddlewareSdk</h2>\n<div><pre><code><span>git</span> clone <span>\"http://zengkaiqiang@192.168.1.194:8089/a/MiddlewareSdk\"</span> <span>&amp;&amp;</span> <span>(</span>cd <span>\"MiddlewareSdk\"</span> <span>&amp;&amp;</span> <span>mkdir</span> -p .git/hooks <span>&amp;&amp;</span> <span>curl</span> -Lo <span><span>`</span><span>git</span> rev-parse --git-dir<span>`</span></span>/hooks/commit-msg http://zengkaiqiang@192.168.1.194:8089/tools/hooks/commit-msg<span>;</span> <span>chmod</span> +x <span><span>`</span><span>git</span> rev-parse --git-dir<span>`</span></span>/hooks/commit-msg<span>)</span>\n</code></pre></div><h2 id=\"middleware3-0adv\" tabindex=\"-1\"> MiddleWare3.0Adv</h2>\n<div><pre><code><span>git</span> clone <span>\"http://zengkaiqiang@192.168.1.194:8089/a/MiddleWare3.0Adv\"</span> <span>&amp;&amp;</span> <span>(</span>cd <span>\"MiddleWare3.0Adv\"</span> <span>&amp;&amp;</span> <span>mkdir</span> -p .git/hooks <span>&amp;&amp;</span> <span>curl</span> -Lo <span><span>`</span><span>git</span> rev-parse --git-dir<span>`</span></span>/hooks/commit-msg http://zengkaiqiang@192.168.1.194:8089/tools/hooks/commit-msg<span>;</span> <span>chmod</span> +x <span><span>`</span><span>git</span> rev-parse --git-dir<span>`</span></span>/hooks/commit-msg<span>)</span>\n</code></pre></div><h2 id=\"middleware3-0\" tabindex=\"-1\"> MiddleWare3.0</h2>\n<div><pre><code><span>git</span> clone <span>\"http://zengkaiqiang@192.168.1.194:8089/a/MiddleWare3.0\"</span> <span>&amp;&amp;</span> <span>(</span>cd <span>\"MiddleWare3.0\"</span> <span>&amp;&amp;</span> <span>mkdir</span> -p .git/hooks <span>&amp;&amp;</span> <span>curl</span> -Lo <span><span>`</span><span>git</span> rev-parse --git-dir<span>`</span></span>/hooks/commit-msg http://zengkaiqiang@192.168.1.194:8089/tools/hooks/commit-msg<span>;</span> <span>chmod</span> +x <span><span>`</span><span>git</span> rev-parse --git-dir<span>`</span></span>/hooks/commit-msg<span>)</span>\n</code></pre></div><h2 id=\"middleware2-0\" tabindex=\"-1\"> MiddleWare2.0</h2>\n<div><pre><code><span>git</span> clone <span>\"http://zengkaiqiang@192.168.1.194:8089/a/MiddleWare2.0\"</span> <span>&amp;&amp;</span> <span>(</span>cd <span>\"MiddleWare2.0\"</span> <span>&amp;&amp;</span> <span>mkdir</span> -p .git/hooks <span>&amp;&amp;</span> <span>curl</span> -Lo <span><span>`</span><span>git</span> rev-parse --git-dir<span>`</span></span>/hooks/commit-msg http://zengkaiqiang@192.168.1.194:8089/tools/hooks/commit-msg<span>;</span> <span>chmod</span> +x <span><span>`</span><span>git</span> rev-parse --git-dir<span>`</span></span>/hooks/commit-msg<span>)</span>\n</code></pre></div><h2 id=\"middleware\" tabindex=\"-1\"> MiddleWare</h2>\n<div><pre><code><span>git</span> clone <span>\"http://zengkaiqiang@192.168.1.194:8089/a/MiddleWare\"</span> <span>&amp;&amp;</span> <span>(</span>cd <span>\"MiddleWare\"</span> <span>&amp;&amp;</span> <span>mkdir</span> -p .git/hooks <span>&amp;&amp;</span> <span>curl</span> -Lo <span><span>`</span><span>git</span> rev-parse --git-dir<span>`</span></span>/hooks/commit-msg http://zengkaiqiang@192.168.1.194:8089/tools/hooks/commit-msg<span>;</span> <span>chmod</span> +x <span><span>`</span><span>git</span> rev-parse --git-dir<span>`</span></span>/hooks/commit-msg<span>)</span>\n</code></pre></div><h2 id=\"xbhsetting\" tabindex=\"-1\"> XbhSetting</h2>\n<div><pre><code><span>git</span> clone <span>\"http://zengkaiqiang@192.168.1.194:8089/a/XbhSetting\"</span> <span>&amp;&amp;</span> <span>(</span>cd <span>\"XbhSetting\"</span> <span>&amp;&amp;</span> <span>mkdir</span> -p .git/hooks <span>&amp;&amp;</span> <span>curl</span> -Lo <span><span>`</span><span>git</span> rev-parse --git-dir<span>`</span></span>/hooks/commit-msg http://zengkaiqiang@192.168.1.194:8089/tools/hooks/commit-msg<span>;</span> <span>chmod</span> +x <span><span>`</span><span>git</span> rev-parse --git-dir<span>`</span></span>/hooks/commit-msg<span>)</span>\n</code></pre></div><h2 id=\"keyguard-edu2-0\" tabindex=\"-1\"> Keyguard_Edu2.0</h2>\n<div><pre><code><span>git</span> clone <span>\"http://zengkaiqiang@192.168.1.194:8089/a/Keyguard_Edu2.0\"</span> <span>&amp;&amp;</span> <span>(</span>cd <span>\"Keyguard_Edu2.0\"</span> <span>&amp;&amp;</span> <span>mkdir</span> -p .git/hooks <span>&amp;&amp;</span> <span>curl</span> -Lo <span><span>`</span><span>git</span> rev-parse --git-dir<span>`</span></span>/hooks/commit-msg http://zengkaiqiang@192.168.1.194:8089/tools/hooks/commit-msg<span>;</span> <span>chmod</span> +x <span><span>`</span><span>git</span> rev-parse --git-dir<span>`</span></span>/hooks/commit-msg<span>)</span>\n</code></pre></div>",
      "date_published": "2024-05-25T01:06:23.000Z",
      "date_modified": "2024-05-25T01:06:23.000Z",
      "authors": [],
      "tags": [
        "朗国科技"
      ]
    },
    {
      "title": "朗国科技相关文档",
      "url": "https://zengkaiqiang562.github.io/lango-tech/",
      "id": "https://zengkaiqiang562.github.io/lango-tech/",
      "content_html": "",
      "date_published": "2024-04-30T10:39:15.000Z",
      "date_modified": "2024-04-30T10:39:15.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "专题",
      "url": "https://zengkaiqiang562.github.io/lango-tech/subject/",
      "id": "https://zengkaiqiang562.github.io/lango-tech/subject/",
      "content_html": "",
      "date_published": "2024-04-30T10:39:15.000Z",
      "date_modified": "2024-04-30T10:39:15.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "GUI系统——SurfaceFlinger",
      "url": "https://zengkaiqiang562.github.io/lango-tech/subject/surfaceflinger.html",
      "id": "https://zengkaiqiang562.github.io/lango-tech/subject/surfaceflinger.html",
      "content_html": "<div><pre><code>Android 的 GUI 系统是基于 OpenGL/EGL 来实现的\n</code></pre></div><h2 id=\"_1-opengl-es-与-egl\" tabindex=\"-1\"> 1 <code>OpenGL ES</code> 与 <code>EGL</code></h2>\n<p>如下图所示，描述了 <code>SurfaceFlinger</code> 与 <code>OpenGL ES</code> 等模块的关系。</p>\n<p><img src=\"@source/lango-tech/subject/images/surfaceflinger/01.png\" alt=\"\" loading=\"lazy\"></p>\n<p>现在由 “底层到上层” 的顺序来逐步分析图中阐述的架构：</p>\n<div><pre><code>（1）Linux 内核提供了统一的 framebuffer 显示驱动。\n\t设备节点 /dev/graphics/fb* 或者 /dev/fb*，其中 fb0 表示第一个 Monitor，当前系统实现中只用到了一个显示屏。\n\n（2）Android 的 HAL 层提供了 Gralloc，包括 fb 和 gralloc 两个设备。\n    前者负责打开内核中的 framebuffer、初始化配置，并提供了 post、setSwapInterval 等操作接口；\n    后者则管理帧缓冲区的分配和释放。\n    这就意味着上层元素只能通过 Gralloc 来间接访问帧缓冲区，从而保证了系统对 framebuffer 的有序使用和统一管理。\n\n    另外，HAL层的另一重要模块是 “Composer” —— 如其名所示，它为厂商自定制“UI合成”提供了接口。\n    Composer 的直接使用者是 SurfaceFlinger 中的 HWComposer（有两个 HWComposer，后面我们会详细讲解），\n    后者除了管理 Composer 的 HAL 模块外，还负责 VSync 信号的产生和控制。\n    VSync则是 “Project Butter” 工程中加入的一种同步机制，它既可以由硬件产生，也可以通过软件来模拟（VsyncThread），\n    后续有专门的小节进行介绍。\n\n（3）由于 OpenGL ES 是一个通用的函数库，在不同的平台系统上需要被 “本地化”，\n    即把它与具体平台中的窗口系统建立起关联，这样才能保证正常工作。\n    从 FramebufferNativeWindow 这个名称就能判断出来，它就是负责 OpenGL ES 在 Android 平台上本地化的中介之一。\n    后面我们还会看到 Android 应用程序中所使用的另一个“本地窗口”。\n\n    为 OpenGL ES 配置本地窗口的是 EGL。\n\n（4）OpenG L或者 OpenGL ES 更多的只是一个接口协议，具体实现既可以采用软件，也可以依托于硬件。\n    既然有多种实现的可能，那么 OpenGL ES 在动态运行时是如何取舍的呢？这也是 EGL 的作用之一。\n    EGL 会去读取 egl.cfg 这个配置文件，然后根据用户的设定来动态加载 libagl（软件实现）或者 libhgl（硬件实现）。\n\n（5）SurfaceFlinger 中持有一个成员数组 mDisplays 来描述系统中支持的各种 “显示设备”。\n    具体有哪些 Display 是由 SurfaceFlinger 在 readyToRun 中判断并赋值的；\n    并且 DisplayDevice 在初始化时还将调用 eglGetDisplay、eglCreateWindowSurface 等接口，\n    并利用 EGL来 完成对 OpenGL ES 环境的搭建。\n\n（6）很多模块都可以调用 OpenGL ES 提供的 API，包括 SurfaceFlinger、DisplayDevice 等模块。\n  （这些 API 接口以 “gl” 为前缀，如 glViewport、glClear、glMatrixMode、glLoadIdentity 等），\n\n（7）与 OpenGL ES 相关的模块可以分为如下几类。\n    配置类：即帮助 OpenGL ES 完成配置的，包括 EGL、DisplayHardware 都可以归为这一类。\n    依赖类：也就是 OpenGL ES 要正常运行起来所依赖的 “本地化” 的东西，上图中是指 FramebufferNativeWindow。\n    使用类：使用者也可能是配置者，如 DisplayDevice 既扮演了构建 OpenGL ES 环境的角色，同时也是它的用户。\n    \n</code></pre></div><h2 id=\"_2-android-的硬件接口-——-hal\" tabindex=\"-1\"> 2 <code>Android</code> 的硬件接口 —— <code>HAL</code></h2>\n<p>对于 <code>Android</code> 中很多子系统来说（如显示系统、音频系统等），<code>HAL</code> 都是必不可少的组成部分 —— <code>HAL</code> 是这些子系统与 <code>Linux Kernel</code> 驱动之间通信的统一接口。</p>\n<p>对于 <code>Gralloc</code> 来说，它的硬件接口定义如下：</p>\n<div><pre><code><span>/* hardware/libhardware/include/hardware/gralloc.h */</span>\n<span>/* \n * Every hardware module must have a data structure named HAL_MODULE_INFO_SYM\n * and the fields of this data structure must begin with hw_module_t\n * followed by module specific information.\n */</span>\n<span>typedef</span> <span>struct</span> <span>gralloc_module_t</span> <span>{</span>\n    <span>struct</span> <span>hw_module_t</span> common<span>;</span>  \n    <span>int</span> <span>(</span><span>*</span>registerBuffer<span>)</span><span>(</span><span>struct</span> <span>gralloc_module_t</span> <span>const</span><span>*</span> <span>module</span><span>,</span> buffer_handle_t handle<span>)</span><span>;</span>\n    <span>int</span> <span>(</span><span>*</span>unregisterBuffer<span>)</span><span>(</span><span>struct</span> <span>gralloc_module_t</span> <span>const</span><span>*</span> <span>module</span><span>,</span> buffer_handle_t handle<span>)</span><span>;</span>   \n\n    <span>int</span> <span>(</span><span>*</span>lock<span>)</span><span>(</span><span>struct</span> <span>gralloc_module_t</span> <span>const</span><span>*</span> <span>module</span><span>,</span> buffer_handle_t handle<span>,</span> \n                  <span>int</span> usage<span>,</span> <span>int</span> l<span>,</span> <span>int</span> t<span>,</span> <span>int</span> w<span>,</span> <span>int</span> h<span>,</span><span>void</span><span>*</span><span>*</span> vaddr<span>)</span><span>;</span>\n\n    <span>int</span> <span>(</span><span>*</span>unlock<span>)</span><span>(</span><span>struct</span> <span>gralloc_module_t</span> <span>const</span><span>*</span> <span>module</span><span>,</span>buffer_handle_t handle<span>)</span><span>;</span>\n    <span>int</span> <span>(</span><span>*</span>perform<span>)</span><span>(</span><span>struct</span> <span>gralloc_module_t</span> <span>const</span><span>*</span> <span>module</span><span>,</span><span>int</span> operation<span>,</span> <span>.</span><span>.</span><span>.</span> <span>)</span><span>;</span>\n\n    <span>int</span> <span>(</span><span>*</span>lock_ycbcr<span>)</span><span>(</span><span>struct</span> <span>gralloc_module_t</span> <span>const</span><span>*</span> <span>module</span><span>,</span>buffer_handle_t handle<span>,</span>\n\t\t\t\t\t<span>int</span> usage<span>,</span> <span>int</span> l<span>,</span> <span>int</span> t<span>,</span> <span>int</span> w<span>,</span> <span>int</span> h<span>,</span><span>struct</span> <span>android_ycbcr</span> <span>*</span>ycbcr<span>)</span><span>;</span>\n\n    <span>/* reserved for future use */</span>\n    <span>void</span><span>*</span> reserved_proc<span>[</span><span>6</span><span>]</span><span>;</span>\n\n<span>}</span> gralloc_module_t<span>;</span>\n</code></pre></div><blockquote>\n<p>从注释中可以看出：</p>\n<ol>\n<li>首先，每一个硬件模块都必须有一个名称为 <code>HAL_MODULE_INFO_SYM</code> 的变量。</li>\n<li>其次，此变量的数据结构要以 <code>hw_module_t</code> 开头。</li>\n</ol>\n</blockquote>\n<h2 id=\"_3-gralloc-与-framebuffer\" tabindex=\"-1\"> 3 <code>Gralloc</code> 与 <code>Framebuffer</code></h2>\n<p><code>Framebuffer</code> 是内核系统提供的图形硬件的抽象描述。之所以称为 <code>buffer</code>，是因为它也占用了系统存储空间的一部分，是一块包含屏幕显示信息的缓冲区。\n由此可见，在 “一切都是文件” 的 <code>Linux</code> 系统中，<code>Framebuffer</code> 被看成了终端显示设备的 “化身”。</p>\n<p>在 <code>Android</code> 系统中，<code>Framebuffer</code> 提供的设备文件节点是 <code>/dev/graphics/fb*</code>。\n因为理论上支持多个屏幕显示，所以 <code>fb</code> 按数字序号进行排列，即 <code>fb0</code>、<code>fb1</code> 等。其中第一个 <code>fb0</code> 是主显示屏幕，必须存在。</p>\n<p><img src=\"@source/lango-tech/subject/images/surfaceflinger/02.png\" alt=\"\" loading=\"lazy\"></p>\n<p><code>Android</code> 的各子系统通常不会直接使用内核驱动，而是由 <code>HAL</code> 层来间接引用底层架构。显示系统中也同样如此 —— 它借助于 <code>HAL</code> 层来操作帧缓冲区，而完成这一中介任务的就是 <code>Gralloc</code>。</p>\n<h3 id=\"_3-1-gralloc-模块的加载\" tabindex=\"-1\"> 3.1 <code>Gralloc</code> 模块的加载</h3>\n<p><code>Gralloc</code> 对应的模块是由 <code>FramebufferNativeWindow</code> 在构造函数中加载的。即：</p>\n<div><pre><code><span>hw_get_module</span><span>(</span>GRALLOC_HARDWARE_MODULE_ID<span>,</span> <span>&amp;</span><span>module</span><span>)</span><span>;</span>\n</code></pre></div><blockquote>\n<p>函数 <code>hw_get_module</code> 是上层使用者加载 <code>HAL</code> 库的入口，这意味着不论是哪个硬件厂商提供的 <code>HAL</code> 库（比如 <code>Gralloc</code> 库），我们都只需要通过这个函数来加载它们。</p>\n</blockquote>\n<p>可以看到，针对 <code>Gralloc</code> 传入的硬件模块 <code>ID</code> 名为：</p>\n<div><pre><code><span><span>#</span><span>define</span> <span>GRALLOC_HARDWARE_MODULE_ID</span> <span>\"gralloc\"</span></span>\n</code></pre></div><p>按照 <code>hw_get_module</code> 的做法，它会在如下路径中查找与 <code>ID</code> 值匹配的库。</p>\n<div><pre><code><span><span>#</span><span>define</span> <span>HAL_LIBRARY_PATH1</span> <span>\"/system/lib/hw\"</span></span>\n<span><span>#</span><span>define</span> <span>HAL_LIBRARY_PATH2</span> <span>\"/vendor/lib/hw\"</span></span>\n</code></pre></div><p><code>lib</code> 库名有如下几种形式：</p>\n<div><pre><code>gralloc.[ro.hardware].so \ngralloc.[ro.product.board].so \ngralloc.[ro.board.platform].so \ngralloc.[ro.arch].so\n</code></pre></div><p>或者当上述系统属性组成的文件名都不存在时，就使用默认的：</p>\n<div><pre><code>gralloc.default.so\n</code></pre></div><blockquote>\n<p>这个 <code>default</code> 库是 <code>Android</code> 原生态的实现，源码位置在 <code>hardware/libhardware/modules/gralloc/</code> 中，它由 <code>gralloc.cpp</code>、<code>framebuffer.cpp</code> 和 <code>mapper.cpp</code> 三个主要源文件编译生成。</p>\n</blockquote>\n<h3 id=\"_3-2-gralloc-提供的接口\" tabindex=\"-1\"> 3.2 <code>Gralloc</code> 提供的接口</h3>\n<div><pre><code><span>/* hardware/libhardware/include/hardware/gralloc.h */</span>\n<span>/* \n * Every hardware module must have a data structure named HAL_MODULE_INFO_SYM\n * and the fields of this data structure must begin with hw_module_t\n * followed by module specific information.\n */</span>\n<span>typedef</span> <span>struct</span> <span>gralloc_module_t</span> <span>{</span>\n    <span>struct</span> <span>hw_module_t</span> common<span>;</span>  \n    <span>int</span> <span>(</span><span>*</span>registerBuffer<span>)</span><span>(</span><span>struct</span> <span>gralloc_module_t</span> <span>const</span><span>*</span> <span>module</span><span>,</span> buffer_handle_t handle<span>)</span><span>;</span>\n    <span>int</span> <span>(</span><span>*</span>unregisterBuffer<span>)</span><span>(</span><span>struct</span> <span>gralloc_module_t</span> <span>const</span><span>*</span> <span>module</span><span>,</span> buffer_handle_t handle<span>)</span><span>;</span>   \n\n    <span>int</span> <span>(</span><span>*</span>lock<span>)</span><span>(</span><span>struct</span> <span>gralloc_module_t</span> <span>const</span><span>*</span> <span>module</span><span>,</span> buffer_handle_t handle<span>,</span> \n                  <span>int</span> usage<span>,</span> <span>int</span> l<span>,</span> <span>int</span> t<span>,</span> <span>int</span> w<span>,</span> <span>int</span> h<span>,</span><span>void</span><span>*</span><span>*</span> vaddr<span>)</span><span>;</span>\n\n    <span>int</span> <span>(</span><span>*</span>unlock<span>)</span><span>(</span><span>struct</span> <span>gralloc_module_t</span> <span>const</span><span>*</span> <span>module</span><span>,</span>buffer_handle_t handle<span>)</span><span>;</span>\n    <span>int</span> <span>(</span><span>*</span>perform<span>)</span><span>(</span><span>struct</span> <span>gralloc_module_t</span> <span>const</span><span>*</span> <span>module</span><span>,</span><span>int</span> operation<span>,</span> <span>.</span><span>.</span><span>.</span> <span>)</span><span>;</span>\n\n    <span>int</span> <span>(</span><span>*</span>lock_ycbcr<span>)</span><span>(</span><span>struct</span> <span>gralloc_module_t</span> <span>const</span><span>*</span> <span>module</span><span>,</span>buffer_handle_t handle<span>,</span>\n\t\t\t\t\t<span>int</span> usage<span>,</span> <span>int</span> l<span>,</span> <span>int</span> t<span>,</span> <span>int</span> w<span>,</span> <span>int</span> h<span>,</span><span>struct</span> <span>android_ycbcr</span> <span>*</span>ycbcr<span>)</span><span>;</span>\n\n    <span>/* reserved for future use */</span>\n    <span>void</span><span>*</span> reserved_proc<span>[</span><span>6</span><span>]</span><span>;</span>\n\n<span>}</span> gralloc_module_t<span>;</span>\n</code></pre></div><div><pre><code><span>/*hardware/libhardware/include/hardware/Hardware.h*/</span>\n<span>typedef</span> <span>struct</span> <span>hw_module_t</span> <span>{</span>\n    …\n    <span>struct</span> <span>hw_module_methods_t</span><span>*</span> methods<span>;</span> <span>//一个 HAL 库必须提供的方法</span>\n    …\n<span>}</span> hw_module_t<span>;</span>\n\n\n<span>typedef</span> <span>struct</span> <span>hw_module_methods_t</span> <span>{</span>\n    <span>int</span> <span>(</span><span>*</span>open<span>)</span><span>(</span><span>const</span> <span>struct</span> <span>hw_module_t</span><span>*</span> <span>module</span><span>,</span> <span>const</span> <span>char</span><span>*</span> id<span>,</span> <span>struct</span> <span>hw_device_t</span><span>*</span><span>*</span> device<span>)</span><span>;</span>\n<span>}</span> hw_module_methods_t<span>;</span>\n</code></pre></div><p>以上给出了三个结构体的定义：<code>gralloc_module_t</code>、<code>hw_module_t</code>、<code>hw_module_methods_t</code>。注意：</p>\n<div><pre><code>硬件接口的抽象涉及了继承关系 —— “抽象的硬件” 是父类，而 “具体的硬件” 则是子类。\n这在 C++ 中很容易实现，但是 HAL 多数是由 C 语言实现的，怎么办呢？\n其实很简单，只要让子类数据结构的第一个成员变量是父类结构即可。\n\n类似于 Gralloc 的硬件接口定义（gralloc_module_t），\n任何硬件设备的 HAL 库都必须实现 hw_module_methods_t。目前 hw_module_methods_t 结构体中只有一个函数指针变量，即 open。\n当上层使用者调用 hw_get_module 时，系统首先在指定目录中查找并加载正确的 HAL 库，然后通过 open 方法来打开指定的设备。\n</code></pre></div><p>在 <code>Gralloc</code> 中，<code>open</code> 接口可以帮助上层使用者打开两种设备。分别是：</p>\n<div><pre><code><span><span>#</span><span>define</span> <span>GRALLOC_HARDWARE_FB0</span> <span>\"fb0\"</span>   <span>// fb0  就是我们前面所说的 “主屏幕”</span></span>\n<span><span>#</span><span>define</span> <span>GRALLOC_HARDWARE_GPU0</span> <span>\"gpu0\"</span> <span>// gpu0 负责图形缓冲区的分配和释放</span></span>\n</code></pre></div><p>这两个设备分别由 <code>FramebufferNativeWindow</code> 中的 <code>fbDev</code> 和 <code>grDev</code> 成员变量来管理：</p>\n<div><pre><code><span>/*frameworks/native/libs/ui/FramebufferNativeWindow.cpp*/</span>\n<span>FramebufferNativeWindow</span><span>::</span><span>FramebufferNativeWindow</span><span>(</span><span>)</span><span>:</span> <span>BASE</span><span>(</span><span>)</span><span>,</span> <span>fbDev</span><span>(</span><span>0</span><span>)</span><span>,</span> <span>grDev</span><span>(</span><span>0</span><span>)</span><span>,</span> <span>mUpdateOnDemand</span><span>(</span><span>false</span><span>)</span>\n<span>{</span>\n    <span>.</span><span>.</span><span>.</span>\n    err <span>=</span> <span>framebuffer_open</span><span>(</span><span>module</span><span>,</span> <span>&amp;</span>fbDev<span>)</span><span>;</span> <span>// 打开 fb 设备（即 framebuffer 设备）</span>\n    err <span>=</span> <span>gralloc_open</span><span>(</span><span>module</span><span>,</span> <span>&amp;</span>grDev<span>)</span><span>;</span> <span>// 打开 gralloc 设备</span>\n</code></pre></div><blockquote>\n<p>上述代码段中的两个 <code>xxx_open</code> 函数由 <code>hardware/libhardware/include/hardware</code> 目录下的 <code>fb.h</code> 和<code> gralloc.h</code> 头文件提供，用于打开 <code>fb</code> 及 <code>gralloc</code> 设备。</p>\n<p>注意：</p>\n<ol>\n<li><code>FramebufferNativeWindow.cpp</code> 在高版本的源代码中已经不存在了，但打开 <code>fb</code> 和 <code>gralloc</code> 设备还是会调用 <code>framebuffer_open</code> 和 <code>gralloc_open</code> 这两个函数。</li>\n<li><code>framebuffer_open</code> 和 <code>gralloc_open</code> 最终调用的肯定还是 <code>hw_module_methods_t</code> 中的 <code>open</code> 方法，只是函数参数有所差异：</li>\n</ol>\n<div><pre><code>fb      对应的设备名为 GRALLOC_HARDWARE_FB0；\ngralloc 对应的设备名为 GRALLOC_HARDWARE_GPU0。\n</code></pre></div></blockquote>\n<p><code>Android</code> 原生态的 <code>Gralloc</code> 实现在 hardware/libhardware/modules/gralloc 中，由 <code>gralloc.cpp</code>、<code>framebuffer.cpp</code> 和 <code>mapper.cpp</code> 三个主要源文件编译生成。</p>\n<p>原生态的 <code>Gralloc</code> 实现中，<code>open</code> 方法接口对应的是 <code>gralloc_device_open@Gralloc.cpp</code>。这个函数会根据设备名来判断是打开 <code>fb</code> 还是 <code>gralloc</code> 设备。</p>\n<div><pre><code><span>/*hardware/libhardware/modules/gralloc/gralloc.cpp*/</span>\n<span>int</span> <span>gralloc_device_open</span><span>(</span><span>const</span> hw_module_t<span>*</span> <span>module</span><span>,</span> <span>const</span> <span>char</span><span>*</span> name<span>,</span> hw_device_t<span>*</span><span>*</span> device<span>)</span>\n<span>{</span>\n    <span>int</span> status <span>=</span> <span>-</span>EINVAL<span>;</span>\n    <span>if</span> <span>(</span><span>!</span><span>strcmp</span><span>(</span>name<span>,</span> GRALLOC_HARDWARE_GPU0<span>)</span><span>)</span> <span>{</span> <span>// 打开 gralloc 设备</span>\n        <span>.</span><span>.</span><span>.</span>\n    <span>}</span> <span>else</span> <span>{</span>\n        status <span>=</span> <span>fb_device_open</span><span>(</span><span>module</span><span>,</span> name<span>,</span> device<span>)</span><span>;</span> <span>// 否则就是 fb 设备</span>\n    <span>}</span>\n    <span>return</span> status<span>;</span>\n<span>}</span>\n</code></pre></div><h4 id=\"_3-2-1-fb-设备的打开过程\" tabindex=\"-1\"> 3.2.1 <code>fb</code> 设备的打开过程</h4>\n<p><strong>先来大概看看 <code>fb</code> 设备（即 <code>framebuffer</code> 设备）的打开过程：</strong></p>\n<div><pre><code><span>/*hardware/libhardware/modules/gralloc/framebuffer.cpp*/</span>\n<span>int</span> <span>fb_device_open</span><span>(</span>hw_module_t <span>const</span><span>*</span> <span>module</span><span>,</span> <span>const</span> <span>char</span><span>*</span> name<span>,</span> hw_device_t<span>*</span><span>*</span> device<span>)</span>\n<span>{</span>\n    <span>int</span> status <span>=</span> <span>-</span>EINVAL<span>;</span>\n    <span>if</span> <span>(</span><span>!</span><span>strcmp</span><span>(</span>name<span>,</span> GRALLOC_HARDWARE_FB0<span>)</span><span>)</span> <span>{</span> <span>// 设备名是否正确</span>\n       fb_context_t <span>*</span>dev <span>=</span> <span>(</span>fb_context_t<span>*</span><span>)</span><span>malloc</span><span>(</span><span>sizeof</span><span>(</span><span>*</span>dev<span>)</span><span>)</span><span>;</span> <span>/* 分配 hw_device_t 空间，这是一个“壳” */</span>\n       <span>memset</span><span>(</span>dev<span>,</span> <span>0</span><span>,</span> <span>sizeof</span><span>(</span><span>*</span>dev<span>)</span><span>)</span><span>;</span> <span>// 初始化</span>\n       <span>.</span><span>.</span><span>.</span>\n       dev<span>-></span>device<span>.</span>common<span>.</span>close <span>=</span> fb_close<span>;</span> <span>// 这几个接口是fb设备的核心</span>\n       dev<span>-></span>device<span>.</span>setSwapInterval <span>=</span> fb_setSwapInterval<span>;</span>\n       dev<span>-></span>device<span>.</span>post <span>=</span> fb_post<span>;</span>\n       <span>.</span><span>.</span><span>.</span>\n       private_module_t<span>*</span> m <span>=</span> <span>(</span>private_module_t<span>*</span><span>)</span><span>module</span><span>;</span>\n       status <span>=</span> <span>mapFrameBuffer</span><span>(</span>m<span>)</span><span>;</span> <span>// 内存映射，以及参数配置</span>\n       <span>if</span> <span>(</span>status <span>>=</span> <span>0</span><span>)</span> <span>{</span>\n           <span>.</span><span>.</span><span>.</span>\n           <span>*</span>device <span>=</span> <span>&amp;</span>dev<span>-></span>device<span>.</span>common<span>;</span> <span>// “壳” 和 “核心” 的关系</span>\n       <span>}</span>\n    <span>}</span>\n    <span>return</span> status<span>;</span>\n<span>}</span>\n</code></pre></div><div><pre><code><span>/* hardware/libhardware/modules/gralloc/framebuffer.cpp */</span>\n<span>struct</span> <span>fb_context_t</span> <span>{</span>\n    framebuffer_device_t  device<span>;</span>\n<span>}</span><span>;</span>\n</code></pre></div><div><pre><code><span>/* hardware/libhardware/include/hardware/fb.h */</span>\n<span>typedef</span> <span>struct</span> <span>framebuffer_device_t</span> <span>{</span>\n    <span>struct</span> <span>hw_device_t</span> common<span>;</span>\n\n    <span>const</span> <span>uint32_t</span>  flags<span>;</span>\n\n    <span>const</span> <span>uint32_t</span>  width<span>;</span>\n    <span>const</span> <span>uint32_t</span>  height<span>;</span>\n\n    <span>const</span> <span>int</span>       stride<span>;</span>\n\n    <span>const</span> <span>int</span>       format<span>;</span>\n\n    <span>const</span> <span>float</span>     xdpi<span>;</span>\n    <span>const</span> <span>float</span>     ydpi<span>;</span>\n\n    <span>const</span> <span>float</span>     fps<span>;</span>\n\n    <span>const</span> <span>int</span>       minSwapInterval<span>;</span>\n\n    <span>const</span> <span>int</span>       maxSwapInterval<span>;</span>\n\n    <span>const</span> <span>int</span>       numFramebuffers<span>;</span>\n\n    <span>int</span> reserved<span>[</span><span>7</span><span>]</span><span>;</span>\n    <span>int</span> <span>(</span><span>*</span>setSwapInterval<span>)</span><span>(</span><span>struct</span> <span>framebuffer_device_t</span><span>*</span> window<span>,</span> <span>int</span> interval<span>)</span><span>;</span>\n\n    <span>int</span> <span>(</span><span>*</span>setUpdateRect<span>)</span><span>(</span><span>struct</span> <span>framebuffer_device_t</span><span>*</span> window<span>,</span> <span>int</span> left<span>,</span> <span>int</span> top<span>,</span> <span>int</span> width<span>,</span> <span>int</span> height<span>)</span><span>;</span>\n\n    <span>int</span> <span>(</span><span>*</span>post<span>)</span><span>(</span><span>struct</span> <span>framebuffer_device_t</span><span>*</span> dev<span>,</span> buffer_handle_t buffer<span>)</span><span>;</span>\n\n    <span>int</span> <span>(</span><span>*</span>compositionComplete<span>)</span><span>(</span><span>struct</span> <span>framebuffer_device_t</span><span>*</span> dev<span>)</span><span>;</span>\n\n    <span>void</span> <span>(</span><span>*</span>dump<span>)</span><span>(</span><span>struct</span> <span>framebuffer_device_t</span><span>*</span> dev<span>,</span> <span>char</span> <span>*</span>buff<span>,</span> <span>int</span> buff_len<span>)</span><span>;</span>\n\n    <span>int</span> <span>(</span><span>*</span>enableScreen<span>)</span><span>(</span><span>struct</span> <span>framebuffer_device_t</span><span>*</span> dev<span>,</span> <span>int</span> enable<span>)</span><span>;</span>\n\n    <span>void</span><span>*</span> reserved_proc<span>[</span><span>6</span><span>]</span><span>;</span>\n\n<span>}</span> framebuffer_device_t<span>;</span>\n</code></pre></div><p>数据类型 <code>fb_context_t</code> 里的唯一成员就是 <code>framebuffer_device_t</code>，这是对 <code>fb</code> 设备的统一描述。</p>\n<p>一个标准的 <code>fb</code> 设备通常要提供如下接口实现：</p>\n<div><pre><code><span>/* 将 buffer 数据 post 到显示屏上。要求 buffer 必须与屏幕尺寸一致，\n\t并且没有被locked。这样 buffer 内容将在下一次 VSYNC 中被显示出来。*/</span>\n<span>int</span> <span>(</span><span>*</span>post<span>)</span><span>(</span><span>struct</span> <span>framebuffer_device_t</span><span>*</span> dev<span>,</span> buffer_handle_t buffer<span>)</span><span>;</span>\n\n<span>// 设置两个缓冲区交换的时间间隔。</span>\n<span>int</span> <span>(</span><span>*</span>setSwapInterval<span>)</span><span>(</span><span>struct</span> <span>framebuffer_device_t</span><span>*</span> window<span>,</span> <span>int</span> interval<span>)</span><span>;</span>\n\n<span>// 设置刷新区域，需要 framebuffer 驱动支持 “update-on-demand”。也就是说，在这个区域外的数据很可能被认为无效。</span>\n<span>int</span> <span>(</span><span>*</span>setUpdateRect<span>)</span><span>(</span><span>struct</span> <span>framebuffer_device_t</span><span>*</span> window<span>,</span> <span>int</span> left<span>,</span> <span>int</span> top<span>,</span> <span>int</span> width<span>,</span> <span>int</span> height<span>)</span><span>;</span>\n</code></pre></div><p>我们再来解释下 <code>framebuffer_device_t</code> 中一些重要的成员变量，如下表所示。</p>\n<table>\n  <tr align=\"left\">\n    <th>变量</th>\n    <th>描述</th>\n  </tr>\n  <tr>\n    <td>flags</td>\n    <td>标志位，指示 framebuffer 的属性配置</td>\n  </tr>\n  <tr>\n    <td>width、height</td>\n    <td>framebuffer 的宽和高,以像素为单位</td>\n  </tr>\n  <tr>\n    <td>format</td>\n    <td>\n\t\tframebuffer 的像素格式，比如：\n\t\t<ul>\n\t\t<li>HAL_PIXEL_FORMAT_RGBA_88888</li>\n\t\t<li>HAL_PIXEL_FORMAT_RGIBX_8888</li>\n\t\t<li>HAL_PIXEL_FORMAT_RGB_888</li>\n\t\t<li>HAL_PIXEL_FORMAT_RGB_565 等</li>\n\t\t</ul>\n\t</td>\n  </tr>\n  <tr>\n    <td>xdpi、ydpi</td>\n    <td>x 和 y 轴的密度（dot per inch）</td>\n  </tr>\n  <tr>\n    <td>xdpi、ydpi</td>\n    <td>x 和 y 轴的密度（dot per inch）</td>\n  </tr>\n  <tr>\n    <td>fps</td>\n    <td>屏幕的每秒刷新频率。假如无法从设备获取这个值，Android 系统会默认设置为 60Hz</td>\n  </tr>\n  <tr>\n    <td>minSwapInterval、maxSwapInterval</td>\n    <td>该 framebuffer 支持的最小和最大的缓冲交换时间</td>\n  </tr>\n</table>\n<p>系统打开 <code>Kernel</code> 层的 <code>fb</code> 设备以及对 <code>fb</code> 进行配置的操作是在 <code>mapFrameBuffer()</code> 中完成的。这个函数首先尝试打开如下路径中的 <code>fb</code> 设备：</p>\n<blockquote>\n<p><code>mapFrameBuffer</code> 函数内部调用 <code>open</code> 接口打开 <code>fb</code> 设备，权限为 <code>O_RDWR</code>。</p>\n</blockquote>\n<div><pre><code>\"/dev/graphics/fb%u\" 或者 \"/dev/fb%u\"\n</code></pre></div><blockquote>\n<p>其中 <code>%u</code> 表示不同的数字，代表不同的屏幕。</p>\n</blockquote>\n<div><pre><code>成功打开 fb 设备后，我们可以通过：\n\n\tioctl(fd, FBIOGET_FSCREENINFO, &amp;finfo); \n\tioctl(fd, FBIOGET_VSCREENINFO, &amp;info)\n\n来得到显示屏的一系列参数，同时通过：\n\n\tioctl(fd, FBIOPUT_VSCREENINFO, &amp;info)\n\n来对底层 fb 设备进行配置。\n</code></pre></div><p>另外，函数 <code>mapFrameBuffer</code> 的另一重要任务就是为 <code>fb</code> 设备做内存映射。主要源码语句如下：</p>\n<div><pre><code><span>/* hardware/libhardware/modules/gralloc/framebuffer.cpp */</span>\n<span>/* mapFrameBufferLocked 函数中 */</span>\n<span>/*\n映射地址保存在 module->framebuffer->base。\n变量 module 对应的是前面 hw_get_module(GRALLOC_HARDWARE_MODULE_ID, &amp;module) 得到的 hw_module_t\n（hw_module_t 被强制类型转化为 private_module_t）。\n*/</span>\n<span>void</span><span>*</span> vaddr <span>=</span> <span>mmap</span><span>(</span><span>0</span><span>,</span> fbSize<span>,</span> PROT_READ<span>|</span>PROT_WRITE<span>,</span> MAP_SHARED<span>,</span> fd<span>,</span> <span>0</span><span>)</span><span>;</span>    \n<span>module</span><span>-></span>framebuffer<span>-></span>base <span>=</span> <span>intptr_t</span><span>(</span>vaddr<span>)</span><span>;</span>\n<span>memset</span><span>(</span>vaddr<span>,</span> <span>0</span><span>,</span> fbSize<span>)</span><span>;</span>\n</code></pre></div><h4 id=\"_3-2-2-gralloc-设备的打开过程\" tabindex=\"-1\"> 3.2.2 <code>gralloc</code> 设备的打开过程</h4>\n<p><strong>接下来再看看系统打开 <code>gralloc</code> 设备的过程，它相对于 <code>fb</code> 设备简单些。如下所示：</strong></p>\n<div><pre><code> <span>/*hardware/libhardware/modules/gralloc/gralloc.cpp*/</span>\n<span>int</span> <span>gralloc_device_open</span><span>(</span><span>const</span> hw_module_t<span>*</span> <span>module</span><span>,</span> <span>const</span> <span>char</span><span>*</span> name<span>,</span> hw_device_t<span>*</span><span>*</span> device<span>)</span>\n<span>{</span>\n    <span>int</span> status <span>=</span> <span>-</span>EINVAL<span>;</span>\n    <span>if</span> <span>(</span><span>!</span><span>strcmp</span><span>(</span>name<span>,</span> GRALLOC_HARDWARE_GPU0<span>)</span><span>)</span> <span>{</span>\n        gralloc_context_t <span>*</span>dev<span>;</span> <span>// 做法和 fb 类似</span>\n        dev <span>=</span> <span>(</span>gralloc_context_t<span>*</span><span>)</span><span>malloc</span><span>(</span><span>sizeof</span><span>(</span><span>*</span>dev<span>)</span><span>)</span><span>;</span> <span>// 分配空间</span>\n        <span>/* initialize our state here */</span>\n        <span>memset</span><span>(</span>dev<span>,</span> <span>0</span><span>,</span> <span>sizeof</span><span>(</span><span>*</span>dev<span>)</span><span>)</span><span>;</span>\n        <span>.</span><span>.</span><span>.</span>\n        dev<span>-></span>device<span>.</span>alloc <span>=</span> gralloc_alloc<span>;</span> <span>// 从提供的接口来看，gralloc 主要负责 “分配和释放” 操作</span>\n        dev<span>-></span>device<span>.</span>free <span>=</span> gralloc_free<span>;</span>\n        <span>.</span><span>.</span><span>.</span>\n<span>}</span>\n</code></pre></div><blockquote>\n<p>上述代码段中与 <code>fb</code> 相似的部分我们就不多做介绍了。</p>\n</blockquote>\n<p>因为 <code>gralloc</code> 担负着图形缓冲区的分配与释放，所以它提供的两个最重要的接口是 <code>alloc</code> 和 <code>free</code>。这里暂时先不深入分析，后续会有讲解。</p>\n<h2 id=\"_4-android-中的本地窗口\" tabindex=\"-1\"> 4 <code>Android</code> 中的本地窗口</h2>\n<p>在  小节中提到了 “本地窗口”（<code>Native Window</code>）这一概念。</p>\n<p>本地窗口是 <code>OpenGL</code> 能否兼容多种系统（如 <code>Windows</code>，<code>Android</code>）的关键。</p>\n<p>那么对于 <code>Android</code> 系统来说，它是如何将 <code>OpenGL ES</code> 本地化的呢？或者说，它提供了什么样的本地窗口？</p>\n<p>根据整个 <code>Android</code> 系统的 <code>GUI</code> 设计理念，我们不难猜想到至少需要两种本地窗口。</p>\n<div><pre><code>面向管理者（SurfaceFlinger）\n\t既然 SurfaceFlinger 扮演了系统中所有 UI 界面的管理者，那么它无可厚非需要直接或间接地持有 “本地窗口”。\n\t我们知道，这个窗口就是 FramebufferNativeWindow。\n\n面向应用程序\n\t这类本地窗口是 Surface。\n</code></pre></div><p>为什么需要两种本地窗口呢？</p>\n<div><pre><code>因为一个系统设备中显然只会有一个帧缓冲区 framebuffer，但一个系统设备中可以同时运行多个 UI 程序。\n\n为了能够让多个 UI 程序有序地进行显示，我们需要为每个 UI 程序单独地分配本地窗口，\n为 UI 程序单独分配本地窗口其实就是单独分配一个内存缓存区来保存显示数据。\n\n而 SurfaceFlinger 所持有的本地窗口就是能直接显示在屏幕上的帧缓冲区 framebuffer。\nSurfaceFlinger 作为管理者，会收集所有 UI 程序的内存缓冲区中的显示数据，\n并进行统一的图像混合操作，然后输出到帧缓冲区 framebuffer 中。\n</code></pre></div><h3 id=\"_4-1-framebuffernativewindow\" tabindex=\"-1\"> 4.1 <code>FramebufferNativeWindow</code></h3>\n<p>EGL 需要通过本地窗口来为<code> OpenGL/OpenGL ES</code> 创造环境。其函数原型如下：</p>\n<div><pre><code>EGLSurface <span>eglCreateWindowSurface</span><span>(</span>EGLDisplay dpy<span>,</span> EGLConfig config<span>,</span> NativeWindowType window<span>,</span> <span>const</span> EGLint <span>*</span>attrib_list<span>)</span><span>;</span>\n</code></pre></div><p>从函数原型来看，不论是哪一类本地窗口，都必须要与 NativeWindowType 保持一致，否则就无法正常使用 EGL 了。</p>\n<p>先从数据类型的定义来看看这个 window 参数有什么特别之处：</p>\n<div><pre><code><span>/*frameworks/native/opengl/include/egl/Eglplatform.h*/</span>\n<span>typedef</span> EGLNativeWindowType NativeWindowType<span>;</span> <span>// NativeWindowType 其实就是 EGLNativeWindowType</span>\n<span>.</span><span>.</span><span>.</span>\n\n<span><span>#</span><span>if</span> <span><span>defined</span><span>(</span>_WIN32<span>)</span> <span>||</span> <span>defined</span><span>(</span>__VC32__<span>)</span> <span>&amp;&amp;</span> <span>!</span><span>defined</span><span>(</span>__CYGWIN__<span>)</span> <span>&amp;&amp;</span> <span>!</span><span>defined</span><span>(</span>__SCITECH_SNAP__<span>)</span></span></span>\n<span>.</span><span>.</span><span>.</span>\n<span>typedef</span> HWND  EGLNativeWindowType<span>;</span> <span>/* Win32 和 WinCE系统下的定义 */</span>\n\n<span><span>#</span><span>elif</span> <span><span>defined</span><span>(</span>__WINSCW__<span>)</span> <span>||</span> <span>defined</span><span>(</span>__SYMBIAN32__<span>)</span>  </span></span>\n<span>.</span><span>.</span><span>.</span>\n<span>typedef</span> <span>void</span> <span>*</span>EGLNativeWindowType<span>;</span> <span>/* Symbian系统 */</span>\n\n<span><span>#</span><span>elif</span> <span><span>defined</span><span>(</span>__ANDROID__<span>)</span> <span>||</span> <span>defined</span><span>(</span>ANDROID<span>)</span></span></span>\n<span>struct</span> <span>ANativeWindow</span><span>;</span>\n<span>.</span><span>.</span><span>.</span>\n<span>typedef</span> <span>struct</span> <span>ANativeWindow</span><span>*</span> EGLNativeWindowType<span>;</span> <span>/* Android系统 */</span>\n<span>.</span><span>.</span><span>.</span>\n\n<span><span>#</span><span>elif</span> <span><span>defined</span><span>(</span>__unix__<span>)</span></span></span>\n<span>.</span><span>.</span><span>.</span>\n<span>typedef</span> Window   EGLNativeWindowType<span>;</span> <span>/* UNIX系统 */</span>\n<span><span>#</span><span>else</span></span>\n<span><span>#</span><span>error</span> <span>\"Platform not recognized\"</span></span>\n<span><span>#</span><span>endif</span></span>\n</code></pre></div><p>以上代码中，不同的操作系统平台下 <code>EGLNativeWindowType</code> 所对应的具体数据类型如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>操作系统</strong></th>\n<th style=\"text-align:left\"><strong>数据类型</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Win32、WinCE</td>\n<td style=\"text-align:left\">HWND，即句柄</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Symbian</td>\n<td style=\"text-align:left\">Void*</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Android`</td>\n<td style=\"text-align:left\">ANativeWindow*</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">UNIX</td>\n<td style=\"text-align:left\">Window</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">其他</td>\n<td style=\"text-align:left\">暂时不支持</td>\n</tr>\n</tbody>\n</table>\n<p><code>ANativeWindow</code> 的定义在 <code>window.h</code> 头文件中：</p>\n<div><pre><code><span>/*system/core/include/system/window.h*/</span>\n<span>struct</span> <span>ANativeWindow</span>\n<span>{</span>\n    <span>.</span><span>.</span><span>.</span>\n    <span>const</span> <span>uint32_t</span> flags<span>;</span> <span>// 与 Surface 或 updater 有关的属性</span>\n    <span>const</span> <span>int</span> minSwapInterval<span>;</span> <span>// 所支持的最小交换间隔时间</span>\n    <span>const</span> <span>int</span> maxSwapInterval<span>;</span> <span>// 所支持的最大交换间隔时间</span>\n    <span>const</span> <span>float</span> xdpi<span>;</span> <span>// 水平方向的密度，以 dpi 为单位</span>\n    <span>const</span> <span>float</span> ydpi<span>;</span> <span>// 垂直方向的密度，以 dpi 为单位</span>\n    intptr_t oem<span>[</span><span>4</span><span>]</span><span>;</span><span>//为OEM定制驱动所保留的空间</span>\n    <span>int</span> <span>(</span><span>*</span>setSwapInterval<span>)</span><span>(</span><span>struct</span> <span>ANativeWindow</span><span>*</span> window<span>,</span> <span>int</span> interval<span>)</span><span>;</span>\n    <span>int</span> <span>(</span><span>*</span>dequeueBuffer<span>)</span><span>(</span><span>struct</span> <span>ANativeWindow</span><span>*</span> window<span>,</span> <span>struct</span> <span>ANativeWindowBuffer</span><span>*</span><span>*</span> buffer<span>,</span> <span>int</span><span>*</span> fenceFd<span>)</span><span>;</span>\n    <span>int</span> <span>(</span><span>*</span>queueBuffer<span>)</span><span>(</span><span>struct</span> <span>ANativeWindow</span><span>*</span> window<span>,</span> <span>struct</span> <span>ANativeWindowBuffer</span><span>*</span> buffer<span>,</span> <span>int</span> fenceFd<span>)</span><span>;</span>\n    <span>int</span> <span>(</span><span>*</span>cancelBuffer<span>)</span><span>(</span><span>struct</span> <span>ANativeWindow</span><span>*</span> window<span>,</span> <span>struct</span> <span>ANativeWindowBuffer</span><span>*</span> buffer<span>,</span> <span>int</span> fenceFd<span>)</span><span>;</span>\n    <span>int</span> <span>(</span><span>*</span>query<span>)</span><span>(</span><span>const</span> <span>struct</span> <span>ANativeWindow</span><span>*</span> window<span>,</span><span>int</span> what<span>,</span> <span>int</span><span>*</span> value<span>)</span><span>;</span>\n    <span>int</span> <span>(</span><span>*</span>perform<span>)</span><span>(</span><span>struct</span> <span>ANativeWindow</span><span>*</span> window<span>,</span><span>int</span> operation<span>,</span> <span>.</span><span>.</span><span>.</span> <span>)</span><span>;</span>\n    <span>void</span><span>*</span> reserved_proc<span>[</span><span>2</span><span>]</span><span>;</span>\n<span>}</span><span>;</span>\n</code></pre></div><p><code>ANativeWindow</code> 结构体中几个重要成员函数如下表所示：</p>\n<table>\n  <tr align=\"left\">\n    <th>Member Function</th>\n    <th>Description</th>\n  </tr>\n  <tr>\n    <td>setSwapInterval</td>\n    <td>设置交换间隔时间</td>\n  </tr>\n  <tr>\n    <td>dequeueBuffer</td>\n    <td>EGL 通过这个接口来申请一个 buffer。从前面我们所举的例子来说，两个本地窗口所提供的 buffer 分别来自于帧缓冲区和内存空间。<br/>\n\t单词 dequeue 的字面意思是出队列。这从侧面告诉我们，一个 Window 所包含的 buffer 很可能不止一份</td>\n  </tr>\n  <tr>\n    <td>queueBuffer</td>\n    <td>当 EGL 对一块 buffer 渲染完成后，它调用这个接口来 unlock 和 post buffer</td>\n  </tr>\n  <tr>\n    <td>cancelBuffer</td>\n    <td>这个接口可以用来取消一个已经 dequeued 的 buffer，但要特别注意同步的问题</td>\n  </tr>\n  <tr>\n    <td>query</td>\n    <td>用于向本地窗口咨询相关信息</td>\n  </tr>\n  <tr>\n    <td>perform</td>\n    <td>\n\t\t用于执行本地窗口支持的各种操作，比如:\n\t\t<ul>\n\t\t\t<li>NATIVE_WINDOW_SET_USAGE</li>\n\t\t\t<li>NATIVE_WINDOW_SET_CROP</li>\n\t\t\t<li>NATIVE_WINDOW_SET_BUFFER_COUNT</li>\n\t\t\t<li>NATIVE_WINDOW_SET_BUFFERS_TRANSFORM</li>\n\t\t\t<li>NATIVE_WINDOW_SET_BUFFERS_TIMESTAMP 等</li>\n\t\t</ul>\n\t</td>\n  </tr>\n</table>\n<p>从上面对 <code>ANativeWindow</code> 的描述可以看出，它更像一份 “协议”，规定了一个本地窗口的形态和功能。这对于支持多种本地窗口的系统是必需的，因为只有这样我们才能针对某种特定的平台窗口来填充具体的实现。</p>\n<p>这个小节中我们需要分析 <code>FramebufferNativeWindow</code> 是如何履行这份 “协议” 的。</p>\n<p><code>FramebufferNativeWindow</code> 本身代码并不多，下面分别选取其构造函数及 <code>dequeue</code> 函数来分析。其他部分的实现都类似，大家可以参考阅读。</p>\n<blockquote>\n<p>注意：</p>\n<p>高版本中，<code>FramebufferNativeWindow</code> 已被移除，实现了 ANativeWindow 接口的子类只发现如下两个：</p>\n<div><pre><code>frameworks<span>/</span>native<span>/</span>services<span>/</span>surfaceflinger<span>/</span>CompositionEngine<span>/</span>include<span>/</span>compositionengine<span>/</span>mock<span>/</span>NativeWindow<span>.</span>h\nframeworks<span>/</span>native<span>/</span>libs<span>/</span>gui<span>/</span>include<span>/</span>gui<span>/</span>Surface<span>.</span>h\n</code></pre></div><p>高版本的差异再后续更新文档时再补充。</p>\n</blockquote>\n<h4 id=\"_4-1-1-构造函数中的初始化操作\" tabindex=\"-1\"> 4.1.1 构造函数中的初始化操作</h4>\n<p>根据 FramebufferNativeWindow 所完成的功能，可以大概推测出它的构造函数里应该至少完成如下初始化操作。</p>\n<div><pre><code>1. 加载 GRALLOC_HARDWARE_MODULE_ID 模块（即 Gralloc 模块），详细流程在 Gralloc 小节已经解释过了。\n2. 分别打开 fb 和 gralloc 设备。我们在 Gralloc 小节也已经分析过，打开后的设备由全局变量 fbDev 和 grDev 管理。\n3. 根据设备的属性来给 FramebufferNativeWindow 赋初值。\n4. 根据 FramebufferNativeWindow 的实现来填充 ANativeWindow 中的 “协议”。\n5. 其他一些必要的初始化。\n</code></pre></div><p>下面从源码的角度来分析上述每个步骤具体是怎么实现的：</p>\n<div><pre><code><span>/* frameworks/native/libs/ui/FramebufferNativeWindow.cpp */</span>\n<span>FramebufferNativeWindow</span><span>::</span><span>FramebufferNativeWindow</span><span>(</span><span>)</span> <span>:</span> <span>BASE</span><span>(</span><span>)</span><span>,</span> <span>fbDev</span><span>(</span><span>0</span><span>)</span><span>,</span> <span>grDev</span><span>(</span><span>0</span><span>)</span><span>,</span> <span>mUpdateOnDemand</span><span>(</span><span>false</span><span>)</span>\n<span>{</span>\n    hw_module_t <span>const</span><span>*</span> <span>module</span><span>;</span>\n    <span>if</span> <span>(</span><span>hw_get_module</span><span>(</span>GRALLOC_HARDWARE_MODULE_ID<span>,</span> <span>&amp;</span><span>module</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span> <span>// 加载模块</span>\n\t\t<span>.</span><span>.</span><span>.</span>\n        <span>int</span> stride<span>;</span>\n        <span>int</span> err<span>;</span>\n        <span>int</span> i<span>;</span>\n        err <span>=</span> <span>framebuffer_open</span><span>(</span><span>module</span><span>,</span> <span>&amp;</span>fbDev<span>)</span><span>;</span>\n        err <span>=</span> <span>gralloc_open</span><span>(</span><span>module</span><span>,</span> <span>&amp;</span>grDev<span>)</span> <span>;</span><span>// 分别打开 fb 和 gralloc</span>\n        <span>/*上面这部分内容我们在前几个小节已经分析过了，不清楚的可以回头看一下*/</span>\n        <span>.</span><span>.</span><span>.</span>\n        <span>if</span><span>(</span>fbDev<span>-></span>numFramebuffers <span>>=</span> MIN_NUM_FRAME_BUFFERS <span>&amp;&amp;</span>\n            fbDev<span>-></span>numFramebuffers <span>&lt;=</span> MAX_NUM_FRAME_BUFFERS<span>)</span><span>{</span> <span>// 根据fb设备属性获得buffer数</span>\n            mNumBuffers <span>=</span> fbDev<span>-></span>numFramebuffers<span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            mNumBuffers <span>=</span> MIN_NUM_FRAME_BUFFERS<span>;</span> <span>// 否则就采用最少的 buffer 数值，即 2</span>\n        <span>}</span>\n        mNumFreeBuffers <span>=</span> mNumBuffers<span>;</span> <span>// 可用的 buffer 个数，初始时是所有 buffer 可用</span>\n        mBufferHead <span>=</span> mNumBuffers<span>-</span><span>1</span><span>;</span>\n        <span>.</span><span>.</span><span>.</span>\n        <span>for</span> <span>(</span>i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> mNumBuffers<span>;</span> i<span>++</span><span>)</span> <span>// 给每个 buffer 初始化</span>\n        <span>{</span>\n            buffers<span>[</span>i<span>]</span> <span>=</span> <span>new</span> <span>NativeBuffer</span><span>(</span>fbDev<span>-></span>width<span>,</span> fbDev<span>-></span>height<span>,</span> fbDev<span>-></span>format<span>,</span> GRALLOC_USAGE _HW_FB<span>)</span><span>;</span>\n        <span>}</span> <span>/</span> <span>/</span>NativeBuffer是什么？\n\n        <span>for</span> <span>(</span>i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> mNumBuffers<span>;</span> i<span>++</span><span>)</span> <span>// 给每个 buffer 分配空间</span>\n        <span>{</span>\n            err <span>=</span> grDev<span>-></span><span>alloc</span><span>(</span>grDev<span>,</span> fbDev<span>-></span>width<span>,</span> fbDev<span>-></span>height<span>,</span> fbDev<span>-></span>format<span>,</span> GRALLOC_USAGE_HW_FB<span>,</span> \n\t\t\t\t\t\t\t\t<span>&amp;</span>buffers<span>[</span>i<span>]</span><span>-></span>handle<span>,</span> <span>&amp;</span>buffers<span>[</span>i<span>]</span><span>-></span>stride<span>)</span><span>;</span>\n            <span>.</span><span>.</span><span>.</span>\n        <span>}</span>\n\n        <span>/* 为本地窗口赋属性值 */</span>\n        <span><span>const_cast</span><span><span>&lt;</span><span>uint32_t</span><span>&amp;</span><span>></span></span></span><span>(</span>ANativeWindow<span>::</span>flags<span>)</span> <span>=</span> fbDev<span>-></span>flags<span>;</span>\n        <span><span>const_cast</span><span><span>&lt;</span><span>float</span><span>&amp;</span><span>></span></span></span><span>(</span>ANativeWindow<span>::</span>xdpi<span>)</span> <span>=</span> fbDev<span>-></span>xdpi<span>;</span>\n        <span><span>const_cast</span><span><span>&lt;</span><span>float</span><span>&amp;</span><span>></span></span></span><span>(</span>ANativeWindow<span>::</span>ydpi<span>)</span> <span>=</span> fbDev<span>-></span>ydpi<span>;</span>\n        <span><span>const_cast</span><span><span>&lt;</span><span>int</span><span>&amp;</span><span>></span></span></span><span>(</span>ANativeWindow<span>::</span>minSwapInterval<span>)</span> <span>=</span>fbDev<span>-></span>minSwapInterval<span>;</span>\n        <span><span>const_cast</span><span><span>&lt;</span><span>int</span><span>&amp;</span><span>></span></span></span><span>(</span>ANativeWindow<span>::</span>maxSwapInterval<span>)</span> <span>=</span> fbDev<span>-></span>maxSwapInterval<span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n        <span>ALOGE</span><span>(</span><span>\"Couldn't get gralloc module\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/* 以下代码段开始履行窗口 “协议” */</span>\n    ANativeWindow<span>::</span>setSwapInterval <span>=</span> setSwapInterval<span>;</span>\n    ANativeWindow<span>::</span>dequeueBuffer <span>=</span> dequeueBuffer<span>;</span>\n    ANativeWindow<span>::</span>queueBuffer <span>=</span> queueBuffer<span>;</span>\n    ANativeWindow<span>::</span>query <span>=</span> query<span>;</span>\n    ANativeWindow<span>::</span>perform <span>=</span> perform<span>;</span>\n\n    <span>/* 下面这几个接口已经被废弃了，不过为了保持兼容性，暂时还是保留的 */</span>\n    ANativeWindow<span>::</span>dequeueBuffer_DEPRECATED <span>=</span> dequeueBuffer_DEPRECATED<span>;</span>\n    ANativeWindow<span>::</span>lockBuffer_DEPRECATED <span>=</span> lockBuffer_DEPRECATED<span>;</span>\n    ANativeWindow<span>::</span>queueBuffer_DEPRECATED <span>=</span> queueBuffer_DEPRECATED<span>;</span>\n<span>}</span>\n</code></pre></div><p>如上初始化代码中，我们重点关注 <code>FramebufferNativeWindow</code> 是如何分配 <code>buffer</code> 的。换句话说，其 <code>dequeue</code> 方法所获得的缓冲区是从何而来的。</p>\n<div><pre><code>成员变量 mNumBuffers 代表了 FramebufferNativeWindow 所管理的 buffer 总数。它取决于两个方面：\n1. 首先从 fb 设备中取值，即 numFramebuffers；\n2. 否则就默认定义为 MIN_NUM_FRAME_BUFFERS。\n\n如下所示：\n    #define MIN_NUM_FRAME_BUFFERS 2 \n    #define MAX_NUM_FRAME_BUFFERS 3\n\n可见 Android 系统认为最少的 buffer 数为 2，最大为 3。\n</code></pre></div><p>有人可能会觉得奇怪，既然 <code>FramebufferNativeWindow</code> 对应的是真实的物理屏幕，那么为什么还需要两个 <code>buffer</code> 呢？</p>\n<p>考虑只有一个 <code>buffer</code> 的情况：</p>\n<div><pre><code>这意味着绘制什么，屏幕上就要显示什么。\n对于用户来说，将看到一个不断刷新的画面。通俗地讲，就是画面很 “卡”。\n特别是对于图像刷新很频繁的场景（比如大型游戏），用户的体验就会更差。\n</code></pre></div><p>那么，有什么解决的办法呢？</p>\n<div><pre><code>我们知道，出现这种现象的原因就是程序直接以屏幕为绘图板，把还没有准备就绪的图像直接呈现给了用户。换句话说，\n如果可以等到整幅图像绘制完成以后再刷新到屏幕上，那么用户在任何时候看到的都是正确而完整的画面，问题也就解决了。\n</code></pre></div><p>也就是说，一个 <code>buffer</code> 用来保存绘制数据，一个 <code>buffer</code> 用来将保存的绘制数据刷新到屏幕上，如下图所示。</p>\n<p><img src=\"@source/lango-tech/subject/images/surfaceflinger/03.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>上图表示的就是通常所称的 “双缓冲”（<code>Double-Buffering</code>）技术。\n除此之外，其实还有三缓冲（<code>Triple Buffering</code>）、四缓冲（<code>Quad Buffering</code>）等，\n我们将它们统称为 “多缓冲”（<code>Multiple Buffering</code>）机制。</p>\n</blockquote>\n<p>理解了为什么需要双缓冲以后，我们再回过头来看 <code>FramebufferNativeWindow</code> 的构造函数。</p>\n<p>接下来要解决的另一个问题是：多个缓冲区空间是从哪里分配的？</p>\n<p>通过前几个小节的知识可知，应该是要向 <code>HAL</code> 层的 <code>Gralloc</code> 申请。</p>\n<div><pre><code>FramebufferNativeWindow 构造函数中的第一个 for 循环里先给各 buffer 创建相应的实例（new NativeBuffer），\n其中的属性值都来源于 fbDev，如宽、高、格式等。\n\n紧随其后的就是调用 Gralloc 设备的 alloc() 方法：\n\n\t/*\n\t函数原型：\n\tint (*alloc)(struct alloc_device_t* dev, int w, int h, int format, int usage, buffer_handle_t* handle, int* stride);\n\t*/\n\terr = grDev->alloc(grDev, fbDev->width, fbDev->height, fbDev->format, GRALLOC_USAGE_HW_FB, \n\t\t\t\t\t\t&amp;buffers[i]->handle, &amp;buffers[i]->stride);\n\n注意第 5 个参数，它代表所要申请的缓冲区的用途，\n定义在 hardware/libhardware/include/hardware/gralloc.h 中，目前已经支持几十种。比如：\n\n\tGRALLOC_USAGE_HW_TEXTURE       // 缓冲区将用于OpenGL ES Texture。\n\tGRALLOC_USAGE_HW_RENDER        // 缓冲区将用于OpenGL ES的渲染。\n\tGRALLOC_USAGE_HW_2D            // 缓冲区会提供给2D 硬件图形设备。\n\tGRALLOC_USAGE_HW_COMPOSER      // 缓冲区用于HWComposer HAL模块。\n\tGRALLOC_USAGE_HW_FB            // 缓冲区用于framebuffer设备。\n\tGRALLOC_USAGE_HW_VIDEO_ENCODER // 缓冲区用于硬件视频编码器。\n\n这里申请的缓冲区是要在终端屏幕上显示的，所以申请的 usage 类 型是 GRALLOC_USAGE_HW_FB，\n对应的 Gralloc 中的实现是 gralloc_alloc_framebuffer@gralloc.cpp；\n\n假如是其他用途的缓冲区申请，则对应 gralloc_alloc_buffer@gralloc.cpp。\n不过，如果底层只允许一个 buffer（不支持 page-flipping 的情况），\n那么 gralloc_alloc_framebuffer 也同样可能只返回一个 ashmem 中申请的 “内存空间”，真正的 “帧缓冲区” 则要在 post 时才会被用到。\n</code></pre></div><p>所有申请到的缓冲区都需要由 <code>FramebufferNativeWindow</code> 中的全局变量 <code>buffers[MAX_NUM_FRAME_BUFFERS]</code> 来记录，</p>\n<p>每个数据元素是一个 <code>NativeBuffer</code>。这个类的定义如下：</p>\n<div><pre><code><span>class</span> <span>NativeBuffer</span> <span>:</span> <span><span>public</span> <span>ANativeObjectBase</span><span>&lt;</span><span>ANativeWindowBuffer</span><span>,</span> <span>NativeBuffer</span><span>,</span> <span>LightRefBase</span><span>&lt;</span><span>NativeBuffer</span><span>>></span></span>\n<span>{</span>\n\t<span>.</span><span>.</span><span>.</span>\n</code></pre></div><p>可见这个 “本地缓冲区” 继承了 <code>ANativeWindowBuffer</code> 的特性，后者的定义在 <code>/system/core/include/system/window.h</code> 中：</p>\n<blockquote>\n<p>高版本系统定义在了 <code>frameworks/native/libs/nativebase/include/nativebase/nativebase.h</code> 中。</p>\n</blockquote>\n<div><pre><code><span>typedef</span> <span>struct</span> <span>ANativeWindowBuffer</span>\n<span>{</span>\n\t<span>.</span><span>.</span><span>.</span>\n    <span>int</span> width<span>;</span> <span>// 宽</span>\n    <span>int</span> height<span>;</span> <span>/</span> <span>/</span>高\n\t<span>.</span><span>.</span><span>.</span>\n    buffer_handle_t handle<span>;</span> <span>/* 代表内存块的句柄，比如 ashmem 机制 */</span>\n\t<span>.</span><span>.</span><span>.</span>\n<span>}</span> ANativeWindowBuffer_t<span>;</span>\n</code></pre></div><p>另外，当前可用（<code>free</code>）的 <code>buffer</code> 数量由 <code>mNumFreeBuffers</code> 管理，这个变量的初始值也是 <code>mNumBuffers</code>，即总共有 <code>2</code> 或 <code>3</code> 个可用缓冲区。</p>\n<p>在程序后续的运行过程中，始终由 <code>mBufferHead</code> 来指向下一个将被申请的 <code>buffer</code>（注意：不是下一个可用 <code>buffer</code>）。</p>\n<div><pre><code>也就是说，每当用户向 FramebufferNativeWindow 申请一个 buffer 时（dequeueBuffer），这个 mBufferHead 就会增加 1；\n一旦它的值超过最大值，则还会变成 0，如此就实现了循环管理。后面在讲解 dequeueBuffer 时再详细解释。\n</code></pre></div><p>一个本地窗口包含了很多属性值，如各种标志（<code>flags</code>）、横纵坐标的密度值等。这些数值都可以从 <code>fb</code> 设备中查询到，<code>我们需要将它们赋予刚生成的FramebufferNativeWindow</code> 实例的属性。</p>\n<p>最后，就应该履行 <code>ANativeWindow</code> 的接口协议了。<code>FramebufferNativeWindow</code> 会将其对应的成员函数逐个填充到 <code>ANativeWindow</code> 的函数指针中，比如：</p>\n<div><pre><code>ANativeWindow<span>::</span>setSwapInterval <span>=</span> setSwapInterval<span>;</span> \nANativeWindow<span>::</span>dequeueBuffer <span>=</span> dequeueBuffer<span>;</span>\n</code></pre></div><p>这样子 <code>OpenGL ES</code> 才能通过一个 <code>ANativeWindow</code> 来与本地窗口系统建立正确的连接。</p>\n<p>下面我们详细分析其中 <code>dequeueBuffer</code> 的实现。</p>\n<h4 id=\"_4-1-2-dequeuebuffer\" tabindex=\"-1\"> 4.1.2 <code>dequeueBuffer</code></h4>\n<p>这个函数虽然很短（只有二十几行），却是 <code>FramebufferNativeWindow</code> 中的核心。<code>OpenGL ES</code> 就是通过它来分配一个可用于渲染的缓冲区的：</p>\n<div><pre><code><span>/*\n\tdequeueBuffer 在 ANativeWindow 中的函数原型：\n\tint (*dequeueBuffer)(struct ANativeWindow* window, struct ANativeWindowBuffer** buffer, int* fenceFd);\n*/</span>\n<span>int</span> <span>FramebufferNativeWindow</span><span>::</span><span>dequeueBuffer</span><span>(</span>ANativeWindow<span>*</span> window<span>,</span> ANativeWindowBuffer<span>*</span><span>*</span> buffer<span>,</span> <span>int</span><span>*</span> fenceFd<span>)</span>\n<span>{</span>\n\t<span>/* Step1 */</span>\n    FramebufferNativeWindow<span>*</span> self <span>=</span> <span>getSelf</span><span>(</span>window<span>)</span><span>;</span> \n\n\t<span>/* Step2 */</span>\n    Mutex<span>::</span>Autolock <span>_l</span><span>(</span>self<span>-></span>mutex<span>)</span><span>;</span> \n    <span>.</span><span>.</span><span>.</span>\n\t<span>/* Step3. 计算 mBufferHead */</span>\n    <span>int</span> index <span>=</span> self<span>-></span>mBufferHead<span>++</span><span>;</span>\n    <span>if</span> <span>(</span>self<span>-></span>mBufferHead <span>>=</span> self<span>-></span>mNumBuffers<span>)</span>\n        self<span>-></span>mBufferHead <span>=</span> <span>0</span><span>;</span> <span>// 循环</span>\n\n    <span>/* Step4. 如果当前没有可用缓冲区 */</span>\n    <span>while</span> <span>(</span><span>!</span>self<span>-></span>mNumFreeBuffers<span>)</span> <span>{</span>\n        self<span>-></span>mCondition<span>.</span><span>wait</span><span>(</span>self<span>-></span>mutex<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/* Step5. 如果有人释放了缓冲区 */</span>\n    self<span>-></span>mNumFreeBuffers<span>--</span><span>;</span>\n    self<span>-></span>mCurrentBufferIndex <span>=</span> index<span>;</span>\n    <span>*</span>buffer <span>=</span> self<span>-></span>buffers<span>[</span>index<span>]</span><span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>\n    <span>*</span>fenceFd <span>=</span> <span>-</span><span>1</span><span>;</span>\n    <span>return</span> <span>0</span><span>;</span>\n<span>}</span>\n</code></pre></div><div><pre><code>Step1@FramebufferNativeWindow::dequeueBuffer\n\n这里先将入参中 ANativeWindow 类型的变量 window 强制转化为 FramebufferNativeWindow。\n因为前者是后者的父类，所以这样的转化当然是有效的。\n\n不过细心的读者可能会发现，为什么函数入参中还要特别传入一个 ANativeWindow 对象的内存地址，\n直接使用FramebufferNativeWindow的this指针不行吗？\n这么做很可能是为了兼容各种平台。\n\n大家应该注意到 ANativeWindow 是一个 Struct 数据类型，而在 C 语言中 Struct 是没有成员函数的，\n所以我们通常是用函数指针的形式来模拟一个成员函数，如这个 dequeueBuffer 在 ANativeWindow 的定义就是一个函数指针，\n\n而且系统并没有办法预先知道最终填充到 ANativeWindow 中的函数指针实现里是否可以使用 this 指针，\n所以在参数中带入一个 window 变量就是必要的。\n</code></pre></div><div><pre><code>Step2@FramebufferNativeWindow::dequeueBuffer\n\n获得一个 Mutex 锁。\n因为接下来的操作涉及资源互斥区，自然需要有一个保护措施。\n这里采用的是 Autolock，意味着 dequeueBuffer 函数结束后会自动释放 Mutex。\n</code></pre></div><div><pre><code>Step3@FramebufferNativeWindow::dequeueBuffer\n\n前面我们介绍过 mBufferHead 变量，这里来看看它的实际使用。\n首先 index 得到的是 mBufferHead 所代表的当前位置，然后 mBufferHead 增加 1。\n由于我们是循环利用多个缓冲区的，所以如果这个变量的值大于或等于 mNumBuffers，那么就需要把它置为 0。\n也就是说，mBufferHead 的值永远只能是 [0-2] 中的一个。\n</code></pre></div><div><pre><code>Step4@FramebufferNativeWindow::dequeueBuffer\n\nmBufferHead 并不代表它所指向的缓冲区是可用的。\n假如当前的 mNumFreeBuffers 表明已经没有多余的缓冲区空间，那么我们就需要等待有人释放 buffer 后才能继续操作。\n(这里使用到 Condition 这一同步机制。)\n可以肯定的是，这里调用了 mCondition.wait，那么必然有其他地方要唤醒它 —— 具体的就是在 queueBuffer()中。\n</code></pre></div><div><pre><code>Step5@FramebufferNativeWindow::dequeueBuffer\n\n一旦成功获取到一个 buffer 后，程序要把可用的 buffer 计数值减 1（mNumFreeBuffers--）。\n另外 mBufferHead 前面已经做过自增（++）处理，这里就不用再做特别工作。\n</code></pre></div><p>这样我们就完成了 <code>Android</code> 系统中 <code>FramebufferNativeWindow</code> 本地窗口的分析。</p>\n<p>接下来讲解另一个重要的本地窗口。</p>\n<h3 id=\"_4-2-surface\" tabindex=\"-1\"> 4.2 <code>Surface</code></h3>\n<p><code>Surface</code> 是针对应用程序端的本地窗口，和 <code>FramebufferNativeWindow</code> 一样，它必须继承 <code>AnativeWindow</code>：</p>\n<div><pre><code><span>/* frameworks/native/libs/gui/include/gui/Surface.h */</span>\n<span>class</span> <span>Surface</span> <span>:</span> <span>public</span> ANativeObjectBase<span>&lt;</span>ANativeWindow<span>,</span> Surface<span>,</span> RefBase<span>></span>\n</code></pre></div><p>这个本地窗口当然也需要实现 <code>ANativeWindow</code> 所制定的 “协议”，我们关注的重点是它与前面的 <code>FramebufferNativeWindow</code> 有什么不同。</p>\n<p><code>Surface</code> 的构造函数只是简单地给 <code>ANativeWindow::dequeueBuffer</code> 等函数指针及内部变量赋了初值。</p>\n<p>由于整个函数的功能很简单，我们只摘录部分核心内容：</p>\n<div><pre><code><span>/* frameworks/native/libs/gui/Surface.cpp */</span>\n<span>Surface</span><span>::</span><span>Surface</span><span>(</span><span>const</span> sp<span>&lt;</span>IGraphicBufferProducer<span>></span><span>&amp;</span> bufferProducer<span>)</span><span>:</span> <span>mGraphicBufferProducer</span><span>(</span>bufferProducer<span>)</span>\n<span>{</span>\n    <span>/* 给 ANativeWindow 中的函数指针赋值 */</span>\n    ANativeWindow<span>::</span>setSwapInterval  <span>=</span> hook_setSwapInterval<span>;</span>\n    ANativeWindow<span>::</span>dequeueBuffer    <span>=</span> hook_dequeueBuffer<span>;</span>\n    <span>.</span><span>.</span><span>.</span>\n    <span>/* 为各内部变量赋值，因为此时用户还没有发起申请，所以大部分变量的初始值是 0 */</span>\n    mReqWidth <span>=</span> <span>0</span><span>;</span>\n    mReqHeight <span>=</span> <span>0</span><span>;</span>\n    <span>.</span><span>.</span><span>.</span>\n    mDefaultWidth <span>=</span> <span>0</span><span>;</span>\n    mDefaultHeight <span>=</span> <span>0</span><span>;</span>\n    mUserWidth <span>=</span> <span>0</span><span>;</span>\n    mUserHeight <span>=</span> <span>0</span><span>;</span>\n    <span>.</span><span>.</span><span>.</span>\n<span>}</span>\n</code></pre></div><p><code>Surface</code> 是面向 <code>Android</code> 系统中所有 <code>UI</code> 应用程序的，即它承担着应用进程中的 <code>UI</code> 显示需求。</p>\n<p>基于这点，可以推测出其内部实现至少要考虑以下几点：</p>\n<div><pre><code>1. 面向上层实现（主要是 Java 层）提供绘制图像的 “画板”\n    前面说过，这个本地窗口分配的内存空间不属于帧缓冲区，那么具体是由谁来分配的，又是如何管理的呢？\n\n2. 它与 SurfaceFlinger 间是如何分工的\n\t显然 SurfaceFlinger 需要收集系统中所有应用程序绘制的图像数据，然后集中显示到物理屏幕上。\n\t在这个过程中，Surface 扮演了什么样的角色呢？\n</code></pre></div><p>先来解释下 <code>Surface</code> 类中一些重要的成员变量，如下表所示。</p>\n<table>\n\t<tr>\n\t\t<th>成员变量</th>\n\t\t<th>说明</th>\n\t</tr>\n\t<tr>\n\t\t<td>sp&lt;IGraphicBufferProducer&gt;mGraphicBufferProducer</td>\n\t\t<td>\n\t\t\t这个变量是 Surface 的核心，很多 “协议” 就是通过它实现的，后面会有详细讲解。\n\t\t\t值得一提的是，它已经多次改名，4.1 的版本中叫作 mSurfaceTexture，后更名为 mBufferProducer，\n\t\t\t而目前则是叫 mGraphicBufferProducer。\n\t\t</td>\n\t</tr>\n\t<tr>\n\t\t<td>BufferSlot mSlots[NUM_BUFFER_SLOTS]</td>\n\t\t<td>\n\t\t\t从名称上不难看出，这是 Surface 内部用于存储 buffer 的地方，容量 NUM_BUFFER_SLOTS 最多可达 32 个。\n\t\t\tBufferSlot 类的内部又由一个 GraphicBuffer 和一个 dirtyRegion 组成，当用户 dequeueBuffer 时才会分配真正的空间\n\t\t</td>\n\t</tr>\n\t<tr>\n\t\t<td>uint32_t mReqWidth</td>\n\t\t<td>\n\t\t\tSurface 中有多组相似的宽/高变量，它们之间是有区别的。\n\t\t\t这里的宽和高是指下一次 dequeue 时将会申请的尺寸，初始值都是 1\n\t\t</td>\n\t</tr>\n\t<tr>\n\t\t<td>uint32_t mReqHeight</td>\n\t\t<td></td>\n\t</tr>\n\t<tr>\n\t\t<td>uint32_t mReqFormat</td>\n\t\t<td>\n\t\t\t和上面两个变量类似，这是指下次 dequeue 时将会申请的 buffer 的像素格式，\n\t\t\t初始值是 PIXEL_FORMAT_RGBA_8888\n\t\t</td>\n\t</tr>\n\t<tr>\n\t\t<td>uint32_t mReqUsage</td>\n\t\t<td>指下次 dequeue 时将会指定的 usage 类型</td>\n\t</tr>\n\t<tr>\n\t\t<td>Rect mCrop</td>\n\t\t<td>\n\t\t\tCrop 表示 “修剪”，这个变量将在下次 queue 时用于修剪缓冲区，\n\t\t\t可以调用 setCrop 来设置具体的值\n\t\t</td>\n\t</tr>\n\t<tr>\n\t\t<td>int mScalingMode</td>\n\t\t<td>\n\t\t\t同样，这个变量将用于下次 queue 时对缓冲区进行 scale，\n\t\t\t可以调用 setScalingMode 来设置具体的值\n\t\t</td>\n\t</tr>\n\t<tr>\n\t\t<td>uint32_t mTransform</td>\n\t\t<td>用于下次 queue 时的图形翻转等操作（Transform）</td>\n\t</tr>\n\t<tr>\n\t\t<td>uint32_t mDefaultWidth</td>\n\t\t<td>默认情况下的缓冲区宽高值</td>\n\t</tr>\n\t<tr>\n\t\t<td>uint32_t mDefaultHeight</td>\n\t\t<td></td>\n\t</tr>\n\t<tr>\n\t\t<td>uint32_t mUserWidth</td>\n\t\t<td>如果不为零的话，就是应用层指定的值，而且会覆盖前面的 mDefaultWidth/mDefaultHeight</td>\n\t</tr>\n\t<tr>\n\t\t<td>uint32_t mUserHeight</td>\n\t\t<td></td>\n\t</tr>\n\t<tr>\n\t\t<td>sp&lt;GraphicBuffer&gt;  mLockedBuffer</td>\n\t\t<td>访问这 3 个变量需要资源锁的保护，接下来还会有分析</td>\n\t</tr>\n\t<tr>\n\t\t<td>sp&lt;GraphicBuffer&gt;  mPostedBuffer</td>\n\t\t<td></td>\n\t</tr>\n\t<tr>\n\t\t<td>Region mDirtyRegion</td>\n\t\t<td></td>\n\t</tr>\n</table>\n<p>从上表中 <code>Surface</code> 类的内部变量的描述中，可以了解到两点：</p>\n<div><pre><code>1. Surface 将通过 mGraphicBufferProducer 来获取 buffer，\n2. 而且这些 buffer 缓冲区会被记录在 mSlots 数组中。\n</code></pre></div><p>接下来我们分析其中的实现细节。</p>\n<p>前面 <code>Surface</code> 构造函数中看到 <code>ANativeWindow</code> 中的函数指针赋予的是各种以 <code>hook</code> 开头的函数，而这些 <code>hook_XX</code> 内部又直接 “钩住” 了 <code>Surface</code> 中真正的实现。</p>\n<blockquote>\n<p>比如 <code>Surface::hook_dequeueBuffer</code> 对应的是 <code>Surface::dequeueBuffer</code>，这就好像 “钩子” 的功能一样，所以得名为 <code>hook</code>。</p>\n</blockquote>\n<div><pre><code><span>/* frameworks/native/libs/gui/Surface.cpp */</span>\n<span>int</span> <span>Surface</span><span>::</span><span>dequeueBuffer</span><span>(</span>android_native_buffer_t<span>*</span><span>*</span> buffer<span>,</span><span>int</span> <span>*</span>fenceFd<span>)</span> <span>{</span>\n\t<span>.</span><span>.</span><span>.</span>\n    Mutex<span>::</span>Autolock <span>lock</span><span>(</span>mMutex<span>)</span><span>;</span>\n    <span>int</span> buf <span>=</span> <span>-</span><span>1</span><span>;</span>\n\n    <span>/* Step1. 宽高计算 */</span>\n    <span>int</span> reqW <span>=</span> mReqWidth <span>?</span> mReqWidth <span>:</span> mUserWidth<span>;</span>\n    <span>int</span> reqH <span>=</span> mReqHeight <span>?</span> mReqHeight <span>:</span> mUserHeight<span>;</span>\n\n    <span>/* Step2. dequeueBuffer 得到一个缓冲区 */</span>\n    sp<span>&lt;</span>Fence<span>></span> fence<span>;</span>\n\t<span>/* 生产者发挥作用了 */</span>\n    status_t result <span>=</span> mGraphicBufferProducer<span>-></span><span>dequeueBuffer</span><span>(</span><span>&amp;</span>buf<span>,</span> <span>&amp;</span>fence<span>,</span> reqW<span>,</span> reqH<span>,</span> mReqFormat<span>,</span> mReqUsage<span>)</span><span>;</span>\n    <span>.</span><span>.</span><span>.</span>\n    sp<span>&lt;</span>GraphicBuffer<span>></span><span>&amp;</span><span>gbuf</span><span>(</span>mSlots<span>[</span>buf<span>]</span><span>.</span>buffer<span>)</span><span>;</span> <span>/* 注意 buf 是一个 int 值，代表的是 mSlots 数组序号 */</span>\n    <span>.</span><span>.</span><span>.</span>\n    <span>if</span> <span>(</span><span>(</span>result <span>&amp;</span> IGraphicBufferProducer<span>::</span>BUFFER_NEEDS_REALLOCATION<span>)</span> <span>||</span> gbuf <span>==</span> <span>0</span><span>)</span> <span>{</span>\n        result <span>=</span> mGraphicBufferProducer<span>-></span><span>requestBuffer</span><span>(</span>buf<span>,</span> <span>&amp;</span>gbuf<span>)</span><span>;</span> <span>// 申请空间</span>\n        <span>.</span><span>.</span><span>.</span>\n    <span>}</span>\n    <span>.</span><span>.</span><span>.</span>\n    <span>*</span>buffer <span>=</span> gbuf<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre></div><div><pre><code>Step1@Surface::dequeueBuffer\n\n图形缓冲区一定有宽高属性，具体的值由 mReqWidth/mReqHeight 或者 mUserWidth/mUserHeight 决定，\n其中前者的优先级比后者高。\n</code></pre></div><div><pre><code>Step2@Surface::dequeueBuffer\n\n如前面所述，真正执行 dequeueBuffer 操作的确实是 mGraphicBufferProducer(IGraphicBufferProducer)。\nSurface 中的这个核心成员变量的来源可以有两个：\n\t1. 作为 Surface 的构造函数参数传入；\n\t2. 或者 Surface 的子类通过直接调用 setIGraphicBufferProducer 来生成。\n在应用进程环境中，属于后者。\n</code></pre></div><h4 id=\"_4-2-1-surface-的创建流程\" tabindex=\"-1\"> 4.2.1 <code>Surface</code> 的创建流程</h4>\n<p>大致流程是：</p>\n<div><pre><code>ViewRootImpl 持有一个 Java 层的 Surface 对象（即 mSurface），初始时是空的。\n后续 ViewRootImpl 将向 WindowManagerService 发起 relayout 请求，此时 mSurface 才被赋予真正有效的值。\n\nWindowManagerService 会先让 WindowStateAnimator 生成一个 SurfaceControl，\n然后通过 Surface.copyFrom() 函数将其复制到 mSurface 中。\n\n这个复制函数会通过 native 接口 nativeCreateFromSurfaceControl 来生成本地 Surface对象（C++ 对象），\n具体是在 android_view_Surface.cpp 文件中。\n\nJNI 函数 nativeCreateFromSurfaceControl 将从 SurfaceControl 中提取出 Surface（C++ ），\n最终记录到 Surface（Java） 的成员变量中。\n\n这样，后期我们就可以从 Surface（Java） 的成员变量中还原出底层的 Surface（C++ ） 对象了。\n</code></pre></div><p><code>Surface</code> 的创建流程图大致如下：</p>\n<p><img src=\"@source/lango-tech/subject/images/surfaceflinger/04.png\" alt=\"\" loading=\"lazy\"></p>\n<p>从上图中可以看到，<code>Surface</code> 由 <code>SurfaceControl</code> 管理，而后者又由 <code>SurfaceComposerClient</code> 创建：</p>\n<div><pre><code><span>/* frameworks/native/libs/gui/SurfaceComposerClient.cpp */</span>\nsp<span>&lt;</span>SurfaceControl<span>></span> <span>SurfaceComposerClient</span><span>::</span><span>createSurface</span><span>(</span><span>const</span> String8<span>&amp;</span> name<span>,</span> <span>uint32_t</span> w<span>,</span> <span>uint32_t</span> h<span>,</span> \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tPixelFormat format<span>,</span> <span>uint32_t</span> flags<span>)</span>\n<span>{</span>\n    sp<span>&lt;</span>SurfaceControl<span>></span> sur<span>;</span>\n    <span>if</span> <span>(</span>mStatus <span>==</span> NO_ERROR<span>)</span> <span>{</span>\n        sp<span>&lt;</span>IBinder<span>></span> handle<span>;</span>\n        sp<span>&lt;</span>IGraphicBufferProducer<span>></span> gbp<span>;</span>\n\n        <span>// 生成一个 Surface</span>\n        status_t err <span>=</span> mClient<span>-></span><span>createSurface</span><span>(</span>name<span>,</span> w<span>,</span> h<span>,</span> format<span>,</span> flags<span>,</span> <span>&amp;</span>handle<span>,</span> <span>&amp;</span>gbp<span>)</span><span>;</span>  \n        <span>.</span><span>.</span><span>.</span>\n        <span>if</span> <span>(</span>err <span>==</span> NO_ERROR<span>)</span> <span>{</span>\n            sur <span>=</span> <span>new</span> <span>SurfaceControl</span><span>(</span><span>this</span><span>,</span> handle<span>,</span> gbp<span>)</span><span>;</span> <span>// SurfaceControl 是 “本地” 的对象</span>\n        <span>}</span>\n    <span>}</span>\n    <span>return</span> sur<span>;</span>\n<span>}</span>\n</code></pre></div><div><pre><code>上述代码段中，mClient 是一个 ISurfaceComposerClient 的 sp 指针，程序通过它来生成一个 Surface。\n值得注意的是，SurfaceControl 对象并不是由 ISurfaceComposerClient 的 createSurface 直接生成的，\nISurfaceComposerClient::createSurface 函数的参数中包括了 gbp（IGraphicBufferProducer），即前面所说的 “buffer生产者”。\n从中我们可以了解到，真正与 SurfaceFlinger 间有联系的应该就是 gbp（IGraphicBufferProducer）。\n</code></pre></div><p>那么 <code>ISurfaceComposerClient</code> 的服务器端实现是谁？</p>\n<div><pre><code><span>/* frameworks/native/libs/gui/SurfaceComposerClient.cpp */</span>\n<span>void</span> <span>SurfaceComposerClient</span><span>::</span><span>onFirstRef</span><span>(</span><span>)</span> <span>{</span>\n    sp<span>&lt;</span>ISurfaceComposer<span>></span> <span>sm</span><span>(</span><span>ComposerService</span><span>::</span><span>getComposerService</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span>sm <span>!=</span> <span>0</span><span>)</span> <span>{</span>\n        sp<span>&lt;</span>ISurfaceComposerClient<span>></span> conn <span>=</span> sm<span>-></span><span>createConnection</span><span>(</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>conn <span>!=</span> <span>0</span><span>)</span> <span>{</span>\n            mClient <span>=</span> conn<span>;</span>\n            mStatus <span>=</span> NO_ERROR<span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre></div><p>由此可见，<code>ISurfaceComposerClient</code> 是由 <code>ISurfaceComposer::createConnection</code> 生成的。在这一过程中，总共涉及了 3 个匿名的 <code>Binder Server</code>，它们所提供的接口如下表所示。</p>\n<table>\n\t<tr>\n\t\t<th>匿名 Binder</th>\n\t\t<th>提供的接口</th>\n\t</tr>\n\t<tr>\n\t\t<td>ISurfaceComposer</td>\n\t\t<td>createConnection</td>\n\t</tr>\n\t<tr>\n\t\t<td>ISurfaceComposerClient</td>\n\t\t<td>\n\t\t\tvirtual status_t createSurface(..., sp&lt;IGraphicBufferProducer&gt;* gbp)=0;<br/>\n\t\t\tvirtual status_t destroySurface(const sp&lt;IBinder&gt;& handle) = 0;\n\t\t</td>\n\t</tr>\n\t<tr>\n\t\t<td>IGraphicBufferProducer</td>\n\t\t<td>\n\t\t\tstatus_t requestBuffer(int slot, sp&lt;GraphicBuffer&gt;* buf);<br/>\n\t\t\tstatus_t setBufferCount(int bufferCount);<br/>\n\t\t\tstatus_t dequeueBuffer(...);<br/>\n\t\t\tstatus_t queueBuffer(...);<br/>\n\t\t\tvoid cancelBuffer(int slot);<br/>\n\t\t\tint query(int what, int* value);<br/>\n\t\t\tstatus_t setSynchronousMode(bool enabled);<br/>\n\t\t\tstatus_t connect(int api, QueueBufferOutput* output);<br/>\n\t\t\tstatus_t disconnect(int api);\n\t\t</td>\n\t</tr>\n</table>\n<div><pre><code>匿名 Binder 一定是需要由一个实名 Binder 来提供的，它就是 SurfaceFlinger，\n这个 SurfaceFlinger 系统服务是在 ServiceManager 中 “注册在案” 的。\n\n具体是在 SurfaceComposerClient::onFirstRef() 这个函数中，\n通过向 ServiceManager 查询名称为 “SurfaceFlinger” 的 Binder Server 来获得的。\n\n不过和其他常见 Binder Server 不同的是，\nSurfaceFlinger 虽然在 ServiceManager 中注册的名称为 “SurfaceFlinger”，\n但它在服务器端实现的 Binder 接口却是 ISurfaceComposer，\n因而 SurfaceComposerClient 得到的其实是 ISurfaceComposer。大家要特别注意这点，否则可能会引起混乱。\n\n我们可以从 SurfaceFlinger 的继承关系中看出这一区别，如下代码片断：\n</code></pre></div><div><pre><code><span>/* frameworks/native/services/surfaceflinger/SurfaceFlinger.h */</span>\n<span>class</span> <span>SurfaceFlinger</span> <span>:</span>\n\t<span>public</span> BinderService<span>&lt;</span>SurfaceFlinger<span>></span><span>,</span> <span>// 在ServiceManager 中注册为 “SurfaceFlinger”</span>\n\t<span>public</span> BnSurfaceComposer<span>,</span> <span>// 实现的接口却叫 ISurfaceComposer，不知道为什么要这么设计</span>\n</code></pre></div><div><pre><code><span>/* frameworks/native/services/surfaceflinger/SurfaceFlinger.h */</span>\n<span>/* 高版本中的声明 */</span>\n<span>class</span> <span>SurfaceFlinger</span> <span>:</span> <span><span>public</span> <span>BnSurfaceComposer</span><span>,</span>\n\t<span>public</span> <span>PriorityDumper</span><span>,</span>\n\t<span>private</span> IBinder<span>::</span><span>DeathRecipient</span><span>,</span>\n\t<span>private</span> HWC2<span>::</span><span>ComposerCallback</span><span>,</span>\n\t<span>private</span> <span>ICompositor</span><span>,</span>\n\t<span>private</span> scheduler<span>::</span><span>ISchedulerCallback</span><span>,</span>\n\t<span>private</span> compositionengine<span>::</span><span>ICEPowerCallback</span><span>,</span>\n\t<span>private</span> scheduler<span>::</span><span>IVsyncTrackerCallback</span>\n\n<span>public</span><span>:</span>\n\t<span>.</span><span>.</span><span>.</span>\n\t<span>static</span> <span>char</span> <span>const</span><span>*</span> <span>getServiceName</span><span>(</span><span>)</span> <span>ANDROID_API</span></span> <span>{</span> <span>return</span> <span>\"SurfaceFlinger\"</span><span>;</span> <span>}</span>\n\n\n<span>/* frameworks/native/libs/gui/include/gui/ISurfaceComposer.h */</span>\n<span>class</span> <span>BnSurfaceComposer</span><span>:</span> <span>public</span> BnInterface<span>&lt;</span>ISurfaceComposer<span>></span>\n</code></pre></div><p>绕了一大圈，我们接着分析前面 <code>Surface::dequeueBuffer</code> 函数的实现。</p>\n<div><pre><code>目前我们已经清楚 mGraphicBufferProducer 的由来了。接下来程序利用这个变量来 dequeueBuffer。\n\n那么，IGraphicBufferProducer 在服务器端又是由谁来实现的呢？\n因为这里面牵扯到很多新的类，我们先不做过多解释，到后面 BufferQueue 小节再详细分析其中的依赖关系。\n\n当 mGraphicBufferProducer->dequeueBuffer 返回后，buf 变量就是 mSlots[] 数组中可用的成员序号。\n接下来就要通过这个序号来获取真正的 buffer 地址，即 mSlots[buf].buffer。\n</code></pre></div><div><pre><code>Step3@Surface::dequeueBuffer\n\n假如返回值 result 中的标志包含了 BUFFER_NEEDS_REALLOCATION，\n说明 BufferQueue 需要为这个 Slot 重新分配空间，具体细节请参见下一个小节。\n此时还需要另外调用 requestBuffer 来确定 gbuf 的值，其中又牵涉到很多东西，也放在下一小节统一解释。\n</code></pre></div><h3 id=\"_4-2-本地窗口小结\" tabindex=\"-1\"> 4.2 本地窗口小结</h3>\n<p>目前，已经介绍了显示系统中两个重要的本地窗口：<code>FramebufferNativewindow</code> 和 <code>Surface</code>。</p>\n<div><pre><code>FramebufferNativewindow 是专门为 SurfaceFlinger 服务的，它由 Gralloc 提供支持；\n\nSurface 虽然是为应用程序服务的，但本质上还是由 SurfaceFlinger 服务统一管理的，因而涉及很多跨进程的通信细节。\n</code></pre></div><p>这个小节我们只是简单地勾勒出其中的框架，接下来就要分几个方面来做完整的分析了：</p>\n<div><pre><code>1. BufferQueue\n为应用程序服务的本地窗口 Surface，其依赖的 IGraphicBufferProducer 对象在 Server 端的实现是 BufferQueue。\n我们将详细解析 BufferQueue 的内部实现，并结合应用程序端的使用流程来理解它们之间的关系。\n\n2. Buffer，Consumer，Producer 是 “生产者-消费者” 模型中的 3 个参与对象，\n如何协调好它们的工作是应用程序能否正常显示 UI 的关键。\n\n接下来，我们先讲解 Buffer（BufferQueue）与 Producer（应用程序）间的交互，\n然后转而切入 Consumer（SurfaceFlinger）做详细分析。\n</code></pre></div><h2 id=\"_5-bufferqueue-详解\" tabindex=\"-1\"> 5 <code>BufferQueue</code> 详解</h2>\n<p><code>BufferQueue</code> 是 <code>Surface</code> 实现本地窗口的关键。从逻辑上来推断，<code>BufferQueue</code> 应该是驻留在 <code>SurfaceFlinger</code> 这边的进程中。</p>\n<p>我们需要进一步解决的疑惑是：</p>\n<div><pre><code>1. 每个应用程序可以有几个 BufferQueue，即它们的关系是一对一、多对一，还是一对多？\n2. 应用程序绘制 UI 所需的内存空间是由谁来分配的？\n3. 应用程序与 SurfaceFlinger 如何互斥共享数据区？\n4. 我们这里面临的是经典的 “生产者-消费者” 模型。Android 显示系统是如何协调好这两者对缓冲区的互斥访问的呢？\n</code></pre></div><h3 id=\"_5-1-bufferqueue-的内部原理\" tabindex=\"-1\"> 5.1 <code>BufferQueue</code> 的内部原理</h3>\n<p>先来解析下 <code>BufferQueue</code> 的内部构造，如下图所示。</p>\n<p><img src=\"@source/lango-tech/subject/images/surfaceflinger/05.png\" alt=\"\" loading=\"lazy\"></p>\n<p>因为 BufferQueue 是 IGraphicBufferProducer 服务器端的实现，所以它必须重载接口中的各种虚函数：</p>\n<div><pre><code>如 queueBuffer、requestBuffer、dequeueBuffer 等。\n</code></pre></div><blockquote>\n<p>注意：</p>\n<p>高版本中，<code>IGraphicBufferProducer</code> 被抽取到 <code>BufferQueueProducer</code> 中实现了，\n<code>BufferQueue</code> 提供了 <code>BufferQueue::createBufferQueue</code> 方法，创建了 <code>BufferQueueProducer</code> 对象，\n同时还创建了 <code>BufferQueueConsumer</code> 对象。</p>\n<div><pre><code><span>/* frameworks/native/libs/gui/include/gui/BufferQueue.h */</span>\n<span>static</span> <span>void</span> <span>createBufferQueue</span><span>(</span>sp<span>&lt;</span>IGraphicBufferProducer<span>></span><span>*</span> outProducer<span>,</span>\n           sp<span>&lt;</span>IGraphicBufferConsumer<span>></span><span>*</span> outConsumer<span>,</span>\n           <span>bool</span> consumerIsSurfaceFlinger <span>=</span> <span>false</span><span>)</span><span>;</span>\n</code></pre></div><div><pre><code><span>/* frameworks/native/libs/gui/include/gui/BufferQueueProducer.h */</span>\n<span>class</span> <span>BufferQueueProducer</span> <span>:</span> <span><span>public</span> <span>BnGraphicBufferProducer</span><span>,</span>\n                            <span>private</span> IBinder<span>::</span><span>DeathRecipient</span></span> <span>{</span>\n\n<span>/* frameworks/native/libs/gui/include/gui/IGraphicBufferProducer.h */</span>\n<span>class</span> <span>BnGraphicBufferProducer</span> <span>:</span> <span><span>public</span> <span>BnInterface</span><span>&lt;</span><span>IGraphicBufferProducer</span><span>></span></span>\n<span>{</span>\n</code></pre></div></blockquote>\n<p>另外，这个 <code>BufferQueue</code> 的内部有一个非常重要的成员数组，即 <code>mSlots[NUM_BUFFER_SLOTS]</code>。</p>\n<p>在前面讲解的 <code>Surface</code> 类中也有一个一模一样的数组：</p>\n<div><pre><code><span>/* frameworks/native/libs/gui/include/gui/Surface.h */</span>\n<span>class</span> <span>Surface</span><span>:</span> <span><span>public</span> <span>ANativeObjectBase</span><span>&lt;</span><span>ANativeWindow</span><span>,</span> <span>Surface</span><span>,</span> <span>RefBase</span><span>></span></span>\n<span>{</span>\n\t<span>.</span><span>.</span><span>.</span>\n\tBufferSlot mSlots<span>[</span>NUM_BUFFER_SLOTS<span>]</span><span>;</span>\n</code></pre></div><p>虽然两个数组从形式上看一模一样，但要特别注意其中的 <code>BufferSlot</code> 定义并不相同：</p>\n<div><pre><code><span>/* frameworks/native/libs/gui/include/gui/Surface.h */</span>\n<span>struct</span> <span>BufferSlot</span> <span>{</span>\n\tsp<span>&lt;</span>GraphicBuffer<span>></span> buffer<span>;</span>\n\tRegion dirtyRegion<span>;</span>\n<span>}</span><span>;</span>\n\n\n<span>/* frameworks/native/libs/gui/include/gui/BufferSlot.h */</span>\n<span>struct</span> <span>BufferSlot</span> <span>{</span>\n\t<span>.</span><span>.</span><span>.</span>\n\tsp<span>&lt;</span>GraphicBuffer<span>></span> mGraphicBuffer<span>;</span>\n\tBufferState mBufferState<span>;</span>\n\t<span>.</span><span>.</span><span>.</span>\n<span>}</span>\n</code></pre></div><div><pre><code>后面一个 BufferSlot 中的 GraphicBuffer 变量（mGraphicBuffer）用于记录这个 Slot 所涉及的缓冲区；\n另一个 BufferState 变量（mBufferState`）用于跟踪每个缓冲区的状态。比如：\n</code></pre></div><div><pre><code><span>enum</span> <span>BufferState</span> <span>{</span>\n\n    <span>/* Buffer 当前可用，也就是说可以被dequeued。此时 Buffer 的 owner 可认为是 BufferQueue */</span>\n\tFREE <span>=</span> <span>0</span><span>,</span> \n\n    <span>/*\n        Buffer 已经被 dequeued，还未被 queued 或 canceled。此时Buffer的owner可认为是producer（应用程序），\n        这意味着 BufferQueue 和 SurfaceFlinger(consumer) 此时都不可以操作这块缓冲区\n    */</span>\n\tDEQUEUED <span>=</span> <span>1</span><span>,</span> \n\n    <span>/*Buffe r已经被客户端 queued，不过还不能对它进行 dequeue，但可以 acquired。此时的 owner 是 BufferQueue*/</span>\n\tQUEUED <span>=</span> <span>2</span><span>,</span> \n\n    <span>/* Buffer 的 owner 改为 consumer，可以被 released，然后状态又返回 FREE*/</span>\n\tACQUIRED <span>=</span> <span>3</span> \n<span>}</span><span>;</span>\n\n<span>/* 高版本中，BufferState 作为一个结构体定义在 frameworks/native/libs/gui/include/gui/BufferSlot.h 中 */</span>\n</code></pre></div><p>从上面的状态描述可以看出，一块 <code>Buffer</code> 在处理过程中经历的生命周期依次是 <code>FREE -&gt; DEQUEUED -&gt; QUEUED -&gt; ACQUIRED -&gt; FREE</code>。</p>\n<p>从 <code>Owner</code> 的角度给出的 <code>Buffer</code> 状态迁移图如下所示：</p>\n<p><img src=\"@source/lango-tech/subject/images/surfaceflinger/06.png\" alt=\"\" loading=\"lazy\"></p>\n<p>从 <code>Buffer</code> 状态迁移图中可以清楚地了解 <code>Buffer</code> 的各个状态、引起状态迁移的条件以及各状态下的 <code>Owner</code>。</p>\n<p>参与 <code>Buffer</code> 管理的 <code>Owner</code> 对象有 3 个：</p>\n<div><pre><code>BufferQueue\n    我们可以认为 BufferQueue 是一个服务中心，其他两个 Owner 必须要通过它来管理 Buffer。\n    比如当 Producer 想要获取一个 Buffer 时，它不能越过 BufferQueue 直接与 Consumer 进行联系，反之亦然。\n\nProducer\n    生产者就是 “填充” Buffer 数据的人，通常情况下当然就是应用程序。\n    因为应用程序不断地刷新 UI，从而将产生的显示数据源源不绝地写到 Buffer 中。\n    当 Producer 需要使用一块 Buffer 时，它首先会向 BufferQueue 发起 dequeue 申请，然后才能对指定的缓冲区进行操作。\n    经过 dequeue 后 Buffer 就属于 producer 的了，它可以对 Buffer 进行任何必要的操作，而其他 Owner 此刻绝不能擅自插手。\n\n    当生产者认为一块 Buffer 已经写入完成后，将进一步调用 BufferQueue 的 queue 接口。\n    从字面上看这个函数是 “入列” 的意思，形象地表达了 Buffer 此时的操作 —— 把 Buffer 归还到 BufferQueue 的队列中。\n    一旦 queue 成功，Owner 也就随之改变为 BufferQueue 了。\n\nConsumer\n    消费者是与生产者相对应的，它的操作同样受到 BufferQueue 的管控。\n    当一块 Buffer 已经就绪后，Consumer 就可以开始工作了，细节我们会在后续 SurfaceFlinger 中描述。\n</code></pre></div><p>这里需要特别留意的是，从各个对象所扮演的角色来看：</p>\n<div><pre><code>BufferQueue 是中介机构，属于服务提供方；\nProducer 属于 Buffer 内容的产出方，它对缓冲区的操作是一个 “主动” 的过程；\n而 Consumer 对 Buffer 的处理则是 “被动” 的、“等待式” 的，即：它必须要等到一块 Buffer 填充完成后才能工作。\n</code></pre></div><p>在这样的模型下，我们怎么保证 <code>Consumer</code> 可以及时处理 <code>Buffer</code> 呢？换句话说，当一块 <code>Buffer</code> 数据 <code>ready</code> 后，应该怎么告知 <code>Consumer</code> 来操作呢？</p>\n<p>仔细观察，可以看到 <code>BufferQueue</code> 里同时还提供了一个特别的类，名称为 <code>ConsumerListener</code>。其中的函数接口包括：</p>\n<div><pre><code><span>struct</span> <span>ConsumerListener</span> <span>:</span> <span><span>public</span> <span>virtual</span> <span>RefBase</span></span> <span>{</span>      \n\n    <span>/* 当一块 buffer 可以被消费时，这个函数会被调用，特别注意此时没有共享锁的保护 */</span>  \n    <span>virtual</span> <span>void</span> <span>onFrameAvailable</span><span>(</span><span>)</span> <span>=</span> <span>0</span><span>;</span> \n\n    <span>/* BufferQueue 通知 consumer 它已经释放其 slot 中的一个或多个 GraphicBuffer 引用 */</span>\n    <span>virtual</span> <span>void</span> <span>onBuffersReleased</span><span>(</span><span>)</span> <span>=</span> <span>0</span><span>;</span> \n<span>}</span><span>;</span>\n\n<span>/* \n    高版本系统定义在 frameworks/native/libs/gui/include/gui/IConsumerListener.h 中\n    声明略有不同，但函数名称都一样\n */</span>\n</code></pre></div><p>这样就很清楚了，当有一帧数据准备就绪后，<code>BufferQueue</code> 就会调用 <code>onFrameAvailable()</code> 来通知 <code>Consumer</code> 进行消费。</p>\n<h3 id=\"_5-2-bufferqueue-的缓冲区分配\" tabindex=\"-1\"> 5.2 <code>BufferQueue</code> 的缓冲区分配</h3>\n<p>我们知道，<code>BufferQueue</code> 中有一个 <code>mSlots</code> 数组用于管理其内的各缓冲区，最大容量为 32。</p>\n<p>从 <code>mSlots</code> 数组的声明方式来看，这个 <code>mSlots</code> 在程序一开始就静态分配了 32 个 <code>BufferSlot</code> 大小的空间。不过这并不代表其中的数据缓冲区也是一次性静态分配的，恰恰相反，从 <code>BufferSlot</code> 的内部变量指针 <code>mGraphicBuffer</code> 可以看出，缓冲区的空间分配应当是动态的（从下面的注释也能看出一些端倪）：</p>\n<div><pre><code><span>/* frameworks/native/libs/gui/include/gui/BufferSlot.h */</span>\n<span>// mGraphicBuffer points to the buffer allocated for this slot or is NULL</span>\n<span>// if no buffer has been allocated.</span>\nsp<span>&lt;</span>GraphicBuffer<span>></span> mGraphicBuffer<span>;</span>\n</code></pre></div><blockquote>\n<p>注意：</p>\n<p>高版本中，<code>mSlots</code> 数据定义在了 <code>BufferQueueProducer.h</code> 中，具体如下：</p>\n<div><pre><code><span>/* frameworks/native/libs/gui/include/gui/BufferQueueProducer.h */</span>\nBufferQueueDefs<span>::</span>SlotsType<span>&amp;</span> mSlots<span>;</span>\n\n<span>// 在创建 BufferQueueProducer 对象时，在 BufferQueueProducer 的构造函数中初始化</span>\n<span>/* frameworks/native/libs/gui/BufferQueueProducer.cpp */</span>\n<span>BufferQueueProducer</span><span>::</span><span>BufferQueueProducer</span><span>(</span><span>const</span> sp<span>&lt;</span>BufferQueueCore<span>></span><span>&amp;</span> core<span>,</span>\n       <span>bool</span> consumerIsSurfaceFlinger<span>)</span> <span>:</span>\n   <span>mCore</span><span>(</span>core<span>)</span><span>,</span>\n   <span>mSlots</span><span>(</span>core<span>-></span>mSlots<span>)</span><span>,</span> <span>// 将 BufferQueueCore::mSlots 赋值给了 BufferQueueProducer::mSlots</span>\n\n<span>/* frameworks/native/libs/gui/include/gui/BufferQueueCore.h */</span>\nBufferQueueDefs<span>::</span>SlotsType mSlots<span>;</span>\n\n<span>// BufferQueueDefs::SlotsType 类型的声明如下</span>\n<span>/* frameworks/native/libs/gui/include/gui/BufferQueueDefs.h */</span>\n<span>// BufferQueueDefs::SlotsType 是一个 BufferSlot 数组，数组长度是 NUM_BUFFER_SLOTS</span>\n<span>typedef</span> BufferSlot SlotsType<span>[</span>NUM_BUFFER_SLOTS<span>]</span><span>;</span>\n\n<span>// NUM_BUFFER_SLOTS 定义如下</span>\n<span>/* frameworks/native/libs/ui/include/ui/BufferQueueDefs.h */</span>\n<span>static</span> <span>constexpr</span> <span>int</span> NUM_BUFFER_SLOTS <span>=</span> <span>64</span><span>;</span> <span>// 也就是说，高版本中，mSlots 数组的容量扩充到了 64</span>\n</code></pre></div></blockquote>\n<p>现在的问题就转化为：在什么情况下会给一个 <code>Slot</code> 分配实际的空间呢？</p>\n<p>首先能想到的就是 <code>dequeueBuffer</code> 。理由如下：</p>\n<div><pre><code>1. 缓冲区的空间分配应该既要满足使用者的需求，又要防止浪费。\n后面这一点 mSlots 已经满足了，因为它并没有采取一开始就静态预分配的方式。\n\n2. 既然 Producer 对 buffer 的操作是 “主动” 的，那么就意味着它是整个需求的发起者。\n换句话说，只要它没有 dequeueBuffer，或者 dequeueBuffer 时能获取到可用的缓冲区，那当然就没有必要再重新分配空间了。\n</code></pre></div><p>下面详细分析 <code>dequeueBuffer</code> 函数，并验证我们上面的猜测：</p>\n<blockquote>\n<p>注意：</p>\n<p>高版本中，<code>BufferQueue::dequeueBuffer</code> 函数对应 <code>BufferQueueProducer::dequeueBuffer</code> 函数。</p>\n<p>目前任然以低版本的代码进行分析，后续再更新到高版本。</p>\n</blockquote>\n<div><pre><code><span>/*frameworks/native/libs/gui/BufferQueue.cpp*/</span>\nstatus_t <span>BufferQueue</span><span>::</span><span>dequeueBuffer</span><span>(</span><span>int</span> <span>*</span>outBuf<span>,</span> sp<span>&lt;</span>Fence<span>></span><span>*</span> outFence<span>,</span><span>uint32_t</span> w<span>,</span> <span>uint32_t</span> h<span>,</span>\n        <span>uint32_t</span> format<span>,</span> <span>uint32_t</span> usage<span>)</span> <span>{</span>\n    <span>.</span><span>.</span><span>.</span>\n    status_t  <span>returnFlags</span><span>(</span>OK<span>)</span><span>;</span>\n    <span>.</span><span>.</span><span>.</span>\n    <span>{</span> <span>// Scope for the lock</span>\n        <span>/* \n            这里采用了自动锁，所以上面需要加个 “{”，这样当 lock 变量生命周期结束后锁也就自动释放了。\n            这种写法在 Android 中很常见 \n        */</span>\n        Mutex<span>::</span>Autolock <span>lock</span><span>(</span>mMutex<span>)</span><span>;</span>\n        <span>.</span><span>.</span><span>.</span>\n        <span>int</span> found <span>=</span> <span>-</span><span>1</span><span>;</span>\n        <span>int</span> dequeuedCount <span>=</span> <span>0</span><span>;</span>\n        <span>bool</span> tryAgain <span>=</span> <span>true</span><span>;</span>\n\n        <span>/* Step1. 循环查找符合要求的 Slot */</span>\n        <span>while</span> <span>(</span>tryAgain<span>)</span> <span>{</span> \n            <span>.</span><span>.</span><span>.</span>                       \n            found <span>=</span> INVALID_BUFFER_SLOT<span>;</span> <span>// 初始值</span>\n            foundSync <span>=</span> INVALID_BUFFER_SLOT<span>;</span>\n            dequeuedCount <span>=</span> <span>0</span><span>;</span>            \n            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> maxBufferCount<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n                <span>const</span> <span>int</span> state <span>=</span> mSlots<span>[</span>i<span>]</span><span>.</span>mBufferState<span>;</span>\n\n                <span>/* Step2. 统计 dequeued buffer 数量，后面会用到 */</span>\n                <span>if</span> <span>(</span>state <span>==</span> BufferSlot<span>::</span>DEQUEUED<span>)</span> <span>{</span>\n                    dequeuedCount<span>++</span><span>;</span>\n                <span>}</span>               \n\n                <span>/* Step3. 寻找符合要求的 Slot */</span>\n                <span>if</span> <span>(</span>state <span>==</span> BufferSlot<span>::</span>FREE<span>)</span> <span>{</span> \n                    <span>if</span> <span>(</span>found <span>&lt;</span> <span>0</span> <span>||</span> mSlots<span>[</span>i<span>]</span><span>.</span>mFrameNumber <span>&lt;</span> mSlots<span>[</span>found<span>]</span><span>.</span>mFrameNumber<span>)</span> <span>{</span>\n                          found <span>=</span> i<span>;</span> <span>// 找到符合要求的 Slot</span>\n                    <span>}</span>\n                <span>}</span>\n            <span>}</span> <span>// for 循环结束</span>\n\n            <span>/* Step4. 如果 Client 没有设置 buffer count 的话，就不允许 dequeue 一个以上的  */</span>\n            <span>if</span> <span>(</span><span>!</span>mOverrideMaxBufferCount<span>&amp;&amp;</span> dequeuedCount<span>)</span> <span>{</span>\n                <span>ST_LOGE</span><span>(</span><span>\"dequeueBuffer: can't dequeue multiple buffers without setting the buffer count\"</span><span>)</span><span>;</span>\n                <span>return</span> <span>-</span>EINVAL<span>;</span>\n            <span>}</span>\n            <span>.</span><span>.</span><span>.</span>\n            <span>/* Step5. 判断是否要重试 */</span>\n            tryAgain <span>=</span> found <span>==</span> INVALID_BUFFER_SLOT<span>;</span>\n            <span>if</span> <span>(</span>tryAgain<span>)</span> <span>{</span>\n                mDequeueCondition<span>.</span><span>wait</span><span>(</span>mMutex<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span> <span>// while 循环结束</span>\n\n        <span>if</span> <span>(</span>found <span>==</span> INVALID_BUFFER_SLOT<span>)</span> <span>{</span>\n            <span>/* 因为前面 while 循环如果没找到的话是不会退出的，所以理论上不会出现这种情况 */</span>\n            <span>ST_LOGE</span><span>(</span><span>\"dequeueBuffer: no available buffer slots\"</span><span>)</span><span>;</span>\n            <span>return</span> <span>-</span>EBUSY<span>;</span>\n        <span>}</span>\n\n        <span>const</span> <span>int</span> buf <span>=</span> found<span>;</span>\n        <span>*</span>outBuf <span>=</span> found<span>;</span> <span>// 返回值</span>\n        <span>/* 成功找到可用的 Slot 序号，接下来就开始对这个指定的 Slot 进行初始操作，及状态变迁等 */</span>\n        <span>.</span><span>.</span><span>.</span>\n        <span>/* Step6. Buffer 状态改变 */</span>\n        mSlots<span>[</span>buf<span>]</span><span>.</span>mBufferState <span>=</span> BufferSlot<span>::</span>DEQUEUED<span>;</span>\n        <span>const</span> sp<span>&lt;</span>GraphicBuffer<span>></span><span>&amp;</span> <span>buffer</span><span>(</span>mSlots<span>[</span>buf<span>]</span><span>.</span>mGraphicBuffer<span>)</span><span>;</span>\n        <span>if</span> <span>(</span><span>(</span>buffer <span>==</span> <span>NULL</span><span>)</span> <span>||</span> <span>(</span><span>uint32_t</span><span>(</span>buffer<span>-></span>width<span>)</span>  <span>!=</span> w<span>)</span> <span>||</span>   \n            <span>(</span><span>uint32_t</span><span>(</span>buffer<span>-></span>height<span>)</span> <span>!=</span> h<span>)</span> <span>||</span> <span>(</span><span>uint32_t</span><span>(</span>buffer<span>-></span>format<span>)</span> <span>!=</span> format<span>)</span>\n                 <span>||</span> <span>(</span><span>(</span><span>uint32_t</span><span>(</span>buffer<span>-></span>usage<span>)</span> <span>&amp;</span> usage<span>)</span> <span>!=</span> usage<span>)</span><span>)</span>\n        <span>{</span>   \n            <span>/* Step7. 为 BufferSlot 对象做初始化 */</span>\n            mSlots<span>[</span>buf<span>]</span><span>.</span>mAcquireCalled <span>=</span> <span>false</span><span>;</span>\n            mSlots<span>[</span>buf<span>]</span><span>.</span>mGraphicBuffer <span>=</span> <span>NULL</span><span>;</span>\n            mSlots<span>[</span>buf<span>]</span><span>.</span>mRequestBufferCalled <span>=</span> <span>false</span><span>;</span>\n            mSlots<span>[</span>buf<span>]</span><span>.</span>mEglFence <span>=</span> EGL_NO_SYNC_KHR<span>;</span>\n            mSlots<span>[</span>buf<span>]</span><span>.</span>mFence <span>=</span> Fence<span>::</span>NO_FENCE<span>;</span>\n            mSlots<span>[</span>buf<span>]</span><span>.</span>mEglDisplay <span>=</span> EGL_NO_DISPLAY<span>;</span>\n\n            returnFlags <span>|=</span> IGraphicBufferProducer<span>::</span>BUFFER_NEEDS_REALLOCATION<span>;</span> <span>/* 需要重新分配 */</span>\n        <span>}</span>\n    <span>}</span>  <span>// 自动锁 lock 结束的地方</span>\n\n    <span>/* Step8. 如果上述判断结果是需要重新分配空间的话 */</span>\n    <span>if</span> <span>(</span>returnFlags <span>&amp;</span> IGraphicBufferProducer<span>::</span>BUFFER_NEEDS_REALLOCATION<span>)</span> <span>{</span>\n        status_t error<span>;</span>\n        <span>/* 终于分配空间了 */</span>\n        sp<span>&lt;</span>GraphicBuffer<span>></span> <span>graphicBuffer</span><span>(</span>mGraphicBufferAlloc<span>-></span><span>createGraphicBuffer</span><span>(</span>w<span>,</span> h<span>,</span> format<span>,</span> usage<span>,</span> <span>&amp;</span>error<span>)</span><span>)</span><span>;</span>\n        <span>.</span><span>.</span><span>.</span>\n        <span>{</span> <span>// Scope for the lock</span>\n            Mutex<span>::</span>Autolock <span>lock</span><span>(</span>mMutex<span>)</span><span>;</span>\n               <span>.</span><span>.</span><span>.</span>\n            mSlots<span>[</span><span>*</span>outBuf<span>]</span><span>.</span>mGraphicBuffer <span>=</span> graphicBuffer<span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>.</span><span>.</span><span>.</span>\n    <span>return</span> returnFlags<span>;</span>\n<span>}</span>\n</code></pre></div><p>因为这个函数很长，我们只保留最核心的部分。从整体框架来看，<code>Step1～Step5</code> 是在查找一个可用的 <code>Slot</code> 序号。从 <code>Step6</code> 开始，就针对这一特定的 <code>Slot</code> 进行操作了。下面我们分步进行解析：</p>\n<div><pre><code>Step1@ BufferQueue::dequeueBuffer\n\n进入 while 循环，退出的条件是 tryAgain 为 false。\n这个变量默认值是 true，如果一轮循环结束后 found 不再是 INVALID_BUFFER_SLOT，就会变成 false，从而结束整个 while 循环。\n\n循环的主要功能就是查找符合要求的 Slot，其中 found 变量是一个 int 值，指的是这个 BufferSlot 在 mSlots 数组中的序号。\n</code></pre></div><div><pre><code>Step2@ BufferQueue::dequeueBuffer\n\n统计当前已经被 dequeued 的 buffer 数量，这将用于后面的判断，\n即假如 Client 没有设置 buffer count，那么它会被禁止 dequeue 一个以上的 buffer。\n</code></pre></div><div><pre><code>Step3@ BufferQueue::dequeueBuffer\n\n假如当前的 buffer 状态是 FREE，那么这个 Slot 就可以进入备选了。\n为什么只是备选而不是直接返回这一结果呢？\n因为 mSlots 中很可能有多个符合条件的 Slot，当然需要挑选其中最匹配的。\n判断的依据是当前符合要求的 Slot 的 mFrameNumber 是否比上一次选中的最优 Slot 的 mFrameNumber 小。具体代码如下：\n\n    mSlots[i].mFrameNumber &lt; mSlots[found].mFrameNumber;\n</code></pre></div><div><pre><code>Step4@ BufferQueue::dequeueBuffer\n\n这里的判断来源于第二步的计算结果，一旦发现 dequeue 的数量“超标”，就直接出错返回。\n</code></pre></div><div><pre><code>Step5@ BufferQueue::dequeueBuffer\n\n经过上述几个步骤，我们已经扫描了一遍 mSlots 中的所有成员，这时就要判断是否可以退出循环。\n前面已经说过，如果成功找到有效的 Slot 就可以不用再循环查找了，否则 tryAgain 仍然是 true。\n假如是后一种情况，证明当前已经没有 FREE 的 Slot。这时如果直接进入下一轮循环，结果通常也是一样的，反而浪费了 CPU 资源。\n所以，就需要使用条件锁来等待。代码如下：\n\n    mDequeueCondition.wait(mMutex);\n\n当有 Buffer 被释放时，这个锁的条件就会满足，然后程序才继续查找可用的 Slot。\n</code></pre></div><div><pre><code>Step6@ BufferQueue::dequeueBuffer\n\n根据前面的 Buffer 状态迁移图，当处于 FREE 状态的 Buffer 被 dequeue 成功后，\n它将进入 DEQUEUED，所以这里我们需要改变其 mBufferState。\n</code></pre></div><div><pre><code>Step7@ BufferQueue::dequeueBuffer\n\n通过上述几个步骤的努力，现在我们已经成功地寻找到有效的 Slot 序号了。\n但是这并不代表这个 Slot 可以直接使用，为什么？最直接的一个原因就是这个 Slot 可能还没有分配空间。\n\n因为 BufferSlot::mGraphicBuffer 初始值是 NULL，假如我们是第一次使用它，必然是需要为它分配空间的。\n另外，即便 mGraphicBuffer 不为空，\n但如果用户所需要的 Buffer 属性（比如 width，height，format 等）和当前这个不符，那么还是要进行重新分配。\n</code></pre></div><div><pre><code>Step8@ BufferQueue::dequeueBuffer\n\n如果上一步的判断结果是 BUFFER_NEEDS_REALLOCATION，说明此 Slot 还未分配到有效的 buffer 空间，\n具体分配操作使用的是 mGraphicBufferAlloc 这个 Allocator，\n这里暂不深究其中的实现了，后续还会有详细分析。\n</code></pre></div><p>如果重新分配了空间，那么最后的返回值中会加上 <code>BUFFER_NEEDS_REALLOCATION</code> 标志。</p>\n<p>客户端在发现这个标志后，还应调用 <code>requestBuffer()</code> 来取得最新的 <code>buffer</code> 地址。</p>\n<p> 小节中的 <code>Surface::dequeueBuffer()</code> 的 <code>Step3</code> 就是一个例子，这里结合起来分析。为了方便阅读，再把这部分代码简单地列出来：</p>\n<div><pre><code>frameworks<span>/</span>native<span>/</span>libs<span>/</span>gui<span>/</span>Surface<span>.</span>cpp\n<span>/* frameworks/native/libs/gui/Surface.cpp */</span>\n<span>int</span> <span>Surface</span><span>::</span><span>dequeueBuffer</span><span>(</span>android_native_buffer_t<span>*</span><span>*</span> buffer<span>,</span><span>int</span> <span>*</span>fenceFd<span>)</span> <span>{</span>…\n    Mutex<span>::</span>Autolock <span>lock</span><span>(</span>mMutex<span>)</span><span>;</span>\n    <span>int</span> buf <span>=</span> <span>-</span><span>1</span><span>;</span>\n    <span>/* Step1. 宽高计算 */</span>\n    <span>int</span> reqW <span>=</span> mReqWidth <span>?</span> mReqWidth <span>:</span> mUserWidth<span>;</span>\n    <span>int</span> reqH <span>=</span> mReqHeight <span>?</span> mReqHeight <span>:</span> mUserHeight<span>;</span>\n\n    <span>/* Step2. dequeueBuffer 得到一个缓冲区 */</span>\n    sp<span>&lt;</span>Fence<span>></span> fence<span>;</span>\n    <span>/* 这一小节讲解的就是这个接口的实现 */</span>\n    status_t result <span>=</span> mGraphicBufferProducer<span>-></span><span>dequeueBuffer</span><span>(</span><span>&amp;</span>buf<span>,</span> <span>&amp;</span>fence<span>,</span> reqW<span>,</span> reqH<span>,</span> mReqFormat<span>,</span> mReqUsage<span>)</span><span>;</span> \n    <span>.</span><span>.</span><span>.</span>\n    sp<span>&lt;</span>GraphicBuffer<span>></span><span>&amp;</span><span>gbuf</span><span>(</span>mSlots<span>[</span>buf<span>]</span><span>.</span>buffer<span>)</span><span>;</span> <span>/* 注意 buf 是一个 int 值， 代表的是 mSlots 数组序号 */</span>\n    <span>.</span><span>.</span><span>.</span>\n    <span>if</span> <span>(</span><span>(</span>result <span>&amp;</span> IGraphicBufferProducer<span>::</span>BUFFER_NEEDS_REALLOCATION<span>)</span> <span>||</span> gbuf <span>==</span> <span>0</span><span>)</span> <span>{</span>\n        <span>/* 因为这个 buffer 是需要重新分配得到的，所以还需要进一步调用 requestBuffer，后面有详细讲解 */</span>\n        result <span>=</span> mGraphicBufferProducer<span>-></span><span>requestBuffer</span><span>(</span>buf<span>,</span> <span>&amp;</span>gbuf<span>)</span><span>;</span>\n        <span>.</span><span>.</span><span>.</span>\n    <span>}</span>\n    <span>.</span><span>.</span><span>.</span>\n    <span>*</span>buffer <span>=</span> gbuf<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre></div><p>当 <code>mGraphicBufferProducer-&gt;dequeueBuffer</code> 成功返回后，<code>buf</code> 得到了 <code>mSlots</code> 中可用数组成员的序号（对应这一小节的 <code>found</code> 变量）。</p>\n<p>但一个很明显的问题是：</p>\n<div><pre><code>既然客户端和 BufferQueue 运行于两个不同的进程中，那么它们的 mSlots[buf] 会指向同一块物理内存吗？\n</code></pre></div><p>这就是 <code>requestBuffer</code> 存在的意义。</p>\n<p>先来看看 <code>BpGraphicBufferProducer</code> 中是如何发起 <code>Binder</code> 申请的：</p>\n<div><pre><code><span>/* frameworks/native/libs/gui/IGraphicBufferProducer.cpp */</span>\n<span>class</span> <span>BpGraphicBufferProducer</span><span>:</span> <span><span>public</span> <span>BpInterface</span><span>&lt;</span><span>IGraphicBufferProducer</span><span>></span></span>\n<span>{</span> \n    <span>.</span><span>.</span><span>.</span>\n    <span>virtual</span> status_t <span>requestBuffer</span><span>(</span><span>int</span> bufferIdx<span>,</span> sp<span>&lt;</span>GraphicBuffer<span>></span><span>*</span> buf<span>)</span> <span>{</span> <span>// 函数参数有两个</span>\n    Parcel data<span>,</span> reply<span>;</span>\n    data<span>.</span><span>writeInterfaceToken</span><span>(</span><span>IGraphicBufferProducer</span><span>::</span><span>getInterfaceDescriptor</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\n    <span>/* 只写入了 bufferIdx 值，也就是说 BnGraphicBufferProducer 中实际上是看不到 buf 变量的 */</span>\n    data<span>.</span><span>writeInt32</span><span>(</span>bufferIdx<span>)</span><span>;</span>\n\n    status_t result <span>=</span><span>remote</span><span>(</span><span>)</span><span>-></span><span>transact</span><span>(</span>REQUEST_BUFFER<span>,</span> data<span>,</span> <span>&amp;</span>reply<span>)</span><span>;</span> <span>// 执行跨进程操作</span>\n    <span>.</span><span>.</span><span>.</span>\n    <span>/* 这里读取的是什么？我们稍后可以去 BnGraphicBufferProducer 中确认下 */</span>\n    <span>bool</span> nonNull <span>=</span> reply<span>.</span><span>readInt32</span><span>(</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span>nonNull<span>)</span> <span>{</span>\n        <span>*</span>buf <span>=</span> <span>new</span> <span>GraphicBuffer</span><span>(</span><span>)</span><span>;</span> <span>// 生成一个 GraphicBuffer，看到没，这是一个本地实例</span>\n        <span>/* buf 是一个 sp 指针,那么 **sp 实际上得到的就是这个智能指针所指向的对象。在这个例子中指的是 mSlots[buf].buffer */</span>\n        reply<span>.</span><span>read</span><span>(</span><span>*</span><span>*</span>buf<span>)</span><span>;</span> \n    <span>}</span>\n    result <span>=</span> reply<span>.</span><span>readInt32</span><span>(</span><span>)</span><span>;</span> <span>/* 读取结果 */</span>\n    <span>return</span> result<span>;</span>\n<span>}</span>\n</code></pre></div><p><code>Native</code> 层的 <code>BpXXX/BnXXX</code> 与 <code>Java</code> 层的不同之处在于：</p>\n<div><pre><code>Java 层的通常都是依赖于 aidl来 自动生成这两个类，而 Native 层 的则是手工完成的。\n</code></pre></div><p>也正因为是手工书写的，使用起来才更具灵活性。比如在 <code>IGraphicBufferProducer</code> 这个例子中：</p>\n<div><pre><code>开发者 “耍” 了点技巧 —— Surface 中调用了\n\n    IgraphicBuffer Producer::requestBuffer(int slot, sp&lt;GraphicBuffer>* buf)\n\n这个函数虽然形式上有两个参数，但只有第一个是入参，后一个则是出参。\n在实际的 Binder 通信中，只有 Slot 序号这个 int 值（即 bufferIdx）传递给了对方进程，\n而 buf 则自始至终都是 Surface 所在的本地进程在处理。\n不过从调用者的角度来讲，好像是由 IGraphicBufferProducer 的 Server 端完成了对 buf 的赋值。\n</code></pre></div><p>从 <code>BpGraphicBufferProducer::requestBuffer</code> 这个函数实现中可以看到，<code>Client</code> 端向 <code>Server</code> 端请求了一个 <code>REQUEST_BUFFER</code> 服务，然后通过读取返回值来获得缓冲区信息。</p>\n<p>为了能看清楚这其中的细节，有必要再分析一下 <code>BnGraphicBufferProducer</code> 具体是如何响应这个服务请求的。如下所示：</p>\n<div><pre><code><span>/* frameworks/native/libs/gui/IGraphicBufferProducer.cpp */</span>\nstatus_t <span>BnGraphicBufferProducer</span><span>::</span><span>onTransact</span><span>(</span><span>uint32_t</span> code<span>,</span> <span>const</span> Parcel<span>&amp;</span> data<span>,</span> Parcel<span>*</span> reply<span>,</span> <span>uint32_t</span> flags<span>)</span>\n<span>{</span>\n    <span>switch</span><span>(</span>code<span>)</span> <span>{</span>\n        <span>case</span> REQUEST_BUFFER<span>:</span> <span>{</span>\n            <span>CHECK_INTERFACE</span><span>(</span>IGraphicBufferProducer<span>,</span> data<span>,</span> reply<span>)</span><span>;</span>\n            <span>int</span> bufferIdx   <span>=</span> data<span>.</span><span>readInt32</span><span>(</span><span>)</span><span>;</span> <span>// 首先读取要处理的 Slot 序号</span>\n            sp<span>&lt;</span>GraphicBuffer<span>></span> buffer<span>;</span> <span>// 生成一个 GraphicBuffer 智能指针</span>\n            <span>int</span> result <span>=</span> <span>requestBuffer</span><span>(</span>bufferIdx<span>,</span> <span>&amp;</span>buffer<span>)</span><span>;</span> <span>// 调用本地端的实现</span>\n            reply<span>-></span><span>writeInt32</span><span>(</span>buffer <span>!=</span> <span>0</span><span>)</span><span>;</span> <span>// 注意，第一个写入的值是判断 buffer 不为空，也就是一个 bool 值</span>\n            <span>if</span> <span>(</span>buffer <span>!=</span> <span>0</span><span>)</span> <span>{</span>\n                reply<span>-></span><span>write</span><span>(</span><span>*</span>buffer<span>)</span><span>;</span> <span>// 好，真正的内容在这里，后面我们详细解释</span>\n            <span>}</span>\n            reply<span>-></span><span>writeInt32</span><span>(</span>result<span>)</span><span>;</span> <span>// 写入结果值</span>\n            <span>return</span> NO_ERROR<span>;</span>\n        <span>}</span> <span>break</span><span>;</span>\n</code></pre></div><div><pre><code>BnGraphicBufferProducer 首先读取 Slot 序号，即 bufferIdx；\n然后通过 BufferQueue 的接口 requestBuffer 来获取与之对应的正确的 GraphicBuffer，这里是指 mSlots[slot].mGraphicBuffer。\n\n要特别注意的是，BnGraphicBufferProducer 在 reply 中第一个写入的是 bool 值（buffer!=0），\n紧随其后的才是 GraphicBuffer，最后写入结果值，大功告成。\n</code></pre></div><p>显然 <code>BpGraphicBufferProducer</code> 必须要按照与 <code>BnGraphicBufferProducer</code> 同样的写入顺序来读取数据，即：</p>\n<div><pre><code>1. 因而 BpGraphicBufferProducer::requestBuffer 首先获取一个 int32 值，赋予 nonNull 变量。\n这个 nonNull 值对应的是 BnGraphicBufferProducer::onTransact 中的 buffer != 0 的逻辑判断。\n假如确实不为空，那说明我们可以接着读取 GraphicBuffer 了。\n\n2. 客户端与服务器端对 GraphicBuffer 变量的 “写入和读取” 操作分别是：\n    reply->write(*buffer); // BnGraphicBufferProducer::onTransact 写入 \n    reply.read(**buf); // BpGraphicBufferProducer::requestBuffer 读取\n\n3. 读取 result 结果值。\n</code></pre></div><p>第 2 点中，<code>Server</code> 端写入的 <code>GraphicBuffer</code> 对象需要在 <code>Client</code> 中完整地复现出来。这就需要作为 <code>Binder</code> 对象的 <code>GraphicBuffer</code> 继承 <code>Flattenable</code>：</p>\n<div><pre><code><span>/* frameworks/native/libs/ui/include/ui/GraphicBuffer.h */</span>\n<span>class</span> <span>GraphicBuffer</span>\n    <span>:</span> <span>public</span> ANativeObjectBase<span>&lt;</span>ANativeWindowBuffer<span>,</span> GraphicBuffer<span>,</span> LightRefBase<span>&lt;</span>GraphicBuffer<span>>></span><span>,</span> \n      <span>public</span> Flattenable\n\n<span>/* 高版本中的声明类似，如下： */</span>\n<span>class</span> <span>GraphicBuffer</span>\n    <span>:</span> <span>public</span> ANativeObjectBase<span>&lt;</span>ANativeWindowBuffer<span>,</span> GraphicBuffer<span>,</span> RefBase<span>></span><span>,</span>\n      <span>public</span> Flattenable<span>&lt;</span>GraphicBuffer<span>></span>\n</code></pre></div><p>接下来只需要看下 <code>GraphicBuffer</code> 是如何实现 <code>flatten</code> 和 <code>unflatten</code> 接口的，相信就能揭晓谜底了：</p>\n<blockquote>\n<p>谜题是：既然客户端和 <code>BufferQueue</code> 运行于两个不同的进程中，那么它们的 <code>mSlots[buf]</code> 会指向同一块物理内存吗？</p>\n</blockquote>\n<div><pre><code><span>/* frameworks/native/libs/ui/GraphicBuffer.cpp */</span>\nstatus_t <span>GraphicBuffer</span><span>::</span><span>flatten</span><span>(</span><span>void</span><span>*</span> buffer<span>,</span> size_t size<span>,</span> <span>int</span> fds<span>[</span><span>]</span><span>,</span> size_t count<span>)</span> <span>const</span>\n<span>{</span>\n    <span>.</span><span>.</span><span>.</span>\n    <span>int</span><span>*</span> buf <span>=</span> <span><span>static_cast</span><span><span>&lt;</span><span>int</span><span>*</span><span>></span></span></span><span>(</span>buffer<span>)</span><span>;</span>\n    <span>.</span><span>.</span><span>.</span>\n    <span>if</span> <span>(</span>handle<span>)</span> <span>{</span>\n        buf<span>[</span><span>6</span><span>]</span> <span>=</span> handle<span>-></span>numFds<span>;</span>\n        buf<span>[</span><span>7</span><span>]</span> <span>=</span> handle<span>-></span>numInts<span>;</span>\n        native_handle_t <span>const</span><span>*</span> <span>const</span> h <span>=</span> handle<span>;</span>\n        <span>memcpy</span><span>(</span>fds<span>,</span> h<span>-></span>data<span>,</span> h<span>-></span>numFds<span>*</span><span>sizeof</span><span>(</span><span>int</span><span>)</span><span>)</span><span>;</span>\n        <span>memcpy</span><span>(</span><span>&amp;</span>buf<span>[</span><span>8</span><span>]</span><span>,</span> h<span>-></span>data <span>+</span> h<span>-></span>numFds<span>,</span> h<span>-></span>numInts<span>*</span><span>sizeof</span><span>(</span><span>int</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> NO_ERROR<span>;</span>\n<span>}</span>\n</code></pre></div><p><code>GraphicBuffer::flatten</code> 函数中，我们最关心的是 <code>handle</code> 这个变量的 <code>flatten</code>，它实际上是 <code>GraphicBuffer</code> 中打开的一个 <code>ashmem</code> 句柄，这是两边进程实现共享缓冲区的关键。与 <code>handle</code> 相关的变量分别是 <code>buf[6]-buf[8]</code> 以及 <code>fds</code>，大家可以深入理解下它们的作用。</p>\n<p>再来看看 <code>Client</code> 端是如何还原出一个 <code>GraphicBuffer</code> 的：</p>\n<div><pre><code><span>/* frameworks/native/libs/ui/GraphicBuffer.cpp */</span>\nstatus_t <span>GraphicBuffer</span><span>::</span><span>unflatten</span><span>(</span><span>void</span> <span>const</span><span>*</span> buffer<span>,</span> size_t size<span>,</span> <span>int</span> fds<span>[</span><span>]</span><span>,</span> size_t count<span>)</span>\n<span>{</span>\n    <span>.</span><span>.</span><span>.</span>\n    <span>int</span> <span>const</span><span>*</span> buf <span>=</span> <span><span>static_cast</span><span><span>&lt;</span><span>int</span> <span>const</span><span>*</span><span>></span></span></span><span>(</span>buffer<span>)</span><span>;</span>\n    <span>.</span><span>.</span><span>.</span>   \n    <span>const</span> size_t numFds  <span>=</span> buf<span>[</span><span>6</span><span>]</span><span>;</span>\n    <span>const</span> size_t numInts <span>=</span> buf<span>[</span><span>7</span><span>]</span><span>;</span>\n    <span>.</span><span>.</span><span>.</span>\n    <span>if</span> <span>(</span>numFds <span>||</span> numInts<span>)</span> <span>{</span>\n        <span>.</span><span>.</span><span>.</span>\n        native_handle<span>*</span> h <span>=</span> <span>native_handle_create</span><span>(</span>numFds<span>,</span> numInts<span>)</span><span>;</span>\n        <span>memcpy</span><span>(</span>h<span>-></span>data<span>,</span> fds<span>,</span> numFds<span>*</span><span>sizeof</span><span>(</span><span>int</span><span>)</span><span>)</span><span>;</span>\n        <span>memcpy</span><span>(</span>h<span>-></span>data <span>+</span> numFds<span>,</span> <span>&amp;</span>buf<span>[</span><span>8</span><span>]</span><span>,</span> numInts<span>*</span><span>sizeof</span><span>(</span><span>int</span><span>)</span><span>)</span><span>;</span>        \n        handle <span>=</span> h<span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n        <span>.</span><span>.</span><span>.</span>\n    <span>}</span>\n    <span>.</span><span>.</span><span>.</span>\n    <span>if</span> <span>(</span>handle <span>!=</span> <span>0</span><span>)</span> <span>{</span>\n        mBufferMapper<span>.</span><span>registerBuffer</span><span>(</span>handle<span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> NO_ERROR<span>;</span>\n<span>}</span>\n</code></pre></div><p>同样，<code>unflatten</code> 中的操作也是依据 <code>flatten</code> 时写入的格式。</p>\n<p>其中最重要的两个函数是 <code>native_handle_create()</code> 和 <code>registerBuffer()</code>。</p>\n<div><pre><code>native_handle_create() 函数生成 native_handle 实例，并将相关数据复制到其内部。\n\nregisterBuffer() 函数则属于 GraphicBufferMapper 类中的实现，\n成员变量 mBufferMapper 是在 GraphicBuffer 构造函数中生成的，它所承担的任务是和 Gralloc 打交道。\n</code></pre></div><p><code>GraphicBufferMapper</code> 构造函数的核心代码如下：</p>\n<div><pre><code><span>GraphicBufferMapper</span><span>::</span><span>GraphicBufferMapper</span><span>(</span><span>)</span>\n<span>{</span>\n    hw_module_t <span>const</span><span>*</span> <span>module</span><span>;</span>\n    <span>int</span> err <span>=</span> <span>hw_get_module</span><span>(</span>GRALLOC_HARDWARE_MODULE_ID<span>,</span> <span>&amp;</span><span>module</span><span>)</span><span>;</span>\n</code></pre></div><p>这里出现了 <code>Gralloc</code> 的 <code>module id</code>，在  小节中有介绍过。</p>\n<p><code>GraphicBufferMapper::registerBuffer()</code> 只是起到了中介作用，它会直接调用 <code>gralloc_module_t::registerBuffer()</code>。</p>\n<p>那么后者究竟完成了什么功能呢？因为这个函数的实现与具体平台有关，我们以 <code>msm7k</code> 为例来大概分析下：</p>\n<div><pre><code><span>/* hardware/msm7k/libgralloc/Mapper.cpp */</span>\n<span>int</span> <span>gralloc_register_buffer</span><span>(</span>gralloc_module_t <span>const</span><span>*</span> <span>module</span><span>,</span> buffer_handle_t handle<span>)</span>\n<span>{</span>\n    <span>.</span><span>.</span><span>.</span>\n    private_handle_t<span>*</span> hnd <span>=</span> <span>(</span>private_handle_t<span>*</span><span>)</span>handle<span>;</span>\n    <span>.</span><span>.</span><span>.</span>    \n    err <span>=</span> <span>gralloc_map</span><span>(</span><span>module</span><span>,</span> handle<span>,</span> <span>&amp;</span>vaddr<span>)</span><span>;</span>\n    <span>return</span> err<span>;</span>\n<span>}</span>\n</code></pre></div><p>可以看到，通过 <code>handle</code> 句柄 <code>Client</code> 端可以将指定的内存区域映射到自己的进程空间中，而这块区域与 <code>BufferQueue</code> 中所指向的物理空间是一致的，从而成功地实现了两者的缓冲区共享。</p>\n<p>这样在 <code>Surface::dequeueBuffer()</code> 函数的处理过程中，一旦遇到 <code>mGraphicBufferProducer-&gt;requestBuffer</code> 结果中包含有 <code>BUFFER_NEEDS_REALLOCATION</code> 的情况，就需要通过 <code>requestBuffer()</code> 得到的结果来 “刷新” <code>Client</code> 这端 <code>mSlots[]</code> 所管辖的缓冲区信息，以保证 <code>Surface</code> 与 <code>BufferQueue</code> 在任何情况下都能在 32 个 <code>BufferSlot</code> 中保持数据缓冲区上的高度一致。这也是后面它们能正确实施 “生产者-消费者” 模型的基础。</p>\n<blockquote>\n<p>注意：</p>\n<p>高版本中将调用 <code>mBufferMapper.registerBuffer</code> 改成了调用 <code>mBufferMapper.importBuffer</code></p>\n<div><pre><code><span>/* frameworks/native/libs/ui/GraphicBufferMapper.cpp */</span>\nstatus_t <span>GraphicBufferMapper</span><span>::</span><span>importBuffer</span><span>(</span><span>const</span> native_handle_t<span>*</span> rawHandle<span>,</span> <span>uint32_t</span> width<span>,</span>\n                                           <span>uint32_t</span> height<span>,</span> <span>uint32_t</span> layerCount<span>,</span> PixelFormat format<span>,</span>\n                                           <span>uint64_t</span> usage<span>,</span> <span>uint32_t</span> stride<span>,</span>\n                                           buffer_handle_t<span>*</span> outHandle<span>)</span> <span>{</span>\n    <span>.</span><span>.</span><span>.</span>\n\n    buffer_handle_t bufferHandle<span>;</span>\n    status_t error <span>=</span> mMapper<span>-></span><span>importBuffer</span><span>(</span>rawHandle<span>,</span> <span>&amp;</span>bufferHandle<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>error <span>!=</span> NO_ERROR<span>)</span> <span>{</span>\n        <span>ALOGW</span><span>(</span><span>\"importBuffer(%p) failed: %d\"</span><span>,</span> rawHandle<span>,</span> error<span>)</span><span>;</span>\n        <span>return</span> error<span>;</span>\n    <span>}</span>\n\n    error <span>=</span> mMapper<span>-></span><span>validateBufferSize</span><span>(</span>bufferHandle<span>,</span> width<span>,</span> height<span>,</span> format<span>,</span> layerCount<span>,</span> usage<span>,</span>\n                                        stride<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>error <span>!=</span> NO_ERROR<span>)</span> <span>{</span>\n        <span>ALOGE</span><span>(</span><span>\"validateBufferSize(%p) failed: %d\"</span><span>,</span> rawHandle<span>,</span> error<span>)</span><span>;</span>\n        <span>freeBuffer</span><span>(</span>bufferHandle<span>)</span><span>;</span>\n        <span>return</span> <span><span>static_cast</span><span><span>&lt;</span>status_t<span>></span></span></span><span>(</span>error<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>*</span>outHandle <span>=</span> bufferHandle<span>;</span>\n\n    <span>return</span> NO_ERROR<span>;</span>\n<span>}</span>\n\n<span>/* frameworks/native/libs/ui/include/ui/Gralloc.h */</span>\n<span>class</span> <span>GrallocMapper</span> \n<span>{</span>\n    <span>virtual</span> status_t <span>importBuffer</span><span>(</span><span>const</span> native_handle_t<span>*</span> rawHandle<span>,</span>\n                                  buffer_handle_t<span>*</span> outBufferHandle<span>)</span> <span>const</span> <span>=</span> <span>0</span><span>;</span>\n\n<span>/* \n    GrallocMapper 的子类实现有多个：Gralloc5Mapper、Gralloc4Mapper、Gralloc3Mapper、Gralloc2Mapper，\n    分别声明在 Grallo5.h、 Grallo4.h、 Grallo3.h、 Grallo2.h\n    分别定义在 Grallo5.cpp、 Grallo4.cpp、 Grallo3.cpp、 Grallo2.cpp\n*/</span>\n\n<span>/* frameworks/native/libs/ui/GraphicBufferMapper.cpp */</span>\n<span>GraphicBufferMapper</span><span>::</span><span>GraphicBufferMapper</span><span>(</span><span>)</span> <span>{</span>\n    mMapper <span>=</span> std<span>::</span><span><span>make_unique</span><span><span>&lt;</span><span>const</span> Gralloc5Mapper<span>></span></span></span><span>(</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span>mMapper<span>-></span><span>isLoaded</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n        mMapperVersion <span>=</span> Version<span>::</span>GRALLOC_5<span>;</span>\n        <span>return</span><span>;</span>\n    <span>}</span>\n    mMapper <span>=</span> std<span>::</span><span><span>make_unique</span><span><span>&lt;</span><span>const</span> Gralloc4Mapper<span>></span></span></span><span>(</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span>mMapper<span>-></span><span>isLoaded</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n        mMapperVersion <span>=</span> Version<span>::</span>GRALLOC_4<span>;</span>\n        <span>return</span><span>;</span>\n    <span>}</span>\n    mMapper <span>=</span> std<span>::</span><span><span>make_unique</span><span><span>&lt;</span><span>const</span> Gralloc3Mapper<span>></span></span></span><span>(</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span>mMapper<span>-></span><span>isLoaded</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n        mMapperVersion <span>=</span> Version<span>::</span>GRALLOC_3<span>;</span>\n        <span>return</span><span>;</span>\n    <span>}</span>\n    mMapper <span>=</span> std<span>::</span><span><span>make_unique</span><span><span>&lt;</span><span>const</span> Gralloc2Mapper<span>></span></span></span><span>(</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span>mMapper<span>-></span><span>isLoaded</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n        mMapperVersion <span>=</span> Version<span>::</span>GRALLOC_2<span>;</span>\n        <span>return</span><span>;</span>\n    <span>}</span>\n\n    <span>LOG_ALWAYS_FATAL</span><span>(</span><span>\"gralloc-mapper is missing\"</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>// 以 Gralloc5Mapper 为例</span>\n<span>/* frameworks/native/libs/ui/Gralloc5.cpp */</span>\nstatus_t <span>Gralloc5Mapper</span><span>::</span><span>importBuffer</span><span>(</span><span>const</span> native_handle_t <span>*</span>rawHandle<span>,</span>\n                                      buffer_handle_t <span>*</span>outBufferHandle<span>)</span> <span>const</span> <span>{</span>\n    <span>return</span> mMapper<span>-></span>v5<span>.</span><span>importBuffer</span><span>(</span>rawHandle<span>,</span> outBufferHandle<span>)</span><span>;</span>\n<span>}</span>\n\n<span>Gralloc5Mapper</span><span>::</span><span>Gralloc5Mapper</span><span>(</span><span>)</span> <span>{</span>\n    mMapper <span>=</span> <span>getInstance</span><span>(</span><span>)</span><span>.</span>mapper<span>;</span>\n<span>}</span>\n\n<span>static</span> <span>const</span> Gralloc5 <span>&amp;</span><span>getInstance</span><span>(</span><span>)</span> <span>{</span>\n    <span>static</span> Gralloc5 instance <span>=</span> <span>[</span><span>]</span><span>(</span><span>)</span> <span>{</span>\n        <span>auto</span> allocator <span>=</span> <span>waitForAllocator</span><span>(</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span><span>!</span>allocator<span>)</span> <span>{</span>\n            <span>return</span> Gralloc5<span>{</span><span>}</span><span>;</span>\n        <span>}</span>\n        <span>void</span> <span>*</span>so <span>=</span> <span>loadIMapperLibrary</span><span>(</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span><span>!</span>so<span>)</span> <span>{</span>\n            <span>return</span> Gralloc5<span>{</span><span>}</span><span>;</span>\n        <span>}</span>\n        <span>// 在动态链接库 so 中查找名为 AIMapper_loadIMapper 的符号</span>\n        <span>auto</span> loadIMapper <span>=</span> <span>(</span>AIMapper_loadIMapperFn<span>)</span><span>dlsym</span><span>(</span>so<span>,</span> <span>\"AIMapper_loadIMapper\"</span><span>)</span><span>;</span> \n        AIMapper <span>*</span>mapper <span>=</span> <span>nullptr</span><span>;</span>\n        AIMapper_Error error <span>=</span> <span>loadIMapper</span><span>(</span><span>&amp;</span>mapper<span>)</span><span>;</span>\n        <span>if</span> <span>(</span>error <span>!=</span> AIMAPPER_ERROR_NONE<span>)</span> <span>{</span>\n            <span>ALOGE</span><span>(</span><span>\"AIMapper_loadIMapper failed %d\"</span><span>,</span> error<span>)</span><span>;</span>\n            <span>return</span> Gralloc5<span>{</span><span>}</span><span>;</span>\n        <span>}</span>\n        <span>return</span> Gralloc5<span>{</span>std<span>::</span><span>move</span><span>(</span>allocator<span>)</span><span>,</span> mapper<span>}</span><span>;</span>\n    <span>}</span><span>(</span><span>)</span><span>;</span>\n    <span>return</span> instance<span>;</span>\n<span>}</span>\n\n<span>static</span> <span>void</span> <span>*</span><span>loadIMapperLibrary</span><span>(</span><span>)</span> <span>{</span>\n    <span>static</span> <span>void</span> <span>*</span>imapperLibrary <span>=</span> <span>[</span><span>]</span><span>(</span><span>)</span> <span>-></span> <span>void</span> <span>*</span> <span>{</span>\n        <span>auto</span> allocator <span>=</span> <span>waitForAllocator</span><span>(</span><span>)</span><span>;</span>\n        std<span>::</span>string mapperSuffix<span>;</span>\n        <span>auto</span> status <span>=</span> allocator<span>-></span><span>getIMapperLibrarySuffix</span><span>(</span><span>&amp;</span>mapperSuffix<span>)</span><span>;</span>\n        <span>if</span> <span>(</span><span>!</span>status<span>.</span><span>isOk</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            <span>ALOGE</span><span>(</span><span>\"Failed to get IMapper library suffix\"</span><span>)</span><span>;</span>\n            <span>return</span> <span>nullptr</span><span>;</span>\n        <span>}</span>\n\n        <span>void</span><span>*</span> so <span>=</span> <span>nullptr</span><span>;</span>\n        <span>// TODO(b/322384429) switch this to __ANDROID_API_V__ when V is finalized</span>\n        <span>if</span> <span>API_LEVEL_AT_LEAST</span><span>(</span>__ANDROID_API_FUTURE__<span>,</span> <span>202404</span><span>)</span> <span>{</span>\n            so <span>=</span> <span>AServiceManager_openDeclaredPassthroughHal</span><span>(</span><span>\"mapper\"</span><span>,</span> mapperSuffix<span>.</span><span>c_str</span><span>(</span><span>)</span><span>,</span>\n                                                            RTLD_LOCAL <span>|</span> RTLD_NOW<span>)</span><span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            std<span>::</span>string lib_name <span>=</span> <span>\"mapper.\"</span> <span>+</span> mapperSuffix <span>+</span> <span>\".so\"</span><span>;</span>\n            so <span>=</span> <span>android_load_sphal_library</span><span>(</span>lib_name<span>.</span><span>c_str</span><span>(</span><span>)</span><span>,</span> RTLD_LOCAL <span>|</span> RTLD_NOW<span>)</span><span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span><span>!</span>so<span>)</span> <span>{</span>\n            <span>ALOGE</span><span>(</span><span>\"Failed to load mapper.%s.so\"</span><span>,</span> mapperSuffix<span>.</span><span>c_str</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> so<span>;</span>\n    <span>}</span><span>(</span><span>)</span><span>;</span>\n    <span>return</span> imapperLibrary<span>;</span>\n<span>}</span>\n\n<span>/* hardware/interfaces/graphics/mapper/stable-c/include/android/hardware/graphics/mapper/IMapper.h */</span>\n<span>typedef</span> <span>struct</span> <span>AIMapperV5</span> <span>{</span>\n    <span>AIMapper_Error</span> <span>(</span><span>*</span>_Nonnull importBuffer<span>)</span><span>(</span><span>const</span> native_handle_t<span>*</span> _Nonnull handle<span>,</span>\n                                            buffer_handle_t _Nullable<span>*</span> _Nonnull outBufferHandle<span>)</span><span>;</span>\n</code></pre></div></blockquote>\n<h3 id=\"_5-3-应用程序的典型绘图流程\" tabindex=\"-1\"> 5.3 应用程序的典型绘图流程</h3>\n<p><code>BufferQueue</code> 可以有多达 32 个的 <code>BufferSlot</code>，为什么这样设计？</p>\n<div><pre><code>一个可能的原因就是提高图形渲染速度。因为假如只有两个 buffer，可以想象一下，\n当应用程序这个生产者的产出效率大于消费者的处理速度时，\n很快就会 dequeue 完所有缓冲区而处于等待状态，从而导致不必要的麻烦。\n当然，实际上 32 只是最大的容量，具体值是可以设置的，大家可以结合后面的 Project Butter 来进一步理解。\n</code></pre></div><p>根据前面介绍的 <code>BufferQueue</code> 的内部原理，应用程序该如何与之配合的呢？</p>\n<div><pre><code>解决这个疑惑的关键就是了解应用程序是如何执行绘图流程的，这也是本节内容的重点。\n\n不过大家应该有个心理准备，即：应用程序并不会直接使用 BufferQueue（或者 Surface）。\n和 Android 系统中很多其他地方一样，“层层封装” 在这里同样是存在的。\n因而我们一方面要尽量抓住核心，另一方面也要辅以有效的分析手段，才能更快更好地从诸多错综复杂的类关系中找出问题的答案。\n</code></pre></div><p>本小节选取 “系统开机动画” 这一应用程序为例，来分析应用程序图形绘制的流程。</p>\n<blockquote>\n<p>开机动画应用程序与 <code>SurfaceFlinger</code> 都是使用 <code>OpenGL ES</code> 来完成 <code>UI</code> 显示的。</p>\n<p>不过因为开机动画是一个 <code>C++</code> 程序，所以不需要上层 <code>GLSurfaceView</code> 的支持。</p>\n</blockquote>\n<p>当一个 <code>Android</code> 设备上电后，正常情况下它会先后显示最多 4 个不同的开机画面。分别是：</p>\n<div><pre><code>BootLoader\n    这是第一个出现的画面。\n    因为 boot-loader 只是负责系统后续模块的加载与启动，所以一般我们只让它显示一张静态的图片。\n\nKernel\n    内核也有自己的显示画面。\n    和 boot-loader 一样，默认情况下它也只是一张静态图片。\n\nAndroid（最多 2 个）\n    Android 是系统启动的最后一个阶段，也是最耗时间的一个。\n    它的开机画面既可以是静态的文字、图片，也可以是动态的画面。\n    另外，这一阶段可以包含最多两个开机画面：\n        1. 通常前一个是文字或者静态图片（注意：默认是图片，但如果图片不存在的话，就显示文字）；\n        2. 另外一个则是动画，如下图所示。\n</code></pre></div><p><img src=\"@source/lango-tech/subject/images/surfaceflinger/07.png\" alt=\"\" loading=\"lazy\"></p>\n<p>这个开机动画的实现类是 <code>BootAnimation</code>，它的内部就是借助于 SurfaceFlinger 来完成的。</p>\n<p>另外，由于它并不是传统意义上的 <code>Java</code> 层应用程序，从而使得我们可以抛离很多上层的牵绊（比如一大堆 <code>JNI</code> 调用），进而以最直观的方式来审视 <code>BufferQueue</code> 的使用细节，这是分析本节问题的最佳选择。</p>\n<p><code>BootAnimation</code> 是一个 <code>C++</code> 程序，其工程源码路径是：</p>\n<p><img src=\"@source/lango-tech/subject/images/surfaceflinger/08.png\" alt=\"\" loading=\"lazy\"></p>\n<p>和很多 <code>native</code> 应用一样，它也是在 <code>init</code> 脚本中被启动的。如下：</p>\n<div><pre><code>service bootanim <span>/</span>system<span>/</span>bin<span>/</span>bootanimation\n    <span>class</span> <span>main</span>\n    user graphics\n    group graphics\n    disabled\n    oneshot\n</code></pre></div><blockquote>\n<p>注意：</p>\n<p>高版本中，略有不同，参考：</p>\n<p><a href=\"https://cloud.tencent.com/developer/article/2358064\" target=\"_blank\" rel=\"noopener noreferrer\">Android 开机动画启动流程<ExternalLinkIcon/></a></p>\n<p><a href=\"https://blog.csdn.net/m0_46857231/article/details/123066642\" target=\"_blank\" rel=\"noopener noreferrer\">安卓 12 开机动画 Bootanimation 源码分析-启动流程<ExternalLinkIcon/></a></p>\n</blockquote>\n<p>当 <code>bootanimation</code> 被启动后，它首先会进入 <code>main</code> 函数（即 <code>main@bootanimation_main.cpp</code>）生成一个 <code>BootAnimation</code> 对象，并开启线程池（因为它需要与 <code>SurfaceFlinger</code> 等系统服务进行跨进程的通信）。在 <code>BootAnimation</code> 的构造函数中，同时会生成一个 <code>SurfaceComposerClient</code>：</p>\n<div><pre><code><span>/* frameworks/base/cmds/bootanimation/BootAnimation.cpp */</span>\n<span>BootAnimation</span><span>::</span><span>BootAnimation</span><span>(</span>sp<span>&lt;</span>Callbacks<span>></span> callbacks<span>)</span>\n        <span>:</span> <span>Thread</span><span>(</span><span>false</span><span>)</span><span>,</span> <span>mLooper</span><span>(</span><span>new</span> <span>Looper</span><span>(</span><span>false</span><span>)</span><span>)</span><span>,</span> <span>.</span><span>.</span><span>.</span> <span>{</span>\n    <span>.</span><span>.</span><span>.</span>\n    mSession <span>=</span> <span>new</span> <span>SurfaceComposerClient</span><span>(</span><span>)</span><span>;</span>\n    <span>.</span><span>.</span><span>.</span>\n<span>}</span>\n</code></pre></div><p><code>SurfaceComposerClient</code> 是每个 UI 应用程序与 <code>SurfaceFlinger</code> 间的独立纽带，后续很多操作都是通过它来完成的。</p>\n<p>不过 <code>SurfaceComposerClient</code> 更多的只是一个封装，真正起作用的还是其内部的 <code>ISurfaceComposerClient</code>。</p>\n<p>前面小节中我们已经讲解了 <code>IGraphicBufferProducer</code> 与 <code>ISurfaceComposerClient</code> 在应用程序中的获取顺序，那么两者有什么区别呢？</p>\n<div><pre><code>简单来说，\nISurfaceComposerClient 是应用程序与 SurfaceFlinger 间的桥梁，\nIgraphicBufferProducer 则是应用程序与 BufferQueue 间的传输通道。\n\n这样的设计是合理的，体现了模块化的思想：\n    SurfaceFlinger 的职责是 “Flinger”，即把系统中所有应用程序最终的 “绘图结果” 进行 “混合”，然后统一显示到物理屏幕上。\n    它不应该也没有办法分出太多的精力去逐一关注各个应用程序的 “绘画过程”。\n    这个任务自然而然地落在了 BufferQueue 的肩膀上，\n    它是 SurfaceFlinger 派出的代表，也是每个应用程序 “一对一” 的辅导老师，\n    指导着 UI 程序的 “画板申请”、“作画流程” 等一系列烦琐细节。\n</code></pre></div><p>所以 BootAnimation 在其构造函数中就建立了与 SurfaceFlinger 的连接通道。</p>\n<p>那么，它在什么时候会再去建立与 BufferQueue 的连接呢？</p>\n<p>因为 BootAnimation 继承自 RefBase，当 main 函数中通过 sp 指针引用它时，会触发如下函数：</p>\n<div><pre><code><span>void</span> <span>BootAnimation</span><span>::</span><span>onFirstRef</span><span>(</span><span>)</span> <span>{</span> <span>// 第一次被引用时</span>\n    status_t err <span>=</span> mSession<span>-></span><span>linkToComposerDeath</span><span>(</span><span>this</span><span>)</span><span>;</span> <span>// 监听死亡事件</span>\n    <span>if</span> <span>(</span>err <span>==</span> NO_ERROR<span>)</span> <span>{</span>        \n        <span>run</span><span>(</span><span>\"BootAnimation\"</span><span>,</span> PRIORITY_DISPLAY<span>)</span><span>;</span> <span>// 开启线程</span>\n    <span>}</span>\n<span>}</span>\n</code></pre></div><blockquote>\n<p>注意：</p>\n<p>高版本中，<code>BootAnimation::run</code> 方法在 <code>main@bootanimation_main.cpp</code> 函数中执行：</p>\n<div><pre><code><span>int</span> <span>main</span><span>(</span><span>)</span>\n<span>{</span>\n    <span>.</span><span>.</span><span>.</span>\n    <span>bool</span> noBootAnimation <span>=</span> <span>bootAnimationDisabled</span><span>(</span><span>)</span><span>;</span>\n    <span>.</span><span>.</span><span>.</span>\n    <span>if</span> <span>(</span><span>!</span>noBootAnimation<span>)</span> <span>{</span>\n        sp<span>&lt;</span>ProcessState<span>></span> <span>proc</span><span>(</span><span>ProcessState</span><span>::</span><span>self</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>ProcessState</span><span>::</span><span>self</span><span>(</span><span>)</span><span>-></span><span>startThreadPool</span><span>(</span><span>)</span><span>;</span>\n\n        <span>// create the boot animation object (may take up to 200ms for 2MB zip)</span>\n        sp<span>&lt;</span>BootAnimation<span>></span> boot <span>=</span> <span>new</span> <span>BootAnimation</span><span>(</span>audioplay<span>::</span><span>createAnimationCallbacks</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>.</span><span>.</span><span>.</span>\n        boot<span>-></span><span>run</span><span>(</span><span>\"BootAnimation\"</span><span>,</span> PRIORITY_DISPLAY<span>)</span><span>;</span> <span>// 执行 BootAnimation::run 函数</span>\n        <span>.</span><span>.</span><span>.</span>\n        <span>IPCThreadState</span><span>::</span><span>self</span><span>(</span><span>)</span><span>-></span><span>joinThreadPool</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> <span>0</span><span>;</span>\n<span>}</span>\n</code></pre></div></blockquote>\n<p>当一个 <code>Client</code> 与远程 <code>Server</code> 建立了 <code>Binder</code> 通信后，它就可以使用这个 <code>Server</code> 的服务了，但前提是服务器运行正常。</p>\n<p>换句话说，假如出现了 <code>Server</code> 异常的情况，<code>Client</code> 又如何知道呢？</p>\n<div><pre><code>这就是 linkToComposerDeath 要解决的问题，\nlinkToComposerDeath 的第一个参数指明了接收 Binder Server 死亡事件的人，在本例中就是 BootAnimation 自身。\n所以 BootAnimation 继承了I Binder::DeathRecipient，并实现了其中的 binderDied 接口。\n</code></pre></div><p>如果 <code>BootAnimation::onFirstRef</code> 中 <code>err == NO_ERROR</code> 成立的话，那么接下来就要启动一个新线程来承载业务了。</p>\n<p>为什么需要独立创建一个新的线程呢？</p>\n<div><pre><code>前面 main 函数中，大家应该发现了 BootAnimation 启动了 Binder 线程池。\n可以想象在只有一个线程的情况下，它是不可能既监听 Binder 请求，又去做开机动画绘制的。\n</code></pre></div><p>当一个新的线程被 <code>run</code> 起来后，又触发了下列函数的调用：</p>\n<div><pre><code><span>/* frameworks/base/cmds/bootanimation/BootAnimation.cpp */</span>\nstatus_t <span>BootAnimation</span><span>::</span><span>readyToRun</span><span>(</span><span>)</span> <span>{</span>…   \n    <span>/* 第一部分，向server端获取buffer空间，从而得到EGL需要的本地窗口 */</span>\n    sp<span>&lt;</span>SurfaceControl<span>></span> control <span>=</span> \n        <span>session</span><span>(</span><span>)</span><span>-></span><span>createSurface</span><span>(</span><span>String8</span><span>(</span><span>\"BootAnimation\"</span><span>)</span><span>,</span> dinfo<span>.</span>w<span>,</span> dinfo<span>.</span>h<span>,</span> PIXEL_FORMAT_RGB_565<span>)</span><span>;</span>\n\n    <span>SurfaceComposerClient</span><span>::</span><span>openGlobalTransaction</span><span>(</span><span>)</span><span>;</span>\n    control<span>-></span><span>setLayer</span><span>(</span><span>0x40000000</span><span>)</span><span>;</span>\n    <span>SurfaceComposerClient</span><span>::</span><span>closeGlobalTransaction</span><span>(</span><span>)</span><span>;</span>\n    sp<span>&lt;</span>Surface<span>></span> s <span>=</span> control<span>-></span><span>getSurface</span><span>(</span><span>)</span><span>;</span>\n\n    <span>/* 以下为第二部分，即 EGL 的配置流程 */</span>\n    <span>const</span> EGLint attribs<span>[</span><span>]</span> <span>=</span> <span>{</span><span>.</span><span>.</span><span>.</span><span>}</span><span>;</span> <span>/* 属性值较多，为了节约篇幅，我们省略具体内容 */</span>\n    EGLint w<span>,</span> h<span>,</span> dummy<span>;</span>\n    EGLint numConfigs<span>;</span> <span>//总共有多少个 config</span>\n    EGLConfig config<span>;</span>\n    EGLSurface surface<span>;</span>\n    EGLContext context<span>;</span>\n    <span>// 第一步，得到默认的物理屏幕</span>\n    EGLDisplay display <span>=</span> <span>eglGetDisplay</span><span>(</span>EGL_DEFAULT_DISPLAY<span>)</span><span>;</span> \n    <span>// 第二步，初始化</span>\n    <span>eglInitialize</span><span>(</span>display<span>,</span> <span>0</span><span>,</span> <span>0</span><span>)</span><span>;</span> \n    <span>// 第三步，选取最佳的 config</span>\n    <span>eglChooseConfig</span><span>(</span>display<span>,</span> attribs<span>,</span> <span>&amp;</span>config<span>,</span> <span>1</span><span>,</span> <span>&amp;</span>numConfigs<span>)</span><span>;</span> \n    <span>// 第四步，通过本地窗口创建 Surface</span>\n    surface <span>=</span> <span>eglCreateWindowSurface</span><span>(</span>display<span>,</span> config<span>,</span> s<span>.</span><span>get</span><span>(</span><span>)</span><span>,</span> <span>NULL</span><span>)</span><span>;</span> \n    <span>// 第五步，创建 context 环境</span>\n    context <span>=</span> <span>eglCreateContext</span><span>(</span>display<span>,</span> config<span>,</span> <span>NULL</span><span>,</span> <span>NULL</span><span>)</span><span>;</span>\n    <span>.</span><span>.</span><span>.</span>\n    <span>// 第六步，设置当前环境</span>\n    <span>if</span> <span>(</span><span>eglMakeCurrent</span><span>(</span>display<span>,</span> surface<span>,</span> surface<span>,</span> context<span>)</span> <span>==</span> EGL_FALSE<span>)</span>\n        <span>return</span> NO_INIT<span>;</span>\n    <span>.</span><span>.</span><span>.</span>\n    <span>return</span> NO_ERROR<span>;</span>\n<span>}</span>\n</code></pre></div><blockquote>\n<p>这个函数不但向我们展示了应用程序与 <code>BufferQueue</code> 的通信过程，</p>\n<p>而且还有另外一个重要的学习点，即 <code>Opengl ES</code> 与 <code>EGL</code> 的使用流程。</p>\n</blockquote>\n<div><pre><code>函数 readyToRun 首先通过 session()->createSurface() 来获取一个 SurfaceControl。\n其中 session() 得到的是 mSession 变量，也就是前面构造函数中生成的 SurfaceComposerClient 对象，\n所以 SurfaceComposerClient::createSurface() 最终就是由 SurfaceFlinger 相关联的服务来实现的。\n</code></pre></div><p>具体而言，<code>SurfaceComposerClient</code> 对应的 <code>Server</code> 端的实现是 <code>Client(C++)</code>：</p>\n<div><pre><code><span>/* frameworks/native/libs/gui/SurfaceComposerClient.cpp */</span>\nsp<span>&lt;</span>SurfaceControl<span>></span> <span>SurfaceComposerClient</span><span>::</span><span>createSurface</span><span>(</span><span>.</span><span>.</span><span>.</span><span>)</span> \n<span>{</span>\n    <span>createSurfaceChecked</span><span>(</span><span>.</span><span>.</span><span>.</span><span>)</span><span>;</span>\n\nstatus_t <span>SurfaceComposerClient</span><span>::</span><span>createSurfaceChecked</span><span>(</span><span>.</span><span>.</span><span>.</span><span>)</span> \n<span>{</span>\n    binder<span>::</span>Status status <span>=</span> mClient<span>-></span><span>createSurface</span><span>(</span><span>.</span><span>.</span><span>.</span><span>)</span><span>;</span>\n        \n<span>/* frameworks/native/libs/gui/include/gui/SurfaceComposerClient.h */</span>\n<span>class</span> <span>SurfaceComposerClient</span> <span>:</span> <span><span>public</span> <span>RefBase</span></span>\n<span>{</span>\n    sp<span>&lt;</span>ISurfaceComposerClient<span>></span>  mClient<span>;</span>\n\n<span>/* frameworks/native/services/surfaceflinger/Client.h */</span>\n<span>class</span> <span>Client</span> <span>:</span> <span><span>public</span> gui<span>::</span><span>BnSurfaceComposerClient</span></span> \n<span>{</span>\n\n<span>/*frameworks/native/services/surfaceflinger/Client.cpp*/</span>\nstatus_t <span>Client</span><span>::</span><span>createSurface</span> <span>(</span><span>.</span><span>.</span><span>.</span><span>)</span>\n<span>{</span>\n    <span>.</span><span>.</span><span>.</span>\n    sp<span>&lt;</span>MessageBase<span>></span> msg <span>=</span> <span>new</span> <span>MessageCreateLayer</span><span>(</span>mFlinger<span>.</span><span>get</span><span>(</span><span>)</span><span>,</span> name<span>,</span> <span>this</span><span>,</span> w<span>,</span> h<span>,</span> format<span>,</span> flags<span>,</span> handle<span>,</span> gbp<span>)</span><span>;</span>\n    mFlinger<span>-></span><span>postMessageSync</span><span>(</span>msg<span>)</span><span>;</span> <span>// 发送给 SurfaceFlinger 进行处理</span>\n    <span>return</span> <span><span>static_cast</span><span><span>&lt;</span>MessageCreateLayer<span>*</span><span>></span></span></span><span>(</span> msg<span>.</span><span>get</span><span>(</span><span>)</span> <span>)</span><span>-></span><span>getResult</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre></div><p><code>Client::createSurface</code> 函数将用户的请求通过消息推送到前者的处理队列中，等到有结果后才返回。</p>\n<blockquote>\n<p>从 <code>postMessageSync</code> 名称可以看出，这是一个同步函数，</p>\n<p>关于 <code>Client</code> 与 <code>SurfaceFlinger</code> 间的这种工作方式，我们会放在后续 <code>SurfaceFlinger</code> 小节作详细解释。</p>\n</blockquote>\n<p>因而最终还是要由 <code>SurfaceFlinger</code> 来执行操作，只不过 “操作的内容” 又是由 <code>Message</code> 本身提供的。</p>\n<div><pre><code><span>class</span> <span>MessageCreateLayer</span> <span>:</span> <span><span>public</span> <span>MessageBase</span></span> <span>{</span>\n<span>.</span><span>.</span><span>.</span>\n<span>public</span><span>:</span>\n    <span>.</span><span>.</span><span>.</span>\n    <span>virtual</span> <span>bool</span> <span>handler</span><span>(</span><span>)</span> <span>{</span>\n        result <span>=</span> flinger<span>-></span><span>createLayer</span><span>(</span>name<span>,</span> client<span>,</span> w<span>,</span> h<span>,</span> format<span>,</span> flags<span>,</span>handle<span>,</span> gbp<span>)</span><span>;</span>\n        <span>return</span> <span>true</span><span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n</code></pre></div><blockquote>\n<p>注意：</p>\n<p>高版本中，<code>Client::createSurface</code> 函数中不再调用 <code>mFlinger-&gt;postMessageSync</code> 发消息，</p>\n<p>而是直接调用 <code>mFlinger-&gt;createLayer</code>。</p>\n</blockquote>\n<p>现在的问题就转换为：<strong><code>createLayer</code> 生成了什么对象呢？</strong></p>\n<p>没错，就是 <code>IGraphicBufferProducer</code>。</p>\n<p>如下代码省略了中间一大段过程，只保留与问题相关的部分，更详细的分析可以参见后续小节：</p>\n<div><pre><code>status_t <span>SurfaceFlinger</span><span>::</span><span>createLayer</span><span>(</span><span>.</span><span>.</span><span>.</span><span>,</span> sp<span>&lt;</span>IBinder<span>></span><span>*</span> handle<span>,</span> sp<span>&lt;</span>IGraphicBufferProducer<span>></span><span>*</span> gbp<span>)</span>\n<span>{</span>\n    <span>.</span><span>.</span><span>.</span>\n    status_t result <span>=</span> NO_ERROR<span>;</span>\n\n    sp<span>&lt;</span>Layer<span>></span> layer<span>;</span>\n    <span>switch</span> <span>(</span>flags <span>&amp;</span> ISurfaceComposerClient<span>::</span>eFXSurfaceMask<span>)</span> <span>{</span>\n        <span>case</span> ISurfaceComposerClient<span>::</span>eFXSurfaceNormal<span>:</span> <span>// 普通 Surface</span>\n            result <span>=</span> <span>createNormalLayer</span><span>(</span>client<span>,</span>name<span>,</span> w<span>,</span> h<span>,</span> flags<span>,</span> format<span>,</span>handle<span>,</span> gbp<span>,</span> <span>&amp;</span>layer<span>)</span><span>;</span>\n            <span>break</span><span>;</span>\n        <span>case</span> ISurfaceComposerClient<span>::</span>eFXSurfaceDim<span>:</span>\n            result <span>=</span> <span>createDimLayer</span><span>(</span>client<span>,</span>name<span>,</span> w<span>,</span> h<span>,</span> flags<span>,</span>handle<span>,</span> gbp<span>,</span> <span>&amp;</span>layer<span>)</span><span>;</span>\n            <span>break</span><span>;</span>\n        <span>default</span><span>:</span>\n            result <span>=</span> BAD_VALUE<span>;</span>\n            <span>break</span><span>;</span>\n    <span>}</span>\n    <span>.</span><span>.</span><span>.</span>\n    <span>return</span> result<span>;</span>\n<span>}</span>\n</code></pre></div><p>通过上面的代码段可以清楚地看到，<code>SurfaceFlinger</code> 不但生成了 <code>IGraphicBufferProducer</code> 对象，而且引入了新的概念：<strong><code>Layer</code></strong>。</p>\n<div><pre><code>Layer 类在 SurfaceFlinger 中表示 “层”，通俗地讲就是代表了一个 “画面”，\n最终物理屏幕上的显示结果就是通过对系统中同时存在的所有 “画面” 进行处理而得到的。\n\n这就好比一排人（列队）各举着一张绘画作品，那么观察者从最前面往后看时，他首先看到的就是第一张画；\n而假如第一张画恰好比第二张小，又或者第一张是透明/半透明的（这并非不可能，如作者是在玻璃上创作的），那么他就能看到第二张画。\n依此类推，最终看到的就是这些 “画”（Layer）的混合（Flinger）结果。\n</code></pre></div><p>以上类比告诉我们，<code>layer</code> 是有层级的，越靠近用户的那个 “层” 就越有优势。</p>\n<p>了解了 <code>layer</code> 的层级概念后，函数 <code>BootAnimation::readyToRun</code> 接下来调用 <code>setLayer</code> 就不难理解了。</p>\n<p>不过参数中传入了一个数值 <code>0x40000000</code>，这又是什么意思？</p>\n<div><pre><code>其实这个值就是 layer 的层级，在显示系统中通常被称为 Z-Order，而且数字越大就越靠近用户。\n\nBootAnimation 显示时因为整个系统中还只有开机画面一个应用程序，所以并不需要担心 Z-Order 的问题。\n换句话说，0x40000000 这个值足矣。\n</code></pre></div><p>设置完层级后，<code>BootAnimation::readyToRun</code> 接着调用 <code>control-&gt;getSurface()</code> 来得到一个 <code>Surface</code> 对象。</p>\n<blockquote>\n<p><code>Surface</code> 对象就是 “<code>Android</code> 中的本地窗口” 小节中介绍的其中一个本地窗口</p>\n<p>详见： </p>\n</blockquote>\n<blockquote>\n<p>涉及的相关类越来越多，为了避免混淆，我们先来整理下目前已经出现的各个类的关系：</p>\n</blockquote>\n<div><pre><code>ISurfaceComposerClient：\n    应用程序与 SurfaceFlinger 间的通道，在应用进程中则被封装在 SurfaceComposerClient 这个类中。\n    这是一个匿名的 Binder Server，\n    由应用程序调用 SurfaceFlinger 这个实名 Binder 的 createConnection 方法来获取到，\n    （具体位置在 SurfaceComposerClient::onFirstRef 中）\n    服务端的实现是 frameworks/native/services/surfaceflinger/Client.h。\n\nIGraphicBufferProducer：\n    由应用程序调用 ISurfaceComposerClient::createSurface() 得到，\n    同时在 SurfaceFlinger 这一进程中将会有一个 Layer 被创建，代表了一个 “画面”。\n    ISurface 就是控制这一画面的 handle，它将保存在应用程序端的 SurfaceControl 中。\n\nSurface：\n    从逻辑关系上看，它是上述 ISurface 的使用者。\n    从继承关系上看，它是一个本地窗口。\n    Surface 内部持有 IGraphicBufferProducer，即 BufferQueue 的实现接口。\n    换个角度来思考，当 EGL 想通过 Surface 这个本地窗口完成某些功能时，\n    Surface 实际上又利用 ISurface 和 IGraphicBufferProducer 来取得远程服务端的对应服务，以完成 EGL 的请求。\n</code></pre></div><p>回到 <code>BootAnimation::readyToRun()</code> 中。</p>\n<div><pre><code>因为本地窗口 Surface 已经成功创建，接下来就该 EGL 上场了。\n具体流程我们在代码中都加了注释，这里就不再赘述。\n</code></pre></div><p>当 <code>EGL</code> 准备好环境后，意味着程序可以正常使用 <code>OpenGL ES</code> 提供的各种 <code>API</code> 函数进行绘图了。</p>\n<blockquote>\n<p>这部分实现就集中在随后的 <code>BootAnimation::threadLoop()</code></p>\n<p>以及 <code>BootAnimation::android()/BootAnimation::movie()</code> 中。</p>\n</blockquote>\n<p>最后，对一个典型的应用程序使用 SurfaceFlinger 进行绘图的流程总结如下图所示：</p>\n<blockquote>\n<p>其中涉及 <code>IgraphicBufferProducer</code>、<code>Surface</code>、<code>SurfaceControl</code>、<code>Layer</code> 等太多元素，只选取部分重点类进行展示</p>\n</blockquote>\n<p><img src=\"@source/lango-tech/subject/images/surfaceflinger/09.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_5-4-应用程序与-bufferqueue-的关系\" tabindex=\"-1\"> 5.4 应用程序与 <code>BufferQueue</code> 的关系</h3>\n<p>现在我们已经明白了应用程序利用 <code>SurfaceFlinger</code> 进行绘制工作的大致流程，只不过在这个过程中直到最后才出现了 <code>BufferQueue</code>。</p>\n<p><strong>那么，应用程序具体是如何借助 <code>BufferQueue</code> 来完成工作的呢？</strong></p>\n<p>仔细观察不难发现，当应用程序端通过 <code>ISurfaceComposerClient::createSurface()</code> 来发起创建 <code>Surface</code> 的请求时，<code>SurfaceFlinger</code> 服务进程这边会创建一个 <code>Layer</code>。既然 <code>Layer</code> 代表了一个画面图层，那么它肯定需要存储 “图层数据” 的地方，因而我们选择以这里作为入口：</p>\n<div><pre><code><span>/*frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp*/</span>\nstatus_t <span>SurfaceFlinger</span><span>::</span><span>createLayer</span><span>(</span><span>const</span> String8<span>&amp;</span> name<span>,</span> <span>const</span> sp<span>&lt;</span>Client<span>></span><span>&amp;</span> client<span>,</span>\n        <span>uint32_t</span> w<span>,</span> <span>uint32_t</span> h<span>,</span> PixelFormat format<span>,</span> <span>uint32_t</span> flags<span>,</span>\n        sp<span>&lt;</span>IBinder<span>></span><span>*</span> handle<span>,</span> sp<span>&lt;</span>IGraphicBufferProducer<span>></span><span>*</span> gbp<span>)</span>\n<span>{</span>\n    <span>.</span><span>.</span>\n    status_t result <span>=</span> NO_ERROR<span>;</span>\n    sp<span>&lt;</span>Layer<span>></span> layer<span>;</span>\n\n    <span>switch</span> <span>(</span>flags <span>&amp;</span> ISurfaceComposerClient<span>::</span>eFXSurfaceMask<span>)</span> <span>{</span> <span>// Layer类型，目前只有两种</span>\n        <span>case</span> ISurfaceComposerClient<span>::</span>eFXSurfaceNormal<span>:</span> <span>// 普通 Layer</span>\n            result <span>=</span> <span>createNormalLayer</span><span>(</span>client<span>,</span> name<span>,</span> w<span>,</span> h<span>,</span> flags<span>,</span> format<span>,</span> handle<span>,</span> gbp<span>,</span> <span>&amp;</span>layer<span>)</span><span>;</span>\n            <span>break</span><span>;</span>\n        <span>case</span> ISurfaceComposerClient<span>::</span>eFXSurfaceDim<span>:</span> <span>// Dim 效果的 Layer</span>\n            result <span>=</span> <span>createDimLayer</span><span>(</span>client<span>,</span> name<span>,</span> w<span>,</span> h<span>,</span> flags<span>,</span> handle<span>,</span> gbp<span>,</span> <span>&amp;</span>layer<span>)</span><span>;</span>\n            <span>break</span><span>;</span>\n        <span>default</span><span>:</span>\n            result <span>=</span> BAD_VALUE<span>;</span>\n            <span>break</span><span>;</span>\n    <span>}</span>\n\n    <span>if</span> <span>(</span>result <span>==</span> NO_ERROR<span>)</span> <span>{</span>\n        <span>addClientLayer</span><span>(</span>client<span>,</span> <span>*</span>handle<span>,</span> <span>*</span>gbp<span>,</span> layer<span>)</span><span>;</span> <span>// 添加到全局的管理中</span>\n        <span>setTransactionFlags</span><span>(</span>eTransactionNeeded<span>)</span><span>;</span> <span>// 设置业务标志</span>\n    <span>}</span>\n    <span>return</span> result<span>;</span>\n<span>}</span>\n</code></pre></div><p>这个函数用于生成一个 <code>Layer</code>。</p>\n<div><pre><code>从 enum 值定义来看，当前系统中有多达十几种 Layer 类型，只不过多数还没有真正实现。\n目前能用的只有两个，即 eFXSurfaceNormal 和 eFXSurfaceDim。\n1. 正常情况下的图层；\n2. 带有 Dim 效果的图层。\n更早前版本中还有一种 Blur 效果的 Layer。可能出于效率的考虑，当前系统中已经统一将它用 Dim 替代了。\n相信在后续的 Android 版本中还会把它们再区分开来。\n</code></pre></div><blockquote>\n<p>注意：</p>\n<p>高版本中 <code>SurfaceFlinger::createLayer</code> 的实现已有所不同。</p>\n<p>不管哪种类型的 <code>Layer</code>，都统一调用  <code>SurfaceFlinger::createBufferStateLayer</code></p>\n</blockquote>\n<p>最终返回给调用者的有两个：即 <code>handle</code> 和 <code>gbp</code>。前者是一个 <code>IBinder</code> 对象，后者则是大家熟悉的 <code>IGraphicBufferProducer</code>。</p>\n<blockquote>\n<p>注意：</p>\n<p>高版本中 返回数据的封装形式也不太一样了。</p>\n</blockquote>\n<p><code>Layer</code> 和 <code>handle</code> 及 <code>gbp</code> 有什么联系呢？我们选取 <code>eFXSurfaceNormal</code> 类型的图层来深入分析：</p>\n<div><pre><code>status_t <span>SurfaceFlinger</span><span>::</span><span>createNormalLayer</span><span>(</span><span>const</span> sp<span>&lt;</span>Client<span>></span><span>&amp;</span> client<span>,</span>\n        <span>const</span> String8<span>&amp;</span> name<span>,</span> <span>uint32_t</span> w<span>,</span> <span>uint32_t</span> h<span>,</span> <span>uint32_t</span> flags<span>,</span> PixelFormat<span>&amp;</span> format<span>,</span>\n        sp<span>&lt;</span>IBinder<span>></span><span>*</span> handle<span>,</span> sp<span>&lt;</span>IGraphicBufferProducer<span>></span><span>*</span> gbp<span>,</span> sp<span>&lt;</span>Layer<span>></span><span>*</span> outLayer<span>)</span>\n<span>{</span>\n    <span>// format 的赋值过程省略</span>\n    <span>.</span><span>.</span><span>.</span>\n    <span>// 生成 Layer 对象</span>\n    <span>*</span>outLayer <span>=</span> <span>new</span> <span>Layer</span><span>(</span><span>this</span><span>,</span> client<span>,</span> name<span>,</span> w<span>,</span> h<span>,</span> flags<span>)</span><span>;</span> \n    <span>// 为 Layer 设置缓冲区</span>\n    status_t err <span>=</span> <span>(</span><span>*</span>outLayer<span>)</span><span>-></span><span>setBuffers</span><span>(</span>w<span>,</span> h<span>,</span> format<span>,</span> flags<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>err <span>==</span> NO_ERROR<span>)</span> <span>{</span>\n        <span>*</span>handle <span>=</span> <span>(</span><span>*</span>outLayer<span>)</span><span>-></span><span>getHandle</span><span>(</span><span>)</span><span>;</span> <span>// handle 是通过这个函数获取的，后面我们再分析</span>\n        <span>*</span>gbp <span>=</span> <span>(</span><span>*</span>outLayer<span>)</span><span>-></span><span>getBufferQueue</span><span>(</span><span>)</span><span>;</span> <span>// gbp 是从 Layer 中取出来的</span>\n    <span>}</span>\n    <span>ALOGE_IF</span><span>(</span>err<span>,</span> <span>\"createNormalLayer() failed (%s)\"</span><span>,</span> <span>strerror</span><span>(</span><span>-</span>err<span>)</span><span>)</span><span>;</span>\n    <span>return</span> err<span>;</span>\n<span>}</span>\n</code></pre></div><blockquote>\n<p>注意：</p>\n<p>高版本中，创建 <code>Layer</code> 对象的过程有所不同：</p>\n<div><pre><code><span>/* frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp */</span>\nstatus_t <span>SurfaceFlinger</span><span>::</span><span>createBufferStateLayer</span><span>(</span>\n                LayerCreationArgs<span>&amp;</span> args<span>,</span> sp<span>&lt;</span>IBinder<span>></span><span>*</span> handle<span>,</span> sp<span>&lt;</span>Layer<span>></span><span>*</span> outLayer<span>)</span> <span>{</span>\n    <span>*</span>outLayer <span>=</span> <span>getFactory</span><span>(</span><span>)</span><span>.</span><span>createBufferStateLayer</span><span>(</span>args<span>)</span><span>;</span>\n    <span>*</span>handle <span>=</span> <span>(</span><span>*</span>outLayer<span>)</span><span>-></span><span>getHandle</span><span>(</span><span>)</span><span>;</span>\n    <span>return</span> NO_ERROR<span>;</span>\n<span>}</span>\n\n<span>/* frameworks/native/services/surfaceflinger/SurfaceFlingerDefaultFactory.cpp */</span>\nsp<span>&lt;</span>Layer<span>></span> <span>DefaultFactory</span><span>::</span><span>createBufferStateLayer</span><span>(</span><span>const</span> LayerCreationArgs<span>&amp;</span> args<span>)</span> <span>{</span>\n    <span>// 调用构造函数 Layer::Layer(const surfaceflinger::LayerCreationArgs&amp; args) 创建 Layer 对象</span>\n    <span>return</span> <span>sp</span><span>&lt;</span>Layer<span>></span><span>::</span><span>make</span><span>(</span>args<span>)</span><span>;</span> \n<span>}</span>\n\n<span>/* frameworks/native/services/surfaceflinger/Layer.cpp */</span>\n<span>void</span> <span>Layer</span><span>::</span><span>onFirstRef</span><span>(</span><span>)</span> <span>{</span>\n    mFlinger<span>-></span><span>onLayerFirstRef</span><span>(</span><span>this</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>/* frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp */</span>\n<span>void</span> <span>SurfaceFlinger</span><span>::</span><span>onLayerFirstRef</span><span>(</span>Layer<span>*</span> layer<span>)</span> <span>{</span>\n    mNumLayers<span>++</span><span>;</span>\n    <span>if</span> <span>(</span><span>!</span>layer<span>-></span><span>isRemovedFromCurrentState</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n        mScheduler<span>-></span><span>registerLayer</span><span>(</span>layer<span>)</span><span>;</span> <span>// 注意：高版本中，会把 Layer 注册到 Scheduler 中</span>\n    <span>}</span>\n<span>}</span>\n</code></pre></div><p>并且，高版本中的 <code>Layer</code> 也没有提供 <code>Layer::getBufferQueue()</code> 函数了，只提供了 <code>Layer::getBuffer()</code> 函数</p>\n<div><pre><code><span>/* frameworks/native/services/surfaceflinger/Layer.h */</span>\n<span>class</span> <span>Layer</span> <span>:</span> <span><span>public</span> <span>virtual</span> <span>RefBase</span></span> \n<span>{</span>\n    sp<span>&lt;</span>GraphicBuffer<span>></span> <span>getBuffer</span><span>(</span><span>)</span> <span>const</span><span>;</span>\n</code></pre></div></blockquote>\n<p><code>SurfaceFlinger::createNormalLayer</code> 这个函数的逻辑很简单：</p>\n<div><pre><code>新建 Layer 对象，\n设置 Buffers 的属性（setBuffers），\n然后分别通过 getHandle 和 getBufferQueue 获得 handle 及 gbp。\n</code></pre></div><p>先来看看 <code>handle</code> 到底是何方 “神圣”：</p>\n<div><pre><code><span>/* frameworks/native/services/surfaceflinger/Layer.cpp */</span>\nsp<span>&lt;</span>IBinder<span>></span> <span>Layer</span><span>::</span><span>getHandle</span><span>(</span><span>)</span> <span>{</span>\n    Mutex<span>::</span>Autolock <span>_l</span><span>(</span>mLock<span>)</span><span>;</span>\n    <span>.</span><span>.</span>\n    <span>class</span> <span>Handle</span> <span>:</span> <span><span>public</span> <span>BBinder</span><span>,</span> <span>public</span> <span>LayerCleaner</span></span> <span>{</span> <span>// Handle “真身” 在这里</span>\n    wp<span>&lt;</span><span>const</span> Layer<span>></span> mOwner<span>;</span>\n    <span>public</span><span>:</span>\n        <span>Handle</span><span>(</span><span>const</span> sp<span>&lt;</span>SurfaceFlinger<span>></span><span>&amp;</span> flinger<span>,</span> <span>const</span> sp<span>&lt;</span>Layer<span>></span><span>&amp;</span> layer<span>)</span>\n            <span>:</span> <span>LayerCleaner</span><span>(</span>flinger<span>,</span> layer<span>)</span><span>,</span> <span>mOwner</span><span>(</span>layer<span>)</span> <span>{</span> <span>// 空的，什么都没有</span>\n        <span>}</span>\n    <span>}</span><span>;</span>\n    <span>return</span> <span>new</span> <span>Handle</span><span>(</span>mFlinger<span>,</span> <span>this</span><span>)</span><span>;</span> <span>// 新建一个 Handle 对象</span>\n<span>}</span>\n</code></pre></div><p>由这段代码可以看出，<code>Handle</code> 几乎没有任何有用的内容。那么，其设计初衷是什么？</p>\n<p>仔细观察可以发现，<code>Handle</code> 继承了 <code>LayerCleaner</code>。从字面意思来看，它是 “图层清理者”，清理时机如下所示：</p>\n<div><pre><code>Layer<span>::</span>LayerCleaner<span>::</span>～<span>LayerCleaner</span><span>(</span><span>)</span> <span>{</span>\n    <span>// destroy client resources</span>\n    mFlinger<span>-></span><span>onLayerDestroyed</span><span>(</span>mLayer<span>)</span><span>;</span>\n<span>}</span>\n</code></pre></div><p>也就是说，当 LayerCleaner（或者 Handle）进行析构操作时，会去主动调用 SurfaceFlinger 的 onLayerDestroyed 来收拾 “图层残局”。换句话说，一旦没有人引用此Handle对象，系统就会开始清理工作。</p>\n<p>了解了 Handle 后，我们再来分析 Layer 中的另一个重要元素，即 BufferQueue：</p>\n<div><pre><code><span>/* frameworks/native/services/surfaceflinger/Layer.cpp */</span>\nsp<span>&lt;</span>BufferQueue<span>></span> <span>Layer</span><span>::</span><span>getBufferQueue</span><span>(</span><span>)</span> <span>const</span> <span>{</span>\n    <span>return</span> mSurfaceFlingerConsumer<span>-></span><span>getBufferQueue</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre></div><p><code>SurfaceFlinger</code> 自认为是 “<code>Consumer</code>” 还是比较贴切的。而这个消费者的另一个职责居然是提供 <code>Buffer</code> 空间，真是 “一条龙服务”。</p>\n<p>我们可以来看看 <code>SurfaceFlinger</code> 是如何提供的 <code>BufferQueue</code>，其中又涉及多个类的继承，如下图所示。</p>\n<p><img src=\"@source/lango-tech/subject/images/surfaceflinger/10.png\" alt=\"\" loading=\"lazy\"></p>\n<p>从图中可以看到，<code>SurfaceFlingerConsumer</code> 中真正持有 <code>BufferQueue</code> 对象的是成员变量 <code>ConsumerBase::mBufferQueu</code>e，那么这个变量又是怎么赋值的呢？其实还是在 <code>Layer</code> 中，即当有人第一次引用 <code>Layer</code> 时触发了它的 <code>onFirstRef</code>。此时：</p>\n<div><pre><code><span>void</span> <span>Layer</span><span>::</span><span>onFirstRef</span><span>(</span><span>)</span>\n<span>{</span>\n    sp<span>&lt;</span>BufferQueue<span>></span> bq <span>=</span> <span>new</span> <span>SurfaceTextureLayer</span><span>(</span>mFlinger<span>)</span><span>;</span>\n    mSurfaceFlingerConsumer <span>=</span> <span>new</span> <span>SurfaceFlingerConsumer</span><span>(</span>mTextureName<span>,</span> <span>true</span><span>,</span> GL_TEXTURE_EXTERNAL_OES<span>,</span> <span>false</span><span>,</span> bq<span>)</span><span>;</span>\n</code></pre></div><p>这样就基本清楚了：</p>\n<div><pre><code>Layer 中直接或者间接地提供了 Handle 和 BufferQueue，而且两者都是匿名的 Binder Server。\n当客户端应用程序调用 createSurface 时，它可以同时获取到这两个重要对象。\n大家一定要记住，IGraphicBufferProducer 的 Server 端的实现是 BufferQueue。由于命名上的差异，这点很容易搞错。\n\n因而应用程序与 BufferQueue 的关系就比较明朗了。\n虽然中间经历了多次跨进程通信，但对于应用程序来说最终只使用到了 BufferQueue（通过 IGraphicBufferProducer）。\n</code></pre></div><p>本小节可以从侧面证明如下几个关键点：</p>\n<ol>\n<li>\n<p>应用程序可以调用 <code>createSurface</code> 来建立多个 <code>Layer</code>，它们是一对多的关系。</p>\n<div><pre><code>理由就是 createSurface 中没有任何机制来限制应用程序的多次调用；\n相反，它会对一个应用程序多次申请而产生的 Layer 进行统一管理。如下所示：\n</code></pre></div><div><pre><code>status_t <span>SurfaceFlinger</span><span>::</span><span>createLayer</span><span>(</span><span>.</span><span>.</span><span>.</span><span>)</span>\n<span>{</span>\n    <span>.</span><span>.</span><span>.</span>\n    <span>if</span> <span>(</span>result <span>==</span> NO_ERROR<span>)</span> <span>{</span>    \n        <span>addClientLayer</span><span>(</span>client<span>,</span> <span>*</span>handle<span>,</span> <span>*</span>gbp<span>,</span> layer<span>)</span><span>;</span> <span>// 添加新增的 Layer 到全局管理中</span>\n        <span>setTransactionFlags</span><span>(</span>eTransactionNeeded<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre></div><div><pre><code>为应用程序申请的 Layer，一方面需要告知 SurfaceFlinger，另一方面要记录到各 Client 内部中。\n这两个步骤是由 addClientLayer() 分别调用 Client::attachLayer() 和 SurfaceFlinger::addLayer_l() 来完成的：\n</code></pre></div><div><pre><code><span>void</span> <span>SurfaceFlinger</span><span>::</span><span>addClientLayer</span><span>(</span><span>const</span> sp<span>&lt;</span>Client<span>></span><span>&amp;</span> client<span>,</span><span>const</span> sp<span>&lt;</span>IBinder<span>></span><span>&amp;</span> handle<span>,</span>\n        <span>const</span> sp<span>&lt;</span>IGraphicBufferProducer<span>></span><span>&amp;</span> gbc<span>,</span><span>const</span> sp<span>&lt;</span>Layer<span>></span><span>&amp;</span> lbc<span>)</span>\n<span>{</span>\n    <span>// attach this layer to the client</span>\n    client<span>-></span><span>attachLayer</span><span>(</span>handle<span>,</span> lbc<span>)</span><span>;</span> <span>// 让此 Layer 与 Client 相关联</span>\n\n    <span>// add this layer to the current state list</span>\n    Mutex<span>::</span>Autolock <span>_l</span><span>(</span>mStateLock<span>)</span><span>;</span>\n    mCurrentState<span>.</span>layersSortedByZ<span>.</span><span>add</span><span>(</span>lbc<span>)</span><span>;</span> <span>// 将 Layer 按顺序添加到全局变量中</span>\n    mGraphicBufferProducerList<span>.</span><span>add</span><span>(</span>gbc<span>-></span><span>asBinder</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// 将 gbc 也添加到全局变量中</span>\n<span>}</span>\n</code></pre></div><div><pre><code>对于 SurfaceFlinger，它需要对系统中当前所有的 Layer 进行 Z-Order 排序，以决定用户所能看到的 “画面” 是什么样的；\n对于 Client，它则利用内部的 mLayers 成员变量来逐一记录新增（attachLayer）和移除（detachLayer）的图层。\n从中不难看出，一个 Client 是可以包含多个 Layer 的。\n</code></pre></div></li>\n<li>\n<p>每个 <code>Layer</code> 对应一个 <code>BufferQueue</code>。换句话说，一个应用程序可能对应多个 <code>BufferQueue</code>。另外，<code>Layer</code> 没有直接持有 <code>BufferQueue</code> 对象，而是由其内部的 <code>mSurfaceFlingerConsumer</code> 来管理。</p>\n</li>\n</ol>\n<h2 id=\"_6-surfaceflinger\" tabindex=\"-1\"> 6 <code>SurfaceFlinger</code></h2>\n<p>从本小节开始，我们正式切入 <code>SurfaceFlinger</code> 的分析。</p>\n<p>为了保持讲解的连贯性，部分内容可能在前面的章节中已经有所涉及，接下来将会对其中的细节做更多的扩展讲解。</p>\n<p>内容组织如下：</p>\n<div><pre><code>1. 首先介绍从 Android 4.1 版本起引入的一个新特性（Project Butter）。\n    理解这个项目是必要的，可以说 SurfaceFlinger 有很大一部分内容就是围绕它展开的。\n2. SurfaceFlinger 的启动过程及工作方式。\n3. SurfaceFlinger 与 BufferQueue 及应用程序间的关系。\n4. SurfaceFlinger 对 VSYNC 信号的处理过程（重点）。\n</code></pre></div><h3 id=\"_6-1-黄油计划-project-butter\" tabindex=\"-1\"> 6.1 “黄油计划”（<code>Project Butter</code>）</h3>\n<p>为什么会叫这个名字呢？</p>\n<div><pre><code>一个可能的原因就是这个 Project 的目的是改善用户抱怨最多的 Android 几大缺陷之一，即 UI 响应速度。\nGoogle 希望这一新计划可以让 Android 系统摆脱 “UI交互” 上的 “滞后” 感，而能像加了黄油一般 “顺滑”。\n</code></pre></div><p><code>Google</code> 在 2012 年的 <code>I/O</code> 大会上宣布了这一计划，并在 <code>Android 4.1</code> 中正式搭载了具体的实现机制。</p>\n<p>“黄油计划” 中有两个重要的组成部分，即 <strong><code>VSync</code> 和 <code>Triple Buffering</code></strong>。下面先分别介绍引入它们的原因。</p>\n<p>当我们玩游戏或者看电影时，可能经常遇到以下情形。</p>\n<div><pre><code>某些游戏场面好像由几个场景 “拼凑” 而成。\n电影画面不连贯，好像被 “割裂” 了。\n</code></pre></div><p>这样描述有点抽象，我们引用 <code>wikipedia</code> 上的一张图来看下实际效果，如下图所示。</p>\n<p><img src=\"@source/lango-tech/subject/images/surfaceflinger/11.png\" alt=\"\" loading=\"lazy\"></p>\n<p>以时间为横坐标来描述接下来会发生的事情，如下图所示。</p>\n<p><img src=\"@source/lango-tech/subject/images/surfaceflinger/12.png\" alt=\"\" loading=\"lazy\"></p>\n<p>上半部分的方框表示在不同的时间点时显示屏的内容（加深的部分），下半部分则是同一时间点时 <code>Frame Buffer</code> 中的数据状态，编号表示第几个 <code>frame</code> 帧，不考虑清屏。</p>\n<div><pre><code>0.01秒\n    由于两者速率相差不少，此时buffer中已经准备好了第 1 帧数据，而显示器只显示了第 1 帧画面的 2/3。\n\n0.015秒\n    第 1 帧画面在显示屏上终于完整地显示了出来，而此时 buffer 中有 1/3 的部分已经被填充上第 2 帧数据了。\n\n0.02秒\n    Buffer 中已经准备好了第 2 帧数据，而显示屏出现了 Screen Tearing，\n    即：有三分之一的内容属于第 2 帧，其余的则来源于第 1 帧画面。\n</code></pre></div><p>在单缓冲区的情况下，这个问题是很难规避的。所以之前我们介绍的双缓冲技术（），其基本原理就是采用了两块 <code>buffer</code>：</p>\n<div><pre><code>一块 Back Buffer 用于 CPU/GPU 后台绘制，\n一块 Frame Buffer 用于屏幕显示；\n</code></pre></div><p>当 <code>Back Buffer</code> 准备就绪后，它们才进行交换。</p>\n<p>不可否认，双缓冲技术（<code>Double Buffering</code>）可以在很大程度上降低 <code>Screen Tearing</code> 类型的错误，但它是万能的吗？</p>\n<p><strong>一个需要考虑的问题是：我们应该每隔多少时间点进行两个缓冲区的交换呢？</strong></p>\n<div><pre><code>假如是 Back Buffer 准备完成一帧数据以后就进行，那么如果此时屏幕还没有完整显示上一帧内容，肯定是会出问题的。\n看来只能等到屏幕处理完一帧数据后，才可以执行这一操作。\n</code></pre></div><p>一个典型的显示器有两个重要特性，即 “行频和场频”。</p>\n<div><pre><code>行频（Horizontal Scanning Frequency）又称为 “水平扫描频率”，是屏幕每秒钟从左至右扫描的次数；\n场频（Vertical Scanning Frequency）也称为 “垂直扫描频率”，是每秒钟整个屏幕刷新的次数。\n\n由此也可以得出它们的关系：行频 = 场频 * 纵坐标分辨率\n</code></pre></div><p>当扫描完一个屏幕后，设备需要重新回到第一行以进入下一轮的循环，此时有一段时间空隙，称为 <code>Vertical Blanking Interval</code>（<code>VBI</code>）。</p>\n<p>这个时间点就是我们进行缓冲区交换的最佳时间。因为此时屏幕没有在刷新，也就避免了交换过程中出现 <code>Screen Tearing</code> 的状况。</p>\n<p><code>Vsync</code>（垂直同步）是 <code>Vertical Synchronization</code> 的简写，它利用 <code>VBI</code> 时期出现的 <code>Vertical Sync Pulse</code> 来保证双缓冲能在最佳时间点进行交换。</p>\n<blockquote>\n<p>所以说 <code>VSync</code> 这个概念并不是 <code>Google</code> 首创的，而是在早些年前的 <code>PC</code> 领域就已经出现了。不过 <code>Android 4.1</code> 赋予了它新的功用，稍后就可以看到。</p>\n</blockquote>\n<p>上面我们讨论的情况其实是基于一个假设，即 “绘图速度大于显示速度”，那么当 “绘图速度小于显示速度” 呢？</p>\n<p>先来分析绘图过程中当 “绘图速度小于显示速度”，且没有采用 <code>VSync</code> 同步时的情况，如下图所示。</p>\n<p><img src=\"@source/lango-tech/subject/images/surfaceflinger/13.png\" alt=\"\" loading=\"lazy\"></p>\n<p>上图中有 3 个元素：</p>\n<div><pre><code>Display 表示显示屏幕，\nGPU 和 CPU 负责渲染帧数据。每一帧以方框表示并以数字进行编号，如 0、1、2 等。\nVSync 用于指导双缓冲区的交换。\n</code></pre></div><p>以时间的顺序来看看当不采用 <code>VSync</code> 同步时将会发生什么异常。</p>\n<div><pre><code>Step1. \n    Display 显示第 0 帧数据，此时 CPU 和 GPU 渲染第 1 帧画面，而且赶在 Display 显示下一帧（帧1）前完成。\nStep2. \n    因为渲染及时，Display 在第 0 帧显示完成后，也就是第 1 个 VSync 后，正常显示第 1 帧。\nStep3. \n    由于某些原因（比如 CPU 资源被占用），系统没能及时地处理第 2 帧，而是等到第 2 个 VSync 到来前才开始处理。\nStep4. \n    第 2 个 VSync 来临时，由于第 2 帧数据还没有准备就绪，实际显示的还是第 1 帧的内容。\n    这种情况被 Android 开发组命名为 “Jank”。\nStep5. \n    当第 2 帧数据准备完成后，它并不会立即被显示，而是要等待下一个 VSync。\n</code></pre></div><p>所以总的来说，就是屏幕 “平白无故” 地重复显示了一次第 1 帧。</p>\n<p>原因大家应该都看到了，就是 <code>CPU</code> 没有及时地着手处理第 2 帧的渲染工作，以致 “延误军机”。</p>\n<p><code>Android</code> 系统中一直存在着这个问题，直到 “黄油计划” 的引入。</p>\n<p>从 <code>Android 4.1 Jelly Bean</code> 开始，<code>VSync</code> 得到了进一步的应用，即：系统在收到 <code>VSync Pulse</code> 后，将立即开始下一帧的渲染，如下图所示。</p>\n<p><img src=\"@source/lango-tech/subject/images/surfaceflinger/14.png\" alt=\"\" loading=\"lazy\"></p>\n<p>上图中展示的是采用 <code>VSync</code> 进行显示同步的情况。</p>\n<div><pre><code>一旦 VSync 信号出现，CPU 便不再犹豫，即刻开始执行 Buffer 的准备工作。\n大部分的 Android 显示设备刷新频率是 60Hz，这也就意味着每一帧最多只能留给系统 1/60=16ms 左右的准备时间。\n假如 CPU/GPU 的 FPS（Frames Per Second）高于这个值，那么这个方案是完美的，显示效果将很好。\n</code></pre></div><p>可是我们没有办法保证所有设备的硬件配置都能达到要求。假如 <code>CPU/GPU</code> 的性能无法满足上图条件（即：<code>FPS</code> 低于屏幕刷新率），又会是什么情况呢？</p>\n<p>在分析这一问题之前，我们先来看看采用 <code>VSync</code> 和双缓冲机制的情况，如下图所示。</p>\n<p><img src=\"@source/lango-tech/subject/images/surfaceflinger/15.png\" alt=\"\" loading=\"lazy\"></p>\n<p>图中采用了双缓冲技术以及前面介绍的 <code>VSync</code> 同步机制，可以看到整个显示过程还是相当不错的。虽然 <code>CPU/GPU</code> 处理所用的时间时短时长，但总的来说都在 <code>16ms</code> 以内，因而不影响显示效果。</p>\n<blockquote>\n<p><code>A</code> 和 <code>B</code> 分别代表两个缓冲区，它们不断地互相交换以保证画面的正确显示。</p>\n</blockquote>\n<p>现在我们可以继续分析 <code>FPS</code> 低于屏幕刷新率的情况了，如下图所示。</p>\n<p><img src=\"@source/lango-tech/subject/images/surfaceflinger/16.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>如果 CPU/GPU 的处理时间超过 16ms，那么第一个 VSync 到来时，缓冲区 B 中的数据还没有准备好，就只能继续显示之前 A 缓冲区中的内容。\n而 B 完成后，又因为缺乏 VSync Pulse 信号，也只能等到下一轮才有机会交换了。\n于是在这一过程中，有一大段时间是被浪费的。\n当下一个 VSync 出现时，CPU/GPU 马上执行操作，此时它可操作的 Buffer 是 A，相应的显示屏对应的就是 B。这时看起来就是正常的。\n只不过由于执行时间仍然超过 16ms，导致下一次应该执行的缓冲区交换又被推迟。\n如此循环反复，便出现了越来越多的 “Jank”。\n</code></pre></div><p>那么，有没有规避的办法呢？</p>\n<div><pre><code>很显然，第一次的 Jank 看起来是没有办法的，除非升级硬件配置来加快 FPS。\n我们关注的重点是被 CPU/GPU 浪费的时间段怎么才能充分利用起来。\n分析上述过程，造成 CPU/GPU 无事可做的假象是因为当前已经没有可用的 buffer 了。\n</code></pre></div><p>换句话说，如果增加一个 <code>Buffer</code>，情况会不会好转呢？如下图所示。</p>\n<p><img src=\"@source/lango-tech/subject/images/surfaceflinger/17.png\" alt=\"\" loading=\"lazy\"></p>\n<p><code>Triple Buffering</code> 是 <code>Multiple Buffering</code> 的一种，指的是系统使用 3 个缓冲区用于显示工作。</p>\n<p>我们逐步分析下这个新机制是否有效。</p>\n<div><pre><code>首先和预料中的一致，第一次 “Jank” 无可厚非。\n不过当第一次 VSync 发生后，CPU 不用再等待了，它会使用第三个 Buffer C 来进行下一帧数据的准备工作。\n虽然对缓冲区 C 的处理所需时间同样超过了 16ms，但这并不影响最终的显示，因为第二次 VSync 到来后，它选择 Buffer B 进行显示；\n而到了第三次 VSync 时，它会接着采用 C，而不是像 Double Buffering 中所看到的只能再显示一遍 B。\n这样就有效地降低了系统显示错误的概率。\n</code></pre></div><blockquote>\n<p>前面小节我们看到 <code>BufferQueue</code> 中最多有 32 个 <code>BufferSlot</code>，不过在实际使用时的具体值是可以设置的。</p>\n</blockquote>\n<p><code>TARGET_DISABLE_TRIPLE_BUFFERING</code> 这个宏用于<code> Disable Triple Buffering</code>。如果宏打开的话，<code>Layer.cpp</code> 在 <code>onFirstRef</code> 有如下操作。</p>\n<div><pre><code><span><span>#</span><span>ifdef</span> <span>TARGET_DISABLE_TRIPLE_BUFFERING</span></span>\n<span><span>#</span><span>warning</span> <span>\"disabling triple buffering\"</span></span>\n    mSurfaceFlingerConsumer<span>-></span><span>setDefaultMaxBufferCount</span><span>(</span><span>2</span><span>)</span><span>;</span>\n<span><span>#</span><span>else</span></span>\n    mSurfaceFlingerConsumer<span>-></span><span>setDefaultMaxBufferCount</span><span>(</span><span>3</span><span>)</span><span>;</span>\n<span><span>#</span><span>endif</span></span>\n</code></pre></div><p><code>mSurfaceFlingerConsumer::setDefaultMaxBufferCount</code> 将进一步调用 <code>BufferQueue::setDefaultMaxBufferCount</code>，然后把 <code>Buffer</code> 数（2 或者 3）保存到 <code>BufferQueue</code> 内部的 <code>mDefaultMaxBufferCount</code> 成员变量中。</p>\n<p>对于应用程序来说，它也可以通过 <code>IGraphicBufferProducer::setBufferCount</code> 来告诉 <code>BufferQueue</code> 它所希望的 <code>Slot</code> 值，这个操作最终影响的是 <code>BufferQueue</code> 中的另一个成员变量 <code>mOverrideMaxBufferCount</code>（而不是 <code>mDefaultMaxBufferCount</code>）。默认情况下这个变量是 0，表示应用端不关心到底有多少 <code>Buffer</code> 可用。</p>\n<p>在具体的实现中，以上两个变量都是要考虑到的，<code>BufferQueue</code> 会通过权衡各个值来选择最佳的解决方案。</p>\n<h3 id=\"_6-2-surfaceflinger-的启动\" tabindex=\"-1\"> 6.2 <code>SurfaceFlinger</code> 的启动</h3>\n<p><code>SurfaceFlinger</code> 的启动和 <code>ServiceManager</code> 有点类似，它们都属于系统的底层支撑服务，因而必须在设备开机的早期就运行起来：</p>\n<div><pre><code><span>/*frameworks/base/cmds/system_server/library/System_init.cpp*/</span>\n<span>extern</span> <span>\"C\"</span> status_t <span>system_init</span><span>(</span><span>)</span>\n<span>{</span>\n    <span>.</span><span>.</span><span>.</span>    \n    <span>property_get</span><span>(</span><span>\"system_init.startsurfaceflinger\"</span><span>,</span> propBuf<span>,</span> <span>\"1\"</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span><span>strcmp</span><span>(</span>propBuf<span>,</span> <span>\"1\"</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>\n        <span>SurfaceFlinger</span><span>::</span><span>instantiate</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n<span>.</span><span>.</span><span>.</span>\n</code></pre></div><p>这个 <code>System_init.cpp</code> 会被编译到 <code>libsystem_server</code> 库中，然后由 <code>SystemServer</code> 在 <code>JNI</code> 层进行加载调用，从而启动包括 <code>SurfaceFlinger</code>，<code>SensorService</code> 等在内的系统服务。</p>\n<blockquote>\n<p>高版本中的启动入口已所有不同，后续再更新。</p>\n</blockquote>\n<p><code>system_init</code> 调用 <code>instantiate</code> 来创建一个 <code>Binder Server</code>，名称为 <code>&quot;SurfaceFlinger&quot;</code>；而且强指针的特性让它在第一次被引用时触发了 <code>onFirstRef</code>：</p>\n<div><pre><code><span>void</span> <span>SurfaceFlinger</span><span>::</span><span>onFirstRef</span><span>(</span><span>)</span>\n<span>{</span>\n    mEventQueue<span>.</span><span>init</span><span>(</span><span>this</span><span>)</span><span>;</span><span>//初始化事件队列</span>\n    <span>run</span><span>(</span><span>\"SurfaceFlinger\"</span><span>,</span> PRIORITY_URGENT_DISPLAY<span>)</span><span>;</span><span>//启动一个新的业务线程</span>\n    mReadyToRunBarrier<span>.</span><span>wait</span><span>(</span><span>)</span><span>;</span><span>//等待新线程启动完毕</span>\n<span>}</span>\n</code></pre></div><p>成员变量 <code>mEventQueue</code> 是一个 <code>MessageQueue</code> 类型的对象。既然有消息队列，那就一定会有配套的事件处理器 <code>Handler</code> 以及循环体 <code>Looper</code>，这些是在 <code>MessageQueue::init</code> 函数中创建的。即：</p>\n<blockquote>\n<p>虽然 <code>Java</code> 层的消息循环机制与 <code>SurfaceFlinger</code> 中用到的有一定差异，但其本质原理是一样的。</p>\n</blockquote>\n<div><pre><code><span>/*frameworks/native/services/surfaceflinger/MessageQueue.cpp*/</span>\n<span>void</span> <span>MessageQueue</span><span>::</span><span>init</span><span>(</span><span>const</span> sp<span>&lt;</span>SurfaceFlinger<span>></span><span>&amp;</span> flinger<span>)</span>\n<span>{</span>\n    mFlinger <span>=</span> flinger<span>;</span>\n    mLooper <span>=</span> <span>new</span> <span>Looper</span><span>(</span><span>true</span><span>)</span><span>;</span>\n    mHandler <span>=</span> <span>new</span> <span>Handler</span><span>(</span><span>*</span><span>this</span><span>)</span><span>;</span><span>//此Handler类是SurfaceFlinger自己定义的，后面有讲解</span>\n<span>}</span>\n</code></pre></div><blockquote>\n<p>高版本中的差异：</p>\n<div><pre><code><span>/* frameworks/native/services/surfaceflinger/Scheduler/MessageQueue.cpp */</span>\n<span>MessageQueue</span><span>::</span><span>MessageQueue</span><span>(</span>ICompositor<span>&amp;</span> compositor<span>,</span> sp<span>&lt;</span>Handler<span>></span> handler<span>)</span>\n      <span>:</span> <span>mCompositor</span><span>(</span>compositor<span>)</span><span>,</span>\n        <span>mLooper</span><span>(</span><span>sp</span><span>&lt;</span>Looper<span>></span><span>::</span><span>make</span><span>(</span>kAllowNonCallbacks<span>)</span><span>)</span><span>,</span>\n        <span>mHandler</span><span>(</span>std<span>::</span><span>move</span><span>(</span>handler<span>)</span><span>)</span> <span>{</span><span>}</span>\n</code></pre></div></blockquote>\n<p>也就是说，这个 <code>MessageQueue</code> 类不但提供了消息队列，其内部还囊括了消息的处理机制。</p>\n<p>那么，这个 <code>Looper</code> 会在什么时候运行起来呢？\n显然 <code>SurfaceFlinger</code> 需要先自行创建一个新的线程来承载这一 “业务”，否则就会阻塞 <code>SystemServer</code> 的主线程。</p>\n<p><code>SurfaceFlinger::onFirstRef</code> 函数最后的 <code>mReadyToRunBarrier.wait()</code> 也可以证明这一点，即：<code>mReadyToRunBarrier</code> 在等待一个事件，在事件没有发生前其所在的线程就会处于等待状态。</p>\n<blockquote>\n<p>这是 <code>Android</code> 系统里两个线程间的一种典型交互方式。</p>\n</blockquote>\n<p>由此可见，<code>SurfaceFlinger</code> 新启动的这个线程中一定还会调用 <code>mReadyToRunBarrier.open</code> 来为等待它的线程解禁。</p>\n<p>这样我们也能推断出 <code>SurfaceFlinger</code> 一定是继承自 <code>Thread</code> 线程类的。如下所示：</p>\n<div><pre><code><span>class</span> <span>SurfaceFlinger</span> <span>:</span><span>public</span> BinderService<span>&lt;</span>SurfaceFlinger<span>></span><span>,</span>\n    <span>.</span><span>.</span><span>.</span>\n    <span>private</span> Thread<span>,</span>\n</code></pre></div><blockquote>\n<p>高版本中 <code>SurfaceFlinger</code> 不在继承 <code>Thread</code> 了，后续会更新对高版本的分析。</p>\n</blockquote>\n<p>所以上面 <code>SurfaceFlinger::onFirstRef</code> 函数中可以调用 <code>Thread::run()</code> 方法来启动一个名为 <code>&quot;SurfaceFlinger&quot;</code> 的线程，并为其设置 <code>PRIORITY_URGENT_DISPLAY</code> 的优先级。这个优先级是在 <code>ThreadDefs.h</code> 中定义的，如下表所示。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>Priority</strong></th>\n<th style=\"text-align:left\"><strong>Value</strong></th>\n<th style=\"text-align:left\"><strong>Description</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>ANDROID_PRIORITY_LOWEST</code></td>\n<td style=\"text-align:left\">19</td>\n<td style=\"text-align:left\">最低优先级</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>ANDROID_PRIORITY_BACKGROUND</code></td>\n<td style=\"text-align:left\">10</td>\n<td style=\"text-align:left\">用于 <code>Background Tasks</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>ANDROID_PRIORITY_NORMAL</code></td>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">大部分线程都以这个优先级运行</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>ANDROID_PRIORITY_FOREGROUND</code></td>\n<td style=\"text-align:left\">-2</td>\n<td style=\"text-align:left\">用户正在交互线程的优先级</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>ANDROID_PRIORITY_DISPLAY</code></td>\n<td style=\"text-align:left\">-4</td>\n<td style=\"text-align:left\">UI 主线程优先级</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>ANDROID_PRIORITY_URGENT_DISPLAY</code></td>\n<td style=\"text-align:left\">-8</td>\n<td style=\"text-align:left\">这个值由 <code>HAL_PRIORITY_URGENT_DISPLAY</code> 来指定，当前版本中是 -8。只在部分紧急状态下使用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>ANDROID_PRIORITY_AUDIO</code></td>\n<td style=\"text-align:left\">-16</td>\n<td style=\"text-align:left\">正常情况下的声音线程优先级</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>ANDROID_PRIORITY_URGENT_AUDIO</code></td>\n<td style=\"text-align:left\">-19</td>\n<td style=\"text-align:left\">紧急声音线程优先级（通常情况下不使用）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>ANDROID_PRIORITY_HIGHEST</code></td>\n<td style=\"text-align:left\">-20</td>\n<td style=\"text-align:left\">最高优先级，禁止使用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>ANDROID_PRIORITY_DEFAULT</code></td>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">默认情况下就是 ANDROID_PRIORITY_NORMAL</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>ANDROID_PRIORITY_MORE_FAVORABLE</code></td>\n<td style=\"text-align:left\">-1</td>\n<td style=\"text-align:left\">在上述各优先级定义的基础上，用于适当微调（加大）优先级</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>ANDROID_PRIORITY_LESS_FAVORABLE</code></td>\n<td style=\"text-align:left\">+1</td>\n<td style=\"text-align:left\">在上述各优先级定义的基础上，用于适当微调（减小）优先级</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>数值越大的，优先级越小。</p>\n<p>因为各等级间的数值并不是连续的，</p>\n<p>所以我们还可以通过表中最后的 <code>ANDROID_PRIORITY_MORE_FAVORABLE</code>(-1) 来适当地提高优先级；</p>\n<p>或者利用 <code>ANDROID_PRIORITY_LESS_FAVORABLE</code>(+1) 来降低优先级。</p>\n</blockquote>\n<div><pre><code>由此可见，SurfaceFlinger 工作线程所采用的优先级相对较高。\n因为屏幕 UI 显示无疑是人机交互中与用户体验关联最直接的，任何滞后的响应速度都将大大降低产品的吸引力。\n</code></pre></div><p>在执行了 <code>Thread::run()</code> 以后，<code>Thread</code> 会自动调用 <code>Thread::threadLoop()</code> 接口。即：</p>\n<div><pre><code><span>bool</span> <span>SurfaceFlinger</span><span>::</span><span>threadLoop</span><span>(</span><span>)</span>\n<span>{</span>\n    <span>waitForEvent</span><span>(</span><span>)</span><span>;</span>\n    <span>return</span> <span>true</span><span>;</span>\n<span>}</span>\n</code></pre></div><p>其中<code> waitForEvent()</code> 是 <code>SurfaceFlinger</code> 中的成员函数，它会进一步调用 <code>mEventQueue.waitMessage()</code>：</p>\n<div><pre><code><span>/* \n    此函数在高版本中未发生变化，只是 MessageQueue 文件的路径发生了变化：\n    frameworks/native/services/surfaceflinger/Scheduler/MessageQueue.cpp\n*/</span>\n<span>void</span> <span>MessageQueue</span><span>::</span><span>waitMessage</span><span>(</span><span>)</span> <span>{</span>\n    <span>do</span> <span>{</span>\n        <span>IPCThreadState</span><span>::</span><span>self</span><span>(</span><span>)</span><span>-></span><span>flushCommands</span><span>(</span><span>)</span><span>;</span>\n        <span>int32_t</span> ret <span>=</span> mLooper<span>-></span><span>pollOnce</span><span>(</span><span>-</span><span>1</span><span>)</span><span>;</span>\n        <span>switch</span> <span>(</span>ret<span>)</span> <span>{</span>\n            <span>case</span> ALOOPER_POLL_WAKE<span>:</span>\n            <span>case</span> ALOOPER_POLL_CALLBACK<span>:</span>\n                <span>continue</span><span>;</span>\n            <span>case</span> ALOOPER_POLL_ERROR<span>:</span>\n                <span>ALOGE</span><span>(</span><span>\"ALOOPER_POLL_ERROR\"</span><span>)</span><span>;</span>\n            <span>case</span> ALOOPER_POLL_TIMEOUT<span>:</span>\n                <span>// timeout (should not happen)</span>\n                <span>continue</span><span>;</span>\n            <span>default</span><span>:</span>\n                <span>// should not happen</span>\n                <span>ALOGE</span><span>(</span><span>\"Looper::pollOnce() returned unknown status %d\"</span><span>,</span> ret<span>)</span><span>;</span>\n                <span>continue</span><span>;</span>\n        <span>}</span>\n    <span>}</span> <span>while</span> <span>(</span><span>true</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre></div><blockquote>\n<p>可以看到程序在这里进入了一个死循环，而且即便 <code>pollOnce</code> 的执行结果是 <code>ALOOPER_POLL_TIMEOUT</code>，也同样不会跳出循环。</p>\n<p>这是 <code>Android</code> 在对待严重错误时的一种普遍态度，即：如果不幸发生致命错误，就听天由命吧。</p>\n</blockquote>\n<p><strong><code>mLooper-&gt;pollOnce(-1)</code></strong> 在内部调用 <code>MessageQueue::mHandler</code> 来处理消息：</p>\n<blockquote>\n<p>注意：<code>pollOnce</code> 函数同样使用了一个死循环，它不断地读取消息进行处理。</p>\n</blockquote>\n<p><code>MessageQueue</code> 是消息循环处理机制的管理者，其下包含了一个 <code>Looper</code> 和一个 <code>Handler</code>。<code>Looper</code> 中的 <code>mMessageEnvelope</code> 才是真正存储消息的地方。</p>\n<blockquote>\n<p>高版本中，<code>Looper</code> 的文件位置如下：</p>\n<div><pre><code>system/core/libutils/include/utils/Looper.h\nsystem/core/libutils/Looper.cpp\n</code></pre></div></blockquote>\n<p>这样就构建了一个完整的循环消息处理框架，<code>SurfaceFlinger</code> 就是基于这个框架来完成各个应用程序的显示请求的。</p>\n<p><code>MessageQueue::mHandler</code> 并非我们在消息机制中认识的那个 <code>Handler</code>，而是 <code>MessageQueue</code> 中自定义的一个事件处理器，即它是专门为 <code>SurfaceFlinger</code> 设计的：</p>\n<div><pre><code><span>/*frameworks/native/services/surfaceflinger/MessageQueue.cpp*/</span>\n<span>void</span> MessageQueue<span>::</span><span>Handler</span><span>::</span><span>handleMessage</span><span>(</span><span>const</span> Message<span>&amp;</span> message<span>)</span> <span>{</span>\n    <span>switch</span> <span>(</span>message<span>.</span>what<span>)</span> <span>{</span>\n      <span>case</span> INVALIDATE<span>:</span>\n           <span>android_atomic_and</span><span>(</span>～eventMaskInvalidate<span>,</span> <span>&amp;</span>mEventMask<span>)</span><span>;</span>\n           mQueue<span>.</span>mFlinger<span>-></span><span>onMessageReceived</span><span>(</span>message<span>.</span>what<span>)</span><span>;</span>\n           <span>break</span><span>;</span>\n      <span>case</span> REFRESH<span>:</span>\n           <span>android_atomic_and</span><span>(</span>～eventMaskRefresh<span>,</span> <span>&amp;</span>mEventMask<span>)</span><span>;</span>\n           mQueue<span>.</span>mFlinger<span>-></span><span>onMessageReceived</span><span>(</span>message<span>.</span>what<span>)</span><span>;</span>\n           <span>break</span><span>;</span>\n      <span>case</span> TRANSACTION<span>:</span>\n           <span>android_atomic_and</span><span>(</span>～eventMaskTransaction<span>,</span> <span>&amp;</span>mEventMask<span>)</span><span>;</span>\n           mQueue<span>.</span>mFlinger<span>-></span><span>onMessageReceived</span><span>(</span>message<span>.</span>what<span>)</span><span>;</span>\n           <span>break</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre></div><p>如上述代码段所示，当 <code>mHandler</code> 收到 <code>INVALIDATE</code>，<code>REFRESH</code> 及 <code>TRANSACTION</code> 的请求时，将进一步回调 <code>SurfaceFlinger</code> 中的 <code>onMessageReceived</code>。等于绕了一个大圈，又回到 <code>SurfaceFlinger</code> 中了。</p>\n<blockquote>\n<p>高版中的差异：<code>SurfaceFlinger::onMessageReceived</code> 被 <code>Scheduler::onFrameSignal</code> 替代。</p>\n<div><pre><code><span>/* frameworks/native/services/surfaceflinger/Scheduler/MessageQueue.cpp */</span>\n<span>void</span> MessageQueue<span>::</span><span>Handler</span><span>::</span><span>handleMessage</span><span>(</span><span>const</span> Message<span>&amp;</span><span>)</span> <span>{</span>\n    mFramePending<span>.</span><span>store</span><span>(</span><span>false</span><span>)</span><span>;</span>\n    <span>/*\n        mQueue 是 MessageQueue 的实现类 Scheduler\n        [class Scheduler : public IEventThreadCallback, android::impl::MessageQueue]\n        头文件路径：frameworks/native/services/surfaceflinger/Scheduler/Scheduler.h\n        \n    */</span>\n    mQueue<span>.</span><span>onFrameSignal</span><span>(</span>mQueue<span>.</span>mCompositor<span>,</span> mVsyncId<span>,</span> mExpectedVsyncTime<span>)</span><span>;</span>\n<span>}</span>\n</code></pre></div></blockquote>\n<h3 id=\"_6-3-接口的服务端-——-client\" tabindex=\"-1\"> 6.3 接口的服务端 —— <code>Client</code></h3>\n<p><code>SurfaceFlinger</code> 运行于 <code>SystemServer</code> 这一系统进程中，需要显示 <code>UI</code> 界面的应用程序则通过 <code>Binder</code> 服务与它进行跨进程通信。每个应用程序在 <code>SurfaceFlinger</code> 中都有 <code>Client</code> 为其提供服务。</p>\n<p><code>Client</code> 这个类名并没有完全表达出它的真正含义，因为在 <code>Android</code> 系统的很多其他地方都可以找到同名的类。</p>\n<p>应用程序与 <code>Client</code> 间的 <code>Binder</code> 接口是 <code>ISurfaceComposerClient</code>，所以作为接口的服务端实现，<code>Client</code> 继承自 <code>BnSurfaceComposerClient</code>：</p>\n<div><pre><code><span>/*frameworks/native/include/gui/ISurfaceComposerClient.h*/</span>\n<span>class</span> <span>ISurfaceComposerClient</span> <span>:</span> <span><span>public</span> <span>IInterface</span></span>\n<span>{</span>   \n    <span>.</span><span>.</span><span>.</span>\n    <span>virtual</span> status_t <span>createSurface</span><span>(</span><span>const</span> String8<span>&amp;</span> name<span>,</span> <span>uint32_t</span> w<span>,</span> <span>uint32_t</span> h<span>,</span> PixelFormat format<span>,</span>\n                        <span>uint32_t</span> flags<span>,</span> sp<span>&lt;</span>IBinder<span>></span><span>*</span> handle<span>,</span> sp<span>&lt;</span>IGraphicBufferProducer<span>></span><span>*</span> gbp<span>)</span> <span>=</span> <span>0</span><span>;</span>\n\n    <span>virtual</span> status_t <span>destroySurface</span><span>(</span><span>const</span> sp<span>&lt;</span>IBinder<span>></span><span>&amp;</span> handle<span>)</span> <span>=</span> <span>0</span><span>;</span>\n<span>}</span><span>;</span>\n</code></pre></div><p>上述接口方法中最重要的两个是 <code>createSurface()</code> 和 <code>destroySurface()</code>，分别用于向 <code>SurfaceFlinger</code> 申请和销毁一个 <code>Surface</code>。</p>\n<blockquote>\n<p>更早期版本的系统中 <code>createSurface</code> 返回的是一个叫作 <code>ISurface</code> 的 <code>Binder</code> 接口，目前已经不复存在。</p>\n<p>但 <code>createSurface</code> 这个函数名称还没有变。<strong>我们可以认为 <code>Surface</code> 在服务器端对应的是 <code>Layer</code></strong>。</p>\n</blockquote>\n<p>值得一提的是，<code>SurfaceFlinger</code> 的客户端程序拥有的 <code>Surface</code> 数量很可能不止一个。</p>\n<div><pre><code>通常情况下，同一个 Activity 中的 UI 布局共用系统分配的 Surface 进行绘图，\n但像 SurfaceView 这种 UI 组件却是特例 —— 它独占一个 Surface 进行绘制。\n</code></pre></div><p>换句话说，如果我们制作一个带 <code>SurfaceView</code> 的视频播放器，其所在的应用程序最终就会有不止一个的 <code>Surface</code> 存在。</p>\n<blockquote>\n<p>这样的设计是必需的，因为播放视频对刷新频率要求很高，采用单独的 <code>Surface</code> 既可以保证视频的流畅度，同时也可以让用户的交互动作（比如触摸事件）得到及时的响应。</p>\n</blockquote>\n<p>下面我们从源码角度来分析客户端与 <code>SurfaceFlinger</code> 连接并创建 <code>Layer</code> 的两个重要接口。</p>\n<h4 id=\"_6-3-1-surfaceflinger-createconnection\" tabindex=\"-1\"> 6.3.1 <code>SurfaceFlinger::createConnection</code></h4>\n<p><code>Client</code> 属于匿名 <code>Binder</code> 服务，外界的进程不可能直接获取到，因而它首先需要借助于 <code>SurfaceFlinger</code> 这一实名 <code>Binder Server</code>。源码实现如下：</p>\n<div><pre><code>sp<span>&lt;</span>ISurfaceComposerClient<span>></span> <span>SurfaceFlinger</span><span>::</span><span>createConnection</span><span>(</span><span>)</span>\n<span>{</span>\n    sp<span>&lt;</span>ISurfaceComposerClient<span>></span> bclient<span>;</span>\n    sp<span>&lt;</span>Client<span>></span> <span>client</span><span>(</span><span>new</span> <span>Client</span><span>(</span><span>this</span><span>)</span><span>)</span><span>;</span>\n    status_t err <span>=</span> client<span>-></span><span>initCheck</span><span>(</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span>err <span>==</span> NO_ERROR<span>)</span> <span>{</span>\n        bclient <span>=</span> client<span>;</span>\n    <span>}</span>\n    <span>return</span> bclient<span>;</span>\n<span>}</span>\n</code></pre></div><p>首先生成一个 <code>Client</code> 本地对象，然后调用 <code>initCheck</code> 进行必要的有效性检查（当前实现中直接返回 <code>NO_ERROR</code>）。</p>\n<p>如果 <code>initCheck</code> 没有错误，程序就会把新生成的 <code>Client</code> 对象以 <code>ISurfaceComposerClient</code> 强指针的形式返回。</p>\n<p>这样应用程序内部就拥有一个 <code>Client</code> 服务了。</p>\n<blockquote>\n<p>高版本的差异：</p>\n<div><pre><code><span>/* frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp */</span>\nbinder<span>::</span>Status <span>SurfaceComposerAIDL</span><span>::</span><span>createConnection</span><span>(</span>sp<span>&lt;</span>gui<span>::</span>ISurfaceComposerClient<span>></span><span>*</span> outClient<span>)</span> <span>{</span>\n    <span>const</span> sp<span>&lt;</span>Client<span>></span> client <span>=</span> <span>sp</span><span>&lt;</span>Client<span>></span><span>::</span><span>make</span><span>(</span>mFlinger<span>)</span><span>;</span> <span>// 创建 Client 对象</span>\n    <span>if</span> <span>(</span>client<span>-></span><span>initCheck</span><span>(</span><span>)</span> <span>==</span> NO_ERROR<span>)</span> <span>{</span>\n        <span>*</span>outClient <span>=</span> client<span>;</span> <span>// 将 Client 对象以 ISurfaceComposerClient 强指针的形式返回</span>\n        <span>.</span><span>.</span><span>.</span>\n        <span>return</span> binder<span>::</span><span>Status</span><span>::</span><span>ok</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n        <span>*</span>outClient <span>=</span> <span>nullptr</span><span>;</span>\n        <span>return</span> <span>binderStatusFromStatusT</span><span>(</span>BAD_VALUE<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre></div></blockquote>\n<h4 id=\"_6-3-2-client-createsurface\" tabindex=\"-1\"> 6.3.2 <code>Client::createSurface</code></h4>\n<p><code>Client</code> 只是 <code>SurfaceFlinger</code> 分派给应用程序的一个 “代表”，真正的图形层（<code>Layer</code>）创建需要另外申请，即调用 <code>Client</code> 提供的 <code>createSurface</code> 接口。这个接口的实现在前几个小节已经有过粗略的分析，下面再从 <code>SurfaceFlinger</code> 的角度来审视下：</p>\n<div><pre><code><span>/* frameworks/native/services/surfaceflinger/Client.cpp */</span>\nstatus_t <span>Client</span><span>::</span><span>createSurface</span><span>(</span><span>const</span> String8<span>&amp;</span> name<span>,</span> <span>uint32_t</span> w<span>,</span> <span>uint32_t</span> h<span>,</span> \n            PixelFormat format<span>,</span> <span>uint32_t</span> flags<span>,</span>sp<span>&lt;</span>IBinder<span>></span><span>*</span> handle<span>,</span> sp<span>&lt;</span>IGraphicBufferProducer<span>></span><span>*</span> gbp<span>)</span>\n<span>{</span>\n    <span>class</span> <span>MessageCreateLayer</span> <span>:</span> <span><span>public</span> <span>MessageBase</span></span> <span>{</span>\n        SurfaceFlinger<span>*</span> flinger<span>;</span> <span>// SurfaceFlinger 服务</span>\n        Client<span>*</span> client<span>;</span> <span>// 表明此消息来源于哪个 Client</span>\n        sp<span>&lt;</span>IBinder<span>></span><span>*</span> handle<span>;</span> <span>// 与 Layer 相对应的 Handle</span>\n        sp<span>&lt;</span>IGraphicBufferProducer<span>></span><span>*</span> gbp<span>;</span> <span>// 与 Layer 相对应的 gbp</span>\n        status_t result<span>;</span>\n        <span>const</span> String8<span>&amp;</span> name<span>;</span>\n        <span>uint32_t</span> w<span>,</span> h<span>;</span>\n        PixelFormat format<span>;</span>\n        <span>uint32_t</span> flags<span>;</span>\n    <span>public</span><span>:</span>\n        <span>MessageCreateLayer</span><span>(</span>SurfaceFlinger<span>*</span> flinger<span>,</span> <span>const</span> String8<span>&amp;</span> name<span>,</span> Client<span>*</span> client<span>,</span> uint32_tw<span>,</span>\n                           <span>uint32_t</span> h<span>,</span> PixelFormat format<span>,</span> <span>uint32_t</span> flags<span>,</span>\n                           sp<span>&lt;</span>IBinder<span>></span><span>*</span> handle<span>,</span> sp<span>&lt;</span>IGraphicBufferProducer<span>></span><span>*</span> gbp<span>)</span>\n            <span>:</span> <span>flinger</span><span>(</span>flinger<span>)</span><span>,</span> <span>client</span><span>(</span>client<span>)</span><span>,</span> <span>handle</span><span>(</span>handle<span>)</span><span>,</span> <span>gbp</span><span>(</span>gbp<span>)</span><span>,</span>\n              <span>name</span><span>(</span>name<span>)</span><span>,</span> <span>w</span><span>(</span>w<span>)</span><span>,</span> <span>h</span><span>(</span>h<span>)</span><span>,</span> <span>format</span><span>(</span>format<span>)</span><span>,</span> <span>flags</span><span>(</span>flags<span>)</span> <span>{</span>\n        <span>}</span>\n        status_t <span>getResult</span><span>(</span><span>)</span> <span>const</span> <span>{</span> <span>return</span> result<span>;</span> <span>}</span>\n        <span>virtual</span> <span>bool</span> <span>handler</span><span>(</span><span>)</span> <span>{</span> <span>// SurfaceFlinger 将回调这个 handler 来执行具体的事务</span>\n            result <span>=</span> flinger<span>-></span><span>createLayer</span><span>(</span>name<span>,</span> client<span>,</span> w<span>,</span> h<span>,</span> format<span>,</span> flags<span>,</span> handle<span>,</span> gbp<span>)</span><span>;</span>\n            <span>return</span> <span>true</span><span>;</span>\n        <span>}</span>\n    <span>}</span><span>;</span>\n\n    sp<span>&lt;</span>MessageBase<span>></span> msg <span>=</span> <span>new</span> <span>MessageCreateLayer</span><span>(</span>mFlinger<span>.</span><span>get</span><span>(</span><span>)</span><span>,</span>\n            name<span>,</span> <span>this</span><span>,</span> w<span>,</span> h<span>,</span> format<span>,</span> flags<span>,</span> handle<span>,</span> gbp<span>)</span><span>;</span> <span>// 生成一个消息</span>\n    mFlinger<span>-></span><span>postMessageSync</span><span>(</span>msg<span>)</span><span>;</span> <span>// 将这一 Message 推送到 SurfaceFlinger 线程中</span>\n    <span>return</span> <span><span>static_cast</span><span><span>&lt;</span>MessageCreateLayer<span>*</span><span>></span></span></span><span>(</span>msg<span>.</span><span>get</span><span>(</span><span>)</span> <span>)</span><span>-></span><span>getResult</span><span>(</span><span>)</span><span>;</span> <span>// 返回结果</span>\n<span>}</span>\n</code></pre></div><blockquote>\n<p>值得注意的是，<code>createSurface</code> 这个函数需要从 <code>OpenGL ES</code> 的环境线程中被调用，这样它才能访问到后者提供的服务。</p>\n</blockquote>\n<p>这个函数比较特别的地方，是它先在内部创建了一个 <code>MessageCreateLayer</code> 类，剩余部分代码就是围绕这个类来展开的。</p>\n<p><code>MessageCreateLayer</code> 继承自 <code>MessageBase</code>，所以 <code>MessageCreateLayer</code> 是一个 <code>Message</code> 的承载体，并且内部提供了处理这条 <code>Message</code> 的 <code>handler()</code> 函数。</p>\n<p>在 <code>Client::createSurface</code> 函数最后调用 <code>SurfaceFlinger::postMessageSync</code> 将一个 <code>MessageCreateLayer</code> 对象 <code>msg</code> 发送到了 <code>SurfaceFlinger</code> 中。</p>\n<p>函数 <code>SurfaceFlinger::postMessageSync</code> 通过 <code>mEventQueue</code> 将 <code>msg</code> 压入其消息队列中，并且会进入等待状态。代码如下：</p>\n<div><pre><code>status_t <span>SurfaceFlinger</span><span>::</span><span>postMessageSync</span><span>(</span><span>const</span> sp<span>&lt;</span>MessageBase<span>></span><span>&amp;</span> msg<span>,</span>nsecs_t reltime<span>,</span> uint <span>32</span>_t flags<span>)</span> <span>{</span>\n    status_t res <span>=</span> mEventQueue<span>.</span><span>postMessage</span><span>(</span>msg<span>,</span> reltime<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>res <span>==</span> NO_ERROR<span>)</span> <span>{</span>\n        msg<span>-></span><span>wait</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> res<span>;</span>\n<span>}</span>\n</code></pre></div><p><code>MessageBase::wait()</code> 调用内部的 <code>Barrier::wait</code> 来实现等待，这意味着发送消息的线程将暂时停止执行，那么什么时候才能继续呢？显然得先唤醒它才行。这个唤醒的地方隐藏在 <code>MessageBase::handleMessage()</code> 中。即：</p>\n<div><pre><code><span>/* frameworks/native/services/surfaceflinger/MessageQueue.cpp */</span>\n<span>void</span> <span>MessageBase</span><span>::</span><span>handleMessage</span><span>(</span><span>const</span> Message<span>&amp;</span><span>)</span> <span>{</span>\n    <span>this</span><span>-></span><span>handler</span><span>(</span><span>)</span><span>;</span>\n    barrier<span>.</span><span>open</span><span>(</span><span>)</span><span>;</span>\n<span>}</span><span>;</span>\n</code></pre></div><p>总的来说，就是 <code>Client</code> 一旦收到来自客户端的请求，并不会马上让 <code>SurfaceFlinger</code> 执行，而是间接地把请求先投递到后者的消息队列中，这样一方面保证这个请求不会丢失，另一方面也使 <code>SurfaceFlinger</code> 不至于中断当前的操作。</p>\n<p>绕了一圈，其实 <code>Client::createSurface</code> 函数的作用就是通过执行 <code>SurfaceFlinger::createLayer</code> 函数来创建 <code>Layer</code>。</p>\n<blockquote>\n<p><code>SurfaceFlinger::createLayer</code> 创建图层的过程分析见  小节。</p>\n</blockquote>\n<h2 id=\"_7-vsync-的产生和处理\" tabindex=\"-1\"> 7 <code>VSync</code> 的产生和处理</h2>\n<p><code>VSync</code> 同步是从 <code>Android 4.1</code> 开始引入的显示系统新特性，也是 “黄油计划” 的一个重要核心。</p>\n<p>在  小节中，我们从理论的角度分析了采用这一机制的必要性和运作机理，那么 <code>SurfaceFlinger</code> 具体是如何实施的呢？</p>\n<p>先来思考一下 <code>SurfaceFlinger</code> 实现 <code>VSync</code> 同步有哪些要点：</p>\n<div><pre><code>VSync 信号的产生和分发\n    如果有硬件主动发出这一信号，那是最好的；\n    否则就得通过软件模拟产生。\n\nVSync 信号的处理\n    当信号产生后，SurfaceFlinger 如何在最短的时间内做出响应。\n    另外，具体的处理流程是怎样的。\n</code></pre></div><h3 id=\"_7-1-vsync-信号的产生和分发\" tabindex=\"-1\"> 7.1 <code>VSync</code> 信号的产生和分发</h3>\n<p><code>Android</code> 源码工程的 <code>surfaceflinger</code> 目录下有一个 <code>displayhardware</code> 文件夹，其中 <code>HWComposer</code> 的主要职责之一，就是用于产生 <code>VSync</code> 信号：</p>\n<div><pre><code><span>/* frameworks/native/services/surfaceflinger/displayhardware/HWComposer.cpp */</span>\n<span>HWComposer</span><span>::</span><span>HWComposer</span><span>(</span><span>const</span> sp<span>&lt;</span>SurfaceFlinger<span>></span><span>&amp;</span> flinger<span>,</span> EventHandler<span>&amp;</span> handler<span>)</span>\n      <span>:</span> <span>mFlinger</span><span>(</span>flinger<span>)</span><span>,</span> <span>mFbDev</span><span>(</span><span>0</span><span>)</span><span>,</span> <span>mHwc</span><span>(</span><span>0</span><span>)</span><span>,</span> <span>mNumDisplays</span><span>(</span><span>1</span><span>)</span><span>,</span> <span>mCBContext</span><span>(</span><span>new</span> cb_context<span>)</span><span>,</span>\n      <span>mEventHandler</span><span>(</span>handler<span>)</span><span>,</span> <span>mVSyncCount</span><span>(</span><span>0</span><span>)</span><span>,</span> <span>mDebugForceFakeVSync</span><span>(</span><span>false</span><span>)</span>\n<span>{</span>\n    <span>.</span><span>.</span><span>.</span>\n    <span>char</span> value<span>[</span>PROPERTY_VALUE_MAX<span>]</span><span>;</span>\n    <span>property_get</span><span>(</span><span>\"debug.sf.no_hw_vsync\"</span><span>,</span> value<span>,</span> <span>\"0\"</span><span>)</span><span>;</span> <span>// 获取系统属性</span>\n    mDebugForceFakeVSync <span>=</span> <span>atoi</span><span>(</span>value<span>)</span><span>;</span>\n    <span>bool</span> needVSyncThread <span>=</span> <span>true</span><span>;</span> <span>// 是否需要软件模拟产生 VSync 信号，默认是 true</span>\n    <span>.</span><span>.</span><span>.</span>    \n    <span>loadHwcModule</span><span>(</span><span>)</span><span>;</span><span>// 打开 HWC 的 HAL 模块</span>\n    <span>.</span><span>.</span><span>.</span>  \n    <span>if</span> <span>(</span>mHwc<span>)</span> <span>{</span>\n        <span>.</span><span>.</span><span>.</span>\n        <span>if</span> <span>(</span>mHwc<span>-></span>registerProcs<span>)</span> <span>{</span><span>// 注册硬件回调事件</span>\n            mCBContext<span>-></span>hwc <span>=</span> <span>this</span><span>;</span>\n            mCBContext<span>-></span>procs<span>.</span>invalidate <span>=</span> <span>&amp;</span>hook_invalidate<span>;</span>\n            mCBContext<span>-></span>procs<span>.</span>vsync <span>=</span> <span>&amp;</span>hook_vsync<span>;</span>\n            <span>if</span> <span>(</span><span>hwcHasApiVersion</span><span>(</span>mHwc<span>,</span> HWC_DEVICE_API_VERSION_1_1<span>)</span><span>)</span>\n                mCBContext<span>-></span>procs<span>.</span>hotplug <span>=</span> <span>&amp;</span>hook_hotplug<span>;</span>\n            <span>else</span>\n                mCBContext<span>-></span>procs<span>.</span>hotplug <span>=</span> <span>NULL</span><span>;</span>\n            <span>memset</span><span>(</span>mCBContext<span>-></span>procs<span>.</span>zero<span>,</span> <span>0</span><span>,</span> <span>sizeof</span><span>(</span>mCBContext<span>-></span>procs<span>.</span>zero<span>)</span><span>)</span><span>;</span>\n            mHwc<span>-></span><span>registerProcs</span><span>(</span>mHwc<span>,</span> <span>&amp;</span>mCBContext<span>-></span>procs<span>)</span><span>;</span>\n        <span>}</span>\n\n\n        <span>// don't need a vsync thread if we have a hardware composer</span>\n        needVSyncThread <span>=</span> <span>false</span><span>;</span><span>//不需要软件模拟</span>\n        <span>.</span><span>.</span><span>.</span>\n    <span>}</span>\n    <span>.</span><span>.</span><span>.</span>\n    <span>if</span> <span>(</span>needVSyncThread<span>)</span> <span>{</span> <span>// 如果需要软件模拟 VSync 信号的话，启动一个 VSyncThread 线程</span>\n        <span>// we don't have VSYNC support, we need to fake it</span>\n        mVSyncThread <span>=</span> <span>new</span> <span>VSyncThread</span><span>(</span><span>*</span><span>this</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre></div><p>这个函数的核心就是决定 <code>VSync</code> 的 “信号发生源” —— 硬件实现或者软件模拟。</p>\n<div><pre><code>假如当前系统可以成功地加载名称为 HWC_HARDWARE_MODULE_ID=\"hwcomposer\" 的 HAL 模块，\n并且通过这个库模块能顺利打开设备（hwc_composer_device_t），其版本号又大于 HWC_DEVICE_API_VERSION_1_1，\n我们就采用 “硬件源”（此时 needVSyncThread 为 false）；\n否则需要创建一个新的 VSync 线程来模拟产生信号。\n</code></pre></div><blockquote>\n<p>高版本的差异：<code>HWComposer</code> 中产生信号发生源的代码存在差异：</p>\n<div><pre><code><span>/* frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp */</span>\n<span>HWComposer</span><span>::</span><span>HWComposer</span><span>(</span><span>const</span> std<span>::</span>string<span>&amp;</span> composerServiceName<span>)</span>\n      <span>:</span> <span>HWComposer</span><span>(</span>Hwc2<span>::</span><span>Composer</span><span>::</span><span>create</span><span>(</span>composerServiceName<span>)</span><span>)</span> <span>{</span><span>}</span>\n\n<span>/* frameworks/native/services/surfaceflinger/DisplayHardware/ComposerHal.cpp */</span>\nstd<span>::</span>unique_ptr<span>&lt;</span>Composer<span>></span> <span>Composer</span><span>::</span><span>create</span><span>(</span><span>const</span> std<span>::</span>string<span>&amp;</span> serviceName<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>AidlComposer</span><span>::</span><span>isDeclared</span><span>(</span>serviceName<span>)</span><span>)</span> <span>{</span>\n        <span>return</span> std<span>::</span><span><span>make_unique</span><span><span>&lt;</span>AidlComposer<span>></span></span></span><span>(</span>serviceName<span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> std<span>::</span><span><span>make_unique</span><span><span>&lt;</span>HidlComposer<span>></span></span></span><span>(</span>serviceName<span>)</span><span>;</span>\n<span>}</span>\n</code></pre></div></blockquote>\n<h4 id=\"_7-1-1-硬件源\" tabindex=\"-1\"> 7.1.1 硬件源</h4>\n<blockquote>\n<p>高版本存在差异，后续再更新。</p>\n</blockquote>\n<p>如果 <code>mHwc-&gt;registerProcs</code> 不为空，我们注册硬件回调 <code>mCBContext.procs</code>。定义如下：</p>\n<div><pre><code><span>/* frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp */</span>\nstatus_t <span>SurfaceFlinger</span><span>::</span><span>readyToRun</span><span>(</span><span>)</span>\n<span>{</span>\n    <span>.</span><span>.</span><span>.</span>\n    mHwc <span>=</span> <span>new</span> <span>HWComposer</span><span>(</span><span>this</span><span>,</span><span>*</span><span><span>static_cast</span><span><span>&lt;</span>HWComposer<span>::</span>EventHandler <span>*</span><span>></span></span></span><span>(</span><span>this</span><span>)</span><span>)</span><span>;</span>\n</code></pre></div><p>从中可以看出，<code>HWComposer</code> 中的 <code>mEventHandler</code> 就是 <code>SurfaceFlinger</code> 对象，\n所以 <code>SurfaceFlinger</code> 必须要继承自 <code>HWComposer::EventHandler</code>，这样才能处理 <code>callback</code> 函数 <code>onVSyncReceived</code>：</p>\n<div><pre><code><span>class</span> <span>SurfaceFlinger</span> <span>:</span> <span>public</span> BinderService<span>&lt;</span>SurfaceFlinger<span>></span><span>,</span> <span>.</span><span>.</span><span>.</span><span>,</span> <span>private</span> HWComposer<span>::</span>EventHandler\n</code></pre></div><h4 id=\"_7-1-2-软件源\" tabindex=\"-1\"> 7.1.2 软件源</h4>\n<p>软件源和硬件源相比最大区别是它需要启动一个新线程 <code>VSyncThread</code>，其运行优先级与 <code>SurfaceFlinger</code> 的工作线程是一样的。</p>\n<blockquote>\n<p>从理论的角度来讲，任何通过软件定时来实现的机制都不可能是 100% 可靠的，即使优先级再高也可能出现延迟和意外。</p>\n<p>不过如果 “不可靠” 的概率很小，而且就算出现意外时也不至于是致命错误，那么还是可以接受的。</p>\n<p>所以说 <code>VSyncThread</code> 从实践的角度来讲，的确起到了很好的作用。</p>\n</blockquote>\n<p>来看看 <code>VSyncThread</code> 都做了些什么工作：</p>\n<div><pre><code><span>bool</span> HWComposer<span>::</span><span>VSyncThread</span><span>::</span><span>threadLoop</span><span>(</span><span>)</span> <span>{</span>\n   <span>/* Step1. 判断系统是否使能了 VSync 信号发生机制 */</span>\n    <span>{</span> <span>// 自动锁控制范围</span>\n        Mutex<span>::</span>Autolock <span>_l</span><span>(</span>mLock<span>)</span><span>;</span>\n        <span>while</span> <span>(</span><span>!</span>mEnabled<span>)</span> <span>{</span><span>//VSync信号开关</span>\n            mCondition<span>.</span><span>wait</span><span>(</span>mLock<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>/* Step2. 计算需要产生 VSync 信号的时间点 */</span>\n    <span>const</span> nsecs_t period <span>=</span> mRefreshPeriod<span>;</span> <span>// 信号的产生间隔</span>\n    <span>const</span> nsecs_t now <span>=</span> <span>systemTime</span><span>(</span>CLOCK_MONOTONIC<span>)</span><span>;</span>\n    nsecs_t next_vsync <span>=</span> mNextFakeVSync<span>;</span> <span>// 产生信号的时间</span>\n    nsecs_t sleep <span>=</span> next_vsync <span>-</span> now<span>;</span> <span>// 需要休眠的时长</span>\n    <span>if</span> <span>(</span>sleep <span>&lt;</span> <span>0</span><span>)</span> <span>{</span><span>//已经过了时间点</span>\n        sleep <span>=</span> <span>(</span>period <span>-</span> <span>(</span><span>(</span>now <span>-</span> next_vsync<span>)</span> <span>%</span> period<span>)</span><span>)</span><span>;</span>\n        next_vsync <span>=</span> now <span>+</span> sleep<span>;</span>\n    <span>}</span>\n    mNextFakeVSync <span>=</span> next_vsync <span>+</span> period<span>;</span> <span>// 下一次的 VSync 时间</span>\n    <span>struct</span> <span>timespec</span> spec<span>;</span>\n    spec<span>.</span>tv_sec  <span>=</span> next_vsync <span>/</span> <span>1000000000</span><span>;</span>\n    spec<span>.</span>tv_nsec <span>=</span> next_vsync <span>%</span> <span>1000000000</span><span>;</span>\n\n\n    <span>int</span> err<span>;</span>\n    <span>do</span> <span>{</span>\n        err <span>=</span> <span>clock_nanosleep</span><span>(</span>CLOCK_MONOTONIC<span>,</span> TIMER_ABSTIME<span>,</span> <span>&amp;</span>spec<span>,</span> <span>NULL</span><span>)</span><span>;</span> <span>// 进入休眠</span>\n    <span>}</span> <span>while</span> <span>(</span>err<span>&lt;</span><span>0</span> <span>&amp;&amp;</span> errno <span>==</span> EINTR<span>)</span><span>;</span>\n\n\n    <span>if</span> <span>(</span>err <span>==</span> <span>0</span><span>)</span> <span>{</span>\n        mHwc<span>.</span>mEventHandler<span>.</span><span>onVSyncReceived</span><span>(</span><span>0</span><span>,</span> next_vsync<span>)</span><span>;</span> <span>// 和硬件源是一样的回调</span>\n    <span>}</span>\n    <span>return</span> <span>true</span><span>;</span>\n<span>}</span>\n</code></pre></div><div><pre><code>Step1@VSyncThread::threadLoop\n\nmEnabled 是用于控制是否产生 VSync 信号的一个使能变量。\n当系统希望关闭 VSync 信号发生源时，可以调用 VSyncThread::setEnabled(false)；否则调用 setEnabled (true)。\n假如 mEnabled 为 false，VSyncThread 就处于等待状态，直到有人再次使能这个线程。\n</code></pre></div><div><pre><code>Step2@VSyncThread::threadLoop\n\n接下来的代码用于真正产生一个 VSync 信号。可以思考一下，无非就是以下步骤：\n1. 计算下一次产生 VSync 信号的时间；\n2. 进入休眠；\n3. 休眠时间到了后，发出 VSync 信号，通知感兴趣的人；\n4. 循环往复。\n</code></pre></div><p>变量 <code>mRefreshPeriod</code> 指定了产生 <code>VSync</code> 信号的间隔。它的计算过程分为几种情况：</p>\n<div><pre><code>1. 首选是从硬件设备获得真实的值；\n2. 否则就采用如下办法：\n    if (disp.refresh == 0) {\n        disp.refresh = nsecs_t(1e9 / mFbDev->fps);\n    }\n    if (disp.refresh == 0) {\n        disp.refresh = nsecs_t(1e9 / 60.0);\n    }\n\n也就是说从硬件设备获取不到后，取值先由 nsecs_t(1e9 / mFbDev->fps) 计算得到的\n如果还不行，那就只能采用默认值了，即：nsecs_t(1e9 / 60.0)，此时，mRefreshPeriod 差不多是 16ms\n</code></pre></div><p>因为 <code>mNextFakeVSync</code> 代表的是 “下一次” 产生信号的时间点，所以首先通过 <code>next_vsync = mNextFakeVSync</code> 来确定 <code>next_vsync</code> 的值。</p>\n<p>接着计算 <code>sleep</code>，也就是距离产生信号的时间点还有多长（同时也是需要休眠的时间）。</p>\n<p>那么，如果 <code>sleep</code> 的结果小于 0 呢？代表我们已经错过了这一次产生信号的最佳时间点（这是有可能发生的）。</p>\n<p>在这种情况下，就只能计算下一个最近的 <code>VSync</code> 离现在还剩多少时间。公式如下：</p>\n<div><pre><code>sleep = (period - ((now - next_vsync) % period));\n</code></pre></div><p>我们采用这个公式的依据如下图所示。</p>\n<p><img src=\"@source/lango-tech/subject/images/surfaceflinger/18.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>上图的前提是 <code>now</code> 超时时间不能超过一个 <code>period</code>，因而 <code>sleep</code> 公式中还要加上 <code>%period</code>。</p>\n</blockquote>\n<p>计算完成 <code>sleep</code> 后，<code>mNextFakeVSync = next_vsync + period</code>。</p>\n<div><pre><code>这是因为 mNextFakeVSync 代表的是下一次 threadLoop 需要用到的时间点，\n而 next_vsync 是指下一次（最近一次）产生 VSync 的时间点。\n</code></pre></div><p>这样我们就计算出来下一次产生信号的时间点了，那么如何在指定的时间点产生信号呢？有两种方法：</p>\n<div><pre><code>其一是采用定时器回调；\n其二就是采用休眠的形式主动等待\n</code></pre></div><blockquote>\n<p><code>HWCompose</code> 采用休眠的形式主动等待。</p>\n</blockquote>\n<p>可想而知这里对时间精度的要求比较高，所以采用的单位是 <code>nanosecond</code>，即纳秒级。</p>\n<blockquote>\n<p>函数 <code>clock_nanosleep</code> 的第一个入参是 <code>CLOCK_MONOTONIC</code>，这种类型的时钟更加稳定，且不受系统时间的影响。</p>\n</blockquote>\n<p>休眠时间一到，表示产生信号的时刻到了。根据前面的分析，就是通过 <code>mEventHandler.onVSyncReceived()</code> 回调来通知对消息感兴趣的人，无论软件还是硬件发生源，其回调方式都是一样的。</p>\n<blockquote>\n<p>高版本中通过 <code>IComposerCallback::onVsync</code> 回调来通知 <code>Vsync</code> 信号的产生。</p>\n</blockquote>\n<p>当产生完一次信号后，<code>VSyncThread::threadLoop</code> 这个函数就直接返回 <code>true</code> 了。</p>\n<blockquote>\n<p>怎么没有看到循环的地方？这是因为当 <code>threadLoop</code> 返回值 <code>true</code> 时，它将被系统再一次调用，如此循环往复。</p>\n</blockquote>\n<p><strong>接下来我们分析下 <code>SurfaceFlinger</code> 是如何处理这个 <code>VSync</code> 信号的。</strong></p>\n<p>在 <code>SurfaceFlinger::onVSyncReceived</code> 中：</p>\n<div><pre><code><span>void</span> <span>SurfaceFlinger</span><span>::</span><span>onVSyncReceived</span><span>(</span><span>int</span> type<span>,</span> nsecs_t timestamp<span>)</span> <span>{</span>\n    <span>.</span><span>.</span><span>.</span>\n    <span>if</span> <span>(</span><span>uint32_t</span><span>(</span>type<span>)</span> <span>&lt;</span> DisplayDevice<span>::</span>NUM_DISPLAY_TYPES<span>)</span> <span>{</span>\n        <span>// we should only receive DisplayDevice::DisplayType from the vsync callback        </span>\n        mEventThread<span>-></span><span>onVSyncReceived</span><span>(</span>type<span>,</span> timestamp<span>)</span><span>;</span> <span>// EventThread 是什么？</span>\n    <span>}</span>\n<span>}</span>\n</code></pre></div><p><code>SurfaceFlinger</code> 直接调用了 <code>EventThread</code> 的 <code>onVSyncReceived</code> 实现。</p>\n<p>从名称上可以猜测到，<code>EventThread</code> 是 <code>SurfaceFilnger</code> 中专门用于处理事件的线程。这个 <code>EventThread</code> 线程对象是在 <code>SurfaceFlinger::readyToRun</code> 生成的：</p>\n<div><pre><code>status_t <span>SurfaceFlinger</span><span>::</span><span>readyToRun</span><span>(</span><span>)</span>\n<span>{</span>\n    <span>.</span><span>.</span><span>.</span>\n    mEventThread <span>=</span> <span>new</span> <span>EventThread</span><span>(</span><span>this</span><span>)</span><span>;</span>\n    mEventQueue<span>.</span><span>setEventThread</span><span>(</span>mEventThread<span>)</span><span>;</span> <span>// EventQueue 与 EventThread 进行了绑定</span>\n</code></pre></div><p><code>EventThread</code> 的启动并不是由 <code>SurfaceFlinger</code> 决定的，而是取决于引用它的人，因为 <code>EventThread</code> 继承自 <code>Thread</code>，后者又是 <code>RefBase</code> 的子类，所以当第一次有人用智能指针引用它时，会自动调用 <code>onFirstRef</code> 函数，继而把这个线程 <code>run</code> 起来。</p>\n<blockquote>\n<p><code>EventThread</code> 线程优先级为 <code>PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE</code>。</p>\n</blockquote>\n<blockquote>\n<p>高版本的差异：</p>\n<div><pre><code>SurfaceFlinger 不再直接引用 EventThread， 而是把 EventThread 保存在了 Scheduler::mConnections 中，\nScheduler::mConnects 是一个 Map 集合，存放 &lt;ConnectionHandle, Connection> 键值对，\n键值对中，Connection 持有 EventThread 对象的引用。外界通过 ConnectionHandle 从 Scheduler 中获取 Connection。\n\n涉及到的函数：\n    Scheduler::createEventThread\n    Scheduler::createConnection\n    EventThread::createEventConnection\n</code></pre></div></blockquote>\n<p>介绍了 <code>EventThread</code> 的创建和启动过程后，再来看看它是如何处理消息的：</p>\n<div><pre><code><span>/* frameworks/native/services/surfaceflinger/EventThread.cpp*/</span>\n<span>void</span> <span>EventThread</span><span>::</span><span>onVSyncReceived</span><span>(</span><span>int</span> type<span>,</span> nsecs_t timestamp<span>)</span> <span>{</span>…    \n    Mutex<span>::</span>Autolock <span>_l</span><span>(</span>mLock<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>type <span>&lt;</span> HWC_NUM_DISPLAY_TYPES<span>)</span> <span>{</span> <span>// 显示类型目前有两种</span>\n        mVSyncEvent<span>[</span>type<span>]</span><span>.</span>header<span>.</span>type <span>=</span> DisplayEventReceiver<span>::</span>DISPLAY_EVENT_VSYNC<span>;</span>\n        mVSyncEvent<span>[</span>type<span>]</span><span>.</span>header<span>.</span>id <span>=</span> type<span>;</span>\n        mVSyncEvent<span>[</span>type<span>]</span><span>.</span>header<span>.</span>timestamp <span>=</span> timestamp<span>;</span>\n        mVSyncEvent<span>[</span>type<span>]</span><span>.</span>vsync<span>.</span>count<span>++</span><span>;</span>\n        mCondition<span>.</span><span>broadcast</span><span>(</span><span>)</span><span>;</span> <span>// 条件满足，唤醒谁？</span>\n    <span>}</span>\n<span>}</span>\n</code></pre></div><p><code>EventThread::onVSyncReceived</code> 函数对 <code>mVSyncEvent[type]</code> 数组中的 <code>DisplayEventReceiver::Event</code> 对象的成员进行数据填充（包括：<code>Event</code> 类型、时间戳、信号计数等）。</p>\n<p>最重要的是，<code>EventThread::onVSyncReceived</code> 函数最后通过 <code>mCondition.broadcast()</code> 来通知等待 <code>Event</code> 的人 —— 会是谁呢？没错，是 <code>EventThread</code> 所在的线程。</p>\n<p>可能有人会觉得奇怪，<code>onVSyncReceived</code> 不就是属于 <code>EventThread</code> 吗，怎么还能处于等待中？</p>\n<div><pre><code>由上面的分析可以看出，\nEventThread::onVSyncReceived 其实是由 SurfaceFlinger 所在线程调用的，所以它的执行也是由 SurfaceFlinger 所在线程完成的。\n不过 onVSyncReceived 并没有对信号做具体的处理。打个比方：\n    SurfaceFlinger 线程只是到了 EventThread 家的厨房（onVSyncReceived）里，\n    然后把 “食材” 通过 DisplayEventReceiver::Event 准备好，放在 mVSyncEvent 中，\n    然后唤醒正在等待的 EventThread —— 东西都准备好了，开动吧！\n    于是接下来的处理工作就正式移交到 EventThread 线程了。\n</code></pre></div><p>这点我们从下面这个代码段中也能得到验证：</p>\n<div><pre><code><span>bool</span> <span>EventThread</span><span>::</span><span>threadLoop</span><span>(</span><span>)</span> <span>{</span>\n    DisplayEventReceiver<span>::</span>Event event<span>;</span>\n    Vector<span>&lt;</span> sp<span>&lt;</span>EventThread<span>::</span>Connection<span>>></span> signalConnections<span>;</span>\n    signalConnections <span>=</span> <span>waitForEvent</span><span>(</span><span>&amp;</span>event<span>)</span><span>;</span> <span>// EventThread 就是在这里面开始等待的</span>\n    <span>const</span> size_t count <span>=</span> signalConnections<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>\n    <span>for</span> <span>(</span>size_t i<span>=</span><span>0</span> <span>;</span> i<span>&lt;</span>count <span>;</span> i<span>++</span><span>)</span> <span>{</span> <span>// 开始 dispatch 消息给所有感兴趣的人</span>\n        <span>const</span> sp<span>&lt;</span>Connection<span>></span><span>&amp;</span> <span>conn</span><span>(</span>signalConnections<span>[</span>i<span>]</span><span>)</span><span>;</span>\n        status_t err <span>=</span> conn<span>-></span><span>postEvent</span><span>(</span>event<span>)</span><span>;</span> <span>// 通过 Connection “通道” 通知对方</span>\n        <span>.</span><span>.</span><span>.</span>\n    <span>}</span>\n    <span>return</span> <span>true</span><span>;</span> <span>// 返回 true 后系统将再次调用 threadLoop</span>\n<span>}</span>\n</code></pre></div><blockquote>\n<p>高版本的代码存在差异，但流程类似：</p>\n<div><pre><code><span>/* frameworks/native/services/surfaceflinger/Scheduler/EventThread.cpp */</span>\n<span>void</span> <span>EventThread</span><span>::</span><span>threadMain</span><span>(</span>std<span>::</span>unique_lock<span>&lt;</span>std<span>::</span>mutex<span>></span><span>&amp;</span> lock<span>)</span> <span>{</span>\n    DisplayEventConsumers consumers<span>;</span>\n\n    <span>while</span> <span>(</span>mState <span>!=</span> State<span>::</span>Quit<span>)</span> <span>{</span>\n        std<span>::</span>optional<span>&lt;</span>DisplayEventReceiver<span>::</span>Event<span>></span> event<span>;</span>\n\n        <span>// Determine next event to dispatch.</span>\n        <span>if</span> <span>(</span><span>!</span>mPendingEvents<span>.</span><span>empty</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            event <span>=</span> mPendingEvents<span>.</span><span>front</span><span>(</span><span>)</span><span>;</span>\n            mPendingEvents<span>.</span><span>pop_front</span><span>(</span><span>)</span><span>;</span>\n            <span>.</span><span>.</span><span>.</span>\n        <span>}</span>\n        <span>.</span><span>.</span><span>.</span>\n        <span>if</span> <span>(</span><span>!</span>consumers<span>.</span><span>empty</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            <span>dispatchEvent</span><span>(</span><span>*</span>event<span>,</span> consumers<span>)</span><span>;</span> <span>// dispatch 消息给所有感兴趣的人</span>\n            consumers<span>.</span><span>clear</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>.</span><span>.</span><span>.</span>\n        <span>if</span> <span>(</span><span>!</span>mPendingEvents<span>.</span><span>empty</span><span>(</span><span>)</span><span>)</span> <span>{</span> <span>// mPendingEvents 中还有未处理完的 DisplayEventReceiver::Event</span>\n            <span>continue</span><span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>mState <span>==</span> State<span>::</span>Idle<span>)</span> <span>{</span>\n            mCondition<span>.</span><span>wait</span><span>(</span>lock<span>)</span><span>;</span> <span>// 等待 VSync 信号的到来</span>\n        <span>}</span> \n        <span>.</span><span>.</span><span>.</span>\n    <span>}</span>\n    <span>// cancel any pending vsync event before exiting</span>\n    mVsyncRegistration<span>.</span><span>cancel</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre></div></blockquote>\n<p><code>EventThread</code> 线程在 <code>mCondition.broadcast()</code> 得到唤醒。接着 <code>EventThread</code> 会统计所有对 <code>Event</code> 感兴趣的人，即记录在 <code>signalConnections</code> 中的元素。然后它通过与这些元素间的纽带（<code>Connection</code>）来通知它们有事件发生了。</p>\n<p>变量 <code>signalConnections</code> 是在 <code>waitForEvent</code> 中准备的，根据 <code>Event</code> 的实际情况从 <code>EventThread</code> 的全局变量 <code>mDisplayEventConnections</code> 中挑选出来的。换句话说，所有对 <code>Event</code> 感兴趣的人都需要被记录到 <code>mDisplayEventConnections</code> 中。具体而言，有两种类型的 “忠实听众”：</p>\n<div><pre><code>1. SurfaceFlinger\n毋庸置疑，SurfaceFlinger 一定会收听 VSync 信号的产生。\n这一工作由它内部的 EventQueue，即 “事件队列管家” 来完成。\n当 SurfaceFlinger::readyToRun 中生成 EventThread 对象后，\n会马上调用 MessageQueue::setEventThread 来把它设置到内部的 mEventThread 变量中；\n同时，MessageQueue 还会通过接口 EventThread::createEventConnection 来创建一个 Connection 连接。\n\n2. 需要刷新 UI 的各进程\nSurfaceFlinger 只是负责最后的 UI 数据合成，而各应用程序才是真正的数据生产者，所以它们也必定是要监听 VSync 信号的。\nSurfaceFlinger 提供了 createDisplayEventConnection 接口来满足各应用程序的需求，\n这个接口同样调用了 EventThread::createEventConnection 来创建一个 Connection 连接。\n</code></pre></div><p>那么，什么情况下这些创建的 <code>Connection</code> 会添加到 <code>EventThread</code> 的 <code>mDisplayEventConnections</code> 中呢？</p>\n<div><pre><code>当这些 Connection 被第一次引用的时候，它会自动调用 registerDisplayEventConnection 来注册到 EventThread 中。\n</code></pre></div><h3 id=\"_7-2-vsync-信号的处理\" tabindex=\"-1\"> 7.2 <code>VSync</code> 信号的处理</h3>\n<p>经过上一小节的分析，现在我们已经明白了系统是如何通过硬件设备或者软件模拟来产生 <code>VSync</code> 信号了，也明白了它的流转过程。</p>\n<p><code>VSync</code> 最终会被 <code>EventThread::threadLoop()</code> 分发给各监听者，如 <code>SurfaceFlinger</code> 进程中就是 <code>MessageQueue</code>。<code>MessageQueue</code> 通过与 <code>EventThread</code> 建立一个 <code>Connection</code> 来监听事件。</p>\n<div><pre><code>对 VSYNC 等事件感兴趣的对象（如 MessageQueue），\n首先要通过调用接口 EventThread::createEventConnection() 来建立一个连接（应用进程是间接由 SurfaceFlinger 完成的），\n实际上就是生成了一个 EventThread::Connection 对象。这个对象将对双方产生如下影响：\n\n影响1：\n当 Connection::onFirstRef() 时，即 “连接” 第一次被引用时，\n它会主动调用 EventThread::registerDisplayEventConnection() 来把自己添加到 EventThread 的 mDisplayEventConnections 中，\n这是保证事件发生后 EventThread 能找到符合要求的 “连接” 的关键一步。\n\n影响2：\n当 MessageQueue 得到 Connection 后，它会马上调用 getDataChannel 来获得一个 BitTube。\n从逻辑关系上看，Connection 只是双方业务上的连接，而 BitTube 则是数据传输通道，各种 Event 信息就是通过这里传输的。\n</code></pre></div><p>下面以 <code>MessageQueue</code> 为例来分析各个进程是如何与 <code>MessageThread</code> 进行交互的：</p>\n<div><pre><code><span>void</span> <span>MessageQueue</span><span>::</span><span>setEventThread</span><span>(</span><span>const</span> sp<span>&lt;</span>EventThread<span>></span><span>&amp;</span> eventThread<span>)</span>\n<span>{</span>\n    mEventThread <span>=</span> eventThread<span>;</span>\n    mEvents <span>=</span> eventThread<span>-></span><span>createEventConnection</span><span>(</span><span>)</span><span>;</span> <span>// 建立一个 Connection</span>\n    mEventTube <span>=</span> mEvents<span>-></span><span>getDataChannel</span><span>(</span><span>)</span><span>;</span> <span>// 立即获取 BitTube</span>\n    mLooper<span>-></span><span>addFd</span><span>(</span>mEventTube<span>-></span><span>getFd</span><span>(</span><span>)</span><span>,</span><span>0</span><span>,</span>\n                    ALOOPER_EVENT_INPUT<span>,</span>MessageQueue<span>::</span>cb_eventReceiver<span>,</span> <span>this</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre></div><p>从扮演的角色来看，<code>EventThread</code> 是 <code>Server</code>，不断地往 <code>Tube</code> 中写入数据；而 <code>MessageQueue</code> 是 <code>Client</code>，负责读取数据。</p>\n<blockquote>\n<p><code>MessageQueue</code> 如何得知有 <code>Event</code> 到来，然后去读取它呢？答案就是它们之间的数据读写模式采用的是 <code>Socket</code>（<code>AF_UNIX</code> 域）。</p>\n</blockquote>\n<p>上面这个函数的末尾通过 <code>Looper</code> 添加了一个 <code>fd</code>，这实际上就是 <code>Socket Pair</code> 中的一端。\n然后 <code>Looper</code> 将这个 <code>fd</code> 与其 <code>callback</code> 函数（即 <code>MessageQueue::cb_eventReceiver</code>）加入全局的 <code>mRequests</code> 进行管理：</p>\n<div><pre><code>KeyedVector<span>&lt;</span><span>int</span><span>,</span> Request<span>></span> mRequests<span>;</span>\n</code></pre></div><p>这个 <code>mRequests</code> 集合中会持有所有需要监测的 <code>fd</code>。这样当 <code>Looper</code> 进行 <code>pollInner</code> 时，只要有事件需要处理，它就可以通过 <code>callback</code> 函数通知 “接收者”。这里面的实现细节主要包括 <code>BitTube.cpp</code> 和 <code>Looper.cpp</code> 两个源文件。</p>\n<p>当 <code>Event</code> 发生后，<code>MessageQueue::cb_eventReceiver</code> 开始执行，进而调用 <code>eventReceiver</code>。如果 <code>event</code> 的类型是 <code>DisplayEventReceiver::DISPLAY_EVENT_VSYNC</code>，则正是我们想要监听的事件。这时会有两种情况：</p>\n<div><pre><code><span>if</span> <span>(</span>buffer<span>[</span>i<span>]</span><span>.</span>header<span>.</span>type <span>==</span> DisplayEventReceiver<span>::</span>DISPLAY_EVENT_VSYNC<span>)</span>\n<span>{</span>\n<span><span>#</span><span>if</span> <span>INVALIDATE_ON_VSYNC</span></span>\n    mHandler<span>-></span><span>dispatchInvalidate</span><span>(</span><span>)</span><span>;</span>\n<span><span>#</span><span>else</span></span>\n    mHandler<span>-></span><span>dispatchRefresh</span><span>(</span><span>)</span><span>;</span>\n<span><span>#</span><span>endif</span></span>\n</code></pre></div><p>宏 <code>INVALIDATE_ON_VSYNC</code> 默认情况下被 <code>define</code> 为 1，什么意思呢？</p>\n<div><pre><code>我们知道在把 UI 刷新到屏幕上（refresh）之前，各 UI 进程需要先准备好数据（invalidate）。分两种情况：\n1. SurfaceFlinger 在 VSYNC 来临时再做数据的准备工作，然后立即刷新到屏幕上；\n2. 平常就开始准备，而当 VSYNC 来临时把数据刷新到屏幕上。\n\n当 INVALIDATE_ON_VSYNC 为 1 时，程序执行情况 1 的操作；否则就是情况 2。\n</code></pre></div><p>函数 <code>dispatchInvalidate</code> 和 <code>dispatchRefresh</code> 在 <code>SurfaceFlinger</code> 中的处理过程是有一定差异的，对比如下表所示。</p>\n<table>\n    <tr>\n        <th>dispatchInvalidate</th>\n        <th>dispatchRefresh</th>\n    </tr>\n    <tr>\n        <td>\n            case MessageQueue::INVALIDATE:<br/>\n            &nbsp;&nbsp;&nbsp;&nbsp;handleMessageTransaction();<br/>\n            &nbsp;&nbsp;&nbsp;&nbsp;handleMessageInvalidate();<br/>\n            &nbsp;&nbsp;&nbsp;&nbsp;signalRefresh();\n        </td>\n        <td>\n            case MessageQueue::REFRESH:<br/>\n            &nbsp;&nbsp;&nbsp;&nbsp;handleMessageRefresh();\n        </td>\n    </tr>\n</table>\n<p>先来看看 <code>handleMessageRefresh</code> 所要做的工作（这也是我们后续几个小节的阐述重点）：</p>\n<div><pre><code><span>void</span> <span>SurfaceFlinger</span><span>::</span><span>handleMessageRefresh</span><span>(</span><span>)</span> <span>{</span>\n    <span>ATRACE_CALL</span><span>(</span><span>)</span><span>;</span>    \n    <span>preComposition</span><span>(</span><span>)</span><span>;</span> <span>// 合成前的准备</span>\n    <span>rebuildLayerStacks</span><span>(</span><span>)</span><span>;</span> <span>// 重新建立 Layer 堆栈</span>\n    <span>setUpHWComposer</span><span>(</span><span>)</span><span>;</span> <span>// HWComposer 的设定</span>\n    <span>doDebugFlashRegions</span><span>(</span><span>)</span><span>;</span>\n    <span>doComposition</span><span>(</span><span>)</span><span>;</span> <span>// 正式的合成工作</span>\n    <span>postComposition</span><span>(</span><span>)</span><span>;</span> <span>//合成后期工作</span>\n<span>}</span>\n</code></pre></div><p>整个 <code>UI</code> 合成过程包括了如上几个函数，再加上 <code>handleMessageTransaction</code>、<code>handleMessageInvalidate</code>，基本涵盖了 <code>SurfaceFlinger</code> 的所有功能。</p>\n<blockquote>\n<p>从分发 <code>VSync</code> 信号，到进行 <code>UI</code> 合成过程，高版本中的差异较大，后续再更新。</p>\n</blockquote>\n",
      "date_published": "2024-04-30T10:39:15.000Z",
      "date_modified": "2024-04-30T10:39:15.000Z",
      "authors": [],
      "tags": [
        "朗国科技"
      ]
    },
    {
      "title": "第1章 音视频基础概念",
      "url": "https://zengkaiqiang562.github.io/zkq/books/audio-video-development-advance-guide/_01_audio_video_basic.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/audio-video-development-advance-guide/_01_audio_video_basic.html",
      "content_html": "",
      "date_published": "2024-03-15T13:10:42.000Z",
      "date_modified": "2024-03-15T13:10:42.000Z",
      "authors": [],
      "tags": [
        "音视频"
      ]
    },
    {
      "title": "第2章 移动端环境搭建",
      "url": "https://zengkaiqiang562.github.io/zkq/books/audio-video-development-advance-guide/_02_mobile_env_build.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/audio-video-development-advance-guide/_02_mobile_env_build.html",
      "content_html": "",
      "date_published": "2024-03-15T13:10:42.000Z",
      "date_modified": "2024-03-15T13:10:42.000Z",
      "authors": [],
      "tags": [
        "音视频"
      ]
    },
    {
      "title": "第3章 FFmpeg的介绍与使用",
      "url": "https://zengkaiqiang562.github.io/zkq/books/audio-video-development-advance-guide/_03_ffmpeg_introduce_usage.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/audio-video-development-advance-guide/_03_ffmpeg_introduce_usage.html",
      "content_html": "",
      "date_published": "2024-03-15T13:10:42.000Z",
      "date_modified": "2024-03-15T13:10:42.000Z",
      "authors": [],
      "tags": [
        "音视频"
      ]
    },
    {
      "title": "第4章 移动平台下的音视频渲染",
      "url": "https://zengkaiqiang562.github.io/zkq/books/audio-video-development-advance-guide/_04_mobile_platform_audio_video_render.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/audio-video-development-advance-guide/_04_mobile_platform_audio_video_render.html",
      "content_html": "",
      "date_published": "2024-03-15T13:10:42.000Z",
      "date_modified": "2024-03-15T13:10:42.000Z",
      "authors": [],
      "tags": [
        "音视频"
      ]
    },
    {
      "title": "第5章 实现一款视频播放器",
      "url": "https://zengkaiqiang562.github.io/zkq/books/audio-video-development-advance-guide/_05_make_video_player.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/audio-video-development-advance-guide/_05_make_video_player.html",
      "content_html": "",
      "date_published": "2024-03-15T13:10:42.000Z",
      "date_modified": "2024-03-15T13:10:42.000Z",
      "authors": [],
      "tags": [
        "音视频"
      ]
    },
    {
      "title": "第6章 音视频的采集与编码",
      "url": "https://zengkaiqiang562.github.io/zkq/books/audio-video-development-advance-guide/_06_audio_video_sample_encoder.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/audio-video-development-advance-guide/_06_audio_video_sample_encoder.html",
      "content_html": "",
      "date_published": "2024-03-15T13:10:42.000Z",
      "date_modified": "2024-03-15T13:10:42.000Z",
      "authors": [],
      "tags": [
        "音视频"
      ]
    },
    {
      "title": "第7章 实现一款视频录制应用",
      "url": "https://zengkaiqiang562.github.io/zkq/books/audio-video-development-advance-guide/_07_make_video_recorder.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/audio-video-development-advance-guide/_07_make_video_recorder.html",
      "content_html": "",
      "date_published": "2024-03-15T13:10:42.000Z",
      "date_modified": "2024-03-15T13:10:42.000Z",
      "authors": [],
      "tags": [
        "音视频"
      ]
    },
    {
      "title": "第8章 音频效果器的介绍与实践",
      "url": "https://zengkaiqiang562.github.io/zkq/books/audio-video-development-advance-guide/_08_audio_effector_introduce_practice.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/audio-video-development-advance-guide/_08_audio_effector_introduce_practice.html",
      "content_html": "",
      "date_published": "2024-03-15T13:10:42.000Z",
      "date_modified": "2024-03-15T13:10:42.000Z",
      "authors": [],
      "tags": [
        "音视频"
      ]
    },
    {
      "title": "第9章 视频效果器的介绍与实践",
      "url": "https://zengkaiqiang562.github.io/zkq/books/audio-video-development-advance-guide/_09_video_effector_introduce_practice.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/audio-video-development-advance-guide/_09_video_effector_introduce_practice.html",
      "content_html": "",
      "date_published": "2024-03-15T13:10:42.000Z",
      "date_modified": "2024-03-15T13:10:42.000Z",
      "authors": [],
      "tags": [
        "音视频"
      ]
    },
    {
      "title": "第10章 专业的视频录制应用实践",
      "url": "https://zengkaiqiang562.github.io/zkq/books/audio-video-development-advance-guide/_10_pro_video_recorder_practice.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/audio-video-development-advance-guide/_10_pro_video_recorder_practice.html",
      "content_html": "",
      "date_published": "2024-03-15T13:10:42.000Z",
      "date_modified": "2024-03-15T13:10:42.000Z",
      "authors": [],
      "tags": [
        "音视频"
      ]
    },
    {
      "title": "第11章 直播应用的构建",
      "url": "https://zengkaiqiang562.github.io/zkq/books/audio-video-development-advance-guide/_11_live_app_build.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/audio-video-development-advance-guide/_11_live_app_build.html",
      "content_html": "",
      "date_published": "2024-03-15T13:10:42.000Z",
      "date_modified": "2024-03-15T13:10:42.000Z",
      "authors": [],
      "tags": [
        "音视频"
      ]
    },
    {
      "title": "第12章 直播应用中的关键处理",
      "url": "https://zengkaiqiang562.github.io/zkq/books/audio-video-development-advance-guide/_12_live_app_key_handle.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/audio-video-development-advance-guide/_12_live_app_key_handle.html",
      "content_html": "",
      "date_published": "2024-03-15T13:10:42.000Z",
      "date_modified": "2024-03-15T13:10:42.000Z",
      "authors": [],
      "tags": [
        "音视频"
      ]
    },
    {
      "title": "广告变现方案",
      "url": "https://zengkaiqiang562.github.io/zkq/hnap/general/ad_realize.html",
      "id": "https://zengkaiqiang562.github.io/zkq/hnap/general/ad_realize.html",
      "content_html": "<h2 id=\"_1-admob-sdk-集成-max-中介\" tabindex=\"-1\"> 1. <code>Admob SDK</code> 集成 <code>MAX</code> 中介</h2>\n<blockquote>\n<p>参考 <a href=\"https://developers.google.com/admob/android/mediate?hl=zh-cn\" target=\"_blank\" rel=\"noopener noreferrer\">AdMob 中介功能<ExternalLinkIcon/></a></p>\n<p>参考 <a href=\"https://developers.google.com/admob/android/mediation/applovin?hl=zh-cn#supported_integrations_and_ad_formats\" target=\"_blank\" rel=\"noopener noreferrer\">集成 MAX 中介<ExternalLinkIcon/></a></p>\n<p>注意：<code>Applovin</code> 可以像 <code>Admob</code> 一样作为广告源，此时需要接入 <code>Applovin MAX SDK</code>；也可以仅仅只作为一种广告中介，此时一般称之为 <code>MAX</code> 中介。</p>\n</blockquote>\n<p>接入 <code>MAX</code> 中介只需在集成了 <code>Admob SDK</code> 的基础上添加依赖即可：</p>\n<div><pre><code><span>/* Admob SDK */</span>\n<span>implementation</span><span>(</span><span><span>\"com.google.android.gms:play-services-ads:22.2.0\"</span></span><span>)</span>\n<span>/* MAX 中介 */</span>\n<span>implementation</span><span>(</span><span><span>\"com.google.ads.mediation:applovin:11.11.1.0\"</span></span><span>)</span>\n</code></pre></div><p><strong>注意：</strong></p>\n<div><pre><code>1. Admob SDK 和 MAX 中介的依赖版本都升级到最新的。\n2. 《集成 MAX 中介》 文档中的可选步骤不需要处理。\n3. 通过中介请求广告，需要在 Admob SDK 初始化完成后才会请求到。因此，在启动加载过程中若广告请求失败，需要不断请求。\n</code></pre></div><h2 id=\"_2-接入-applovin-max-sdk-并集成-meta-和-mintergal-中介\" tabindex=\"-1\"> 2. 接入 <code>Applovin MAX SDK</code>，并集成 <code>Meta</code> 和 <code>Mintergal</code> 中介</h2>\n<h3 id=\"_2-1-添加-applovin-max-sdk-依赖并初始化\" tabindex=\"-1\"> 2.1 添加 <code>Applovin MAX SDK</code> 依赖并初始化</h3>\n<blockquote>\n<p>参考 <a href=\"https://dash.applovin.com/documentation/mediation/android/getting-started/integration\" target=\"_blank\" rel=\"noopener noreferrer\">Applovin MAX SDK 集成<ExternalLinkIcon/></a></p>\n</blockquote>\n<p><strong>添加依赖：</strong></p>\n<div><pre><code><span>implementation</span><span>(</span><span><span>\"com.applovin:applovin-sdk:11.11.2\"</span></span><span>)</span>\n</code></pre></div><p><strong>配置 <code>SDK KEY</code></strong></p>\n<div><pre><code><span>&lt;!-- \n    AndroidManifest.xml 的 &lt;application> 标签下\n    注意：SKD密钥格式是84位的字符串，开发阶段可以随机生成一个84位字符串即可\n --></span>\n<span><span><span>&lt;</span>meta-data</span> <span><span>android:</span>name</span><span><span>=</span><span>\"</span>applovin.sdk.key<span>\"</span></span>\n           <span><span>android:</span>value</span><span><span>=</span><span>\"</span>YOUR_SDK_KEY_HERE<span>\"</span></span><span>/></span></span>\n</code></pre></div><p><strong>初始化</strong></p>\n<div><pre><code><span>private</span> <span>void</span> <span>initApplovin</span><span>(</span><span>Application</span> application<span>)</span> <span>{</span>\n\n    <span>AppLovinSdk</span><span>.</span><span>getInstance</span><span>(</span>application<span>)</span><span>.</span><span>getSettings</span><span>(</span><span>)</span><span>.</span><span>setVerboseLogging</span><span>(</span><span>HealthConfig</span><span>.</span>HEALTH_DEBUG<span>)</span><span>;</span> <span>// 是否打开调试日志</span>\n\n    <span>// Make sure to set the mediation provider value to \"max\" to ensure proper functionality</span>\n    <span>AppLovinSdk</span><span>.</span><span>getInstance</span><span>(</span>application<span>)</span><span>.</span><span>setMediationProvider</span><span>(</span><span>\"max\"</span><span>)</span><span>;</span>\n    <span>AppLovinSdk</span><span>.</span><span>initializeSdk</span><span>(</span>application<span>,</span> <span>new</span> <span>AppLovinSdk<span>.</span>SdkInitializationListener</span><span>(</span><span>)</span> <span>{</span>\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onSdkInitialized</span><span>(</span><span>final</span> <span>AppLovinSdkConfiguration</span> configuration<span>)</span> <span>{</span>\n            <span>// AppLovin SDK is initialized, start loading ads</span>\n            <span>LogUtils</span><span>.</span><span>e</span><span>(</span>TAG<span>,</span> <span>\"--> initApplovin()  onSdkInitialized  configuration=\"</span> <span>+</span> configuration<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span> <span>)</span><span>;</span>\n<span>}</span>\n</code></pre></div><h3 id=\"_2-2-集成-banner-广告\" tabindex=\"-1\"> 2.2 集成 <code>banner</code> 广告</h3>\n<blockquote>\n<p>参考 <a href=\"https://dash.applovin.com/documentation/mediation/android/ad-formats/banners\" target=\"_blank\" rel=\"noopener noreferrer\">Banners<ExternalLinkIcon/></a></p>\n</blockquote>\n<div><pre><code><span>@Override</span>\n<span>protected</span> <span>boolean</span> <span>showBanAd</span><span>(</span><span>Activity</span> activity<span>,</span> <span>@Nullable</span> <span>ViewGroup</span> container<span>)</span> <span>{</span>\n    <span>.</span><span>.</span><span>.</span>\n\n    <span>MaxAdView</span> maxAdView <span>=</span> <span>new</span> <span>MaxAdView</span><span>(</span>unitBean<span>.</span><span>getId</span><span>(</span><span>)</span><span>,</span> activity<span>)</span><span>;</span>\n\n    maxAdView<span>.</span><span>setPlacement</span><span>(</span>placeBean<span>.</span><span>getPlace</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// 设置广告位名称</span>\n\n    maxAdView<span>.</span><span>setRequestListener</span><span>(</span><span>new</span> <span>MaxAdRequestListener</span><span>(</span><span>)</span> <span>{</span> <span>// 设置开始请求的监听</span>\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onAdRequestStarted</span><span>(</span><span>String</span> adUnitId<span>)</span> <span>{</span>\n            <span>LogUtils</span><span>.</span><span>e</span><span>(</span>TAG<span>,</span> <span>\"-->  onAdRequestStarted() MaxAdView adUnitId=\"</span> <span>+</span> adUnitId<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span><span>)</span><span>;</span>\n\n    maxAdView<span>.</span><span>setRevenueListener</span><span>(</span><span>new</span> <span>MaxAdRevenueListener</span><span>(</span><span>)</span> <span>{</span> <span>// 设置广告价值的监听</span>\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onAdRevenuePaid</span><span>(</span><span>MaxAd</span> maxAd<span>)</span> <span>{</span>\n            <span>LogUtils</span><span>.</span><span>e</span><span>(</span>TAG<span>,</span> <span>\"-->  onAdRevenuePaid() MaxAdView  maxAd=\"</span> <span>+</span> maxAd<span>)</span><span>;</span>\n            <span>// 上报广告价值</span>\n            <span>AdjustAdRevenue</span> adjustAdRevenue <span>=</span> <span>new</span> <span>AdjustAdRevenue</span><span>(</span> <span>AdjustConfig</span><span>.</span>AD_REVENUE_APPLOVIN_MAX <span>)</span><span>;</span>\n            adjustAdRevenue<span>.</span><span>setRevenue</span><span>(</span>maxAd<span>.</span><span>getRevenue</span><span>(</span><span>)</span><span>,</span> <span>\"USD\"</span><span>)</span><span>;</span>\n            adjustAdRevenue<span>.</span><span>setAdRevenueNetwork</span><span>(</span>maxAd<span>.</span><span>getNetworkName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            adjustAdRevenue<span>.</span><span>setAdRevenueUnit</span><span>(</span>maxAd<span>.</span><span>getAdUnitId</span><span>(</span><span>)</span> <span>)</span><span>;</span>\n            adjustAdRevenue<span>.</span><span>setAdRevenuePlacement</span><span>(</span>maxAd<span>.</span><span>getPlacement</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>Adjust</span><span>.</span><span>trackAdRevenue</span><span>(</span>adjustAdRevenue<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span><span>)</span><span>;</span>\n\n    maxAdView<span>.</span><span>setListener</span><span>(</span><span>new</span> <span>MaxAdViewAdListener</span><span>(</span><span>)</span> <span>{</span>\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onAdExpanded</span><span>(</span><span>MaxAd</span> maxAd<span>)</span> <span>{</span>\n            <span>LogUtils</span><span>.</span><span>e</span><span>(</span>TAG<span>,</span> <span>\"-->  onAdExpanded() MaxAdView  maxAd=\"</span> <span>+</span> maxAd<span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onAdCollapsed</span><span>(</span><span>MaxAd</span> maxAd<span>)</span> <span>{</span>\n            <span>LogUtils</span><span>.</span><span>e</span><span>(</span>TAG<span>,</span> <span>\"-->  onAdCollapsed() MaxAdView  maxAd=\"</span> <span>+</span> maxAd<span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onAdLoaded</span><span>(</span><span>MaxAd</span> maxAd<span>)</span> <span>{</span> <span>// 广告请求成功的回调</span>\n            <span>LogUtils</span><span>.</span><span>e</span><span>(</span>TAG<span>,</span> <span>\"--> onAdLoaded() MaxAdView  maxAd=\"</span> <span>+</span> maxAd<span>)</span><span>;</span>\n            <span>.</span><span>.</span><span>.</span>\n        <span>}</span>\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onAdLoadFailed</span><span>(</span><span>String</span> s<span>,</span> <span>MaxError</span> maxError<span>)</span> <span>{</span> <span>// 广告请求失败的回调</span>\n            <span>LogUtils</span><span>.</span><span>e</span><span>(</span>TAG<span>,</span> <span>\"--> onAdLoadFailed() MaxAdView maxError=\"</span> <span>+</span> maxError<span>)</span><span>;</span>\n            status <span>=</span> <span>Status</span><span>.</span>PULL_FAILED<span>;</span>\n            <span>int</span> code <span>=</span> maxError<span>.</span><span>getCode</span><span>(</span><span>)</span><span>;</span>\n            <span>String</span> message <span>=</span> maxError<span>.</span><span>getMessage</span><span>(</span><span>)</span><span>;</span>\n            <span>int</span> mediatedNetworkErrorCode <span>=</span> maxError<span>.</span><span>getMediatedNetworkErrorCode</span><span>(</span><span>)</span><span>;</span>\n            <span>String</span> mediatedNetworkErrorMessage <span>=</span> maxError<span>.</span><span>getMediatedNetworkErrorMessage</span><span>(</span><span>)</span><span>;</span>\n            <span>String</span> errorMsg <span>=</span> <span>String</span><span>.</span><span>format</span><span>(</span><span>Locale</span><span>.</span><span>getDefault</span><span>(</span><span>)</span><span>,</span> <span>\"code: %d, message: %s, mediatedNetworkErrorCode: %d, mediatedNetworkErrorMessage: %s\"</span><span>,</span>\n                    code<span>,</span> message<span>,</span> mediatedNetworkErrorCode<span>,</span> mediatedNetworkErrorMessage<span>)</span><span>;</span>\n            <span>if</span> <span>(</span>listener <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n                listener<span>.</span><span>onPullFailed</span><span>(</span><span>MaxResource</span><span>.</span><span>this</span><span>,</span> code<span>,</span> errorMsg<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        \n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onAdDisplayed</span><span>(</span><span>MaxAd</span> maxAd<span>)</span> <span>{</span> <span>// 广告展示成功的回调</span>\n            <span>LogUtils</span><span>.</span><span>e</span><span>(</span>TAG<span>,</span> <span>\"--> onAdDisplayed() MaxAdView  maxAd=\"</span> <span>+</span> maxAd<span>)</span><span>;</span>\n            status <span>=</span> <span>Status</span><span>.</span>SHOW<span>;</span>\n            <span>if</span> <span>(</span>listener <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n                listener<span>.</span><span>onShow</span><span>(</span><span>MaxResource</span><span>.</span><span>this</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onAdHidden</span><span>(</span><span>MaxAd</span> maxAd<span>)</span> <span>{</span> <span>// 广告展示后隐藏的回调</span>\n            <span>LogUtils</span><span>.</span><span>e</span><span>(</span>TAG<span>,</span> <span>\"--> onAdHidden() MaxAdView  maxAd=\"</span> <span>+</span> maxAd<span>)</span><span>;</span>\n            status <span>=</span> <span>Status</span><span>.</span>DISMISS<span>;</span>\n            <span>if</span> <span>(</span>listener <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n                listener<span>.</span><span>onDismiss</span><span>(</span><span>MaxResource</span><span>.</span><span>this</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onAdClicked</span><span>(</span><span>MaxAd</span> maxAd<span>)</span> <span>{</span>\n            <span>LogUtils</span><span>.</span><span>e</span><span>(</span>TAG<span>,</span> <span>\"--> onAdClicked() MaxAdView  maxAd=\"</span> <span>+</span> maxAd<span>)</span><span>;</span>\n            <span>EventTracker</span><span>.</span><span>traceAdClick</span><span>(</span>unitBean<span>.</span><span>getId</span><span>(</span><span>)</span><span>,</span> placeBean<span>.</span><span>getPlace</span><span>(</span><span>)</span><span>,</span> maxAd<span>.</span><span>getNetworkName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span>listener <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n                listener<span>.</span><span>onClick</span><span>(</span><span>MaxResource</span><span>.</span><span>this</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onAdDisplayFailed</span><span>(</span><span>MaxAd</span> maxAd<span>,</span> <span>MaxError</span> maxError<span>)</span> <span>{</span> <span>// 广告展示失败的回调</span>\n            <span>LogUtils</span><span>.</span><span>e</span><span>(</span>TAG<span>,</span> <span>\"--> onAdDisplayFailed() MaxAdView maxAd=\"</span> <span>+</span> maxAd <span>+</span> <span>\"  maxError=\"</span> <span>+</span> maxError<span>)</span><span>;</span>\n            status <span>=</span> <span>Status</span><span>.</span>UNSHOW<span>;</span>\n            <span>int</span> code <span>=</span> maxError<span>.</span><span>getCode</span><span>(</span><span>)</span><span>;</span>\n            <span>String</span> message <span>=</span> maxError<span>.</span><span>getMessage</span><span>(</span><span>)</span><span>;</span>\n            <span>int</span> mediatedNetworkErrorCode <span>=</span> maxError<span>.</span><span>getMediatedNetworkErrorCode</span><span>(</span><span>)</span><span>;</span>\n            <span>String</span> mediatedNetworkErrorMessage <span>=</span> maxError<span>.</span><span>getMediatedNetworkErrorMessage</span><span>(</span><span>)</span><span>;</span>\n            <span>String</span> errorMsg <span>=</span> <span>String</span><span>.</span><span>format</span><span>(</span><span>Locale</span><span>.</span><span>getDefault</span><span>(</span><span>)</span><span>,</span> <span>\"code: %d, message: %s, mediatedNetworkErrorCode: %d, mediatedNetworkErrorMessage: %s\"</span><span>,</span>\n                    code<span>,</span> message<span>,</span> mediatedNetworkErrorCode<span>,</span> mediatedNetworkErrorMessage<span>)</span><span>;</span>\n            <span>if</span> <span>(</span>listener <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n                listener<span>.</span><span>onUnshow</span><span>(</span><span>MaxResource</span><span>.</span><span>this</span><span>,</span> code<span>,</span> errorMsg<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span><span>)</span><span>;</span>\n\n    maxAdView<span>.</span><span>setExtraParameter</span><span>(</span> <span>\"allow_pause_auto_refresh_immediately\"</span><span>,</span> <span>\"true\"</span> <span>)</span><span>;</span>\n    maxAdView<span>.</span><span>stopAutoRefresh</span><span>(</span><span>)</span><span>;</span> <span>// banner 广告请求前先停止自动刷新</span>\n\n    status <span>=</span> <span>Status</span><span>.</span>PULLING<span>;</span>\n\n    maxAdView<span>.</span><span>loadAd</span><span>(</span><span>)</span><span>;</span>\n    <span>int</span> widthPx <span>=</span> container<span>.</span><span>getLayoutParams</span><span>(</span><span>)</span><span>.</span>width<span>;</span>\n    <span>if</span> <span>(</span>widthPx <span>&lt;=</span> <span>0</span><span>)</span> <span>{</span>\n        widthPx <span>=</span> <span>ScreenUtils</span><span>.</span><span>getScreenWidth</span><span>(</span><span>)</span><span>;</span> <span>// dp</span>\n    <span>}</span>\n    <span>int</span> heightPx <span>=</span> <span>ConvertUtils</span><span>.</span><span>dp2px</span><span>(</span><span>50</span><span>)</span><span>;</span>\n    maxAdView<span>.</span><span>setLayoutParams</span><span>(</span><span>new</span> <span>FrameLayout<span>.</span>LayoutParams</span><span>(</span>widthPx<span>,</span> heightPx<span>)</span><span>)</span><span>;</span> <span>// 设置 banner 广告的尺寸</span>\n\n    maxAdView<span>.</span><span>setBackgroundColor</span><span>(</span><span>Color</span><span>.</span><span>parseColor</span><span>(</span><span>\"#FFFFE7D6\"</span><span>)</span><span>)</span><span>;</span> <span>// 设置 banner 广告的背景</span>\n\n    container<span>.</span><span>removeAllViews</span><span>(</span><span>)</span><span>;</span>\n    container<span>.</span><span>addView</span><span>(</span>maxAdView<span>)</span><span>;</span>\n\n    maxAdView<span>.</span><span>startAutoRefresh</span><span>(</span><span>)</span><span>;</span> <span>// 开始自动刷新</span>\n    ad <span>=</span> <span>(</span><span>T</span><span>)</span> maxAdView<span>;</span>\n    <span>return</span> <span>true</span><span>;</span>\n<span>}</span>\n</code></pre></div><h3 id=\"_2-3-集成原生广告\" tabindex=\"-1\"> 2.3 集成原生广告</h3>\n<blockquote>\n<p>参考：<a href=\"https://dash.applovin.com/documentation/mediation/android/ad-formats/native-manual\" target=\"_blank\" rel=\"noopener noreferrer\">Native Ads (Manual)<ExternalLinkIcon/></a></p>\n</blockquote>\n<p><strong>请求广告</strong></p>\n<div><pre><code><span>@Override</span>\n<span>protected</span> <span>void</span> <span>pullNavAd</span><span>(</span><span>)</span> <span>{</span>\n\n    maxNativeAdLoader <span>=</span> <span>new</span> <span>MaxNativeAdLoader</span><span>(</span>unitBean<span>.</span><span>getId</span><span>(</span><span>)</span><span>,</span> <span>LifecyclerManager</span><span>.</span>INSTANCE<span>.</span><span>getApplication</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\n    maxNativeAdLoader<span>.</span><span>setPlacement</span><span>(</span>placeBean<span>.</span><span>getPlace</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// 设置广告位名称</span>\n\n    maxNativeAdLoader<span>.</span><span>setRevenueListener</span><span>(</span><span>new</span> <span>MaxAdRevenueListener</span><span>(</span><span>)</span> <span>{</span> <span>// 设置广告价值的监听</span>\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onAdRevenuePaid</span><span>(</span><span>MaxAd</span> maxAd<span>)</span> <span>{</span>\n            <span>LogUtils</span><span>.</span><span>e</span><span>(</span>TAG<span>,</span> <span>\"-->  onAdRevenuePaid() MaxNativeAd  maxAd=\"</span> <span>+</span> maxAd<span>)</span><span>;</span>\n            <span>// 上报广告价值</span>\n            <span>AdjustAdRevenue</span> adjustAdRevenue <span>=</span> <span>new</span> <span>AdjustAdRevenue</span><span>(</span> <span>AdjustConfig</span><span>.</span>AD_REVENUE_APPLOVIN_MAX <span>)</span><span>;</span>\n            adjustAdRevenue<span>.</span><span>setRevenue</span><span>(</span>maxAd<span>.</span><span>getRevenue</span><span>(</span><span>)</span><span>,</span> <span>\"USD\"</span><span>)</span><span>;</span>\n            adjustAdRevenue<span>.</span><span>setAdRevenueNetwork</span><span>(</span>maxAd<span>.</span><span>getNetworkName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            adjustAdRevenue<span>.</span><span>setAdRevenueUnit</span><span>(</span>maxAd<span>.</span><span>getAdUnitId</span><span>(</span><span>)</span> <span>)</span><span>;</span>\n            adjustAdRevenue<span>.</span><span>setAdRevenuePlacement</span><span>(</span>maxAd<span>.</span><span>getPlacement</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>Adjust</span><span>.</span><span>trackAdRevenue</span><span>(</span>adjustAdRevenue<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span><span>)</span><span>;</span>\n\n    maxNativeAdLoader<span>.</span><span>setNativeAdListener</span><span>(</span><span>new</span> <span>MaxNativeAdListener</span><span>(</span><span>)</span> <span>{</span>\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onNativeAdLoaded</span><span>(</span><span>@Nullable</span> <span>MaxNativeAdView</span> maxNativeAdView<span>,</span> <span>MaxAd</span> maxAd<span>)</span> <span>{</span> <span>// 广告请求成功的回调</span>\n            <span>LogUtils</span><span>.</span><span>e</span><span>(</span>TAG<span>,</span> <span>\"--> onNativeAdLoaded() MaxNativeAd nativeAd=\"</span> <span>+</span> maxAd<span>)</span><span>;</span>\n            status <span>=</span> <span>Status</span><span>.</span>PULL_SUCCESS<span>;</span>\n            timeLoaded <span>=</span> <span>SystemClock</span><span>.</span><span>elapsedRealtime</span><span>(</span><span>)</span><span>;</span>\n            <span>EventTracker</span><span>.</span><span>traceAdPullSuccess</span><span>(</span>unitBean<span>.</span><span>getId</span><span>(</span><span>)</span><span>,</span> placeBean<span>.</span><span>getPlace</span><span>(</span><span>)</span><span>,</span> maxAd<span>.</span><span>getNetworkName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            ad <span>=</span> <span>(</span><span>T</span><span>)</span> maxAd<span>;</span>\n            <span>if</span> <span>(</span>listener <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n                listener<span>.</span><span>onPullSuccess</span><span>(</span><span>MaxResource</span><span>.</span><span>this</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onNativeAdLoadFailed</span><span>(</span><span>String</span> s<span>,</span> <span>MaxError</span> maxError<span>)</span> <span>{</span> <span>// 广告请求失败的回调</span>\n            <span>LogUtils</span><span>.</span><span>e</span><span>(</span>TAG<span>,</span> <span>\"--> onNativeAdLoadFailed() MaxNativeAd maxError=\"</span> <span>+</span> maxError<span>)</span><span>;</span>\n            status <span>=</span> <span>Status</span><span>.</span>PULL_FAILED<span>;</span>\n            <span>int</span> code <span>=</span> maxError<span>.</span><span>getCode</span><span>(</span><span>)</span><span>;</span>\n            <span>String</span> message <span>=</span> maxError<span>.</span><span>getMessage</span><span>(</span><span>)</span><span>;</span>\n            <span>int</span> mediatedNetworkErrorCode <span>=</span> maxError<span>.</span><span>getMediatedNetworkErrorCode</span><span>(</span><span>)</span><span>;</span>\n            <span>String</span> mediatedNetworkErrorMessage <span>=</span> maxError<span>.</span><span>getMediatedNetworkErrorMessage</span><span>(</span><span>)</span><span>;</span>\n            <span>String</span> errorMsg <span>=</span> <span>String</span><span>.</span><span>format</span><span>(</span><span>Locale</span><span>.</span><span>getDefault</span><span>(</span><span>)</span><span>,</span> <span>\"code: %d, message: %s, mediatedNetworkErrorCode: %d, mediatedNetworkErrorMessage: %s\"</span><span>,</span>\n                    code<span>,</span> message<span>,</span> mediatedNetworkErrorCode<span>,</span> mediatedNetworkErrorMessage<span>)</span><span>;</span>\n            <span>if</span> <span>(</span>listener <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n                listener<span>.</span><span>onPullFailed</span><span>(</span><span>MaxResource</span><span>.</span><span>this</span><span>,</span> code<span>,</span> errorMsg<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onNativeAdClicked</span><span>(</span><span>MaxAd</span> maxAd<span>)</span> <span>{</span>\n            <span>LogUtils</span><span>.</span><span>e</span><span>(</span>TAG<span>,</span> <span>\"--> onAdClicked()\"</span><span>)</span><span>;</span>\n            <span>EventTracker</span><span>.</span><span>traceAdClick</span><span>(</span>unitBean<span>.</span><span>getId</span><span>(</span><span>)</span><span>,</span> placeBean<span>.</span><span>getPlace</span><span>(</span><span>)</span><span>,</span> maxAd<span>.</span><span>getNetworkName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span>listener <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n                listener<span>.</span><span>onClick</span><span>(</span><span>MaxResource</span><span>.</span><span>this</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onNativeAdExpired</span><span>(</span><span>MaxAd</span> maxAd<span>)</span> <span>{</span> <span>// 广告过期的回调</span>\n            status <span>=</span>  <span>Status</span><span>.</span>EXPIRED<span>;</span>\n            <span>if</span> <span>(</span>listener <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n                listener<span>.</span><span>onExpired</span><span>(</span><span>MaxResource</span><span>.</span><span>this</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span><span>)</span><span>;</span>\n\n    maxNativeAdLoader<span>.</span><span>loadAd</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre></div><p><strong>展示广告</strong></p>\n<div><pre><code><span>&lt;!-- 原生广告的布局文件 --></span>\n<span>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?></span>\n<span><span><span>&lt;</span>androidx.constraintlayout.widget.ConstraintLayout</span> <span><span>xmlns:</span>android</span><span><span>=</span><span>\"</span>http://schemas.android.com/apk/res/android<span>\"</span></span>\n    <span><span>xmlns:</span>app</span><span><span>=</span><span>\"</span>http://schemas.android.com/apk/res-auto<span>\"</span></span>\n    <span><span>xmlns:</span>tools</span><span><span>=</span><span>\"</span>http://schemas.android.com/tools<span>\"</span></span>\n    <span>...</span><span>></span></span>\n\n    <span><span><span>&lt;</span>FrameLayout</span>\n        <span><span>android:</span>id</span><span><span>=</span><span>\"</span>@id/ad_media<span>\"</span></span>\n        <span>...</span><span>/></span></span>\n\n    <span><span><span>&lt;</span>ImageView</span>\n        <span><span>android:</span>id</span><span><span>=</span><span>\"</span>@id/ad_app_icon<span>\"</span></span>\n        <span>...</span> <span>/></span></span>\n\n    <span><span><span>&lt;</span>TextView</span>\n        <span><span>android:</span>id</span><span><span>=</span><span>\"</span>@+id/tv_ad<span>\"</span></span>\n        <span>...</span>\n        <span><span>android:</span>text</span><span><span>=</span><span>\"</span>@string/ad<span>\"</span></span>\n        <span>/></span></span>\n\n    <span><span><span>&lt;</span>TextView</span>\n        <span><span>android:</span>id</span><span><span>=</span><span>\"</span>@+id/ad_headline<span>\"</span></span>\n        <span>...</span><span>/></span></span>\n\n    <span><span><span>&lt;</span>TextView</span>\n        <span><span>android:</span>id</span><span><span>=</span><span>\"</span>@+id/ad_body<span>\"</span></span>\n        <span>...</span><span>/></span></span>\n\n    <span><span><span>&lt;</span>Button</span>\n        <span><span>android:</span>id</span><span><span>=</span><span>\"</span>@+id/ad_call_to_action<span>\"</span></span>\n        <span>...</span>\n        <span><span>android:</span>text</span><span><span>=</span><span>\"</span>@string/install<span>\"</span></span><span>/></span></span>\n\n<span><span><span>&lt;/</span>androidx.constraintlayout.widget.ConstraintLayout</span><span>></span></span>\n</code></pre></div><div><pre><code><span>// 原生广告的展示代码</span>\n<span>@Override</span>\n<span>protected</span> <span>boolean</span> <span>showNavAd</span><span>(</span><span>Activity</span> activity<span>,</span> <span>@Nullable</span> <span>ViewGroup</span> container<span>,</span> <span>@NonNull</span> <span>NativeAdViewCreator</span> creator<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>container <span>==</span> <span>null</span><span>)</span> <span>{</span>\n        <span>return</span> <span>false</span><span>;</span>\n    <span>}</span>\n    <span>MaxAd</span> nativeAd <span>=</span> <span>(</span><span>MaxAd</span><span>)</span> ad<span>;</span>\n    <span>if</span> <span>(</span>maxNativeAdLoader <span>==</span> <span>null</span> <span>||</span> nativeAd<span>.</span><span>getNativeAd</span><span>(</span><span>)</span> <span>==</span> <span>null</span> <span>||</span> nativeAd<span>.</span><span>getNativeAd</span><span>(</span><span>)</span><span>.</span><span>isExpired</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n        status <span>=</span> <span>Status</span><span>.</span>UNSHOW<span>;</span>\n        <span>if</span> <span>(</span>listener <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n            <span>String</span> errorMsg <span>=</span> <span>\"errorMsg: {\"</span> <span>+</span> <span>\" maxNativeAdLoader=\"</span> <span>+</span> maxNativeAdLoader <span>+</span> <span>\"  nativeAd=\"</span> <span>+</span>nativeAd<span>.</span><span>getNativeAd</span><span>(</span><span>)</span> <span>+</span> <span>\"}\"</span><span>;</span>\n            listener<span>.</span><span>onUnshow</span><span>(</span><span>MaxResource</span><span>.</span><span>this</span><span>,</span> <span>-</span><span>1</span><span>,</span> errorMsg<span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> <span>false</span><span>;</span>\n    <span>}</span>\n\n    <span>MaxNativeAdView</span> maxNativeAdView <span>=</span> creator<span>.</span><span>create</span><span>(</span><span>Provider</span><span>.</span>MAX<span>,</span> activity<span>)</span><span>;</span>\n    <span>// 从 nativeAd 中获取原生广告的资源（图片，标题，文本等），渲染到视图 MaxNativeAdView 中</span>\n    maxNativeAdLoader<span>.</span><span>render</span><span>(</span>maxNativeAdView<span>,</span> nativeAd<span>)</span><span>;</span>\n\n    container<span>.</span><span>removeAllViews</span><span>(</span><span>)</span><span>;</span>\n    container<span>.</span><span>addView</span><span>(</span>maxNativeAdView<span>)</span><span>;</span>\n\n    status <span>=</span> <span>Status</span><span>.</span>SHOW<span>;</span>\n    <span>if</span> <span>(</span>listener <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n        listener<span>.</span><span>onShow</span><span>(</span><span>MaxResource</span><span>.</span><span>this</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> <span>true</span><span>;</span>\n<span>}</span>\n\n\n<span>public</span> <span>abstract</span> <span>class</span> <span>NativeAdViewCreator</span> <span>{</span>\n\n    <span>private</span> <span>static</span> <span>final</span> <span>String</span> TAG <span>=</span> <span>\"NativeAdViewCreator\"</span><span>;</span>\n\n    <span>// 用于渲染 Admob 原生广告</span>\n    <span>NativeAdView</span> <span>create</span><span>(</span><span>Provider</span> provider<span>,</span> <span>NativeAd</span> ad<span>,</span> <span>Activity</span> activity<span>)</span> <span>{</span>\n        <span>return</span> <span>AdmobNavRender</span><span>.</span><span>render</span><span>(</span><span>getLayoutId</span><span>(</span>provider<span>)</span><span>,</span> <span>hasMediaView</span><span>(</span><span>)</span><span>,</span> ad<span>,</span> activity<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>// 用于渲染 Max 原生广告</span>\n    <span>public</span> <span>MaxNativeAdView</span> <span>create</span><span>(</span><span>Provider</span> provider<span>,</span> <span>Activity</span> activity<span>)</span> <span>{</span>\n        <span>return</span> <span>MaxNavRender</span><span>.</span><span>render</span><span>(</span><span>getLayoutId</span><span>(</span>provider<span>)</span><span>,</span> <span>hasMediaView</span><span>(</span><span>)</span><span>,</span> activity<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>protected</span> <span>abstract</span> <span>boolean</span> <span>hasMediaView</span><span>(</span><span>)</span><span>;</span>\n\n    <span>protected</span> <span>abstract</span> <span>@LayoutRes</span> <span>int</span> <span>getLayoutId</span><span>(</span><span>Provider</span> provider<span>)</span><span>;</span>\n<span>}</span>\n\n\n<span>public</span> <span>class</span> <span>MaxNavRender</span> <span>{</span>\n\n    <span>public</span> <span>static</span> <span>MaxNativeAdView</span> <span>render</span><span>(</span><span>int</span> layoutId<span>,</span> <span>boolean</span> hasMediaView<span>,</span> <span>Activity</span> activity<span>)</span> <span>{</span>\n\n        <span>MaxNativeAdViewBinder<span>.</span>Builder</span> builder <span>=</span> <span>new</span> <span>MaxNativeAdViewBinder<span>.</span>Builder</span><span>(</span>layoutId<span>)</span><span>;</span>\n\n        builder<span>.</span><span>setTitleTextViewId</span><span>(</span><span>R</span><span>.</span>id<span>.</span>ad_headline<span>)</span><span>;</span>\n        builder<span>.</span><span>setBodyTextViewId</span><span>(</span><span>R</span><span>.</span>id<span>.</span>ad_body<span>)</span><span>;</span>\n        builder<span>.</span><span>setIconImageViewId</span><span>(</span><span>R</span><span>.</span>id<span>.</span>ad_app_icon<span>)</span><span>;</span>\n        builder<span>.</span><span>setCallToActionButtonId</span><span>(</span><span>R</span><span>.</span>id<span>.</span>ad_call_to_action<span>)</span><span>;</span> <span>// Button</span>\n\n        <span>if</span> <span>(</span>hasMediaView<span>)</span> <span>{</span>\n            builder<span>.</span><span>setMediaContentViewGroupId</span><span>(</span><span>R</span><span>.</span>id<span>.</span>ad_media<span>)</span><span>;</span> <span>// FrameLayout</span>\n        <span>}</span>\n\n        <span>MaxNativeAdViewBinder</span> binder <span>=</span> builder<span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>\n        <span>return</span> <span>new</span> <span>MaxNativeAdView</span><span>(</span>binder<span>,</span> activity<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre></div><h3 id=\"_2-4-集成其他类型的广告\" tabindex=\"-1\"> 2.4 集成其他类型的广告</h3>\n<blockquote>\n<p>参考：<a href=\"https://dash.applovin.com/documentation/mediation/android/ad-formats/app-open\" target=\"_blank\" rel=\"noopener noreferrer\">集成开屏广告<ExternalLinkIcon/></a></p>\n<p>参考：<a href=\"https://dash.applovin.com/documentation/mediation/android/ad-formats/interstitials\" target=\"_blank\" rel=\"noopener noreferrer\">集成插页广告<ExternalLinkIcon/></a></p>\n<p>参考：<a href=\"https://dash.applovin.com/documentation/mediation/android/ad-formats/rewarded-ads\" target=\"_blank\" rel=\"noopener noreferrer\">集成激励广告<ExternalLinkIcon/></a></p>\n</blockquote>\n<h3 id=\"_2-5-集成-meta-和-mintergal-中介\" tabindex=\"-1\"> 2.5 集成 <code>Meta</code> 和 <code>Mintergal</code> 中介</h3>\n<p>类似于 <code>Admob SDK</code> 集成 <code>MAX</code> 中介，<code>Applovin MAX SDK</code> 集成 <code>Meta</code> 和 <code>Mintergal</code> 中介也是只需要添加依赖即可。</p>\n<div><pre><code><span>/* Applovin SDK 的依赖 */</span>\n<span>implementation</span><span>(</span><span><span>\"com.applovin:applovin-sdk:11.11.2\"</span></span><span>)</span>\n\n<span>/* Meta 中介的依赖 */</span>\n<span>implementation</span><span>(</span><span><span>\"com.applovin.mediation:facebook-adapter:6.15.0.0\"</span></span><span>)</span>\n\n<span>/* Mintergal 中介的依赖 */</span>\n<span>implementation</span><span>(</span><span><span>\"com.applovin.mediation:mintegral-adapter:16.4.91.0\"</span></span><span>)</span>\n</code></pre></div>",
      "date_published": "2023-08-29T07:58:48.000Z",
      "date_modified": "2023-08-29T07:58:48.000Z",
      "authors": [],
      "tags": [
        "HNAP"
      ]
    },
    {
      "title": "C448代码评审报告",
      "url": "https://zengkaiqiang562.github.io/zkq/hnap/code_review/c448.html",
      "id": "https://zengkaiqiang562.github.io/zkq/hnap/code_review/c448.html",
      "content_html": "<h2 id=\"_1-代码结构和组织\" tabindex=\"-1\"> 1. 代码结构和组织</h2>\n<p>代码结构清晰，组织合理。界面与数据的处理基本分离。单个类的分工明确，未发现代码臃肿的情况。</p>\n<h2 id=\"_2-可读性和可维护性\" tabindex=\"-1\"> 2. 可读性和可维护性</h2>\n<p>代码的可读性较高，关键代码注释清晰，程序结构的命名比较规范的，但还存在硬编码的情况。</p>\n<h2 id=\"_3-错误处理和异常处理\" tabindex=\"-1\"> 3. 错误处理和异常处理</h2>\n<p>代码中对于错误和异常的处理较为完善。对于可能出现的错误情况进行了合理的判断和处理，并且在必要的地方抛出了适当的异常。\n但在多线程环境下，异步更新 <code>UI</code> 时，应该多考虑下界面的生命周期，以提高代码的健壮性和容错性。</p>\n<h2 id=\"_4-性能和效率\" tabindex=\"-1\"> 4. 性能和效率</h2>\n<p>代码在性能和效率方面表现良好。但一些细节还可以做得更好，比如 <code>if-else</code> 条件语句中相同类型的赋值语句，可以共用同一个局部变量。\n可以共用的类型不要多次 <code>new</code>，如 <code>Handler</code> 可以作为成员变量，不要局部 <code>new Handler</code></p>\n<h2 id=\"_5-安全性\" tabindex=\"-1\"> 5. 安全性</h2>\n<p>代码在安全性方面没有明显的问题。测试环境中没有出现任何的正式环境配置。</p>\n<h2 id=\"_6-评审建议\" tabindex=\"-1\"> 6. 评审建议</h2>\n<p><strong>1. 尽量避免出现硬编码，变量名应起得有意义</strong></p>\n<p><img src=\"@source/zkq/hnap/code_review/images/c448/01.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>2. 异步更新 <code>UI</code> 时，应该先判断 <code>Activity</code> 的生命周期是否已销毁</strong></p>\n<blockquote>\n<p>采用 <code>EventBus</code>、<code>Handler</code> 等方式异步更新 <code>UI</code> 时，应该先判断 <code>Activity</code> 的生命周期是否已销毁。在销毁后，不应该再进行 <code>UI</code> 的更新。</p>\n</blockquote>\n<p><img src=\"@source/zkq/hnap/code_review/images/c448/02.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>3. 非构造方法的方法名不建议以大写字母开头，建议采用下划线或小写字母开头</strong></p>\n<p><img src=\"@source/zkq/hnap/code_review/images/c448/03.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>4. <code>Activity</code> 中的 <code>Handler</code> 用于延迟/定时任务时，应该保证在 <code>Activity</code> 销毁时也会被销毁掉，否则会出现内存泄露</strong></p>\n<p><img src=\"@source/zkq/hnap/code_review/images/c448/04.png\" alt=\"\" loading=\"lazy\"></p>\n<p>总体而言，评审人员对该代码的质量较为满意。代码结构清晰，组织合理，可读性和可维护性较高，错误处理和异常处理较为完善，性能和效率表现良好，安全性方面也没有明显的问题。评审人员建议在某些地方进行一些改进和优化，以进一步提高代码的质量和性能。</p>\n",
      "date_published": "2023-08-28T03:24:14.000Z",
      "date_modified": "2023-08-28T03:24:14.000Z",
      "authors": [],
      "tags": [
        "HNAP"
      ]
    },
    {
      "title": "C462代码评审报告",
      "url": "https://zengkaiqiang562.github.io/zkq/hnap/code_review/c462.html",
      "id": "https://zengkaiqiang562.github.io/zkq/hnap/code_review/c462.html",
      "content_html": "",
      "date_published": "2023-08-28T03:24:14.000Z",
      "date_modified": "2023-08-28T03:24:14.000Z",
      "authors": [],
      "tags": [
        "HNAP"
      ]
    },
    {
      "title": "远程打包方案",
      "url": "https://zengkaiqiang562.github.io/zkq/hnap/general/remote_pack.html",
      "id": "https://zengkaiqiang562.github.io/zkq/hnap/general/remote_pack.html",
      "content_html": "<blockquote>\n<p>参考：<a href=\"https://github.com/zengkaiqiang562/HNAP_VpnTemplate\" target=\"_blank\" rel=\"noopener noreferrer\">远程打包方案示例代码<ExternalLinkIcon/></a></p>\n</blockquote>\n<h2 id=\"_1-项目结构介绍\" tabindex=\"-1\"> 1. 项目结构介绍</h2>\n<p><img src=\"@source/zkq/hnap/general/images/remote_pack/01.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_1-1-module-模块介绍\" tabindex=\"-1\"> 1.1 <code>Module</code> 模块介绍</h3>\n<p>项目结构如上所示，至少需要三个 <code>Module</code>：</p>\n<div><pre><code>1. app：项目代码\n2. buildSrc：Gralde 本地插件，提供各种属性和修改包路径结构\n3. libconfig：封装 buildSrc 提供的各种属性，集中管理，方便维护\n</code></pre></div><p><code>Module</code> 模块中的文件结构如下：</p>\n<p><img src=\"@source/zkq/hnap/general/images/remote_pack/02.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>注意：跟默认结构不同的是，<code>main</code> 目录下多了 <code>debug</code> 目录，代码文件、资源文件、布局文件、<code>jni</code> 文件、混淆文件都放在了 <code>main/debug</code> 目录下。</strong></p>\n<blockquote>\n<p>这样做的目的是为了区别正式环境的所有文件，因为正式环境的文件都会在 <code>Gradle Sync</code> 后生成在 <code>main/release</code> 目录下。</p>\n</blockquote>\n<h3 id=\"_1-2-配置文件介绍\" tabindex=\"-1\"> 1.2 配置文件介绍</h3>\n<p><strong>一些重要的配置文件介绍如下：</strong></p>\n<div><pre><code>1. deploy.json：\n    定义项目所需的属性，这些属性会在 buildSrc 插件中进行解析\n    该文件不能提交到 git 仓库中\n\n2. config.json：\n    放置本地内置的全局配置数据\n    该文件不能提交到 git 仓库中\n\n3. app/google-services.json：\n    集成 firebase 所需的文件\n    注意：测试环境下，该文件并不是产品提供的，而是自己按内容格式胡乱定义的，目的只是为了在测试环境下集成 firebase 后能编译通过\n    该文件不能提交到 git 仓库中\n\n4. xxx.jks\n    测试环境下的签名文件\n    该文件不能提交到 git 仓库中\n\n5. template.ovpn\n    提供 vpn 证书信息，只有在 VPN 项目中才需提供这个文件\n    注意：文件内容并不是完整的 ovpn 文件内容，而是截取从 &lt;ca> 到文件结尾这部分的内容\n</code></pre></div><h3 id=\"_1-3-gitinore-中需要忽略的文件\" tabindex=\"-1\"> 1.3 <code>.gitinore</code> 中需要忽略的文件</h3>\n<p><code>.gitignore</code> 文件内容如下：</p>\n<blockquote>\n<p>注意：新项目一定要记得修改 <code>.gitignore</code> 文件，不要把测试环境相关的配置提交到 <code>git</code> 仓库中。</p>\n</blockquote>\n<div><pre><code>*.iml\n.gradle/\n.idea/\n.DS_Store\nbuild/\ncaptures/\n.externalNativeBuild/\n.cxx/\nlocal.properties\napp/release/\nconfig.json\ndeploy.json\n*.jks\ngoogle-services.json\ndefine.cmake\n*/src/main/release/\n</code></pre></div><h2 id=\"_2-集成步骤\" tabindex=\"-1\"> 2. 集成步骤</h2>\n<h3 id=\"_2-1-在项目中创建所需的配置文件\" tabindex=\"-1\"> 2.1 在项目中创建所需的配置文件</h3>\n<h4 id=\"_2-1-1-创建-deploy-json-文件\" tabindex=\"-1\"> 2.1.1 创建 <code>deploy.json</code> 文件</h4>\n<div><pre><code><span>{</span>\n    <span>\"outputName\"</span><span>:</span> <span>\"vpn\"</span><span>,</span> <span>// 声明 aab 文件的名称为：&lt;outputName>-&lt;versionName>-&lt;versionCode>.aab</span>\n    <span>\"versionName\"</span><span>:</span> <span>\"1.0.0\"</span><span>,</span>\n    <span>\"versionCode\"</span><span>:</span> <span>1</span><span>,</span>\n  \n    <span>\"zipwd\"</span><span>:</span> <span>\"123456\"</span><span>,</span> <span>// 声明将 aab 文件压缩后得到的同名 zip 文件的解压密码</span>\n  \n    <span>\"signPwd\"</span><span>:</span> <span>\"xxx\"</span><span>,</span> <span>// 声明签名文件的密码</span>\n    <span>\"signPath\"</span><span>:</span> <span>\"xxx.jks\"</span><span>,</span> <span>// 声明签名文件的路径</span>\n\n    <span>\"enableLog\"</span><span>:</span> <span>true</span><span>,</span> <span>// 是否打印日志（正式环境打包时需置为 false）</span>\n    <span>// 是否允许 firebase 上传混淆映射文件 mapping.txt （测试环境置为 false，因为测试环境无法上传，会导致编译失败）</span>\n    <span>\"uploadMappingFile\"</span><span>:</span> <span>false</span><span>,</span> \n    <span>\"debug\"</span><span>:</span> <span>true</span><span>,</span> <span>// 区分测试环境和正式环境：测试环境置为 true，正式环境置为 false。</span>\n  \n    <span>\"debugPkgName\"</span><span>:</span> <span>\"com.template.vpn\"</span><span>,</span> <span>// 声明测试包名</span>\n    <span>\"releasePkgName\"</span><span>:</span> <span>\"com.proxy.vpn\"</span><span>,</span> <span>// 声明正式包名</span>\n    <span>\"debugLibPrefix\"</span><span>:</span> <span>\"com.template\"</span><span>,</span> <span>// 声明测试环境下 lib 模块的包路径前缀</span>\n    <span>\"releaseLibPrefix\"</span><span>:</span> <span>\"com.proxy\"</span><span>,</span> <span>// 声明正式环境下 lib 模块的包路径前缀</span>\n  \n    <span>\"debugMainDir\"</span><span>:</span> <span>\"src/main/debug\"</span><span>,</span> <span>// 声明测试环境下的 main 目录路径</span>\n    <span>\"releaseMainDir\"</span><span>:</span> <span>\"src/main/release\"</span><span>,</span>  <span>// 声明正式环境下的 main 目录路径</span>\n  \n    <span>\"facebookId\"</span><span>:</span> <span>\"222222222222222\"</span><span>,</span> <span>// 声明 Facebook 的应用 id</span>\n    <span>\"facebookToken\"</span><span>:</span> <span>\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"</span><span>,</span> <span>// 声明 Facebook 的 token</span>\n    <span>\"adjustToken\"</span><span>:</span> <span>\"{YourAppToken}\"</span><span>,</span> <span>// 声明 Adjust 的 token</span>\n    <span>\"admobId\"</span><span>:</span> <span>\"ca-app-pub-3940256099942544~3347511713\"</span><span>,</span> <span>// 声明 Admob 的应用 id</span>\n  \n    <span>\"urlPrivacy\"</span><span>:</span> <span>\"https://xxx/privacy\"</span><span>,</span> <span>// 隐私协议 url</span>\n    <span>\"urlTerms\"</span><span>:</span> <span>\"https://xxx/term\"</span><span>,</span> <span>// 服务条款 url</span>\n    <span>\"emailFeedback\"</span><span>:</span> <span>\"xxx@xxx.com\"</span><span>,</span> <span>// 反馈邮箱</span>\n  \n    <span>\"baseUrl\"</span><span>:</span> <span>\"http://baseUrl/\"</span><span>,</span> <span>// 后台接口域名</span>\n    <span>\"pathConfig\"</span><span>:</span> <span>\"/pathConfig\"</span><span>,</span> <span>// 请求全局配置的 path 路径</span>\n    <span>\"pathVpnNodeList\"</span><span>:</span> <span>\"/pathVpnNodeList\"</span><span>,</span> <span>// vp 项目中请求 vps 列表的 path 路径</span>\n    <span>\"pathVpnNodeInfo\"</span><span>:</span> <span>\"/pathVpnNodeInfo\"</span><span>,</span>  <span>// vp 项目中上报 vps 连接状态的 path 路径</span>\n  \n    <span>// 后台给的用于接口请求的签名字符串，如果不提供该属性，则会根据 jks 签名文件自动生成一个签名字符串</span>\n    <span>\"fixSign\"</span><span>:</span> <span>\"757vhrf9mbvustbwx6g1ex1otu68vn8o\"</span><span>,</span> \n    <span>\"ckey\"</span><span>:</span> <span>\"eSV1FDdfzDlDVQTU\"</span><span>,</span> <span>// 后台给的用于接口请求的客户端 key</span>\n    <span>\"civ\"</span><span>:</span> <span>\"A\"</span><span>,</span> <span>// 后台给的用于接口请求的客户端 iv</span>\n    <span>\"skey\"</span><span>:</span> <span>\"s9enGjjZm3yeGiZn\"</span><span>,</span> <span>// 后台给的用于接口请求的服务端 key</span>\n    <span>\"siv\"</span><span>:</span> <span>\"A\"</span> <span>// 后台给的用于接口请求的服务端 iv</span>\n<span>}</span>\n</code></pre></div><h4 id=\"_2-1-2-创建-config-json-文件\" tabindex=\"-1\"> 2.1.2 创建 <code>config.json</code> 文件</h4>\n<p><strong>注意：</strong> <code>config.json</code> 文件中的内容建议只包含后台接口文档中的基本出参内的响应体部分。（这个跟自己在解析全局配置时的代码相关，请参考自己的代码确定是否需要导入完整的出参数据）</p>\n<div><pre><code><span>{</span>\n  <span>\"strategies\"</span><span>:</span> <span>[</span>...<span>]</span><span>,</span>\n  <span>\"ext_enable\"</span><span>:</span> <span>true</span><span>,</span>\n  <span>\"outerAds\"</span><span>:</span> <span>[</span>...<span>]</span><span>,</span>\n  <span>\"load_duration\"</span><span>:</span> <span>10</span><span>,</span>\n  <span>\"config_duration\"</span><span>:</span> <span>1</span><span>,</span>\n  <span>\"country\"</span><span>:</span> <span>\"US\"</span>\n<span>}</span>\n</code></pre></div><h4 id=\"_2-1-3-创建-app-google-services-json-文件\" tabindex=\"-1\"> 2.1.3 创建 <code>app/google-services.json</code> 文件</h4>\n<p><strong>注意：</strong> 在测试环境中集成 firebase 时，需要提供 <code>google-services.json</code> 文件，否则无法编译通过。</p>\n<p>而正式环境的 <code>google-services.json</code> 文件禁止在测试环境中出现，所以我们可以自己按照内容格式胡乱地定义内容数据，只要保证包名与测试报名对应上即可。</p>\n<div><pre><code><span>{</span>\n  <span>\"project_info\"</span><span>:</span> <span>{</span>\n    <span>\"project_number\"</span><span>:</span> <span>\"545454545454\"</span><span>,</span>\n    <span>\"project_id\"</span><span>:</span> <span>\"abab-ababa\"</span><span>,</span>\n    <span>\"storage_bucket\"</span><span>:</span> <span>\"abab-ababa.dfdfdfd.com\"</span>\n  <span>}</span><span>,</span>\n  <span>\"client\"</span><span>:</span> <span>[</span>\n    <span>{</span>\n      <span>\"client_info\"</span><span>:</span> <span>{</span>\n        <span>\"mobilesdk_app_id\"</span><span>:</span> <span>\"1:545454545454:android:ererererererererererer\"</span><span>,</span>\n        <span>\"android_client_info\"</span><span>:</span> <span>{</span>\n          <span>\"package_name\"</span><span>:</span> <span>\"com.template.vpn\"</span> <span>// 对应测试包名</span>\n        <span>}</span>\n      <span>}</span><span>,</span>\n      <span>\"oauth_client\"</span><span>:</span> <span>[</span>\n        <span>{</span>\n          <span>\"client_id\"</span><span>:</span> <span>\"545454545454-asasasasasasasasasasasasasasasas.apps.googleusercontent.com\"</span><span>,</span>\n          <span>\"client_type\"</span><span>:</span> <span>3</span>\n        <span>}</span>\n      <span>]</span><span>,</span>\n      <span>\"api_key\"</span><span>:</span> <span>[</span>\n        <span>{</span>\n          <span>\"current_key\"</span><span>:</span> <span>\"nbnbnbnbnbnbnbnbnbnbnbnbnbnbnbnbnbnbnbn\"</span>\n        <span>}</span>\n      <span>]</span><span>,</span>\n      <span>\"services\"</span><span>:</span> <span>{</span>\n        <span>\"appinvite_service\"</span><span>:</span> <span>{</span>\n          <span>\"other_platform_oauth_client\"</span><span>:</span> <span>[</span>\n            <span>{</span>\n              <span>\"client_id\"</span><span>:</span> <span>\"545454545454-asasasasasasasasasasasasasasasas.apps.googleusercontent.com\"</span><span>,</span>\n              <span>\"client_type\"</span><span>:</span> <span>3</span>\n            <span>}</span>\n          <span>]</span>\n        <span>}</span>\n      <span>}</span>\n    <span>}</span>\n  <span>]</span><span>,</span>\n  <span>\"configuration_version\"</span><span>:</span> <span>\"1\"</span>\n<span>}</span>\n</code></pre></div><h4 id=\"_2-1-4-创建-xxx-jks-签名文件\" tabindex=\"-1\"> 2.1.4 创建 <code>xxx.jks</code> 签名文件</h4>\n<p>可以通过如下指令来创建 <code>jks</code> 文件，也可以通过 <code>AS</code> 来生成，放到项目根目录下即可。</p>\n<div><pre><code>keytool -genkey -keystore xxx.jks -alias xxx -keypass xxx -keyalg RSA -keysize <span>2048</span> -validity <span>36500</span> -storepass xxx\n</code></pre></div><h4 id=\"_2-1-5-创建-template-ovpn-证书文件\" tabindex=\"-1\"> 2.1.5 创建 <code>template.ovpn</code> 证书文件</h4>\n<p>原始的 <code>.ovpn</code> 文件由各组长提供，根据各自的 <code>vpncore</code> 的封装不同，对 <code>.ovpn</code> 文件中内容的导入方式也不同。</p>\n<p>本打包方案中是将 <code>.ovpn</code> 文件中的证书信息提取出来，经过加密处理后作为宏变量保存在 <code>native</code> 层中。</p>\n<p>因此，在本打包方案中，<code>template.ovpn</code> 证书文件的内容只需截取原始的 <code>.ovpn</code> 文件中 <code>&lt;ca&gt;</code> 后面部分的内容，如下所示：</p>\n<div><pre><code>&lt;ca>\n-----BEGIN CERTIFICATE-----\nxxx\n-----END CERTIFICATE-----\n&lt;/ca>\n&lt;cert>\n-----BEGIN CERTIFICATE-----\nxxx\n-----END CERTIFICATE-----\n&lt;/cert>\n&lt;key>\n-----BEGIN PRIVATE KEY-----\nxxx\n-----END PRIVATE KEY-----\n&lt;/key>\n&lt;tls-crypt>\n#\n# 2048 bit OpenVPN static key\n#\n-----BEGIN OpenVPN Static key V1-----\nxxx\n-----END OpenVPN Static key V1-----\n&lt;/tls-crypt>\n</code></pre></div><h3 id=\"_2-2-将-buildsrc-插件模块导入到项目中\" tabindex=\"-1\"> 2.2 将 <code>buildSrc</code> 插件模块导入到项目中</h3>\n<p><img src=\"@source/zkq/hnap/general/images/remote_pack/03.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>DeployPlugin：\n    自定义插件类，插件处理流程的入口\n\nDeployExtension：\n    自定义插件提供的扩展属性类（导入该插件的 Project 可以访问到这些扩展属性）\n\nDeployLoader：\n    处理一些数据，如：\n    1. 根据 jks 文件生成签名字符串\n    2. 对 config.json 中的本地内置全局配置数据进行压缩加密\n    3. 对 template.ovpn 中的 VPN 证书进行压缩加密\n    4. 将生成的签名字符串、压缩加密后的全局配置以及 VPN 证书写入到 cmake 文件中，作为宏变量给 Native 层使用\n\nDeployAdapter：\n    在 main/release 下生成正式环境下的代码，并修改包路径结构，以及文件中的包名\n</code></pre></div><h3 id=\"_2-3-将-libconfig-配置模块导入到项目中\" tabindex=\"-1\"> 2.3 将 <code>libconfig</code> 配置模块导入到项目中</h3>\n<p><img src=\"@source/zkq/hnap/general/images/remote_pack/04.png\" alt=\"\" loading=\"lazy\"></p>\n<p>导入 <code>libconfig</code> 模块后，需要修改如下内容：</p>\n<p><strong>1、修改 <code>build.gradle.kts</code> 文件（注释的部分）</strong></p>\n<div><pre><code>plugins <span>{</span>\n    <span>id</span><span>(</span><span><span>\"com.android.library\"</span></span><span>)</span>\n\n    <span>id</span><span>(</span><span><span>\"com.deploy.plugin\"</span></span><span>)</span> <span>// 导入自定义插件 buildSrc</span>\n<span>}</span>\n\nandroid <span>{</span>\n    <span>println</span><span>(</span><span><span>\"curLibPkgName=</span><span><span>${</span><span>deployExt<span>.</span>curLibPkgName</span><span>}</span></span><span>\"</span></span><span>)</span>\n    namespace <span>=</span> deployExt<span>.</span>curLibPkgName <span>// 库模块的包路径</span>\n    compileSdk <span>=</span> <span>32</span>\n\n    defaultConfig <span>{</span>\n        minSdk <span>=</span> <span>21</span>\n        targetSdk <span>=</span> <span>32</span>\n\n        <span>/* 将扩展属性添加到库模块的 BuildConfig 类中 */</span>\n        <span>buildConfigField</span><span>(</span><span><span>\"boolean\"</span></span><span>,</span> <span><span>\"VPN_DEBUG\"</span></span><span>,</span> <span><span>\"</span><span><span>${</span><span>deployExt<span>.</span>debug</span><span>}</span></span><span>\"</span></span><span>)</span>\n        <span>buildConfigField</span><span>(</span><span><span>\"boolean\"</span></span><span>,</span> <span><span>\"ENABLE_LOG\"</span></span><span>,</span> <span><span>\"</span><span><span>${</span><span>deployExt<span>.</span>enableLog</span><span>}</span></span><span>\"</span></span><span>)</span>\n        <span>buildConfigField</span><span>(</span><span><span>\"boolean\"</span></span><span>,</span> <span><span>\"LIMIT_VPN\"</span></span><span>,</span> <span><span>\"</span><span><span>${</span><span>deployExt<span>.</span>limitVPN</span><span>}</span></span><span>\"</span></span><span>)</span>\n\n        <span>buildConfigField</span><span>(</span><span><span>\"String\"</span></span><span>,</span> <span><span>\"PROTOCOL_PRIVACY\"</span></span><span>,</span> <span><span>\"\\\"</span><span><span>${</span><span>deployExt<span>.</span>urlPrivacy</span><span>}</span></span><span>\\\"\"</span></span><span>)</span>\n        <span>buildConfigField</span><span>(</span><span><span>\"String\"</span></span><span>,</span> <span><span>\"PROTOCOL_SERVICE\"</span></span><span>,</span> <span><span>\"\\\"</span><span><span>${</span><span>deployExt<span>.</span>urlTerms</span><span>}</span></span><span>\\\"\"</span></span><span>)</span>\n        <span>buildConfigField</span><span>(</span><span><span>\"String\"</span></span><span>,</span> <span><span>\"FEEDBACK_EMAIL\"</span></span><span>,</span> <span><span>\"\\\"</span><span><span>${</span><span>deployExt<span>.</span>emailFeedback</span><span>}</span></span><span>\\\"\"</span></span><span>)</span>\n\n        <span>buildConfigField</span><span>(</span><span><span>\"String\"</span></span><span>,</span> <span><span>\"BASE_URL\"</span></span><span>,</span> <span><span>\"\\\"</span><span><span>${</span><span>deployExt<span>.</span>baseUrl</span><span>}</span></span><span>\\\"\"</span></span><span>)</span>\n        <span>buildConfigField</span><span>(</span><span><span>\"String\"</span></span><span>,</span> <span><span>\"PATH_CONFIG\"</span></span><span>,</span> <span><span>\"\\\"</span><span><span>${</span><span>deployExt<span>.</span>pathConfig</span><span>}</span></span><span>\\\"\"</span></span><span>)</span>\n        <span>buildConfigField</span><span>(</span><span><span>\"String\"</span></span><span>,</span> <span><span>\"PATH_VPN_NODE_LIST\"</span></span><span>,</span> <span><span>\"\\\"</span><span><span>${</span><span>deployExt<span>.</span>pathVpnNodeList</span><span>}</span></span><span>\\\"\"</span></span><span>)</span>\n        <span>buildConfigField</span><span>(</span><span><span>\"String\"</span></span><span>,</span> <span><span>\"PATH_VPN_NODE_INFO\"</span></span><span>,</span> <span><span>\"\\\"</span><span><span>${</span><span>deployExt<span>.</span>pathVpnNodeInfo</span><span>}</span></span><span>\\\"\"</span></span><span>)</span>\n\n        <span>buildConfigField</span><span>(</span><span><span>\"String\"</span></span><span>,</span> <span><span>\"PATH_LOCATION_1\"</span></span><span>,</span> <span><span>\"\\\"</span><span><span>${</span><span>deployExt<span>.</span>pathLocation1</span><span>}</span></span><span>\\\"\"</span></span><span>)</span>\n        <span>buildConfigField</span><span>(</span><span><span>\"String\"</span></span><span>,</span> <span><span>\"PATH_LOCATION_2\"</span></span><span>,</span> <span><span>\"\\\"</span><span><span>${</span><span>deployExt<span>.</span>pathLocation2</span><span>}</span></span><span>\\\"\"</span></span><span>)</span>\n        <span>buildConfigField</span><span>(</span><span><span>\"String\"</span></span><span>,</span> <span><span>\"PATH_LOCATION_3\"</span></span><span>,</span> <span><span>\"\\\"</span><span><span>${</span><span>deployExt<span>.</span>pathLocation3</span><span>}</span></span><span>\\\"\"</span></span><span>)</span>\n        <span>buildConfigField</span><span>(</span><span><span>\"String\"</span></span><span>,</span> <span><span>\"PATH_LOCATION_4\"</span></span><span>,</span> <span><span>\"\\\"</span><span><span>${</span><span>deployExt<span>.</span>pathLocation4</span><span>}</span></span><span>\\\"\"</span></span><span>)</span>\n\n        <span>/* 将扩展属性添加到库模块的资源文件 string.xml 中 */</span>\n        <span>resValue</span><span>(</span><span><span>\"string\"</span></span><span>,</span> <span><span>\"facebook_id\"</span></span><span>,</span> deployExt<span>.</span>facebookId<span>)</span>\n        <span>resValue</span><span>(</span><span><span>\"string\"</span></span><span>,</span> <span><span>\"facebook_token\"</span></span><span>,</span> deployExt<span>.</span>facebookToken<span>)</span>\n        <span>resValue</span><span>(</span><span><span>\"string\"</span></span><span>,</span> <span><span>\"adjust_token\"</span></span><span>,</span> deployExt<span>.</span>adjustToken<span>)</span>\n        <span>resValue</span><span>(</span><span><span>\"string\"</span></span><span>,</span> <span><span>\"admob_id\"</span></span><span>,</span> deployExt<span>.</span>admobId<span>)</span>\n\n        <span>buildConfigField</span><span>(</span><span><span>\"String\"</span></span><span>,</span> <span><span>\"FACEBOOK_ID\"</span></span><span>,</span> <span><span>\"\\\"</span><span><span>${</span><span>deployExt<span>.</span>facebookId</span><span>}</span></span><span>\\\"\"</span></span><span>)</span>\n        <span>buildConfigField</span><span>(</span><span><span>\"String\"</span></span><span>,</span> <span><span>\"FACEBOOK_TOKEN\"</span></span><span>,</span> <span><span>\"\\\"</span><span><span>${</span><span>deployExt<span>.</span>facebookToken</span><span>}</span></span><span>\\\"\"</span></span><span>)</span>\n        <span>buildConfigField</span><span>(</span><span><span>\"String\"</span></span><span>,</span> <span><span>\"ADJUST_TOKEN\"</span></span><span>,</span> <span><span>\"\\\"</span><span><span>${</span><span>deployExt<span>.</span>adjustToken</span><span>}</span></span><span>\\\"\"</span></span><span>)</span>\n    <span>}</span>\n\n    buildTypes <span>{</span>\n        release <span>{</span>\n            <span>// 混淆文件的路径从扩展属性中取</span>\n            <span>proguardFiles</span><span>(</span><span>getDefaultProguardFile</span><span>(</span><span><span>\"proguard-android-optimize.txt\"</span></span><span>)</span><span>,</span> deployExt<span>.</span>proguardPath<span>)</span> \n        <span>}</span>\n    <span>}</span>\n\n    compileOptions <span>{</span>\n        sourceCompatibility <span>=</span> JavaVersion<span>.</span>VERSION_1_8\n        targetCompatibility <span>=</span> JavaVersion<span>.</span>VERSION_1_8\n    <span>}</span>\n\n    sourceSets <span>{</span>\n        <span>getByName</span><span>(</span><span><span>\"main\"</span></span><span>)</span> <span>{</span>\n            <span>/* 因为需要区分测试环境(main/debug/)和正式环境(main/release/)的代码，所以需要修改项目文件的默认存放位置 */</span>\n            assets<span>.</span><span>srcDirs</span><span>(</span>deployExt<span>.</span>assetsPath<span>)</span>\n            java<span>.</span><span>srcDirs</span><span>(</span>deployExt<span>.</span>javaPath<span>)</span>\n            res<span>.</span><span>srcDirs</span><span>(</span>deployExt<span>.</span>resPath<span>)</span>\n            manifest<span>.</span><span>srcFile</span><span>(</span>deployExt<span>.</span>manifestPath<span>)</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n\ndependencies <span>{</span>\n    <span>implementation</span><span>(</span><span><span>\"androidx.appcompat:appcompat:1.4.2\"</span></span><span>)</span>\n    <span>implementation</span><span>(</span><span><span>\"com.google.android.material:material:1.6.1\"</span></span><span>)</span>\n<span>}</span>\n</code></pre></div><p><strong>2、修改 <code>AndroidManifest.xml</code> 文件</strong></p>\n<p>一些需要在配置清单文件（<code>AndroidManifest.xml</code>）中配置的数据，请在 <code>libconfig</code> 模块的 <code>AndroidManifest.xml</code> 文件中配置。</p>\n<div><pre><code><span>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?></span>\n<span><span><span>&lt;</span>manifest</span> <span><span>xmlns:</span>android</span><span><span>=</span><span>\"</span>http://schemas.android.com/apk/res/android<span>\"</span></span><span>></span></span>\n    <span><span><span>&lt;</span>application</span><span>></span></span>\n        <span>&lt;!-- Facebook --></span>\n        <span><span><span>&lt;</span>meta-data</span>\n            <span><span>android:</span>name</span><span><span>=</span><span>\"</span>com.facebook.sdk.ApplicationId<span>\"</span></span>\n            <span><span>android:</span>value</span><span><span>=</span><span>\"</span>@string/facebook_id<span>\"</span></span><span>/></span></span>\n\n        <span>&lt;!-- Admob --></span>\n        <span><span><span>&lt;</span>meta-data</span>\n            <span><span>android:</span>name</span><span><span>=</span><span>\"</span>com.google.android.gms.ads.APPLICATION_ID<span>\"</span></span>\n            <span><span>android:</span>value</span><span><span>=</span><span>\"</span>@string/admob_id<span>\"</span></span><span>/></span></span>\n    <span><span><span>&lt;/</span>application</span><span>></span></span>\n<span><span><span>&lt;/</span>manifest</span><span>></span></span>\n</code></pre></div><p><strong>3. 修改 <code>LibConfig.java</code></strong></p>\n<p><code>LibConfig</code> 类存在的目的是对 <code>BuildConfig</code> 的属性做一次封装，避免直接使用 <code>BuildConfig</code>。</p>\n<p>因为在项目未编译时，<code>BuildConfig</code> 类是不存在的，此时无法访问到 <code>BuildConfig</code>，于是引用 <code>BuildConfig</code> 的地方都会报错。</p>\n<p>因此，<code>LibConfig</code> 的作用主要就是让 <code>BuildConfig</code> 引起的报错都集中在一个地方，方便管理。</p>\n<div><pre><code><span>package</span> <span>com<span>.</span>template<span>.</span>config</span><span>;</span>\n\n<span>public</span> <span>final</span> <span>class</span> <span>LibConfig</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>final</span> <span>boolean</span> VPN_DEBUG <span>=</span> <span>BuildConfig</span><span>.</span>VPN_DEBUG<span>;</span>\n    <span>public</span> <span>static</span> <span>final</span> <span>boolean</span> ENABLE_LOG <span>=</span> <span>BuildConfig</span><span>.</span>ENABLE_LOG<span>;</span>\n    <span>public</span> <span>static</span> <span>final</span> <span>boolean</span> LIMIT_VPN <span>=</span> <span>BuildConfig</span><span>.</span>LIMIT_VPN<span>;</span>\n\n    <span>public</span> <span>static</span> <span>final</span> <span>String</span> PROTOCOL_PRIVACY <span>=</span> <span>BuildConfig</span><span>.</span>PROTOCOL_PRIVACY<span>;</span>\n    <span>public</span> <span>static</span> <span>final</span> <span>String</span> PROTOCOL_SERVICE <span>=</span> <span>BuildConfig</span><span>.</span>PROTOCOL_SERVICE<span>;</span>\n    <span>public</span> <span>static</span> <span>final</span> <span>String</span> FEEDBACK_EMAIL <span>=</span> <span>BuildConfig</span><span>.</span>FEEDBACK_EMAIL<span>;</span>\n\n    <span>public</span> <span>static</span> <span>final</span> <span>String</span> BASE_URL <span>=</span> <span>BuildConfig</span><span>.</span>BASE_URL<span>;</span>\n    <span>public</span> <span>static</span> <span>final</span> <span>String</span> PATH_CONFIG <span>=</span> <span>BuildConfig</span><span>.</span>PATH_CONFIG<span>;</span>\n    <span>public</span> <span>static</span> <span>final</span> <span>String</span> PATH_VPN_NODE_LIST <span>=</span> <span>BuildConfig</span><span>.</span>PATH_VPN_NODE_LIST<span>;</span>\n    <span>public</span> <span>static</span> <span>final</span> <span>String</span> PATH_VPN_NODE_INFO <span>=</span> <span>BuildConfig</span><span>.</span>PATH_VPN_NODE_INFO<span>;</span>\n\n    <span>public</span> <span>static</span> <span>final</span> <span>String</span> PATH_LOCATION_1 <span>=</span> <span>BuildConfig</span><span>.</span>PATH_LOCATION_1<span>;</span>\n    <span>public</span> <span>static</span> <span>final</span> <span>String</span> PATH_LOCATION_2 <span>=</span> <span>BuildConfig</span><span>.</span>PATH_LOCATION_2<span>;</span>\n    <span>public</span> <span>static</span> <span>final</span> <span>String</span> PATH_LOCATION_3 <span>=</span> <span>BuildConfig</span><span>.</span>PATH_LOCATION_3<span>;</span>\n    <span>public</span> <span>static</span> <span>final</span> <span>String</span> PATH_LOCATION_4 <span>=</span> <span>BuildConfig</span><span>.</span>PATH_LOCATION_4<span>;</span>\n\n    <span>public</span> <span>static</span> <span>final</span> <span>String</span> FACEBOOK_ID <span>=</span> <span>BuildConfig</span><span>.</span>FACEBOOK_ID<span>;</span>\n    <span>public</span> <span>static</span> <span>final</span> <span>String</span> FACEBOOK_TOKEN <span>=</span> <span>BuildConfig</span><span>.</span>FACEBOOK_TOKEN<span>;</span>\n    <span>public</span> <span>static</span> <span>final</span> <span>String</span> ADJUST_TOKEN <span>=</span> <span>BuildConfig</span><span>.</span>ADJUST_TOKEN<span>;</span>\n<span>}</span>\n</code></pre></div><h3 id=\"_2-4-修改-app-模块的目录结构以及-build-gradle-kts-文件\" tabindex=\"-1\"> 2.4 修改 <code>app</code> 模块的目录结构以及 <code>build.gradle.kts</code> 文件</h3>\n<p><img src=\"@source/zkq/hnap/general/images/remote_pack/05.png\" alt=\"\" loading=\"lazy\"></p>\n<p>为了区分正式环境的代码，需要将测试环境的代码以及资源文件、混淆文件、<code>AndroidManifest.xml</code> 文件都放到 <code>main/debug/</code> 目录下。</p>\n<p>然后在 <code>build.gradle.kts</code> 中修改这些文件的默认存放位置：</p>\n<div><pre><code><span>import</span> com<span>.</span>google<span>.</span>firebase<span>.</span>crashlytics<span>.</span>buildtools<span>.</span>gradle<span>.</span>CrashlyticsExtension\n\nplugins <span>{</span>\n    <span>id</span><span>(</span><span><span>\"com.android.application\"</span></span><span>)</span>\n    <span>id</span><span>(</span><span><span>\"com.google.gms.google-services\"</span></span><span>)</span>  \n    <span>id</span><span>(</span><span><span>\"com.google.firebase.crashlytics\"</span></span><span>)</span> \n\n    <span>id</span><span>(</span><span><span>\"com.deploy.plugin\"</span></span><span>)</span> <span>// // 导入自定义插件 buildSrc</span>\n<span>}</span>\n\nandroid <span>{</span>\n    namespace <span>=</span> deployExt<span>.</span>curPkgName\n    compileSdk <span>=</span> <span>32</span>\n\n    defaultConfig <span>{</span>\n        <span>/* 版本信息和包名从扩展属性中取 */</span>\n        applicationId <span>=</span> deployExt<span>.</span>curPkgName\n        minSdk <span>=</span> <span>21</span>\n        targetSdk <span>=</span> <span>32</span>\n        versionCode <span>=</span> deployExt<span>.</span>versionCode\n        versionName <span>=</span> deployExt<span>.</span>versionName\n\n        externalNativeBuild <span>{</span>\n            ndk <span>{</span>\n                abiFilters <span>+=</span> <span>listOf</span><span>(</span><span>/*\"x86\", \"x86_64\",*/</span> <span><span>\"armeabi-v7a\"</span></span><span>,</span> <span><span>\"arm64-v8a\"</span></span><span>)</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n\n    signingConfigs <span>{</span>\n        <span>register</span><span>(</span><span><span>\"release\"</span></span><span>)</span> <span>{</span>\n            <span>/* 签名信息从扩展属性中取 */</span>\n            enableV1Signing <span>=</span> <span>true</span>\n            enableV2Signing <span>=</span> <span>true</span>\n            keyAlias <span>=</span> deployExt<span>.</span>signPwd\n            keyPassword <span>=</span> deployExt<span>.</span>signPwd\n            storePassword <span>=</span> deployExt<span>.</span>signPwd\n            storeFile <span>=</span> rootProject<span>.</span><span>file</span><span>(</span>deployExt<span>.</span>signPath<span>)</span>\n\n            <span>println</span><span>(</span><span><span>\"storeFile=</span><span><span>${</span><span>storeFile<span>?</span><span>.</span>absolutePath</span><span>}</span></span><span>\"</span></span><span>)</span>\n        <span>}</span>\n    <span>}</span>\n\n    buildTypes <span>{</span>\n        release <span>{</span>\n            isMinifyEnabled <span>=</span> <span>true</span>\n            isShrinkResources <span>=</span> <span>true</span>\n            <span>// 混淆文件的路径从扩展属性中取</span>\n            <span>proguardFiles</span><span>(</span><span>getDefaultProguardFile</span><span>(</span><span><span>\"proguard-android-optimize.txt\"</span></span><span>)</span><span>,</span> deployExt<span>.</span>proguardPath<span>)</span>\n\n            configure<span>&lt;</span>CrashlyticsExtension<span>></span> <span>{</span>\n                <span>// 是否上传混淆映射文件到 firebase（测试环境下不上传，因为 google-services.json 文件是乱写的，会上传失败）</span>\n                mappingFileUploadEnabled <span>=</span> deployExt<span>.</span>uploadMappingFile\n            <span>}</span>\n\n            ndk <span>{</span>\n                debugSymbolLevel <span>=</span> <span><span>\"none\"</span></span>\n            <span>}</span>\n\n            signingConfig <span>=</span> signingConfigs<span>.</span><span>getByName</span><span>(</span><span><span>\"release\"</span></span><span>)</span>\n        <span>}</span>\n    <span>}</span>\n\n    sourceSets <span>{</span>\n        <span>getByName</span><span>(</span><span><span>\"main\"</span></span><span>)</span> <span>{</span>\n            <span>/* 修改项目文件的默认存放位置 */</span>\n            assets<span>.</span><span>srcDirs</span><span>(</span>deployExt<span>.</span>assetsPath<span>)</span>\n            java<span>.</span><span>srcDirs</span><span>(</span>deployExt<span>.</span>javaPath<span>)</span>\n            res<span>.</span><span>srcDirs</span><span>(</span>deployExt<span>.</span>resPath<span>)</span>\n            manifest<span>.</span><span>srcFile</span><span>(</span>deployExt<span>.</span>manifestPath<span>)</span>\n        <span>}</span>\n    <span>}</span>\n\n    externalNativeBuild <span>{</span>\n        cmake <span>{</span>\n            <span>path</span><span>(</span>deployExt<span>.</span>cmakePath<span>)</span> <span>// cmake 文件的路径从扩展属性中取</span>\n            version <span>=</span> <span><span>\"3.18.1\"</span></span>\n        <span>}</span>\n    <span>}</span>\n    \n    compileOptions <span>{</span>\n        sourceCompatibility <span>=</span> JavaVersion<span>.</span>VERSION_1_8\n        targetCompatibility <span>=</span> JavaVersion<span>.</span>VERSION_1_8\n    <span>}</span>\n\n    bundle <span>{</span>\n        abi <span>{</span> enableSplit <span>=</span> <span>false</span> <span>}</span>\n    <span>}</span>\n\n    packagingOptions <span>{</span>\n        jniLibs <span>{</span>\n            useLegacyPackaging <span>=</span> <span>true</span>\n        <span>}</span>\n    <span>}</span>\n\n    dataBinding <span>{</span>\n        enable <span>=</span> <span>true</span>\n    <span>}</span>\n<span>}</span>\n\ndependencies <span>{</span>\n    <span>..</span><span>.</span>\n    <span>implementation</span><span>(</span><span>project</span><span>(</span><span><span>\":libconfig\"</span></span><span>)</span><span>)</span> <span>// app 模块需要依赖 libconfig 模块</span>\n    <span>..</span><span>.</span>\n<span>}</span>\n</code></pre></div><h3 id=\"_2-5-项目编译\" tabindex=\"-1\"> 2.5 项目编译</h3>\n<p><strong>Step1：</strong> 根据测试环境和正式环境的不同，修改如下内容：</p>\n<ol>\n<li>修改 <code>config.json</code></li>\n<li>修改 <code>deploy.json</code></li>\n<li>正式环境下替换产品给的 <code>app/google-services.json</code></li>\n<li>正式环境下替换远程打包服务器上生成的 <code>jks</code> 签名文件</li>\n</ol>\n<p><strong>Step2：</strong> 执行 <code>build</code> -&gt; <code>Clean Project</code> 清理下项目，此时会把之前生成的 <code>main/release</code> 下的正式环境的代码都删除掉。</p>\n<p><strong>Step3：</strong> 执行 <code>Gralde Sync</code>，此时会根据当前的 <code>main/debug</code> 下的代码在 <code>main/release</code> 下生成正式环境的代码</p>\n<p><strong>Step4：</strong> 编译项目或打 <code>aab</code> 包</p>\n<h2 id=\"_3-注意事项\" tabindex=\"-1\"> 3. 注意事项</h2>\n<ol>\n<li>\n<p>将 <code>aab</code> 包压缩成 <code>zip</code> 文件，需要用到 <code>7z</code> 压缩软件，且该打包方案的压缩程序只适配了 <code>windows</code> 系统的命令格式。所以只会在远程打包服务器上生成 <code>zip</code> 压缩文件。</p>\n<blockquote>\n<p><code>windows</code> 系统中需安装 <code>7z</code> 压缩软件，并将 <code>7z.exe</code> 添加到环境变量后，再打开 <code>AS</code>，才能生成 <code>zip</code> 文件。</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"_4-移除-aab-包中的混淆映射文件\" tabindex=\"-1\"> 4. 移除 <code>aab</code> 包中的混淆映射文件</h2>\n<p>在 <code>app</code> 模块中的 <code>build.gradle.kts</code> 文件中添加如下代码：</p>\n<div><pre><code>tasks<span>.</span><span>register</span><span>(</span><span><span>\"removeProguardMappingFromReleaseIntermediateBundle\"</span></span><span>,</span> Zip<span>::</span><span>class</span><span>.</span>java<span>)</span> <span>{</span>\n    description <span>=</span> <span><span>\"Remove proguard mapping from bundle file for Google Play upload\"</span></span>\n\n    archiveName <span>=</span> <span><span>\"intermediary-bundle.tmp.aab\"</span></span>\n\n    destinationDir <span>=</span> <span>file</span><span>(</span><span><span>\"</span><span><span>${</span><span>project<span>.</span>buildDir</span><span>}</span></span><span>/intermediates/intermediary_bundle/release/\"</span></span><span>)</span>\n\n    <span>println</span><span>(</span>destinationDir<span>.</span><span>listFiles</span><span>(</span><span>)</span><span>)</span>\n\n    <span>from</span><span>(</span><span>zipTree</span><span>(</span><span><span>\"</span><span><span>${</span><span>project<span>.</span>buildDir</span><span>}</span></span><span>/intermediates/intermediary_bundle/release/intermediary-bundle.aab\"</span></span><span>)</span><span>)</span> <span>{</span>\n        <span>exclude</span><span>(</span><span><span>\"BUNDLE-METADATA/com.android.tools.build.obfuscation/proguard.map\"</span></span><span>)</span>\n    <span>}</span>\n\n    doLast <span>{</span>\n        <span>val</span> source <span>=</span> <span><span>\"</span><span><span>${</span><span>project<span>.</span>buildDir</span><span>}</span></span><span>/intermediates/intermediary_bundle/release/intermediary-bundle.tmp.aab\"</span></span>\n        <span>val</span> target <span>=</span> source<span>.</span><span>replace</span><span>(</span><span><span>\".tmp.aab\"</span></span><span>,</span> <span><span>\".aab\"</span></span><span>)</span>\n        <span>file</span><span>(</span>target<span>)</span><span>.</span><span>delete</span><span>(</span><span>)</span>\n        <span>file</span><span>(</span>source<span>)</span><span>.</span><span>renameTo</span><span>(</span><span>file</span><span>(</span>target<span>)</span><span>)</span>\n    <span>}</span>\n<span>}</span>\n\nproject<span>.</span><span>afterEvaluate</span> <span>{</span>\n    tasks<span>.</span><span>getByName</span><span>(</span><span><span>\"shrinkBundleReleaseResources\"</span></span><span>)</span><span>.</span><span>finalizedBy</span><span>(</span><span><span>\"removeProguardMappingFromReleaseIntermediateBundle\"</span></span><span>)</span>\n<span>}</span>\n</code></pre></div>",
      "date_published": "2023-06-02T10:22:47.000Z",
      "date_modified": "2023-08-29T07:58:48.000Z",
      "authors": [],
      "tags": [
        "HNAP"
      ]
    },
    {
      "title": "面试问题",
      "url": "https://zengkaiqiang562.github.io/zkq/hnap/interview_faq.html",
      "id": "https://zengkaiqiang562.github.io/zkq/hnap/interview_faq.html",
      "content_html": "<h2 id=\"_1-ui-篇\" tabindex=\"-1\"> 1. <code>UI</code> 篇</h2>\n<h3 id=\"_1-1-中级\" tabindex=\"-1\"> 1.1 中级</h3>\n<h4 id=\"_1-1-1-简述-ui-绘制流程\" tabindex=\"-1\"> 1.1.1 简述 <code>UI</code> 绘制流程？</h4>\n<h4 id=\"_1-1-2-简述事件传递机制\" tabindex=\"-1\"> 1.1.2 简述事件传递机制？</h4>\n<h4 id=\"_1-1-2-view-补间动画有哪些-什么是插值器\" tabindex=\"-1\"> 1.1.2 <code>View</code> 补间动画有哪些？什么是插值器？</h4>\n<h4 id=\"_1-1-3-lottie-动画的基本使用-有哪些优缺点\" tabindex=\"-1\"> 1.1.3 <code>Lottie</code> 动画的基本使用？有哪些优缺点？</h4>\n<p><strong>缺点：</strong> 客户端不可以实现 <code>3D</code> 效果（如绕 <code>Y</code> 轴旋转），用什么代替？（<code>SVGA</code> 动画）</p>\n<h4 id=\"_1-1-4-简述-constraintlayout-约束布局的优点\" tabindex=\"-1\"> 1.1.4 简述 <code>ConstraintLayout</code> 约束布局的优点？</h4>\n<ol>\n<li>\n<p>减少布局层级；</p>\n</li>\n<li>\n<p>实现屏幕适配。</p>\n</li>\n</ol>\n<h4 id=\"_1-1-5-简述-recyclerview-的基本使用流程\" tabindex=\"-1\"> 1.1.5 简述 <code>RecyclerView</code> 的基本使用流程？</h4>\n<h4 id=\"_1-1-6-activity-的启动模式有哪些-简述下各启动模式的特点。\" tabindex=\"-1\"> 1.1.6 <code>Activity</code> 的启动模式有哪些？简述下各启动模式的特点。</h4>\n<h3 id=\"_1-2-高级\" tabindex=\"-1\"> 1.2 高级</h3>\n<h4 id=\"_1-2-1-滑动冲突是如何产生的-怎样解决\" tabindex=\"-1\"> 1.2.1 滑动冲突是如何产生的？怎样解决？</h4>\n<h4 id=\"_1-2-2-recyclerview-回收复用机制中用到了哪些回收池-它们的作用分别是什么\" tabindex=\"-1\"> 1.2.2 <code>RecyclerView</code> 回收复用机制中用到了哪些回收池，它们的作用分别是什么？</h4>\n<h2 id=\"_2-线程篇\" tabindex=\"-1\"> 2. 线程篇</h2>\n<h3 id=\"_2-1-中级\" tabindex=\"-1\"> 2.1 中级</h3>\n<h4 id=\"_2-1-1-简述-handler-的基本工作机制\" tabindex=\"-1\"> 2.1.1 简述 <code>Handler</code> 的基本工作机制</h4>\n<h4 id=\"_2-1-2-handlderthread-的作用是什么\" tabindex=\"-1\"> 2.1.2 <code>HandlderThread</code> 的作用是什么？</h4>\n<h4 id=\"_2-1-3-new-出来的-thread-线程如何正确停止\" tabindex=\"-1\"> 2.1.3 <code>new</code> 出来的 <code>Thread</code> 线程如何正确停止？</h4>\n<h4 id=\"_2-1-4-一个线程有哪几种状态\" tabindex=\"-1\"> 2.1.4 一个线程有哪几种状态？</h4>\n<h4 id=\"_2-1-5-android-提供的线程池有哪四类\" tabindex=\"-1\"> 2.1.5 <code>Android</code> 提供的线程池有哪四类？</h4>\n<h3 id=\"_2-2-高级\" tabindex=\"-1\"> 2.2 高级</h3>\n<h4 id=\"_2-2-1-一个线程的消息机制内可以有几个-handler-对象、几个-looper-对象\" tabindex=\"-1\"> 2.2.1 一个线程的消息机制内可以有几个 <code>Handler</code> 对象、几个 <code>Looper</code> 对象？</h4>\n<h4 id=\"_2-2-2-handler-对象是否可以持有-activity-对象的强引用\" tabindex=\"-1\"> 2.2.2 <code>Handler</code> 对象是否可以持有 <code>Activity</code> 对象的强引用？</h4>\n<h4 id=\"_2-2-3-什么是死锁-死锁是如何产生的\" tabindex=\"-1\"> 2.2.3 什么是死锁？死锁是如何产生的？</h4>\n<h4 id=\"_2-2-4-线程池-threadpoolexecutor-是如何分配线程的\" tabindex=\"-1\"> 2.2.4 线程池 <code>ThreadPoolExecutor</code> 是如何分配线程的？</h4>\n<h2 id=\"_3-性能篇\" tabindex=\"-1\"> 3. 性能篇</h2>\n<h3 id=\"_3-1-中级\" tabindex=\"-1\"> 3.1 中级</h3>\n<h4 id=\"_3-1-1-什么是内存泄漏-如何产生的-怎样避免\" tabindex=\"-1\"> 3.1.1 什么是内存泄漏？如何产生的？怎样避免？</h4>\n<h4 id=\"_3-1-2-什么是内存抖动-如何产生的-怎样避免\" tabindex=\"-1\"> 3.1.2 什么是内存抖动？如何产生的？怎样避免？</h4>\n<h4 id=\"_3-1-3-什么是-anr-如何产生的-怎样避免\" tabindex=\"-1\"> 3.1.3 什么是 <code>ANR</code>？如何产生的？怎样避免？</h4>\n<h4 id=\"_3-1-4-app-冷启动时的白屏现象是如何产生的-怎样避免\" tabindex=\"-1\"> 3.1.4 <code>App</code> 冷启动时的白屏现象是如何产生的？怎样避免？</h4>\n<h3 id=\"_3-2-高级\" tabindex=\"-1\"> 3.2 高级</h3>\n<h4 id=\"_3-2-1-简述下垃圾回收机制中的根搜索算法\" tabindex=\"-1\"> 3.2.1 简述下垃圾回收机制中的根搜索算法？</h4>\n<h4 id=\"_3-2-2-可作为-gc-roots-根节点的对象有哪些\" tabindex=\"-1\"> 3.2.2 可作为 <code>GC Roots</code> 根节点的对象有哪些？</h4>\n<h4 id=\"_3-2-3-主线程消息机制中的-looper-死循环为什么不会导致-anr\" tabindex=\"-1\"> 3.2.3 主线程消息机制中的 <code>Looper</code> 死循环为什么不会导致 <code>ANR</code>？</h4>\n<h2 id=\"_4-架构篇\" tabindex=\"-1\"> 4. 架构篇</h2>\n<h3 id=\"_4-1-中级\" tabindex=\"-1\"> 4.1 中级</h3>\n<h4 id=\"_4-1-1-简述下-mvc、mvp、mvvm-三种架构的特点\" tabindex=\"-1\"> 4.1.1 简述下 <code>MVC</code>、<code>MVP</code>、<code>MVVM</code> 三种架构的特点</h4>\n<h4 id=\"_4-1-2-用过哪些设计模式-什么场景下会用到这些设计模式\" tabindex=\"-1\"> 4.1.2 用过哪些设计模式？什么场景下会用到这些设计模式？</h4>\n<h4 id=\"_4-1-3-面向对象编程的基本原则有哪些\" tabindex=\"-1\"> 4.1.3 面向对象编程的基本原则有哪些？</h4>\n<h3 id=\"_4-2-高级\" tabindex=\"-1\"> 4.2 高级</h3>\n<h4 id=\"_4-2-1-单例模式的实现方式有哪些\" tabindex=\"-1\"> 4.2.1 单例模式的实现方式有哪些？</h4>\n<p>饿汉式、懒汉式、双重检查、静态内部类、枚举</p>\n<h4 id=\"_4-2-2-单例模式的双重检查方式中的外层-if-和-内存-if-的作用分别是什么\" tabindex=\"-1\"> 4.2.2 单例模式的双重检查方式中的外层 <code>if</code> 和 内存 <code>if</code> 的作用分别是什么？</h4>\n<h4 id=\"_4-2-3-依赖倒置原则中的-倒置-是什么倒置了\" tabindex=\"-1\"> 4.2.3 依赖倒置原则中的 “倒置” 是什么倒置了？</h4>\n<h2 id=\"_5-开源框架篇\" tabindex=\"-1\"> 5. 开源框架篇</h2>\n<h3 id=\"_5-1-中级\" tabindex=\"-1\"> 5.1 中级</h3>\n<h4 id=\"_5-1-1-okhttp-的请求过程中主要涉及到了哪些类-它们的作用分别是什么\" tabindex=\"-1\"> 5.1.1 <code>OKHttp</code> 的请求过程中主要涉及到了哪些类？它们的作用分别是什么？</h4>\n<h4 id=\"_5-1-2-retrofit-在实例化网络请求接口时用到了哪种设计模式\" tabindex=\"-1\"> 5.1.2 <code>Retrofit</code> 在实例化网络请求接口时用到了哪种设计模式？</h4>\n<h4 id=\"_5-1-3-glide-是如何将加载图片的过程跟-activity-的生命周期绑定的\" tabindex=\"-1\"> 5.1.3 <code>Glide</code> 是如何将加载图片的过程跟 <code>Activity</code> 的生命周期绑定的？</h4>\n<p><code>Glide</code> 内部会在加载图片前，创建一个没有界面的 <code>Fragment</code> 对象并添加到传入的 <code>Activity</code> 对象的 <code>FragmentManager</code> 中。</p>\n<p>通过监听这个 <code>Fragment</code> 对象的生命周期来与 <code>Activity</code> 的生命周期进行绑定</p>\n<h4 id=\"_5-1-4-用过哪些数据库框架-简单介绍其特点-什么是对象关系映射-orm\" tabindex=\"-1\"> 5.1.4 用过哪些数据库框架？简单介绍其特点？什么是对象关系映射（<code>ORM</code>）</h4>\n<h3 id=\"_5-2-高级\" tabindex=\"-1\"> 5.2 高级</h3>\n",
      "date_published": "2023-05-10T15:47:41.000Z",
      "date_modified": "2023-05-10T15:47:41.000Z",
      "authors": [],
      "tags": [
        "HNAP"
      ]
    },
    {
      "title": "Adjust接入",
      "url": "https://zengkaiqiang562.github.io/zkq/hnap/sdk/adjust.html",
      "id": "https://zengkaiqiang562.github.io/zkq/hnap/sdk/adjust.html",
      "content_html": "<h2 id=\"_1-接入步骤\" tabindex=\"-1\"> 1. 接入步骤</h2>\n<blockquote>\n<p>参考：<a href=\"https://help.adjust.com/zh/article/get-started-android-sdk#set-up-environment\" target=\"_blank\" rel=\"noopener noreferrer\">Adjust 开发文档<ExternalLinkIcon/></a></p>\n</blockquote>\n<h3 id=\"step-1-添加依赖包\" tabindex=\"-1\"> Step 1. 添加依赖包</h3>\n<div><pre><code><span>/* 在 Module 的 build.gradle 中添加依赖 */</span>\n\ndependencies <span>{</span>\n    implementation <span>'com.adjust.sdk:adjust-android:4.33.0'</span>\n\n    <span>// Install Referrer 是一种唯一标识符，可用来将应用安装归因至来源</span>\n    implementation <span>'com.android.installreferrer:installreferrer:2.2'</span>\n\n    <span>// Add the following if you are using the Adjust SDK inside web views on your app</span>\n    implementation <span>'com.adjust.sdk:adjust-android-webbridge:4.33.0'</span>\n\n    <span>// 为了让 Adjust SDK 能使用 Google 广告 ID，需要集成 Google Play 服务</span>\n    implementation <span>'com.google.android.gms:play-services-ads-identifier:17.0.1'</span>\n<span>}</span>\n</code></pre></div><h3 id=\"step-2-添加权限\" tabindex=\"-1\"> Step 2. 添加权限</h3>\n<div><pre><code>/* AndroidManifest.xml */\n\n<span><span><span>&lt;</span>uses-permission</span> <span><span>android:</span>name</span><span><span>=</span><span>\"</span>android.permission.INTERNET<span>\"</span></span> <span>/></span></span>\n<span><span><span>&lt;</span>uses-permission</span> <span><span>android:</span>name</span><span><span>=</span><span>\"</span>android.permission.ACCESS_NETWORK_STATE<span>\"</span></span> <span>/></span></span>\n<span><span><span>&lt;</span>uses-permission</span> <span><span>android:</span>name</span><span><span>=</span><span>\"</span>android.permission.ACCESS_WIFI_STATE<span>\"</span></span> <span>/></span></span>\n</code></pre></div><h3 id=\"step-3-设置-proguard-混淆\" tabindex=\"-1\"> Step 3. 设置 <code>Proguard</code> 混淆</h3>\n<div><pre><code>/* proguard-rules.pro */\n\n-keep class com.adjust.sdk.**{ *; }\n-keep class com.google.android.gms.common.ConnectionResult {\n    int SUCCESS;\n}\n-keep class com.google.android.gms.ads.identifier.AdvertisingIdClient {\n    com.google.android.gms.ads.identifier.AdvertisingIdClient$Info getAdvertisingIdInfo(android.content.Context);\n}\n-keep class com.google.android.gms.ads.identifier.AdvertisingIdClient$Info {\n    java.lang.String getId();\n    boolean isLimitAdTrackingEnabled();\n}\n-keep public class com.android.installreferrer.**{ *; }\n</code></pre></div><h3 id=\"step-4-在-application-中进行配置和初始化\" tabindex=\"-1\"> Step 4. 在 <code>Application</code> 中进行配置和初始化</h3>\n<div><pre><code><span>import</span> <span>com<span>.</span>adjust<span>.</span>sdk<span>.</span></span><span>Adjust</span><span>;</span>\n<span>import</span> <span>com<span>.</span>adjust<span>.</span>sdk<span>.</span></span><span>AdjustConfig</span><span>;</span>\n\n<span>public</span> <span>class</span> <span>MyApplication</span> <span>extends</span> <span>Application</span> <span>{</span>\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>onCreate</span><span>(</span><span>)</span> <span>{</span>\n        <span>super</span><span>.</span><span>onCreate</span><span>(</span><span>)</span><span>;</span>\n        <span>initAdjust</span><span>(</span><span>this</span><span>)</span><span>;</span>\n        <span>registerActivityLifecycleCallbacks</span><span>(</span><span>new</span> <span>MyLifecycleCallbacks</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>initAdjust</span><span>(</span><span>Application</span> application<span>)</span> <span>{</span>\n        <span>// TODO 正式环境改为实际的 appToken</span>\n        <span>String</span> appToken <span>=</span> <span>\"{YourAppToken}\"</span><span>;</span>\n        <span>/*\n        Debug 时 environment 设置为 AdjustConfig.ENVIRONMENT_SANDBOX 。\n        Release 时 environment 设置为 AdjustConfig.ENVIRONMENT_PRODUCTION。\n         */</span>\n        <span>String</span> environment <span>=</span> <span>BuildConfig</span><span>.</span>DEBUG <span>?</span> <span>AdjustConfig</span><span>.</span>ENVIRONMENT_SANDBOX <span>:</span> <span>AdjustConfig</span><span>.</span>ENVIRONMENT_PRODUCTION<span>;</span>\n        <span>AdjustConfig</span> config <span>=</span> <span>new</span> <span>AdjustConfig</span><span>(</span>application<span>,</span> appToken<span>,</span> environment<span>)</span><span>;</span>\n        <span>// LogLevel.SUPRESS 禁用所有日志</span>\n        config<span>.</span><span>setLogLevel</span><span>(</span><span>BuildConfig</span><span>.</span>DEBUG <span>?</span> <span>LogLevel</span><span>.</span>WARN <span>:</span> <span>LogLevel</span><span>.</span>SUPRESS<span>)</span><span>;</span>\n        <span>Adjust</span><span>.</span><span>onCreate</span><span>(</span>config<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>// 跟踪 Activity 的生命周期</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>class</span> <span>MyLifecycleCallbacks</span> <span>implements</span> <span>ActivityLifecycleCallbacks</span> <span>{</span>\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onActivityResumed</span><span>(</span><span>Activity</span> activity<span>)</span> <span>{</span>\n            <span>Adjust</span><span>.</span><span>onResume</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onActivityPaused</span><span>(</span><span>Activity</span> activity<span>)</span> <span>{</span>\n            <span>Adjust</span><span>.</span><span>onPause</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>//...</span>\n    <span>}</span>\n<span>}</span>\n</code></pre></div><h2 id=\"_2-事件跟踪-即-埋点\" tabindex=\"-1\"> 2. 事件跟踪（即：埋点）</h2>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>trackEvent</span><span>(</span><span>String</span> event<span>,</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> params<span>,</span> <span>boolean</span> unique<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>unique <span>&amp;&amp;</span> <span>SPUtils</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>.</span><span>getBoolean</span><span>(</span>event<span>)</span><span>)</span> <span>{</span>\n        <span>Log</span><span>.</span><span>e</span><span>(</span>TAG<span>,</span> <span>\"trackEvent() -->  unique event \"</span> <span>+</span> event <span>+</span> <span>\"  has been REPORT !!!\"</span><span>)</span><span>;</span>\n        <span>return</span><span>;</span> <span>// 去重事件已经上报过，不再上报</span>\n    <span>}</span>\n\n    <span>AdjustEvent</span> adjustEvent <span>=</span> <span>new</span> <span>AdjustEvent</span><span>(</span>event<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>unique<span>)</span> <span>{</span>\n        adjustEvent<span>.</span><span>setOrderId</span><span>(</span>event<span>)</span><span>;</span> <span>// Adjust 内部的去重（最多只能支持10个事件，所以自己再套了层 SP 保证去重）</span>\n    <span>}</span>\n\n    <span>if</span> <span>(</span>params <span>!=</span> <span>null</span> <span>&amp;&amp;</span> <span>!</span>params<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n        <span>for</span> <span>(</span><span>Map<span>.</span>Entry</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> entry <span>:</span> params<span>.</span><span>entrySet</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            adjustEvent<span>.</span><span>addCallbackParameter</span><span>(</span>entry<span>.</span><span>getKey</span><span>(</span><span>)</span><span>,</span> entry<span>.</span><span>getValue</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>Adjust</span><span>.</span><span>trackEvent</span><span>(</span>adjustEvent<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>unique<span>)</span> <span>{</span>\n        <span>SPUtils</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>.</span><span>put</span><span>(</span>event<span>,</span> <span>true</span><span>)</span><span>;</span> <span>// 自己通过 SP 保证去重</span>\n    <span>}</span>\n<span>}</span>\n</code></pre></div><h2 id=\"_3-bi-系统接入\" tabindex=\"-1\"> 3. <code>BI</code> 系统接入</h2>\n<p><code>BI</code> 系统接入就是 <code>Adjust</code> 将客户端上报的信息再转发给 <code>BI</code> 系统。客户端只需关心要上报哪些信息给 <code>Adjust</code> 即可。</p>\n<p>目前，需要上报三类信息：</p>\n<ol>\n<li>\n<p>通过 <code>Adjust</code> 上报归因（上报 <code>FB</code> 安装事件）</p>\n</li>\n<li>\n<p>通过 <code>Adjust</code> 上报广告价值</p>\n</li>\n<li>\n<p>通过 <code>Adjust</code> 上报广告的请求事件、匹配事件、点击事件</p>\n</li>\n</ol>\n<h3 id=\"_3-1-通过-adjust-上报归因-上报-fb-安装事件\" tabindex=\"-1\"> 3.1 通过 <code>Adjust</code> 上报归因（上报 <code>FB</code> 安装事件）</h3>\n<h4 id=\"_3-1-1-产品需提供的信息\" tabindex=\"-1\"> 3.1.1 产品需提供的信息</h4>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>事件名称</strong></th>\n<th style=\"text-align:left\"><strong><code>Adjust</code> 识别码</strong></th>\n<th style=\"text-align:left\"><strong>备注</strong></th>\n<th style=\"text-align:left\"><strong>触发条件</strong></th>\n<th style=\"text-align:left\"><strong>参数</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>cfinstalla</code></td>\n<td style=\"text-align:left\"><code>xm2kgc</code></td>\n<td style=\"text-align:left\"><code>FB</code> <code>install</code> 事件</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">加密数据参数：<code>cfurla</code></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"_3-1-2-示例代码\" tabindex=\"-1\"> 3.1.2 示例代码</h4>\n<div><pre><code><span>public</span> <span>class</span> <span>MyApplication</span> <span>extends</span> <span>Application</span> <span>{</span>\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>onCreate</span><span>(</span><span>)</span> <span>{</span>\n        <span>super</span><span>.</span><span>onCreate</span><span>(</span><span>)</span><span>;</span>\n        <span>initAdjust</span><span>(</span><span>this</span><span>)</span><span>;</span>\n        <span>registerActivityLifecycleCallbacks</span><span>(</span><span>new</span> <span>MyLifecycleCallbacks</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>.</span><span>.</span><span>.</span>\n        <span>// 上报归因的初始化</span>\n        <span>setupReferrer</span><span>(</span><span>this</span><span>)</span><span>;</span>\n        <span>.</span><span>.</span><span>.</span>\n    <span>}</span>\n<span>}</span>\n</code></pre></div><div><pre><code><span>private</span> <span>void</span> <span>setupReferrer</span><span>(</span><span>Application</span> application<span>)</span> <span>{</span>\n    <span>InstallReferrerClient</span> referrerClient<span>;</span>\n    referrerClient <span>=</span> <span>InstallReferrerClient</span><span>.</span><span>newBuilder</span><span>(</span>application<span>)</span><span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>\n    referrerClient<span>.</span><span>startConnection</span><span>(</span><span>new</span> <span>InstallReferrerStateListener</span><span>(</span><span>)</span> <span>{</span>\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onInstallReferrerSetupFinished</span><span>(</span><span>int</span> responseCode<span>)</span> <span>{</span>\n            <span>try</span> <span>{</span>\n                <span>switch</span> <span>(</span>responseCode<span>)</span> <span>{</span>\n                    <span>case</span> <span>InstallReferrerClient<span>.</span>InstallReferrerResponse</span><span>.</span>OK<span>:</span>\n                        <span>// Connection established.</span>\n                        <span>boolean</span> traced <span>=</span> <span>SPUtils</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>.</span><span>getBoolean</span><span>(</span><span>IConstants</span><span>.</span>SP_REFERRER_TRACE<span>)</span><span>;</span>\n                        <span>if</span> <span>(</span><span>!</span>traced<span>)</span> <span>{</span>\n                            <span>String</span> referrerUrl <span>=</span> referrerClient<span>.</span><span>getInstallReferrer</span><span>(</span><span>)</span><span>.</span><span>getInstallReferrer</span><span>(</span><span>)</span><span>;</span>\n                            <span>AdjustEvent</span> event <span>=</span> <span>new</span> <span>AdjustEvent</span><span>(</span><span>\"xm2kgc\"</span><span>)</span><span>;</span>\n                            event<span>.</span><span>addCallbackParameter</span><span>(</span><span>\"cfurla\"</span><span>,</span> referrerUrl<span>)</span><span>;</span>\n                            <span>Adjust</span><span>.</span><span>trackEvent</span><span>(</span>event<span>)</span><span>;</span>\n                            <span>//注意要做一个上传标记，避免重复上传，文档也说了尽量避免不必要的重复调用</span>\n                            <span>SPUtils</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>.</span><span>put</span><span>(</span><span>IConstants</span><span>.</span>SP_REFERRER_TRACE<span>,</span> <span>true</span><span>)</span><span>;</span>\n                        <span>}</span>\n                        <span>//获取归因后要及时断开，避免内存泄露</span>\n                        referrerClient<span>.</span><span>endConnection</span><span>(</span><span>)</span><span>;</span>\n                        <span>break</span><span>;</span>\n                    <span>case</span> <span>InstallReferrerClient<span>.</span>InstallReferrerResponse</span><span>.</span>FEATURE_NOT_SUPPORTED<span>:</span>\n                        <span>// API not available on the current Play Store app.</span>\n                        <span>break</span><span>;</span>\n                    <span>case</span> <span>InstallReferrerClient<span>.</span>InstallReferrerResponse</span><span>.</span>SERVICE_UNAVAILABLE<span>:</span>\n                        <span>// Connection couldn't be established.</span>\n                        <span>break</span><span>;</span>\n                <span>}</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onInstallReferrerServiceDisconnected</span><span>(</span><span>)</span> <span>{</span>\n            <span>// Try to restart the connection on the next request to</span>\n            <span>// Google Play by calling the startConnection() method.</span>\n        <span>}</span>\n    <span>}</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre></div><h3 id=\"_3-2-通过-adjust-上报广告价值\" tabindex=\"-1\"> 3.2 通过 <code>Adjust</code> 上报广告价值</h3>\n<h4 id=\"_3-2-1-step1-adjust-上报广告价值的方法封装\" tabindex=\"-1\"> 3.2.1 Step1. <code>Adjust</code> 上报广告价值的方法封装</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>reportRevenue</span><span>(</span><span>long</span> valueMicros<span>,</span> <span>String</span> currencyCode<span>,</span> <span>String</span> network<span>,</span> <span>String</span> adId<span>,</span> <span>String</span> adPlace<span>)</span> <span>{</span>\n    <span>double</span> revenue <span>=</span> valueMicros <span>/</span> <span>1000000.0</span><span>;</span> <span>//把原来的千分值转换成0.001</span>\n    <span>AdjustAdRevenue</span> adRevenue <span>=</span> <span>new</span> <span>AdjustAdRevenue</span><span>(</span><span>AdjustConfig</span><span>.</span>AD_REVENUE_ADMOB<span>)</span><span>;</span>\n    adRevenue<span>.</span><span>setRevenue</span><span>(</span>revenue<span>,</span> currencyCode<span>)</span><span>;</span>\n    adRevenue<span>.</span><span>setAdRevenueNetwork</span><span>(</span>network<span>)</span><span>;</span> <span>//广告源渠道</span>\n    adRevenue<span>.</span><span>setAdRevenuePlacement</span><span>(</span>adPlace<span>)</span><span>;</span> <span>//广告位名称</span>\n    adRevenue<span>.</span><span>setAdRevenueUnit</span><span>(</span>adId<span>)</span><span>;</span> <span>//广告ID</span>\n    <span>Adjust</span><span>.</span><span>trackAdRevenue</span><span>(</span>adRevenue<span>)</span><span>;</span> <span>//调用Adjust上报广告价值的方法</span>\n<span>}</span>\n</code></pre></div><h4 id=\"_3-2-2-step2-获取广告源渠道的方法封装\" tabindex=\"-1\"> 3.2.2 Step2. 获取广告源渠道的方法封装</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>String</span> <span>getAdChannel</span><span>(</span><span>String</span> adapter<span>)</span> <span>{</span> <span>// 参数 adapter 通过广告 SDK 提供的 API 获取</span>\n    <span>String</span> channel <span>=</span> <span>\"\"</span><span>;</span> <span>// 广告源渠道</span>\n\n    <span>if</span> <span>(</span><span>TextUtils</span><span>.</span><span>isEmpty</span><span>(</span>adapter<span>)</span><span>)</span> <span>{</span>\n        <span>return</span> channel<span>;</span>\n    <span>}</span>\n\n    <span>if</span> <span>(</span>adapter<span>.</span><span>contains</span><span>(</span><span>\"AdMobAdapter\"</span><span>)</span><span>)</span> <span>{</span>\n        channel <span>=</span> <span>\"admob\"</span><span>;</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span>adapter<span>.</span><span>contains</span><span>(</span><span>\"adcolony\"</span><span>)</span><span>)</span> <span>{</span>\n        channel <span>=</span> <span>\"adcolony\"</span><span>;</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span>adapter<span>.</span><span>contains</span><span>(</span><span>\"chartboost\"</span><span>)</span><span>)</span> <span>{</span>\n        channel <span>=</span> <span>\"chartboost\"</span><span>;</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span>adapter<span>.</span><span>contains</span><span>(</span><span>\"inmobi\"</span><span>)</span><span>)</span> <span>{</span>\n        channel <span>=</span> <span>\"inmobi\"</span><span>;</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span>adapter<span>.</span><span>contains</span><span>(</span><span>\"ironsource\"</span><span>)</span><span>)</span> <span>{</span>\n        channel <span>=</span> <span>\"ironsource\"</span><span>;</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span>adapter<span>.</span><span>contains</span><span>(</span><span>\"pangle\"</span><span>)</span><span>)</span> <span>{</span>\n        channel <span>=</span> <span>\"pangle\"</span><span>;</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span>adapter<span>.</span><span>contains</span><span>(</span><span>\"unity\"</span><span>)</span><span>)</span> <span>{</span>\n        channel <span>=</span> <span>\"unity\"</span><span>;</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span>adapter<span>.</span><span>contains</span><span>(</span><span>\"vungle\"</span><span>)</span><span>)</span> <span>{</span>\n        channel <span>=</span> <span>\"vungle\"</span><span>;</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span>adapter<span>.</span><span>contains</span><span>(</span><span>\".mtg\"</span><span>)</span><span>)</span> <span>{</span>\n        channel <span>=</span> <span>\"mintegral\"</span><span>;</span>\n    <span>}</span>\n\n    <span>return</span> channel<span>;</span>\n<span>}</span>\n</code></pre></div><h4 id=\"_3-2-3-step3-实现-onpaideventlistener-接口\" tabindex=\"-1\"> 3.2.3 Step3. 实现 <code>OnPaidEventListener</code> 接口</h4>\n<div><pre><code><span>public</span> <span>class</span> <span>MyOnPaidEventListener</span> <span>implements</span> <span>OnPaidEventListener</span> <span>{</span>\n\n    <span>private</span> <span>final</span> <span>PlaceBean</span> placeBean<span>;</span> <span>// placeBean 实体类的作用是提供广告位名称</span>\n    <span>private</span> <span>final</span> <span>UnitBean</span> unitBean<span>;</span> <span>// unitBean 实体类的作用是提供广告单元 id</span>\n    <span>private</span> <span>final</span> <span>String</span> adapter<span>;</span> <span>// // 参数 adapter 通过广告 SDK 提供的 API 获取</span>\n\n    <span>public</span> <span>MyOnPaidEventListener</span><span>(</span><span>PlaceBean</span> placeBean<span>,</span> <span>UnitBean</span> unitBean<span>,</span> <span>String</span> adapter<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>placeBean <span>=</span> placeBean<span>;</span>\n        <span>this</span><span>.</span>unitBean <span>=</span> unitBean<span>;</span>\n        <span>this</span><span>.</span>adapter <span>=</span> adapter <span>==</span> <span>null</span> <span>?</span> <span>\"\"</span> <span>:</span> adapter<span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>onPaidEvent</span><span>(</span><span>@NonNull</span> <span>AdValue</span> adValue<span>)</span> <span>{</span>\n        <span>String</span> network <span>=</span> <span>getAdChannel</span><span>(</span>adapter<span>)</span><span>;</span> <span>// 广告源渠道</span>\n\n        <span>if</span> <span>(</span>placeBean <span>==</span> <span>null</span> <span>||</span> unitBean <span>==</span> <span>null</span><span>)</span> <span>{</span>\n            <span>return</span><span>;</span>\n        <span>}</span>\n\n        <span>reportRevenue</span><span>(</span>adValue<span>.</span><span>getValueMicros</span><span>(</span><span>)</span><span>,</span> adValue<span>.</span><span>getCurrencyCode</span><span>(</span><span>)</span><span>,</span> network<span>,</span> unitBean<span>.</span><span>getId</span><span>(</span><span>)</span><span>,</span> placeBean<span>.</span><span>getPlace</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre></div><h4 id=\"_3-2-4-step4-在请求成功的回调中为广告对象设置-onpaideventlistener\" tabindex=\"-1\"> 3.2.4 Step4. 在请求成功的回调中为广告对象设置 <code>OnPaidEventListener</code></h4>\n<div><pre><code><span>/* 示例：开屏广告设置监听器的方法。（插页广告与之类似） */</span>\n<span>@Override</span>\n<span>public</span> <span>void</span> <span>onAdLoaded</span><span>(</span><span>@NonNull</span> <span>AppOpenAd</span> appOpenAd<span>)</span> <span>{</span>\n    <span>.</span><span>.</span><span>.</span>\n    <span>String</span> adapterName <span>=</span> appOpenAd<span>.</span><span>getResponseInfo</span><span>(</span><span>)</span><span>.</span><span>getMediationAdapterClassName</span><span>(</span><span>)</span><span>;</span>\n    <span>/*\n        placeBean 实体类的作用是提供广告位名称\n        unitBean 实体类的作用是提供广告单元 id\n    */</span>\n    appOpenAd<span>.</span><span>setOnPaidEventListener</span><span>(</span><span>new</span> <span>MyOnPaidEventListener</span><span>(</span>placeBean<span>,</span> unitBean<span>,</span> adapterName<span>)</span><span>)</span><span>;</span>\n    ad <span>=</span> <span>(</span><span>T</span><span>)</span> appOpenAd<span>;</span>\n    <span>.</span><span>.</span><span>.</span>\n<span>}</span>\n</code></pre></div><div><pre><code><span>/* 示例：原生广告设置监听器的方法。 */</span>\nadLoadBuilder<span>.</span><span>forNativeAd</span><span>(</span>nativeAd <span>-></span> <span>{</span> <span>// onNativeAdLoaded</span>\n    <span>.</span><span>.</span><span>.</span>\n    <span>String</span> adapterName <span>=</span> nativeAd<span>.</span><span>getResponseInfo</span><span>(</span><span>)</span> <span>==</span> <span>null</span> <span>?</span> <span>\"\"</span> <span>:</span> nativeAd<span>.</span><span>getResponseInfo</span><span>(</span><span>)</span><span>.</span><span>getMediationAdapterClassName</span><span>(</span><span>)</span><span>;</span>\n    nativeAd<span>.</span><span>setOnPaidEventListener</span><span>(</span><span>new</span> <span>MyOnPaidEventListener</span><span>(</span>placeBean<span>,</span> unitBean<span>,</span> adapterName<span>)</span><span>)</span><span>;</span>\n    ad <span>=</span> <span>(</span><span>T</span><span>)</span> nativeAd<span>;</span>\n    <span>.</span><span>.</span><span>.</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre></div><div><pre><code><span>/* 示例：Banner 广告设置监听器的方法。 */</span>\n<span>public</span> <span>void</span> <span>onAdLoaded</span><span>(</span><span>)</span> <span>{</span>\n    <span>.</span><span>.</span><span>.</span>\n    <span>String</span> adapterName <span>=</span> adView<span>.</span><span>getResponseInfo</span><span>(</span><span>)</span> <span>==</span> <span>null</span> <span>?</span> <span>\"\"</span> <span>:</span> adView<span>.</span><span>getResponseInfo</span><span>(</span><span>)</span><span>.</span><span>getMediationAdapterClassName</span><span>(</span><span>)</span><span>;</span>\n    adView<span>.</span><span>setOnPaidEventListener</span><span>(</span><span>new</span> <span>MyOnPaidEventListener</span><span>(</span>placeBean<span>,</span> unitBean<span>,</span> adapterName<span>)</span><span>)</span><span>;</span>\n    <span>.</span><span>.</span><span>.</span>\n<span>}</span>\n</code></pre></div><h3 id=\"_3-3-通过-adjust-上报广告的请求事件、匹配事件、点击事件\" tabindex=\"-1\"> 3.3 通过 <code>Adjust</code> 上报广告的请求事件、匹配事件、点击事件</h3>\n<h4 id=\"_3-3-1-产品需提供的信息\" tabindex=\"-1\"> 3.3.1 产品需提供的信息</h4>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>事件名称</strong></th>\n<th style=\"text-align:left\"><strong><code>Adjust</code> 识别码</strong></th>\n<th style=\"text-align:left\"><strong>备注</strong></th>\n<th style=\"text-align:left\"><strong>触发条件</strong></th>\n<th style=\"text-align:left\"><strong>参数</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>cfaska</code></td>\n<td style=\"text-align:left\"><code>c6j2e7</code></td>\n<td style=\"text-align:left\">请求事件</td>\n<td style=\"text-align:left\">开始请求广告后，回传数据</td>\n<td style=\"text-align:left\">广告单元 <code>unitId</code>、广告位置 <code>place</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>cfmata</code></td>\n<td style=\"text-align:left\"><code>2scofd</code></td>\n<td style=\"text-align:left\">匹配事件</td>\n<td style=\"text-align:left\">广告请求成功后，回传数据</td>\n<td style=\"text-align:left\">广告单元 <code>unitId</code>、收入渠道 <code>channel</code>、广告位置 <code>place</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>cfpota</code></td>\n<td style=\"text-align:left\"><code>g55rtc</code></td>\n<td style=\"text-align:left\">点击事件</td>\n<td style=\"text-align:left\">广告点击后，回传数据</td>\n<td style=\"text-align:left\">广告单元 <code>unitId</code>、收入渠道 <code>channel</code>、广告位置 <code>place</code></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>注意：广告的请求事件触发时，还无法获取到收入渠道，所以此时不需要传（或根据产品需求传 <code>&quot;&quot;</code>，或传一个默认值（如 &quot;<code>admob</code>&quot;））</p>\n</blockquote>\n<h4 id=\"_3-3-2-定义埋点方法-兼容带参数的事件\" tabindex=\"-1\"> 3.3.2 定义埋点方法（兼容带参数的事件）</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>trackEvent</span><span>(</span><span>String</span> event<span>,</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> params<span>,</span> <span>boolean</span> unique<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>unique <span>&amp;&amp;</span> <span>SPUtils</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>.</span><span>getBoolean</span><span>(</span>event<span>)</span><span>)</span> <span>{</span>\n        <span>Log</span><span>.</span><span>e</span><span>(</span>TAG<span>,</span> <span>\"trackEvent() -->  unique event \"</span> <span>+</span> event <span>+</span> <span>\"  has been REPORT !!!\"</span><span>)</span><span>;</span>\n        <span>return</span><span>;</span> <span>// 去重事件已经上报过，不再上报</span>\n    <span>}</span>\n\n    <span>AdjustEvent</span> adjustEvent <span>=</span> <span>new</span> <span>AdjustEvent</span><span>(</span>event<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>unique<span>)</span> <span>{</span>\n        adjustEvent<span>.</span><span>setOrderId</span><span>(</span>event<span>)</span><span>;</span> <span>// Adjust 内部的去重（最多只能支持10个事件，所以自己再套了层 SP 保证去重）</span>\n    <span>}</span>\n\n    <span>if</span> <span>(</span>params <span>!=</span> <span>null</span> <span>&amp;&amp;</span> <span>!</span>params<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n        <span>for</span> <span>(</span><span>Map<span>.</span>Entry</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> entry <span>:</span> params<span>.</span><span>entrySet</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            adjustEvent<span>.</span><span>addCallbackParameter</span><span>(</span>entry<span>.</span><span>getKey</span><span>(</span><span>)</span><span>,</span> entry<span>.</span><span>getValue</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>Adjust</span><span>.</span><span>trackEvent</span><span>(</span>adjustEvent<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>unique<span>)</span> <span>{</span>\n        <span>SPUtils</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>.</span><span>put</span><span>(</span>event<span>,</span> <span>true</span><span>)</span><span>;</span> <span>// 自己通过 SP 保证去重</span>\n    <span>}</span>\n<span>}</span>\n</code></pre></div><h4 id=\"_3-3-3-上报各个广告的请求事件\" tabindex=\"-1\"> 3.3.3 上报各个广告的请求事件</h4>\n<div><pre><code><span>/* 1. 广告请求事件的埋点方法封装 */</span>\n<span>/**\n * 事件: 开始请求广告后，回传数据\n * 事件识别码: xxx\n * 广告单元参数 unitId, 广告位置参数 place\n */</span>\n<span>public</span> <span>static</span> <span>void</span> <span>traceAdPreload</span><span>(</span><span>String</span> unitId<span>,</span> <span>String</span> place<span>)</span> <span>{</span>\n    <span>LogUtils</span><span>.</span><span>e</span><span>(</span>TAG<span>,</span> <span>\"--> traceAdPreload()  unitId=\"</span> <span>+</span> unitId <span>+</span> <span>\"  place=\"</span> <span>+</span> place<span>)</span><span>;</span>\n    <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> map <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    map<span>.</span><span>put</span><span>(</span><span>\"unitId\"</span><span>,</span> unitId<span>)</span><span>;</span>\n    map<span>.</span><span>put</span><span>(</span><span>\"place\"</span><span>,</span> place<span>)</span><span>;</span>\n    <span>trackEvent</span><span>(</span><span>\"xxx\"</span><span>,</span> map<span>,</span> <span>false</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre></div><div><pre><code><span>/* 2. 在各个广告请求前调用 traceAdPreload 方法 */</span>\n\n<span>// 示例：在开屏广告请求前调用（其他广告类似处理）</span>\n<span>traceAdPreload</span><span>(</span>unitBean<span>.</span><span>getId</span><span>(</span><span>)</span><span>,</span> placeBean<span>.</span><span>getPlace</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>AdRequest</span> request <span>=</span> <span>new</span> <span>AdRequest<span>.</span>Builder</span><span>(</span><span>)</span><span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>\n<span>AppOpenAd</span><span>.</span><span>load</span><span>(</span>context<span>,</span> unitBean<span>.</span><span>getId</span><span>(</span><span>)</span><span>,</span> request<span>,</span> <span>AppOpenAd</span><span>.</span>APP_OPEN_AD_ORIENTATION_PORTRAIT<span>,</span> appOpenAdLoadCallback<span>)</span><span>;</span>\n</code></pre></div><h4 id=\"_3-3-4-上报各个广告的匹配事件-请求成功\" tabindex=\"-1\"> 3.3.4 上报各个广告的匹配事件（请求成功）</h4>\n<div><pre><code><span>/* 1. 广告匹配事件（请求成功）的埋点方法封装 */</span>\n<span>/**\n * 事件: 广告请求成功后，回传数据\n * 事件识别码: xxx\n * 广告单元参数 unitId, 广告位置参数 place, 收入渠道参数 channel\n */</span>\n<span>public</span> <span>static</span> <span>void</span> <span>traceAdLoadSuccess</span><span>(</span><span>String</span> unitId<span>,</span> <span>String</span> place<span>,</span> <span>String</span> channel<span>)</span> <span>{</span>\n    <span>LogUtils</span><span>.</span><span>e</span><span>(</span>TAG<span>,</span> <span>\"--> traceAdLoadSuccess()  unitId=\"</span> <span>+</span> unitId <span>+</span> <span>\"  place=\"</span> <span>+</span> place <span>+</span> <span>\"  channel=\"</span> <span>+</span> channel<span>)</span><span>;</span>\n    <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> map <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    map<span>.</span><span>put</span><span>(</span><span>\"unitId\"</span><span>,</span> unitId<span>)</span><span>;</span>\n    map<span>.</span><span>put</span><span>(</span><span>\"place\"</span><span>,</span> place<span>)</span><span>;</span>\n    map<span>.</span><span>put</span><span>(</span><span>\"channel\"</span><span>,</span> channel<span>)</span><span>;</span>\n    <span>trackEvent</span><span>(</span><span>\"xxx\"</span><span>,</span> map<span>,</span> <span>false</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre></div><div><pre><code><span>/* 2. 在各个广告请求成功的回调中调用 traceAdLoadSuccess 方法 */</span>\n\n<span>// 示例：在开屏广告请求成功时调用 traceAdLoadSuccess 方法（其他广告类似处理）</span>\n<span>@Override</span>\n<span>public</span> <span>void</span> <span>onAdLoaded</span><span>(</span><span>@NonNull</span> <span>AppOpenAd</span> appOpenAd<span>)</span> <span>{</span>\n    <span>LogUtils</span><span>.</span><span>e</span><span>(</span>TAG<span>,</span> <span>\"--> onAdLoaded() appOpenAd=\"</span> <span>+</span> appOpenAd<span>)</span><span>;</span>\n    <span>.</span><span>.</span><span>.</span>\n    <span>String</span> adapterName <span>=</span> appOpenAd<span>.</span><span>getResponseInfo</span><span>(</span><span>)</span><span>.</span><span>getMediationAdapterClassName</span><span>(</span><span>)</span><span>;</span>\n    appOpenAd<span>.</span><span>setOnPaidEventListener</span><span>(</span><span>new</span> <span>MyOnPaidEventListener</span><span>(</span>placeBean<span>,</span> unitBean<span>,</span> adapterName<span>)</span><span>)</span><span>;</span>\n    <span>traceAdLoadSuccess</span><span>(</span>unitBean<span>.</span><span>getId</span><span>(</span><span>)</span><span>,</span> placeBean<span>.</span><span>getPlace</span><span>(</span><span>)</span><span>,</span> <span>AdConfig</span><span>.</span><span>getAdChannel</span><span>(</span>adapterName<span>)</span><span>)</span><span>;</span>\n    ad <span>=</span> <span>(</span><span>T</span><span>)</span> appOpenAd<span>;</span>\n    <span>.</span><span>.</span><span>.</span>\n<span>}</span>\n</code></pre></div><blockquote>\n<p>注意：就是在  调用 <code>traceAdLoadSuccess</code> 方法</p>\n</blockquote>\n<h4 id=\"_3-3-5-上报各个广告的点击事件\" tabindex=\"-1\"> 3.3.5 上报各个广告的点击事件</h4>\n<div><pre><code><span>/* 2. 广告点击事件的埋点方法封装 */</span>\n<span>/**\n * 事件: 广告点击后，回传数据\n * 事件识别码: xxx\n * 广告单元参数 unitId, 广告位置参数 place, 收入渠道参数 channel\n */</span>\n<span>public</span> <span>static</span> <span>void</span> <span>traceAdClick</span><span>(</span><span>String</span> unitId<span>,</span> <span>String</span> place<span>,</span> <span>String</span> channel<span>)</span> <span>{</span>\n    <span>LogUtils</span><span>.</span><span>e</span><span>(</span>TAG<span>,</span> <span>\"--> traceAdClick()  unitId=\"</span> <span>+</span> unitId <span>+</span> <span>\"  place=\"</span> <span>+</span> place <span>+</span> <span>\"  channel=\"</span> <span>+</span> channel<span>)</span><span>;</span>\n    <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> map <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    map<span>.</span><span>put</span><span>(</span><span>\"unitId\"</span><span>,</span> unitId<span>)</span><span>;</span>\n    map<span>.</span><span>put</span><span>(</span><span>\"place\"</span><span>,</span> place<span>)</span><span>;</span>\n    map<span>.</span><span>put</span><span>(</span><span>\"channel\"</span><span>,</span> channel<span>)</span><span>;</span>\n    <span>trackEvent</span><span>(</span><span>\"xxx\"</span><span>,</span> map<span>,</span> <span>false</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre></div><div><pre><code><span>/* 2. 在各个广告点击事件的回调中调用 traceAdClick 方法 */</span>\n\n<span>// 示例：在开屏广告的点击事件中调用 traceAdClick 方法（插页广告类似处理）</span>\n<span>@Override</span>\n<span>public</span> <span>void</span> <span>onAdClicked</span><span>(</span><span>)</span> <span>{</span>\n    <span>String</span> adapterName <span>=</span> <span>(</span><span>(</span><span>AppOpenAd</span><span>)</span> ad<span>)</span><span>.</span><span>getResponseInfo</span><span>(</span><span>)</span><span>.</span><span>getMediationAdapterClassName</span><span>(</span><span>)</span><span>;</span>\n    <span>traceAdClick</span><span>(</span>unitBean<span>.</span><span>getId</span><span>(</span><span>)</span><span>,</span> placeBean<span>.</span><span>getPlace</span><span>(</span><span>)</span><span>,</span> <span>AdConfig</span><span>.</span><span>getAdChannel</span><span>(</span>adapterName<span>)</span><span>)</span><span>;</span>\n    <span>.</span><span>.</span><span>.</span>\n<span>}</span>\n\n<span>// 示例：在原生广告的点击事件中调用 traceAdClick 方法</span>\n<span>@Override</span>\n<span>public</span> <span>void</span> <span>onAdClicked</span><span>(</span><span>)</span> <span>{</span>\n    <span>String</span> adapterName <span>=</span> <span>(</span><span>(</span><span>NativeAd</span><span>)</span> ad<span>)</span><span>.</span><span>getResponseInfo</span><span>(</span><span>)</span> <span>==</span> <span>null</span> <span>?</span> \n            <span>\"\"</span> <span>:</span> <span>(</span><span>(</span><span>NativeAd</span><span>)</span> ad<span>)</span><span>.</span><span>getResponseInfo</span><span>(</span><span>)</span><span>.</span><span>getMediationAdapterClassName</span><span>(</span><span>)</span><span>;</span>\n    <span>traceAdClick</span><span>(</span>unitBean<span>.</span><span>getId</span><span>(</span><span>)</span><span>,</span> placeBean<span>.</span><span>getPlace</span><span>(</span><span>)</span><span>,</span> <span>AdConfig</span><span>.</span><span>getAdChannel</span><span>(</span>adapterName<span>)</span><span>)</span><span>;</span>\n    <span>.</span><span>.</span><span>.</span>\n<span>}</span>\n\n<span>// 示例：在Banner 广告的点击事件中调用 traceAdClick 方法</span>\n<span>@Override</span>\n<span>public</span> <span>void</span> <span>onAdClicked</span><span>(</span><span>)</span> <span>{</span>\n    <span>String</span> adapterName <span>=</span> adView<span>.</span><span>getResponseInfo</span><span>(</span><span>)</span> <span>==</span> <span>null</span> <span>?</span> <span>\"\"</span> <span>:</span> adView<span>.</span><span>getResponseInfo</span><span>(</span><span>)</span><span>.</span><span>getMediationAdapterClassName</span><span>(</span><span>)</span><span>;</span>\n    <span>traceAdClick</span><span>(</span>unitBean<span>.</span><span>getId</span><span>(</span><span>)</span><span>,</span> placeBean<span>.</span><span>getPlace</span><span>(</span><span>)</span><span>,</span> <span>AdConfig</span><span>.</span><span>getAdChannel</span><span>(</span>adapterName<span>)</span><span>)</span><span>;</span>\n    <span>.</span><span>.</span><span>.</span>\n<span>}</span>\n</code></pre></div>",
      "date_published": "2023-05-04T15:57:35.000Z",
      "date_modified": "2023-05-28T07:27:11.000Z",
      "authors": [],
      "tags": [
        "HNAP"
      ]
    },
    {
      "title": "Admob广告接入",
      "url": "https://zengkaiqiang562.github.io/zkq/hnap/sdk/admob.html",
      "id": "https://zengkaiqiang562.github.io/zkq/hnap/sdk/admob.html",
      "content_html": "<blockquote>\n<p>参考：<a href=\"https://developers.google.cn/admob/android/quick-start\" target=\"_blank\" rel=\"noopener noreferrer\">入门指南<ExternalLinkIcon/></a></p>\n</blockquote>\n<h2 id=\"_1-接入步骤\" tabindex=\"-1\"> 1. 接入步骤</h2>\n<h3 id=\"step-1-添加依赖仓库\" tabindex=\"-1\"> Step 1. 添加依赖仓库</h3>\n<p>在根 <code>build.gradle</code> 文件中添加：</p>\n<div><pre><code>buildscript <span>{</span>\n    repositories <span>{</span>\n        <span>google</span><span>(</span><span>)</span>\n        <span>mavenCentral</span><span>(</span><span>)</span>\n    <span>}</span>\n<span>}</span>\n\nallprojects <span>{</span>\n    repositories <span>{</span>\n        <span>google</span><span>(</span><span>)</span>\n        <span>mavenCentral</span><span>(</span><span>)</span>\n    <span>}</span>\n<span>}</span>\n</code></pre></div><p><code>Android Gradle Plugin 7.0+</code> 在 <code>settings.gradle</code> 中添加：</p>\n<div><pre><code>pluginManagement <span>{</span>\n    repositories <span>{</span>\n        <span>gradlePluginPortal</span><span>(</span><span>)</span>\n        <span>google</span><span>(</span><span>)</span>\n        <span>mavenCentral</span><span>(</span><span>)</span>\n    <span>}</span>\n<span>}</span>\ndependencyResolutionManagement <span>{</span>\n    repositoriesMode<span>.</span><span>set</span><span>(</span>RepositoriesMode<span>.</span>FAIL_ON_PROJECT_REPOS<span>)</span>\n    repositories <span>{</span>\n        <span>google</span><span>(</span><span>)</span>\n        <span>mavenCentral</span><span>(</span><span>)</span>\n        maven <span>{</span> url <span>'https://jitpack.io'</span> <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre></div><h3 id=\"step-2-添加依赖包\" tabindex=\"-1\"> Step 2. 添加依赖包</h3>\n<p>在模块 <code>build.gradle</code> 文件中添加：</p>\n<div><pre><code>dependencies <span>{</span>\n    implementation <span>'com.google.android.gms:play-services-ads:21.0.0'</span>\n<span>}</span>\n</code></pre></div><h3 id=\"step-3-在-androidmanifest-xml-中配置-app-id\" tabindex=\"-1\"> Step 3. 在 <code>AndroidManifest.xml</code> 中配置 <code>App Id</code></h3>\n<div><pre><code><span><span><span>&lt;</span>manifest</span><span>></span></span>\n    <span><span><span>&lt;</span>application</span><span>></span></span>\n        <span>&lt;!-- Sample AdMob app ID: ca-app-pub-3940256099942544~3347511713 --></span>\n        <span>&lt;!-- 注意：实际开发时要替换成自己的 App Id --></span>\n        <span><span><span>&lt;</span>meta-data</span>\n            <span><span>android:</span>name</span><span><span>=</span><span>\"</span>com.google.android.gms.ads.APPLICATION_ID<span>\"</span></span>\n            <span><span>android:</span>value</span><span><span>=</span><span>\"</span>ca-app-pub-xxxxxxxxxxxxxxxx~yyyyyyyyyy<span>\"</span></span><span>/></span></span>\n    <span><span><span>&lt;/</span>application</span><span>></span></span>\n<span><span><span>&lt;/</span>manifest</span><span>></span></span>\n</code></pre></div><h3 id=\"step-4-在-application-中初始化\" tabindex=\"-1\"> Step 4. 在 <code>Application</code> 中初始化</h3>\n<div><pre><code><span>public</span> <span>class</span> <span>MyApplication</span> <span>extends</span> <span>Application</span> <span>{</span>\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>onCreate</span><span>(</span><span>)</span> <span>{</span>\n        <span>super</span><span>.</span><span>onCreate</span><span>(</span><span>)</span><span>;</span>\n\n        <span>initMobileAds</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>private</span> <span>void</span> <span>initMobileAds</span><span>(</span><span>)</span> <span>{</span>\n\n        <span>// if (BuildConfig.DEBUG) {</span>\n        <span>//     // TODO 添写测试机的 DeviceId</span>\n        <span>//     // 参考：https://developers.google.cn/admob/android/test-ads#add_your_test_device_programmatically</span>\n        <span>//       List&lt;String> testDeviceIds = Arrays.asList(\"2B290798B3C52E15FF6CACDAAA57C910\", \"F9180FB4550B86775EB93370CFB3BCA8\");</span>\n        <span>//       RequestConfiguration configuration =</span>\n        <span>//               new RequestConfiguration.Builder().setTestDeviceIds(testDeviceIds).build();</span>\n        <span>//       MobileAds.setRequestConfiguration(configuration);</span>\n        <span>// }</span>\n\n        <span>MobileAds</span><span>.</span><span>initialize</span><span>(</span><span>this</span><span>,</span> initializationStatus <span>-></span> <span>{</span>\n            <span>for</span> <span>(</span><span>Map<span>.</span>Entry</span><span><span>&lt;</span><span>String</span><span>,</span> <span>AdapterStatus</span><span>></span></span> entry <span>:</span> initializationStatus<span>.</span><span>getAdapterStatusMap</span><span>(</span><span>)</span><span>.</span><span>entrySet</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                <span>Printer</span><span>.</span><span>e</span><span>(</span>TAG<span>,</span> <span>\"==> initMobileAds() onCompleted  entry.key=\"</span> <span>+</span> entry<span>.</span><span>getKey</span><span>(</span><span>)</span>\n                        <span>+</span> <span>\"  entry.AdapterStatus.desc=\"</span> <span>+</span> entry<span>.</span><span>getValue</span><span>(</span><span>)</span><span>.</span><span>getDescription</span><span>(</span><span>)</span> \n                        <span>+</span> <span>\"  entry.AdapterStatus.state=\"</span> <span>+</span> entry<span>.</span><span>getValue</span><span>(</span><span>)</span><span>.</span><span>getInitializationState</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre></div><blockquote>\n<p>加载广告之前，请先调用 <code>MobileAds.initialize()</code>，以便让应用初始化 <code>Google</code> 移动广告 <code>SDK</code>。</p>\n<p>该方法将初始化相应 <code>SDK</code>，并在初始化完成后或 <code>30</code> 秒超时后回调完成监听器。此操作仅需执行一次，最好是在应用启动时执行。</p>\n</blockquote>\n<h3 id=\"step-5-测试广告\" tabindex=\"-1\"> Step 5. 测试广告</h3>\n<p>在开发过程中启用测试广告非常重要，这样您就可以在不向 <code>Google</code> 广告客户收费的情况下点击广告。</p>\n<p><strong>在非测试模式下，如果您点击过多广告，可能会导致您的帐号因为无效活动而被举报。</strong></p>\n<p>有以下两种获得测试广告的方法：</p>\n<ol>\n<li>\n<p>使用 <code>Google</code> 提供的任一示例广告单元 <code>ID</code>。</p>\n</li>\n<li>\n<p>使用自己的广告单元 <code>ID</code> 并 <a href=\"https://developers.google.cn/admob/android/test-ads#enable_test_devices\" target=\"_blank\" rel=\"noopener noreferrer\">启用测试设备<ExternalLinkIcon/></a>。</p>\n</li>\n</ol>\n<p><strong>如下所示，为 <code>Google</code> 提供的示例广告单元 <code>ID</code>：</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">广告格式</th>\n<th style=\"text-align:left\">示例广告单元 <code>ID</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">开屏广告</td>\n<td style=\"text-align:left\"><code>ca-app-pub-3940256099942544/3419835294</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">横幅广告</td>\n<td style=\"text-align:left\"><code>ca-app-pub-3940256099942544/6300978111</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">插页式广告</td>\n<td style=\"text-align:left\"><code>ca-app-pub-3940256099942544/1033173712</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">插页式视频广告</td>\n<td style=\"text-align:left\"><code>ca-app-pub-3940256099942544/8691691433</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">激励广告</td>\n<td style=\"text-align:left\"><code>ca-app-pub-3940256099942544/5224354917</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">插页式激励广告</td>\n<td style=\"text-align:left\"><code>ca-app-pub-3940256099942544/5354046379</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">原生高级广告</td>\n<td style=\"text-align:left\"><code>ca-app-pub-3940256099942544/2247696110</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">原生高级视频广告</td>\n<td style=\"text-align:left\"><code>ca-app-pub-3940256099942544/1044960115</code></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"_2-获取-google-的广告-id\" tabindex=\"-1\"> 2. 获取 <code>Google</code> 的广告 <code>ID</code></h2>\n<div><pre><code><span>/* 需要依赖 Admob 广告 SDK */</span>\n<span>// 在子线程中执行</span>\n<span>private</span> <span>void</span> <span>fetchGoogleAdvertID</span><span>(</span><span>)</span> <span>{</span>\n    <span>try</span> <span>{</span>\n        <span>AdvertisingIdClient<span>.</span>Info</span> adInfo <span>=</span> <span>AdvertisingIdClient</span><span>.</span><span>getAdvertisingIdInfo</span><span>(</span><span>this</span><span>)</span><span>;</span>\n        sGoogleAdvertID <span>=</span> adInfo<span>.</span><span>getId</span><span>(</span><span>)</span><span>;</span>\n        <span>Printer</span><span>.</span><span>e</span><span>(</span>TAG<span>,</span> <span>\"fetchGoogleAdvertID() ==>  sGoogleAdvertID=\"</span> <span>+</span> sGoogleAdvertID<span>)</span><span>;</span>\n    <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n        <span>Printer</span><span>.</span><span>e</span><span>(</span>TAG<span>,</span> <span>\"fetchGoogleAdvertID() ==>  Exception=\"</span> <span>+</span> e<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre></div>",
      "date_published": "2023-05-04T15:57:35.000Z",
      "date_modified": "2023-05-04T15:57:35.000Z",
      "authors": [],
      "tags": [
        "HNAP"
      ]
    },
    {
      "title": "Facebook接入",
      "url": "https://zengkaiqiang562.github.io/zkq/hnap/sdk/facebook.html",
      "id": "https://zengkaiqiang562.github.io/zkq/hnap/sdk/facebook.html",
      "content_html": "<blockquote>\n<p>参考：<a href=\"https://developers.facebook.com/docs/android/getting-started\" target=\"_blank\" rel=\"noopener noreferrer\">Android 版 Facebook SDK 入门指南<ExternalLinkIcon/></a></p>\n</blockquote>\n<h2 id=\"_1-接入步骤\" tabindex=\"-1\"> 1. 接入步骤</h2>\n<h3 id=\"step-1-添加依赖包\" tabindex=\"-1\"> Step 1. 添加依赖包</h3>\n<div><pre><code><span>/* Module build.gradle */</span>\n\n<span>/* Facebook */</span>\nimplementation <span>'com.facebook.android:facebook-core:12.1.0'</span>\nimplementation <span>'com.facebook.android:facebook-applinks:12.1.0'</span>\n</code></pre></div><h3 id=\"step-2-在-androidmanifest-xml-中配置-app-id\" tabindex=\"-1\"> Step 2. 在 <code>AndroidManifest.xml</code> 中配置 <code>App ID</code></h3>\n<div><pre><code><span>&lt;!-- Facebook --></span>\n<span><span><span>&lt;</span>meta-data</span>\n    <span><span>android:</span>name</span><span><span>=</span><span>\"</span>com.facebook.sdk.ApplicationId<span>\"</span></span>\n    <span><span>android:</span>value</span><span><span>=</span><span>\"</span>000000000000000<span>\"</span></span><span>/></span></span>\n</code></pre></div><h3 id=\"step3-在-application-中进行初始化配置\" tabindex=\"-1\"> Step3. 在 <code>Application</code> 中进行初始化配置</h3>\n<div><pre><code><span>public</span> <span>class</span> <span>MyApplication</span> <span>extends</span> <span>Application</span> <span>{</span>\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>onCreate</span><span>(</span><span>)</span> <span>{</span>\n        <span>super</span><span>.</span><span>onCreate</span><span>(</span><span>)</span><span>;</span>\n\n        <span>initFacebook</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>private</span> <span>void</span> <span>initFacebook</span><span>(</span><span>)</span> <span>{</span>\n        <span>FacebookSdk</span><span>.</span><span>setApplicationId</span><span>(</span><span>\"000000000000000\"</span><span>)</span><span>;</span> <span>// app id（跟 AndroidManifest.xml 中配置的一样）</span>\n        <span>FacebookSdk</span><span>.</span><span>setClientToken</span><span>(</span><span>\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"</span><span>)</span><span>;</span> <span>// token</span>\n        <span>FacebookSdk</span><span>.</span><span>sdkInitialize</span><span>(</span><span>this</span><span>)</span><span>;</span>\n        <span>AppEventsLogger</span><span>.</span><span>activateApp</span><span>(</span><span>this</span><span>)</span><span>;</span>\n        <span>FacebookSdk</span><span>.</span><span>setAutoLogAppEventsEnabled</span><span>(</span><span>true</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre></div>",
      "date_published": "2023-05-04T15:57:35.000Z",
      "date_modified": "2023-05-04T15:57:35.000Z",
      "authors": [],
      "tags": [
        "HNAP"
      ]
    },
    {
      "title": "Firebase接入",
      "url": "https://zengkaiqiang562.github.io/zkq/hnap/sdk/firebase.html",
      "id": "https://zengkaiqiang562.github.io/zkq/hnap/sdk/firebase.html",
      "content_html": "<h2 id=\"_1-接入步骤\" tabindex=\"-1\"> 1. 接入步骤</h2>\n<blockquote>\n<p>参考：<a href=\"https://firebase.google.com/docs/android/setup?authuser=0#prerequisites\" target=\"_blank\" rel=\"noopener noreferrer\">将 Firebase 添加到您的 Android 项目<ExternalLinkIcon/></a></p>\n<p>参考：<a href=\"https://firebase.google.com/docs/analytics/get-started?platform=android&amp;authuser=0\" target=\"_blank\" rel=\"noopener noreferrer\">Google Analytics（分析）使用入门<ExternalLinkIcon/></a></p>\n<p>参考：<a href=\"https://firebase.google.com/docs/crashlytics/get-started?authuser=0&amp;platform=android\" target=\"_blank\" rel=\"noopener noreferrer\">Firebase Crashlytics 使用入门<ExternalLinkIcon/></a></p>\n</blockquote>\n<h3 id=\"step-1-添加依赖仓库\" tabindex=\"-1\"> Step 1. 添加依赖仓库</h3>\n<div><pre><code><span>/* Project build.gradle */</span>\nbuildscript <span>{</span>\n    dependencies <span>{</span>\n        classpath <span>'com.google.gms:google-services:4.3.14'</span>  <span>// Google Services plugin</span>\n        classpath <span>'com.google.firebase:firebase-crashlytics-gradle:2.9.2'</span>\n    <span>}</span>\n<span>}</span>\n</code></pre></div><blockquote>\n<p>注意：<code>Android Gradle Plugin 7.0+</code> 中 <code>buildscript {...}</code> 需要添加在 <code>plugins {...}</code> 之前。</p>\n</blockquote>\n<h3 id=\"step-2-导入-gradle-插件\" tabindex=\"-1\"> Step 2. 导入 <code>Gradle</code> 插件</h3>\n<div><pre><code><span>/* Module build.gradle */</span>\nplugins <span>{</span>\n    id <span>'com.android.application'</span>\n    id <span>'com.google.gms.google-services'</span>  <span>// Google Services plugin</span>\n    id <span>'com.google.firebase.crashlytics'</span> <span>// Apply the Crashlytics Gradle plugin</span>\n<span>}</span>\n</code></pre></div><h3 id=\"step-3-添加依赖包\" tabindex=\"-1\"> Step 3. 添加依赖包</h3>\n<div><pre><code><span>/* Module build.gradle */</span>\n\n<span>/* Firebase */</span>\n<span>// Import the BoM for the Firebase platform</span>\nimplementation <span>platform</span><span>(</span><span>'com.google.firebase:firebase-bom:30.5.0'</span><span>)</span>\n<span>// Declare the dependencies for the Crashlytics and Analytics libraries</span>\n<span>// When using the BoM, you don't specify versions in Firebase library dependencies</span>\nimplementation <span>'com.google.firebase:firebase-crashlytics'</span>\nimplementation <span>'com.google.firebase:firebase-analytics'</span>\n</code></pre></div><h3 id=\"step-4-导入-google-services-json-配置文件\" tabindex=\"-1\"> Step 4. 导入 <code>google-services.json</code> 配置文件</h3>\n<p>将 <code>google-services.json</code> 文件存放在模块目录下（如路径 <code>app/google-services.json</code>）</p>\n<h3 id=\"step-5-androidmanifest-xml-中的配置\" tabindex=\"-1\"> Step 5. AndroidManifest.xml 中的配置</h3>\n<div><pre><code><span>&lt;!-- 在 application 标签下配置 --></span>\n\n<span>&lt;!-- Firebase 的 Crashlytics 启用自选式报告 --></span>\n<span>&lt;!-- 参考：https://firebase.google.com/docs/crashlytics/customize-crash-reports?authuser=0&amp;platform=android#enable-reporting --></span>\n<span>&lt;!-- 此时，当代码中调用 FirebaseCrashlytics.getInstance().setCrashlyticsCollectionEnabled(true); 时才会启动崩溃分析  --></span>\n<span><span><span>&lt;</span>meta-data</span>\n    <span><span>android:</span>name</span><span><span>=</span><span>\"</span>firebase_crashlytics_collection_enabled<span>\"</span></span>\n    <span><span>android:</span>value</span><span><span>=</span><span>\"</span>false<span>\"</span></span> <span>/></span></span>\n</code></pre></div><h3 id=\"step-6-在-application-中进行初始化配置\" tabindex=\"-1\"> Step 6. 在 <code>Application</code> 中进行初始化配置</h3>\n<div><pre><code><span>public</span> <span>class</span> <span>MyApplication</span> <span>extends</span> <span>Application</span> <span>{</span>\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>onCreate</span><span>(</span><span>)</span> <span>{</span>\n        <span>super</span><span>.</span><span>onCreate</span><span>(</span><span>)</span><span>;</span>\n\n        <span>setFirebaseEnable</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>private</span> <span>void</span> <span>setFirebaseEnable</span><span>(</span><span>)</span> <span>{</span>\n        <span>// Analytics</span>\n        <span>obtainAnalytics</span><span>(</span><span>)</span><span>.</span><span>setAnalyticsCollectionEnabled</span><span>(</span><span>true</span><span>)</span><span>;</span>\n        <span>// Crashlytics: release 传 true，debug 传 false</span>\n        <span>FirebaseCrashlytics</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>.</span><span>setCrashlyticsCollectionEnabled</span><span>(</span><span>!</span><span>BuildConfig</span><span>.</span>VPN_DEBUG<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>// 埋点时需要用到 FirebaseAnalytics 实例，所以对外提供 FirebaseAnalytics 对象</span>\n    <span>public</span> <span>static</span> <span>FirebaseAnalytics</span> <span>obtainAnalytics</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>FirebaseAnalytics</span><span>.</span><span>getInstance</span><span>(</span>app<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre></div><h2 id=\"_2-fcm-云消息\" tabindex=\"-1\"> 2. <code>FCM</code> 云消息</h2>\n<h2 id=\"_3-remote-config\" tabindex=\"-1\"> 3. <code>Remote Config</code></h2>\n<h2 id=\"_4-a-b-testing\" tabindex=\"-1\"> 4. <code>A/B Testing</code></h2>\n",
      "date_published": "2023-05-04T15:57:35.000Z",
      "date_modified": "2023-05-04T15:57:35.000Z",
      "authors": [],
      "tags": [
        "HNAP"
      ]
    },
    {
      "title": "学习笔记",
      "url": "https://zengkaiqiang562.github.io/zkq/study_note/",
      "id": "https://zengkaiqiang562.github.io/zkq/study_note/",
      "content_html": "<h4 id=\"享学-android-1、2期\" tabindex=\"-1\"> 享学 Android 1、2期</h4>\n<h4 id=\"码牛-android-2期\" tabindex=\"-1\"> 码牛 Android 2期</h4>\n<ol>\n<li>\n<p>kotlin 专题</p>\n</li>\n<li>\n<p>高级音视频专题</p>\n</li>\n</ol>\n<h4 id=\"黑马-c-32期\" tabindex=\"-1\"> 黑马 C++ 32期</h4>\n<h4 id=\"黑马前端-v6-5\" tabindex=\"-1\"> 黑马前端 v6.5</h4>\n<h4 id=\"flutter-开发实战详解\" tabindex=\"-1\"> Flutter 开发实战详解</h4>\n<h5 id=\"玩转-java-并发工具-精通-juc-成为并发多面手\" tabindex=\"-1\"> 玩转 Java 并发工具，精通 JUC，成为并发多面手</h5>\n<h4 id=\"一站式学习-java-网络编程全面理解-bio\" tabindex=\"-1\"> 一站式学习 Java 网络编程全面理解 BIO</h4>\n<h4 id=\"老男孩-linux-云计算-76期-高级-sre-运维课程\" tabindex=\"-1\"> 老男孩 Linux 云计算（76期）高级 SRE 运维课程</h4>\n",
      "date_published": "2023-04-09T15:40:54.000Z",
      "date_modified": "2023-04-09T15:40:54.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "C/C++",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/",
      "content_html": "<p><strong>黑马 <code>C/C++ 32</code> 期</strong></p>\n",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "第01天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day01.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day01.html",
      "content_html": "<h2 id=\"_1-system-函数\" tabindex=\"-1\"> 1. <code>system</code> 函数</h2>\n<p><strong>作用：</strong> 执行系统命令。如：<code>pause</code>、<code>cmd</code>、<code>calc</code>、<code>mspaint</code>、<code>notepad</code> ...</p>\n<p><strong>示例：</strong></p>\n<div><pre><code><span>system</span><span>(</span><span>\"cmd\"</span><span>)</span><span>;</span>  \n<span>system</span><span>(</span><span>\"calc\"</span><span>)</span><span>;</span>\n<span>system</span><span>(</span><span>\"cls\"</span><span>)</span><span>;</span> <span>// 清屏命令：cls;</span>\n</code></pre></div><h2 id=\"_2-gcc-编译步骤-预处理-编译-汇编-链接\" tabindex=\"-1\"> 2. <code>gcc</code> 编译步骤（预处理-编译-汇编-链接）</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day01/01.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>（-o 选项仅用于指定输出文件名, 不使用 -o, 仅执行 gcc hello.c , 则默认生成 a.exe）\ngcc -E hello.c -o hello.i\ngcc -S hello.i -o hello.s\ngcc -c hello.s -o hello.o\ngcc hello.o -o hello.exe\n</code></pre></div><p><strong>1. 预处理</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">命名选项</th>\n<th style=\"text-align:left\">输出文件</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>-E</code></td>\n<td style=\"text-align:left\"><code>xxx.i</code> 预处理文件（纯文本文件）</td>\n</tr>\n</tbody>\n</table>\n<div><pre><code>gcc -E xxx.c -o xxx.i\n\n1）头文件展开（即 生成的预处理文件 xxx.i 中会包括头文件的所有内容）。 \n    --- 不检查语法错误（但会将语法错误提示出来，仍能成预处理文件）。可以展开任意文件。\n2）宏定义替换。\n    --- 将宏名替换为宏值。\n3）替换注释。\n    --- 变成空行\n4）展开条件编译。\n    --- 根据条件来展开指令。\n</code></pre></div><p><strong>2. 编译</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">命名选项</th>\n<th style=\"text-align:left\">输出文件</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>-S</code></td>\n<td style=\"text-align:left\"><code>xxx.s</code> 汇编文件（纯文本文件，即汇编代码文件）</td>\n</tr>\n</tbody>\n</table>\n<div><pre><code>gcc -S hello.i -o hello.s\n\n1）逐行检查语法错误。【重点】    \n    --- 整个编译4步骤中最耗时的过程。\n2）将 C 程序翻译成汇编指令，得到 .s 汇编文件。\n</code></pre></div><p><strong>3. 汇编</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">命名选项</th>\n<th style=\"text-align:left\">输出文件</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>-c</code></td>\n<td style=\"text-align:left\"><code>xxx.o</code> 目标文件（二进制文件）</td>\n</tr>\n</tbody>\n</table>\n<div><pre><code>gcc -c hello.s -o hello.o\n\n1）翻译：将汇编指令翻译成对应的二进制编码。\n</code></pre></div><p><strong>4. 链接</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">命名选项</th>\n<th style=\"text-align:left\">输出文件</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">无</td>\n<td style=\"text-align:left\"><code>xxx.exe</code> 可执行文件（二进制文件）</td>\n</tr>\n</tbody>\n</table>\n<div><pre><code>gcc  hello.o -o hello.exe\n\n1）数据段合并\n2）数据地址回填\n3）库引入\n</code></pre></div><h2 id=\"_3-查找程序所依赖的动态库\" tabindex=\"-1\"> 3. 查找程序所依赖的动态库</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day01/02.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p><code>windows</code> 中 <code>.dll</code> 文件就是库文件。</p>\n</blockquote>\n<h2 id=\"_4-调试程序\" tabindex=\"-1\"> 4. 调试程序</h2>\n<p><strong><code>VS</code> 中添加行号：</strong></p>\n<div><pre><code>工具 -> 选项 -> 文本编辑器 -> C/C++ -> 行号 选中。\n</code></pre></div><p><strong>调试步骤：</strong></p>\n<div><pre><code>1. 设置断点。F5 启动调试\n2. 停止的位置，是尚未执行的指令。\n3. 逐语句执行一下条（F11）：进入函数内部，逐条执行跟踪。\n3. 逐过程执行一下条（F10）：不进入函数内部，逐条执行程序。\n4. 添加监视：调试 -> 窗口 -> 监视：输入监视变量名。自动监视变量值的变化。\n</code></pre></div><p><strong><code>VS</code> 调试过程中查看对应的汇编指令：</strong></p>\n<div><pre><code>调用 -> 窗口 -> 反汇编\n</code></pre></div><h2 id=\"_5-在指定路径下打开-cmd-命令行\" tabindex=\"-1\"> 5. 在指定路径下打开 <code>cmd</code> 命令行</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day01/03.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>如上图，在路径框内输入 <code>cmd</code> ，按回车即可打开 <code>cmd</code>，并定位到当前目录</p>\n</blockquote>\n",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-16T03:14:27.000Z",
      "authors": [],
      "tags": [
        "C语言基础"
      ]
    },
    {
      "title": "第02天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day02.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day02.html",
      "content_html": "<h2 id=\"_1-常量-不会变化的数据-不能被修改\" tabindex=\"-1\"> 1. 常量（不会变化的数据，不能被修改）</h2>\n<p><strong>三种类型的常量：</strong></p>\n<div><pre><code>1. \"hello\"、'A'、-10、3.1415926（浮点常量）\n\n2. #define PI 3.1415\n    【推荐】\n    【强调】：没有分号结束标记。 \n    【定义宏】：#define 宏名 宏值 \n\n3. const int a = 10;\n    定义语法：const 类型名 变量名 = 变量值。【不推荐，通过指针可修改】\n    const 关键字：被该关键字修饰的变量，表示为只读变量。\n</code></pre></div><h2 id=\"_2-变量-会变化的数据-能被修改\" tabindex=\"-1\"> 2. 变量（会变化的数据，能被修改）</h2>\n<p><strong>定义语法：</strong></p>\n<div><pre><code>类型名 变量名 = 变量值。（一般方法）\n</code></pre></div><p><strong>变量三要素：</strong></p>\n<div><pre><code>类型名、变量名、变量值。\n\n示例：\nint r = 3;    \nfloat s = PI*r*r;（变量值是一个表达式）\n</code></pre></div><p><strong>变量的定义 &amp; 变量的声明</strong></p>\n<div><pre><code>变量的定义： \n    int a = 40;\n\n变量的声明： \n    1）int a; // 没有变量值的变量定义叫做声明。\n    2）extern int a; // 添加了关键字 extern。\n\n1. 变量定义会开辟内存空间。变量声明不会开辟内存空间。\n2. 变量要想使用必须有定义。\n    当编译器编译程序时，在变量使用之前，必须要看到变量定义。如果没有看到变量定义，编译器会自动找寻一个变量声明提升成为定义。\n    如果该变量的声明前有 extern 关键字，无法提升。\n</code></pre></div><blockquote>\n<p>【建议】：定义变量时。尽量不要重名。</p>\n</blockquote>\n<h2 id=\"_3-标识符-变量和常量的统称\" tabindex=\"-1\"> 3. 标识符（变量和常量的统称）</h2>\n<p><strong>命名规则：</strong></p>\n<div><pre><code>1. 通常常量使用大写、变量使用小写。大小写严格区分。\n\n2. 只能使用字母、数字、下划线（\"_\"）命名标识符。且数字不能开头。 a-z/A-Z/0-9/_\n    int a5ir = 10; // ok \n    int _34F = 6; // ok\n    float s2_i85c = 5.4;  // ok\n    int 98ti_54 = 4;  // error\n\n3. 禁止使用关键字和系统函数作为标识符名称。 main/system/printf/sleep ...\n</code></pre></div><h2 id=\"_4-sizeof-关键字-sizeof-不是函数-只是一个关键字\" tabindex=\"-1\"> 4. <code>sizeof</code> 关键字（<code>sizeof</code> 不是函数，只是一个关键字）</h2>\n<p><code>sizeof</code> 不是函数，只是一个关键字，所以不需要依赖任何头文件。</p>\n<p><code>sizeof</code> 用来求一个变量、类型的大小。</p>\n<p><code>sizeof</code> 的返回值为 <code>size_t</code>，<code>size_t</code> 类型在 32 位操作系统下是 <code>unsigned int</code>，是一个无符号的整数，使用 <code>%u</code> 接收返回值。</p>\n<p><strong>使用方式：</strong></p>\n<div><pre><code>方式1：sizeof(类型名) -- sizeof(int)\n\n方式2：sizeof(变量名) -- int a = 20； sizeof(a)\n\n【了解】：sizeof 变量名/类型名  （这种去掉括号的方式不推荐使用，因为不方便阅读）\n    举例1： sizeof int \n    举例2： sizeof a\n</code></pre></div><h2 id=\"_5-数据类型\" tabindex=\"-1\"> 5. 数据类型</h2>\n<h3 id=\"_5-1-有符号整型-signed\" tabindex=\"-1\"> 5.1 有符号整型（<code>signed</code>）</h3>\n<p>类型前缀 <code>signed</code> 表示有符号（类型默认为有符号，所以通常省略前缀 <code>signed</code>）</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>整型类型</strong></th>\n<th style=\"text-align:left\"><strong>格式符</strong></th>\n<th style=\"text-align:left\"><strong>所占字节</strong></th>\n<th style=\"text-align:left\"><strong>使用示例</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>int</code></td>\n<td style=\"text-align:left\"><code>%d</code></td>\n<td style=\"text-align:left\"><code>4</code> 字节</td>\n<td style=\"text-align:left\"><code>int 名 = 值;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>short</code></td>\n<td style=\"text-align:left\"><code>%hd</code></td>\n<td style=\"text-align:left\"><code>2</code> 字节</td>\n<td style=\"text-align:left\"><code>short 名 = 值;</code> <code>short s1 = 3;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>long</code></td>\n<td style=\"text-align:left\"><code>%ld</code></td>\n<td style=\"text-align:left\"><code>4</code> 字节（windows 32/64：<code>4B</code> ； Linux 32位：<code>4B</code> ，64位：<code>8B</code> )）</td>\n<td style=\"text-align:left\"><code>long 名 = 值;</code> <code>long len = 6;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>long long</code></td>\n<td style=\"text-align:left\"><code>%lld</code></td>\n<td style=\"text-align:left\"><code>8</code> 字节</td>\n<td style=\"text-align:left\"><code>long long 名= 值;</code> <code>long long llen = 70;</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_5-2-无符号整型-unsigned\" tabindex=\"-1\"> 5.2 无符号整型（<code>unsigned</code>）</h3>\n<p>类型前缀 <code>unsigned</code> 表示无符号。无符号意味着只关心数据量，不关心方向（没有正负）</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>整型类型</strong></th>\n<th style=\"text-align:left\"><strong>格式符</strong></th>\n<th style=\"text-align:left\"><strong>所占字节</strong></th>\n<th style=\"text-align:left\"><strong>使用示例</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>unsigned int</code></td>\n<td style=\"text-align:left\"><code>%u</code></td>\n<td style=\"text-align:left\"><code>4</code> 字节</td>\n<td style=\"text-align:left\"><code>unsigned int 名 = 值;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>unsigned short</code></td>\n<td style=\"text-align:left\"><code>%hu</code></td>\n<td style=\"text-align:left\"><code>2</code> 字节</td>\n<td style=\"text-align:left\"><code>unsigned short 名 = 值;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>unsigned long</code></td>\n<td style=\"text-align:left\"><code>%lu</code></td>\n<td style=\"text-align:left\"><code>4</code> 字节（windows 32/64：<code>4B</code> ； Linux 32位：<code>4B</code> ，64位：<code>8B</code> )）</td>\n<td style=\"text-align:left\"><code>unsigned long 名 = 值;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>unsigned long long</code></td>\n<td style=\"text-align:left\"><code>%llu</code></td>\n<td style=\"text-align:left\"><code>8</code> 字节</td>\n<td style=\"text-align:left\"><code>unsigned long long 名 = 值;</code></td>\n</tr>\n</tbody>\n</table>\n<p><strong>示例：</strong></p>\n<div><pre><code><span>unsigned</span> <span>int</span> a <span>=</span> <span>10u</span><span>;</span>  <span>// 简写成 unsigned int a = 10;</span>\n<span>unsigned</span> <span>short</span> b <span>=</span> <span>20u</span><span>;</span><span>// 简写成 unsigned short b = 20;</span>\n<span>unsigned</span> <span>long</span> c <span>=</span> <span>30Lu</span><span>;</span>\n<span>unsigned</span> <span>long</span> <span>long</span> d <span>=</span> <span>40LLu</span><span>;</span>\n<span>printf</span><span>(</span><span>\"unsigned int 型数据值：%u\\n\"</span><span>,</span> a<span>)</span><span>;</span>\n<span>printf</span><span>(</span><span>\"unsigned short 型数据值：%hu\\n\"</span><span>,</span> b<span>)</span><span>;</span>\n<span>printf</span><span>(</span><span>\"unsigned long 型数据值：%lu\\n\"</span><span>,</span> c<span>)</span><span>;</span>\n<span>printf</span><span>(</span><span>\"unsigned long long 型数据值：%llu\\n\"</span><span>,</span> d<span>)</span><span>;</span>\n</code></pre></div><div><pre><code><span>int</span> a <span>=</span> <span>3</span><span>;</span>\n<span>short</span> b <span>=</span> <span>4</span><span>;</span>\n<span>long</span> c <span>=</span> <span>5</span><span>;</span>                <span>// 5L  5l</span>\n<span>long</span> <span>long</span> d <span>=</span> <span>6</span><span>;</span>  <span>// 6LL  6ll</span>\n<span>printf</span><span>(</span><span>\"sizeof(int) = %d\\n\"</span><span>,</span> <span>sizeof</span><span>(</span><span>int</span><span>)</span><span>)</span><span>;</span>\n<span>printf</span><span>(</span><span>\"sizeof(short) = %d\\n\"</span><span>,</span> <span>sizeof</span><span>(</span><span>short</span><span>)</span><span>)</span><span>;</span>\n<span>printf</span><span>(</span><span>\"sizeof(long) = %d\\n\"</span><span>,</span> <span>sizeof</span><span>(</span><span>long</span><span>)</span><span>)</span><span>;</span>\n<span>printf</span><span>(</span><span>\"sizeof(long long) = %d\\n\"</span><span>,</span> <span>sizeof</span><span>(</span><span>long</span> <span>long</span><span>)</span><span>)</span><span>;</span>\n\n<span>printf</span><span>(</span><span>\"--------------------------------------\\n\"</span><span>)</span><span>;</span>\n\n<span>unsigned</span> <span>int</span> aun <span>=</span> <span>3</span><span>;</span>             <span>// 3u</span>\n<span>unsigned</span> <span>short</span> bun <span>=</span> <span>4</span><span>;</span>           <span>// 4u</span>\n<span>unsigned</span> <span>long</span> cun <span>=</span> <span>5</span><span>;</span>            <span>// 5lu</span>\n<span>unsigned</span> <span>long</span> <span>long</span> dun <span>=</span> <span>6</span><span>;</span><span>// 6llu</span>\n<span>printf</span><span>(</span><span>\"sizeof(unsigned int) = %d\\n\"</span><span>,</span> <span>sizeof</span><span>(</span><span>unsigned</span> <span>int</span><span>)</span><span>)</span><span>;</span> <span>// aun</span>\n<span>printf</span><span>(</span><span>\"sizeof(unsigned short) = %d\\n\"</span><span>,</span> <span>sizeof</span><span>(</span><span>unsigned</span> <span>short</span><span>)</span><span>)</span><span>;</span>\n<span>printf</span><span>(</span><span>\"sizeof(unsigned long) = %d\\n\"</span><span>,</span> <span>sizeof</span><span>(</span><span>unsigned</span> <span>long</span><span>)</span><span>)</span><span>;</span>\n<span>printf</span><span>(</span><span>\"sizeof(unsigned long long) = %d\\n\"</span><span>,</span> <span>sizeof</span><span>(</span><span>unsigned</span> <span>long</span> <span>long</span><span>)</span><span>)</span><span>;</span>\n</code></pre></div><h3 id=\"_5-3-char-字符类型-1-字节\" tabindex=\"-1\"> 5.3 <code>char</code> 字符类型（<code>1</code> 字节）</h3>\n<p>格式匹配符： <code>%c</code>。</p>\n<p>存储一个字符，如 <code>'A'</code>、<code>'a'</code>、<code>'%'</code>、<code>'#'</code>、<code>'0'</code>。本质是 <code>ASCII</code> 码，即：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>字符</strong></th>\n<th style=\"text-align:left\"><strong>对应的 <code>ASCII</code> 码</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>'A'</code></td>\n<td style=\"text-align:left\"><code>65</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>'a'</code></td>\n<td style=\"text-align:left\"><code>97</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>'0'</code></td>\n<td style=\"text-align:left\"><code>48</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>'\\n'</code> （转义字符）</td>\n<td style=\"text-align:left\"><code>10</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>'\\0'</code> （转义字符）</td>\n<td style=\"text-align:left\"><code>0</code></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>转义字符：<code>'\\'</code> 将普通字符转为特殊意。将特殊字符转为本身意。</p>\n</blockquote>\n<h3 id=\"_5-4-浮点型-float、double\" tabindex=\"-1\"> 5.4 浮点型（<code>float</code>、<code>double</code>）</h3>\n<p><strong><code>float</code>（单精度浮点型，<code>4</code> 字节）</strong></p>\n<div><pre><code>使用示例：float v1 = 4.345;\n格式匹配符：%f \n默认保留 6 位小数。\n</code></pre></div><p><strong><code>double</code>（双精度浮点型，<code>8</code> 字节）</strong></p>\n<div><pre><code>使用示例：double v2 = 5.678;\n格式匹配符：%lf \n</code></pre></div><p><strong>无符号的浮点型</strong></p>\n<div><pre><code><span>unsigned</span> <span>float</span> v1 <span>=</span> <span>4.345</span><span>;</span> <span>// 无符号的 float 数据</span>\n<span>unsigned</span> <span>double</span> v2 <span>=</span> <span>5.678</span><span>;</span> <span>// 无符号的 float 数据</span>\n</code></pre></div><p><strong>格式化输出浮点型</strong></p>\n<div><pre><code><span>// 输出的含义为：显示 8 位数（包含小数点），不足 8 位用 0 填充。并且保留 3 位小数。对第4 位做四舍五入。</span>\n<span>printf</span><span>(</span><span>\"n = %08.3f\\n\"</span><span>,</span> n<span>)</span><span>;</span>\n<span>// 不足 8 位用空格填充。</span>\n<span>printf</span><span>(</span><span>\"n = %8.3f\\n\"</span><span>,</span> n<span>)</span><span>;</span>  \n</code></pre></div><h2 id=\"_6-进制\" tabindex=\"-1\"> 6. 进制</h2>\n<h3 id=\"_6-1-八进制\" tabindex=\"-1\"> 6.1 八进制</h3>\n<p><strong>定义八进制数语法：</strong> 零开头，每位数 <code>0~7</code> 之间。</p>\n<p><strong>八进制转十进制：</strong></p>\n<div><pre><code>056 -- 46\n    5x8+6=46\n    \n0124 -- 84\n    0x8x8x8+1x8x8+2x8+4=64+16+4=84\n</code></pre></div><p><strong>八进制转二进制：</strong></p>\n<blockquote>\n<p>原理：按 <code>421</code> 码将每个八进制位展开。</p>\n</blockquote>\n<div><pre><code>056 -- 101110\n    5 -- 101\n    6 -- 110\n\n05326 -- 101011010110\n    5 -- 101\n    3 -- 011 \n    2 -- 010\n    6 -- 110\n</code></pre></div><p><strong>二进制转八进制：</strong></p>\n<blockquote>\n<p>原理：自右向左，每 <code>3</code> 位一组，按 <code>421</code> 码转换。高位不足三位补 <code>0</code></p>\n</blockquote>\n<div><pre><code>1 010 111 010 110 -- 012726\n</code></pre></div><h3 id=\"_6-2-十六进制\" tabindex=\"-1\"> 6.2 十六进制</h3>\n<p><strong>语法：</strong></p>\n<div><pre><code>以 0x 开头，每位取 0-9/A-F/a-f\n\nA -- 10\nB -- 11\nC -- 12\nD -- 13\nE -- 14\nF -- 15\n</code></pre></div><p><strong>十六进制转十进制：</strong></p>\n<div><pre><code>0x1A： 16+10 = 26\n0x13F：15+3x16+256\n</code></pre></div><p><strong>十六进制转二进制：</strong></p>\n<div><pre><code>0x1A： 00011010\n0x13F：000100111111\n</code></pre></div><p><strong>二进制转十六进制：</strong></p>\n<blockquote>\n<p>原理：自右向左，每 <code>4</code> 位一组，按 <code>8421</code> 码转换。高位不足三位补 <code>0</code></p>\n</blockquote>\n<div><pre><code>0001 0011 1111 -- 13F\n</code></pre></div><h3 id=\"_6-3-进制转换技巧-凑数法\" tabindex=\"-1\"> 6.3 进制转换技巧（凑数法）</h3>\n<div><pre><code>321:    256 128 64 32 16 8 4 2 1\n        1   0   1  0  0  0 0 0 1\n\n以上表示十进制数 321 转二进制数 1 0100 0001 的过程。\n\n凑数法：即列举出不超过 321 的所有 2 的幂指数，然后从大到小怼出 321 来\n</code></pre></div><div><pre><code>321:    256 16 1\n        1   4  1\n\n以上表示十进制数 321 转十六进制数 141 的过程。\n\n凑数法：即列举出不超过 321 的所有 16 的幂指数，然后从大到小怼出 321 来\n</code></pre></div><div><pre><code>321:    64 8 1\n        5  0 1\n\n以上表示十进制数 321 转八进制数 501 的过程。\n\n凑数法：即列举出不超过 321 的所有 8 的幂指数，然后从大到小怼出 321 来\n</code></pre></div><h3 id=\"_6-4-注意-不能给变量直接复制二进制数据\" tabindex=\"-1\"> 6.4 注意：不能给变量直接复制二进制数据</h3>\n<div><pre><code><span>int</span> m <span>=</span> <span>0x15F4</span><span>;</span>\n<span>int</span> n <span>=</span> <span>345</span><span>;</span>\n<span>int</span> var <span>=</span> <span>010011</span><span>;</span> <span>// 不允许。</span>\n</code></pre></div><h3 id=\"_6-5-八进制-十六进制的格式化打印\" tabindex=\"-1\"> 6.5 八进制 &amp; 十六进制的格式化打印</h3>\n<div><pre><code><span>int</span> a <span>=</span> <span>0x2C</span><span>;</span>  <span>// 等价 0x2c</span>\n<span>printf</span><span>(</span><span>\"10进制显示 a = %d\\n\"</span><span>,</span> a<span>)</span><span>;</span>\n<span>printf</span><span>(</span><span>\"8进制显示 a = %o\\n\"</span><span>,</span> a<span>)</span><span>;</span>\n<span>printf</span><span>(</span><span>\"16进制显示 a = %x\\n\"</span><span>,</span> a<span>)</span><span>;</span>\n</code></pre></div><h2 id=\"_7-原码-反码-补码\" tabindex=\"-1\"> 7. 原码 &amp; 反码 &amp; 补码</h2>\n<p><strong>原码：</strong></p>\n<div><pre><code> 43 -> 00101011\n-43 -> 10101011\n</code></pre></div><p><strong>反码：</strong></p>\n<div><pre><code> 43 -> 00101011\n-43 -> 10101011  \n       11010100  反码：符号位不变，其它部分取反\n</code></pre></div><p><strong>补码（现今计算机采用的存储形式）：</strong></p>\n<div><pre><code> 43 -> 00101011 ： 正数不变\n-43 -> 11010101 ： 负数，最高位表符号位不变，其余取反+1\n</code></pre></div><p><strong>总结：</strong></p>\n<div><pre><code>对于正数，三码合一\n对于负数，补码 = 原码取反（符号位不变）再加 1\n</code></pre></div><div><pre><code>两数相减 等价于 正负数相加\n43 - 27 &lt;=> 43 + -27\n</code></pre></div><div><pre><code>人为规定： 10000000 => -128 （即 -0 = -128）\n</code></pre></div>",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-16T03:14:27.000Z",
      "authors": [],
      "tags": [
        "C语言基础"
      ]
    },
    {
      "title": "第03天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day03.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day03.html",
      "content_html": "<h2 id=\"_1-类型限定符\" tabindex=\"-1\"> 1. 类型限定符</h2>\n<h3 id=\"_1-1-extern\" tabindex=\"-1\"> 1.1 <code>extern</code></h3>\n<div><pre><code>表示声明；\nextern 声明的变量没有建立存储空间；\n不能提升。\n</code></pre></div><h3 id=\"_1-2-const\" tabindex=\"-1\"> 1.2 <code>const</code></h3>\n<div><pre><code>限定一个变量为只读变量\n</code></pre></div><h3 id=\"_1-3-volatile\" tabindex=\"-1\"> 1.3 <code>volatile</code></h3>\n<div><pre><code>防止编译器优化代码。\n使用：volatile int flg = 0;\n</code></pre></div><h3 id=\"_1-4-register\" tabindex=\"-1\"> 1.4 <code>register</code></h3>\n<div><pre><code>定义一个寄存器变量。没有内存地址，所以不能对寄存器变量使用指针。\nregister 是建议型的指令，而不是命令型的指令，如果 CPU 有空闲寄存器，那么 register 就生效，如果没有空闲寄存器，那么 register 无效。\n使用：register int a = 10;\n</code></pre></div><h2 id=\"_2-字符串\" tabindex=\"-1\"> 2. 字符串</h2>\n<p>C语言中，用双引号引着的一串字符，称之为字符串。一定有一个结束标记 <code>'\\0'</code></p>\n<div><pre><code>char ch = 'A';  占一个字节\n字符串 \"abc\" 包含 4 个字符：'a'、'b'、'c'、'\\0'\n'a' 不等价 \"a\"（字符串 \"a\" 包括 2 个字符：'a'、'\\0'）\n</code></pre></div><h3 id=\"_2-1-打印字符串时-遇到结束标记-0-才会停止打印\" tabindex=\"-1\"> 2.1 打印字符串时，遇到结束标记 <code>'\\0'</code> 才会停止打印</h3>\n<p>如果字符串变量 <code>str</code> 没有以 <code>'\\0'</code> 结束，那么 <code>printf</code> 函数打印时，就会继续打印 <code>str</code> 变量之后的内存地址中的值，直到遇到 <code>'\\0'</code> 为止。</p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day03/01.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_3-printf-函数\" tabindex=\"-1\"> 3. <code>printf</code> 函数</h2>\n<h3 id=\"_3-1-printf-函数支持的格式匹配符\" tabindex=\"-1\"> 3.1 <code>printf</code> 函数支持的格式匹配符</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>格式符</strong></th>\n<th style=\"text-align:left\"><strong>作用</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>%s</code></td>\n<td style=\"text-align:left\">打印字符串，从字符串的第一个字符开始挨个打印，打印到 <code>'\\0'</code> 结束</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>%d</code></td>\n<td style=\"text-align:left\">打印整数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>%c</code></td>\n<td style=\"text-align:left\">打印字符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>%x</code></td>\n<td style=\"text-align:left\">打印十六进制数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>%u</code></td>\n<td style=\"text-align:left\">打印无符号</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>%m.n</code></td>\n<td style=\"text-align:left\">打印浮点数时用到，一共有 <code>m</code> 位（整数、小数、小数点），<code>n</code> 位小数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>%0m.nf</code></td>\n<td style=\"text-align:left\">其中 <code>f</code> 表示打印浮点数，一共有 <code>m</code> 位（整数、小数、小数点），<code>n</code> 位小数。<code>0</code> 表示不足 <code>m</code> 位时用 <code>0</code> 凑够 <code>m</code> 位</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>%%</code></td>\n<td style=\"text-align:left\">显示一个 <code>%</code>。 转义字符 <code>'\\'</code> 对 <code>%</code> 转义无效。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>%Ns</code></td>\n<td style=\"text-align:left\">显示 <code>N</code> 个字符的字符串。不足 <code>N</code> 用空格向左填充</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>%0Ns</code></td>\n<td style=\"text-align:left\">显示 <code>N</code> 个字符的字符串。不足 <code>N</code> 用 <code>0</code> 向左填充</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>%-Ns</code></td>\n<td style=\"text-align:left\">显示 <code>N</code> 个字符的字符串。不足 <code>N</code> 用空格向右填充</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"_4-putchar-函数\" tabindex=\"-1\"> 4. <code>putchar</code> 函数</h2>\n<div><pre><code>输出一个字符到屏幕。\n可以直接传入字符的 ASCII 码。\n不能输出字符串。\n'abc' 既不是一个有效字符，也不是一个有效字符串。\n常用 putchar('\\n'); 来打印换行。使用 printf(\"\\n\"); 也可以打印换行\n</code></pre></div><h2 id=\"_5-scanf-函数\" tabindex=\"-1\"> 5. <code>scanf</code> 函数</h2>\n<p>从键盘接收用户输入。</p>\n<p><strong>1. 接收整数 <code>%d</code></strong></p>\n<div><pre><code><span>int</span> a<span>,</span> b<span>,</span> c<span>;</span>  <span>// 创建变量空间，等待接收用户输入。</span>\n<span>scanf</span><span>(</span><span>\"%d %d %d\"</span><span>,</span> <span>&amp;</span>a<span>,</span> <span>&amp;</span>b<span>,</span> <span>&amp;</span>c<span>)</span><span>;</span>\n</code></pre></div><p><strong>2. 接收字符 <code>%c</code></strong></p>\n<div><pre><code><span>char</span> a<span>,</span> b<span>,</span> c<span>;</span>\n<span>scanf</span><span>(</span><span>\"%c %c %c\"</span><span>,</span> <span>&amp;</span>a<span>,</span> <span>&amp;</span>b<span>,</span> <span>&amp;</span>c<span>)</span><span>;</span>\n</code></pre></div><p><strong>3. 接收字符串 <code>%s</code></strong></p>\n<div><pre><code><span>char</span> str<span>[</span><span>10</span><span>]</span><span>;</span> <span>// 定义一个数组，用来接收用户输入的字符串。</span>\n<span>scanf</span><span>(</span><span>\"%s\"</span><span>,</span> str<span>)</span><span>;</span> <span>// 变量名要取地址传递给 scanf，数组名本身表示地址，不用 &amp; 符。</span>\n</code></pre></div><h3 id=\"_5-1-接收字符串时的注意项\" tabindex=\"-1\"> 5.1 接收字符串时的注意项</h3>\n<div><pre><code>1. scanf 具有安全隐患。如果存储空间不足，数据能存储到内存中，但不被保护（即存储到参数变量内存范围之外的地址中去了）。\n  【因此，空间不足不要使用】\n2. scanf 函数接收字符串时，碰到 空格 和 换行 会自动终止。不能使用 scanf 的 %s 接收带有空格的字符串。\n</code></pre></div><h3 id=\"_5-2-解决-scanf-4996-错误\" tabindex=\"-1\"> 5.2 解决 <code>scanf</code> <code>4996</code> 错误</h3>\n<div><pre><code>将 #define _CRT_SECURE_NO_WARNINGS  添加到程序第一行。\n</code></pre></div><h2 id=\"_6-getchar-函数\" tabindex=\"-1\"> 6. <code>getchar</code> 函数</h2>\n<div><pre><code>从键盘获取用户输入的一个字符。\n返回该获取的字符的 ASCII 码。\n</code></pre></div><h2 id=\"_7-运算符\" tabindex=\"-1\"> 7. 运算符</h2>\n<h3 id=\"_7-1-运算符优先级\" tabindex=\"-1\"> 7.1 运算符优先级</h3>\n<div><pre><code>[] () > ++ -- (强转) sizeof > 算数运算（先乘除取余，后加减）> 比较运算 > 逻辑运算 > 三目运算（条件运算）> 赋值运算 > 逗号运算 \n</code></pre></div><table>\n    <tr>\n        <th>优先级</th>\n        <th>运算符</th>\n        <th>名称或含义</th>\n        <th>使用形式</th>\n        <th>结合方向</th>\n        <th>说明</th>\n    </tr>\n    <tr>\n        <td rowspan=\"4\">1</td>\n        <td>[]</td>\n        <td>数组下标</td>\n        <td>数组名[常量表达式]</td>\n        <td rowspan=\"4\">左到右</td>\n        <td>--</td>\n    </tr>\n    <tr>\n        <td>()</td>\n        <td>圆括号</td>\n        <td>(表达式）/函数名(形参表)</td>\n        <td>--</td>\n    </tr>\n    <tr>\n        <td>.</td>\n        <td>成员选择（对象）</td>\n        <td>对象.成员名</td>\n        <td>--</td>\n    </tr>\n    <tr>\n        <td>-></td>\n        <td>成员选择（指针）</td>\n        <td>对象指针->成员名</td>\n        <td>--</td>\n    </tr>\n    <tr>\n        <td rowspan=\"9\">2</td>\n        <td>-</td>\n        <td>负号运算符</td>\n        <td>-表达式</td>\n        <td rowspan=\"9\">右到左</td>\n        <td rowspan=\"7\">单目运算符</td>\n    </tr>\n    <tr>\n        <td>~</td>\n        <td>按位取反运算符</td>\n        <td>~表达式</td>\n    </tr>\n    <tr>\n        <td>++</td>\n        <td>自增运算符</td>\n        <td>++变量名/变量名++</td>\n    </tr>\n    <tr>\n        <td>--</td>\n        <td>自减运算符</td>\n        <td>--变量名/变量名--</td>\n    </tr>\n    <tr>\n        <td>*</td>\n        <td>取值运算符</td>\n        <td>*指针变量</td>\n    </tr>\n    <tr>\n        <td>&</td>\n        <td>取地址运算符</td>\n        <td>&变量名</td>\n    </tr>\n    <tr>\n        <td>!</td>\n        <td>逻辑非运算符</td>\n        <td>!表达式</td>\n    </tr>\n    <tr>\n        <td>(类型)</td>\n        <td>强制类型转换</td>\n        <td>(数据类型)表达式</td>\n        <td>--</td>\n    </tr>\n    <tr>\n        <td>sizeof</td>\n        <td>长度运算符</td>\n        <td>sizeof(表达式)</td>\n        <td>--</td>\n    </tr>\n    <tr>\n        <td rowspan=\"3\">3</td>\n        <td>/</td>\n        <td>除</td>\n        <td>表达式/表达式</td>\n        <td rowspan=\"3\">左到右</td>\n        <td rowspan=\"3\">双目运算符</td>\n    </tr>\n    <tr>\n        <td>*</td>\n        <td>乘</td>\n        <td>表达式*表达式</td>\n    </tr>\n    <tr>\n        <td>%</td>\n        <td>余数（取模）</td>\n        <td>整型表达式%整型表达式</td>\n    </tr>\n    <tr>\n        <td rowspan=\"2\">4</td>\n        <td>+</td>\n        <td>加</td>\n        <td>表达式+表达式</td>\n        <td rowspan=\"2\">左到右</td>\n        <td rowspan=\"2\">双目运算符</td>\n    </tr>\n    <tr>\n        <td>-</td>\n        <td>减</td>\n        <td>表达式-表达式</td>\n    </tr>\n    <tr>\n        <td rowspan=\"2\">5</td>\n        <td>&lt;&lt;</td>\n        <td>左移</td>\n        <td>变量&lt;&lt;表达式</td>\n        <td rowspan=\"2\">左到右</td>\n        <td rowspan=\"2\">双目运算符</td>\n    </tr>\n    <tr>\n        <td>&gt;&gt;</td>\n        <td>右移</td>\n        <td>变量&gt;&gt;表达式</td>\n    </tr>\n    <tr>\n        <td rowspan=\"4\">6</td>\n        <td>&gt;</td>\n        <td>大于</td>\n        <td>表达式&gt;表达式</td>\n        <td rowspan=\"4\">左到右</td>\n        <td rowspan=\"4\">双目运算符</td>\n    </tr>\n    <tr>\n        <td>&gt;=</td>\n        <td>大于等于</td>\n        <td>表达式&gt;=表达式</td>\n    </tr>\n    <tr>\n        <td>&lt;</td>\n        <td>小于</td>\n        <td>表达式&lt;表达式</td>\n    </tr>\n    <tr>\n        <td>&lt;=</td>\n        <td>小于等于</td>\n        <td>表达式&lt;=表达式</td>\n    </tr>\n    <tr>\n        <td rowspan=\"2\">7</td>\n        <td>==</td>\n        <td>等于</td>\n        <td>表达式==表达式</td>\n        <td rowspan=\"2\">左到右</td>\n        <td rowspan=\"2\">双目运算符</td>\n    </tr>\n    <tr>\n        <td>!=</td>\n        <td>不等于</td>\n        <td>表达式!=表达式</td>\n    </tr>\n    <tr>\n        <td>8</td>\n        <td>&</td>\n        <td>按位与</td>\n        <td>表达式&表达式</td>\n        <td>左到右</td>\n        <td>双目运算符</td>\n    </tr>\n    <tr>\n        <td>9</td>\n        <td>^</td>\n        <td>按位异或</td>\n        <td>表达式^表达式</td>\n        <td>左到右</td>\n        <td>双目运算符</td>\n    </tr>\n    <tr>\n        <td>10</td>\n        <td>|</td>\n        <td>按位或</td>\n        <td>表达式|表达式</td>\n        <td>左到右</td>\n        <td>双目运算符</td>\n    </tr>\n    <tr>\n        <td>11</td>\n        <td>&&</td>\n        <td>逻辑与</td>\n        <td>表达式&&表达式</td>\n        <td>左到右</td>\n        <td>双目运算符</td>\n    </tr>\n    <tr>\n        <td>12</td>\n        <td>||</td>\n        <td>逻辑或</td>\n        <td>表达式||表达式</td>\n        <td>左到右</td>\n        <td>双目运算符</td>\n    </tr>\n    <tr>\n        <td>13</td>\n        <td>?:</td>\n        <td>条件运算符</td>\n        <td>表达式1 ? 表达式2 : 表达式3</td>\n        <td>右到左</td>\n        <td>三目运算符</td>\n    </tr>\n    <tr>\n        <td rowspan=\"11\">14</td>\n        <td>=</td>\n        <td>赋值运算符</td>\n        <td>变量=表达式</td>\n        <td rowspan=\"11\">右到左</td>\n        <td>--</td>\n    </tr>\n    <tr>\n        <td>/=</td>\n        <td>除后赋值</td>\n        <td>变量/=表达式</td>\n        <td>--</td>\n    </tr>\n    <tr>\n        <td>*=</td>\n        <td>乘后赋值</td>\n        <td>变量*/=表达式</td>\n        <td>--</td>\n    </tr>\n    <tr>\n        <td>%=</td>\n        <td>取模后赋值</td>\n        <td>变量%=表达式</td>\n        <td>--</td>\n    </tr>\n    <tr>\n        <td>+=</td>\n        <td>加后赋值</td>\n        <td>变量+=表达式</td>\n        <td>--</td>\n    </tr>\n    <tr>\n        <td>-=</td>\n        <td>减后赋值</td>\n        <td>变量-=表达式</td>\n        <td>--</td>\n    </tr>\n    <tr>\n        <td>&lt;&lt;=</td>\n        <td>左移后赋值</td>\n        <td>变量&lt;&lt;=表达式</td>\n        <td>--</td>\n    </tr>\n    <tr>\n        <td>&gt;&gt;=</td>\n        <td>右移后赋值</td>\n        <td>变量&gt;&gt;=表达式</td>\n        <td>--</td>\n    </tr>\n    <tr>\n        <td>&=</td>\n        <td>按位与后赋值</td>\n        <td>变量&=表达式</td>\n        <td>--</td>\n    </tr>\n    <tr>\n        <td>^=</td>\n        <td>按位异或后赋值</td>\n        <td>变量^=表达式</td>\n        <td>--</td>\n    </tr>\n    <tr>\n        <td>|=</td>\n        <td>按位或后赋值</td>\n        <td>变量|=表达式</td>\n        <td>--</td>\n    </tr>\n    <tr>\n        <td>15</td>\n        <td>,</td>\n        <td>逗号运算符</td>\n        <td>表达式,表达式,...</td>\n        <td>左到右</td>\n        <td>--</td>\n    </tr>\n</table>\n<h3 id=\"_7-2-算数运算符\" tabindex=\"-1\"> 7.2 算数运算符</h3>\n<div><pre><code>不允许对小数取余，即余数不能是小数。 错误示例：35 % 3.4;\n对负数取余，结果为余数的绝对值。示例：10 % -3; // 结果为 1\n</code></pre></div><h3 id=\"_7-3-逗号运算符\" tabindex=\"-1\"> 7.3 逗号运算符</h3>\n<blockquote>\n<p>从左到右，取最后一次运算的结果。</p>\n</blockquote>\n<p><strong>示例：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day03/02.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_8-类型转换\" tabindex=\"-1\"> 8 类型转换</h2>\n<h3 id=\"_8-1-隐式类型转换\" tabindex=\"-1\"> 8.1 隐式类型转换</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day03/03.png\" alt=\"\" loading=\"lazy\"></p>\n<p>隐式类型转换分两种情况：</p>\n<div><pre><code>1. 由编译器自动完成\n    由上图可知，若 float 型数据和 int 型数据进行运算，会分别先转换成 double 型数据后再进行运算。\n\n2. 由赋值产生的类型转换\n    小 -> 大 没问题。 \n        int r = 3;\n        float s = 3.14 * r * r; // 右侧表达式结果为 double 型，赋值转换为 float 型\n    大 -> 小 有可能发生数据丢失。\n        321:    256 128 64 32 16 8 4 2 1\n                1   0   1  0  0  0 0 0 1 // 高位 1 转 char 型时会丢失\n        char ch  = 0   1  0  0  0 0 0 1  // int 型 321 转 char 型，会发生数据丢失\n</code></pre></div><h3 id=\"_8-2-强制类型转换\" tabindex=\"-1\"> 8.2 强制类型转换</h3>\n<p><strong>语法：</strong></p>\n<div><pre><code>（目标类型）带转换变量\n（目标类型）带转换表达式\n</code></pre></div><h2 id=\"_9-vs2013-的-c4996-错误\" tabindex=\"-1\"> 9. <code>VS2013</code> 的 <code>C4996</code> 错误</h2>\n<p>由于微软在 <code>VS2013</code> 中不建议再使用 <code>C</code> 的传统库函数 <code>scanf</code>、<code>strcpy</code>、<code>sprintf</code> 等，所以直接使用这些库函数会提示 <code>C4996</code> 错误：</p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day03/04.png\" alt=\"\" loading=\"lazy\"></p>\n<p><code>VS</code> 建议采用带 <code>_s</code> 的函数，如 <code>scanf_s</code>、<code>strcpy_s</code>，但这些并不是标准 <code>C</code> 函数。要想继续使用此函数，需要在源文件中添加以下指令就可以避免这个错误提示：</p>\n<div><pre><code><span><span>#</span><span>define</span> <span>_CRT_SECURE_NO_WARNINGS</span>   <span>// 这个宏定义最好要放到 .c 文件的第一行</span></span>\n\n<span><span>#</span><span>pragma</span> <span><span>warning</span><span>(</span>disable<span>:</span><span>4996</span><span>)</span>    </span><span>// 或者使用这个</span></span>\n</code></pre></div><h2 id=\"_10-switch-分支语句\" tabindex=\"-1\"> 10. <code>switch</code> 分支语句</h2>\n<div><pre><code>switch(判别表达式)\n{\n    case 1：\n        执行语句1；\n        break; // 防止 case 穿透\n    case 2:\n        执行语句2;\n        break;\n    case 3:\n        执行语句3;\n        break;\n    ...\n    case N:\n        执行语句N;\n        break;\n    default:\n        其他情况的统一处理;\n        break;\n}\n</code></pre></div><h3 id=\"_10-1-什么是-case-穿透\" tabindex=\"-1\"> 10.1 什么是 <code>case</code> 穿透</h3>\n<div><pre><code>在一个 case 分支中如果，没有 break; 那么它会向下继续执行下一个 case 分支。\n</code></pre></div>",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-16T03:14:27.000Z",
      "authors": [],
      "tags": [
        "C语言基础"
      ]
    },
    {
      "title": "第04天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day04.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day04.html",
      "content_html": "<h2 id=\"_1-for-循环\" tabindex=\"-1\"> 1. <code>for</code> 循环</h2>\n<h3 id=\"_1-1-案例\" tabindex=\"-1\"> 1.1 案例</h3>\n<h4 id=\"_1-1-1-案例1-猜数字游戏-rand-随机数函数\" tabindex=\"-1\"> 1.1.1 案例1：猜数字游戏（<code>rand</code> 随机数函数）</h4>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day04/01.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>1. time 函数在 time.h 中声明；返回时间戳\n2. srand 函数在 stdlib.h 中声明；用于产生随机数种子\n3. rand 函数在 stdlib.h 中声明；用于产生随机数\n\n注意：\n如果不执行 srand(time(NULL)); 生成一个随时间变化的随机数种子，\n那么每次编译运行后，第一次执行 rand() 函数得到的随机数都是相同的。\n</code></pre></div><h4 id=\"_1-1-2-案例2-模拟电子表-sleep-休眠函数\" tabindex=\"-1\"> 1.1.2 案例2：模拟电子表（<code>Sleep</code> 休眠函数）</h4>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day04/02.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>Sleep 函数在 Windows.h 中声明\n</code></pre></div><h4 id=\"_1-1-3-案例3-正序99乘法表\" tabindex=\"-1\"> 1.1.3 案例3：正序99乘法表</h4>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day04/03.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>typedef unsigned int    size_t;\n</code></pre></div><h4 id=\"_1-1-4-案例4-倒序99乘法表\" tabindex=\"-1\"> 1.1.4 案例4：倒序99乘法表</h4>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day04/04.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_1-2-跳转语句-break-continue-goto\" tabindex=\"-1\"> 1.2 跳转语句：<code>break</code> &amp; <code>continue</code> &amp; <code>goto</code></h3>\n<p><strong><code>break</code></strong></p>\n<div><pre><code>作用1：跳出一重循环。 for、while、do while\n作用2：防止 case 穿透。 switch   \n</code></pre></div><p><strong><code>continue</code></strong></p>\n<div><pre><code>作用：结束【本次】循环 continue 关键字之后的循环体，让其在本次循环中不执行。\n</code></pre></div><p><strong><code>goto</code></strong></p>\n<div><pre><code>1. 设定一个标签\n2. 使用 \"goto 标签名\" 跳转到标签的位置。（只在函数内部生效）\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day04/05.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>如上代码，由于 <code>goto</code> 语句直接跳转到了第二个 <code>for</code> 循环的循环体中，略过了循环因子 <code>j</code> 赋初值的步骤，所以打印变量 <code>j</code> 时的输出数据是不确定的。</p>\n</blockquote>\n<h2 id=\"_2-格式符-p-打印内存地址\" tabindex=\"-1\"> 2. 格式符 <code>%p</code>（打印内存地址）</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day04/06.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>如上代码，格式符 %p 专门用来打印内存地址\n</code></pre></div><h2 id=\"_3-数组\" tabindex=\"-1\"> 3. 数组</h2>\n<h3 id=\"_3-1-初识数组\" tabindex=\"-1\"> 3.1 初识数组</h3>\n<div><pre><code>- 相同数据类型的有序连续存储。\n- 各个元素的内存地址连续。\n- 数组名为地址，是数组首元素的地址。即：arr == &amp;arr[0];\n</code></pre></div><h3 id=\"_3-2-数组长度-sizeof-arr-sizeof-arr-0\" tabindex=\"-1\"> 3.2 数组长度：<code>sizeof(arr) / sizeof(arr[0])</code></h3>\n<div><pre><code>取数组长度的方式： sizeof(arr) / sizeof(arr[0]) \n(没有 arr.length 这种 java 中的方式)\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day04/07.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_3-3-数组初始化\" tabindex=\"-1\"> 3.3 数组初始化</h3>\n<div><pre><code>int arr[12] = { 1, 2 ,4, 6, 76, 8, 90 ,4, 3, 6, 6, 8 }; 【重点】\n\nint arr[10] = { 1, 2 ,4, 6, 76, 8, 9 };  剩余未初始化的元素，默认 0 值。【重点】\n\nint arr[10] = {0};  初始化一个全为 0 的数组。【重点】\n\nint arr[] = {1, 2, 4, 6, 8};  编译器自动求取元素个数。【重点】\n\nint arr[] = {0};  只有一个元素，值为 0\n\nint arr[10];\narr[0] = 5;\narr[1] = 6;\narr[2] = 7;    \n其余元素未被初始化，默认值 不确定数。\n</code></pre></div><h3 id=\"_3-4-数组倒序\" tabindex=\"-1\"> 3.4 数组倒序</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day04/08.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_3-5-冒泡排序\" tabindex=\"-1\"> 3.5 冒泡排序</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day04/09.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-16T03:14:27.000Z",
      "authors": [],
      "tags": [
        "C语言基础"
      ]
    },
    {
      "title": "第05天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day05.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day05.html",
      "content_html": "<h2 id=\"_1-二维数组\" tabindex=\"-1\"> 1. 二维数组</h2>\n<h3 id=\"_1-1-获取-数组的大小、数组行的大小、元素的大小、行数、列数\" tabindex=\"-1\"> 1.1 获取：数组的大小、数组行的大小、元素的大小、行数、列数</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day05/01.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>如上代码中，打印的大小单位是字节 <code>Byte</code></p>\n</blockquote>\n<h3 id=\"_1-2-二维数组的地址合一-数组首地址-首行地址-首元素地址\" tabindex=\"-1\"> 1.2 二维数组的地址合一：数组首地址 = 首行地址 = 首元素地址</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day05/02.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_1-3-二维数组初始化\" tabindex=\"-1\"> 1.3 二维数组初始化</h3>\n<p><strong>1. 常规初始化：</strong></p>\n<div><pre><code><span>int</span> arr<span>[</span><span>3</span><span>]</span><span>[</span><span>5</span><span>]</span> <span>=</span> <span>{</span><span>{</span><span>2</span><span>,</span> <span>3</span><span>,</span> <span>54</span><span>,</span> <span>56</span><span>,</span> <span>7</span> <span>}</span><span>,</span> <span>{</span><span>2</span><span>,</span> <span>67</span><span>,</span> <span>4</span><span>,</span> <span>35</span><span>,</span> <span>9</span><span>}</span><span>,</span> <span>{</span><span>1</span><span>,</span> <span>4</span><span>,</span> <span>16</span><span>,</span> <span>3</span><span>,</span> <span>78</span><span>}</span><span>}</span><span>;</span>\n</code></pre></div><p><strong>2. 不完全初始化：</strong></p>\n<div><pre><code><span>int</span> arr<span>[</span><span>3</span><span>]</span><span>[</span><span>5</span><span>]</span> <span>=</span> <span>{</span><span>{</span><span>2</span><span>,</span> <span>3</span><span>}</span><span>,</span> <span>{</span><span>2</span><span>,</span> <span>67</span><span>,</span> <span>4</span><span>,</span> <span>}</span><span>,</span> <span>{</span><span>1</span><span>,</span> <span>4</span><span>,</span> <span>16</span><span>,</span> <span>78</span><span>}</span><span>}</span><span>;</span>  <span>// 未被初始化的数值为 0</span>\n\n<span>int</span> arr<span>[</span><span>3</span><span>]</span><span>[</span><span>5</span><span>]</span> <span>=</span> <span>{</span><span>0</span><span>}</span><span>;</span>    <span>// 初始化一个初值全为 0 的二维数组</span>\n\n<span>int</span> arr<span>[</span><span>3</span><span>]</span><span>[</span><span>5</span><span>]</span> <span>=</span> <span>{</span><span>2</span><span>,</span> <span>3</span><span>,</span> <span>2</span><span>,</span> <span>67</span><span>,</span> <span>4</span><span>,</span> <span>1</span><span>,</span> <span>4</span><span>,</span> <span>16</span><span>,</span> <span>78</span><span>}</span><span>;</span>   <span>// 【少见】系统自动分配行列。</span>\n</code></pre></div><p><strong>3. 不完全指定行列初始化：</strong></p>\n<div><pre><code><span>int</span> arr<span>[</span><span>]</span><span>[</span><span>]</span> <span>=</span> <span>{</span><span>1</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>}</span><span>;</span>  <span>// 错误：二维数组定义必须指定列值。</span>\n\n<span>int</span> arr<span>[</span><span>]</span><span>[</span><span>2</span><span>]</span> <span>=</span> <span>{</span> <span>1</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>6</span><span>,</span> <span>7</span> <span>}</span><span>;</span>  <span>// 正确：可以不指定行值。</span>\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day05/03.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_2-vs-代码片段模板的导入\" tabindex=\"-1\"> 2. <code>VS</code> 代码片段模板的导入</h2>\n<div><pre><code>操作步骤：VS -> 工具 -> 代码片段管理器 -> Visual C++\n</code></pre></div><h2 id=\"_3-多维数组\" tabindex=\"-1\"> 3. 多维数组</h2>\n<p><strong>定义语法：</strong></p>\n<div><pre><code>三维数组：[层][行][列]\n\n数组类型 数组名[层][行][列];\n</code></pre></div><p><strong>示例：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day05/04.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_4-字符串\" tabindex=\"-1\"> 4. 字符串</h2>\n<h3 id=\"_4-1-字符数组和字符串的区别\" tabindex=\"-1\"> 4.1 字符数组和字符串的区别</h3>\n<div><pre><code>字符数组：\n    char str[5] = {'h', 'e', 'l', 'l', 'o'};    \n字符串：\n    char str[6] = {'h', 'e', 'l', 'l', 'o', '\\0'};   &lt;=>  char str[6] = \"hello\";\n        \nprintf(\"%s\"); // 使用 printf 打印字符串的时候，必须碰到 '\\0' 结束。\n</code></pre></div><h3 id=\"_4-2-案例-统计字符串中每个字母的出现次数\" tabindex=\"-1\"> 4.2 案例：统计字符串中每个字母的出现次数</h3>\n<p>键盘输入字符串，存至 <code>str[]</code> 中，统计每个字母出现的次数。</p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day05/05.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_4-3-字符串获取函数-scanf\" tabindex=\"-1\"> 4.3 字符串获取函数 <code>scanf</code></h3>\n<h4 id=\"_4-3-1-注意事项-预留足够空间-遇空格或换行终止\" tabindex=\"-1\"> 4.3.1 注意事项（预留足够空间；遇空格或换行终止）</h4>\n<div><pre><code>1. 用于存储字符串的空间必须足够大，防止溢出。\n2. 获取字符串 %s ，遇到 空格 和 \\n 终止。\n</code></pre></div><h4 id=\"_4-3-2-获取带有空格的字符串-scanf-n-s-str\" tabindex=\"-1\"> 4.3.2 获取带有空格的字符串：<code>scanf(&quot;%[^\\n]s&quot;, str)</code></h4>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day05/06.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_4-4-字符串操作函数\" tabindex=\"-1\"> 4.4 字符串操作函数</h3>\n<h4 id=\"_4-4-1-从键盘获取一个字符串-gets\" tabindex=\"-1\"> 4.4.1 从键盘获取一个字符串：<code>gets</code></h4>\n<p><strong>作用：</strong></p>\n<div><pre><code>从键盘获取一个字符串，返回字符串的首地址。可以获取带有空格的字符串。【不安全】\n</code></pre></div><p><strong>说明：</strong></p>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>char</span> <span>*</span><span>gets</span><span>(</span><span>char</span> <span>*</span>s<span>)</span><span>;</span>\n    参数：用来存储字符串的空间地址。\n    返回值：返回实际获取到的字符串首地址，失败返回 <span>NULL</span>。\n</code></pre></div><p><code>gets(str)</code> 与<code> scanf(&quot;%s&quot;,str)</code> 的区别：</p>\n<div><pre><code>gets(str) 允许输入的字符串含有空格\nscanf(\"%s\",str) 不允许含有空格\n</code></pre></div><p><strong>注意：</strong></p>\n<div><pre><code>由于 scanf() 和 gets() 无法知道字符串 s 大小，必须遇到换行符或读到文件结尾为止才接收输入，\n因此容易导致字符数组越界（缓冲区溢出）的情况，即 scanf 和 gets 都是【不安全】的。\n</code></pre></div><p><strong>示例：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day05/07.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>\"hello world\" 算上 '\\0' 有 12 个字符，数组 str 只能存储 10 个字符，\n所以用数组 str 存储 \"hello world\" 会发出缓冲区溢出，最后两个字符 'd' 和 '\\0' 不在 str 内存范围内，可能会被其他数据覆盖，不安全。\n</code></pre></div><h4 id=\"_4-4-2-从指定输入流中获取一个字符串-fgets\" tabindex=\"-1\"> 4.4.2 从指定输入流中获取一个字符串：<code>fgets</code></h4>\n<p><strong>作用：</strong></p>\n<div><pre><code>从指定输入流中获取一个字符串，预留 '\\0' 的存储空间。空间足够读 '\\n'，空间不足舍弃 '\\n'。【安全】\n</code></pre></div><p><strong>说明：</strong></p>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>char</span> <span>*</span><span>fgets</span><span>(</span><span>char</span> <span>*</span>s<span>,</span> <span>int</span> size<span>,</span> FILE <span>*</span>stream<span>)</span><span>;</span>\n    参<span>1</span>：用来存储字符串的空间地址。\n    参<span>2</span>：描述空间的大小。\n    参<span>3</span>：读取字符串的位置。可以从文件中读取，也可以从标准输入中读取。标准输入：<span>stdin</span> <span>-></span> 即：键盘\n    返回值：返回实际获取到的字符串首地址，失败返回 <span>NULL</span>。\n</code></pre></div><p><strong>示例：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day05/08.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>因为 fgets 的参数中指定了存储空间大小，所有不会出现缓冲区溢出的情况；只会出现输入字符串过长时被截断的情况。\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day05/09.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>因为 fgets 函数的参数中传入的存储空间足够大，所以会把输入的换行符 '\\n' 也存储到数组 str 中，作为输入字符串的一部分。\n</code></pre></div><h4 id=\"_4-4-3-将一个字符串写出到屏幕-puts\" tabindex=\"-1\"> 4.4.3 将一个字符串写出到屏幕：<code>puts</code></h4>\n<p><strong>作用：</strong></p>\n<div><pre><code>将一个字符串写出到屏幕。\nprintf(\"%s\", \"hello\");  &lt;=>  printf(\"hello\\n\");  &lt;=>  puts(\"hello\");   \n</code></pre></div><p><strong>说明：</strong></p>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>int</span> <span>puts</span><span>(</span><span>const</span> <span>char</span> <span>*</span>s<span>)</span><span>;</span>    \n    参数<span>1</span>：待写出到屏幕的字符串。\n    返回值：成功：非负数（通常是 <span>0</span>）；失败：<span>-</span><span>1.</span>  \n</code></pre></div><p><strong>示例：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day05/10.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_4-4-4-将一个字符串写出到指定输出流-fputs\" tabindex=\"-1\"> 4.4.4 将一个字符串写出到指定输出流：<code>fputs</code></h4>\n<p><strong>作用：</strong></p>\n<div><pre><code>将一个字符串写出到指定输出流，输出字符串后不添加 '\\n' 换行符。\n</code></pre></div><p><strong>说明：</strong></p>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>int</span> <span>fputs</span><span>(</span><span>const</span> <span>char</span> <span>*</span> str<span>,</span> FILE <span>*</span> stream<span>)</span><span>;</span>    \n    参数<span>1</span>：待写出到屏幕的字符串。        \n    参数<span>2</span>：写出位置，可以输出到指定的文件，也可以输出到标准输出上。标准输出：<span>stdout</span> <span>-></span> 即：显示器\n    返回值：成功：非负数（通常是 <span>0</span>）；失败：<span>-</span><span>1.</span>\n</code></pre></div><p><strong>示例：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day05/11.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>因为 puts 函数仅面向标准输出（即显示器），所以 puts 函数默认打印换行符；\n而 fputs 函数可以面向任意指定的输出位置，所以 fgets 函数默认不打印换行符。\n</code></pre></div><h4 id=\"_4-4-5-获取字符串长度-strlen\" tabindex=\"-1\"> 4.4.5 获取字符串长度：<code>strlen</code></h4>\n<p><strong>作用：</strong></p>\n<div><pre><code>获取字符串长度，碰到 '\\0' 结束。（长度不包括 '\\0'）\n</code></pre></div><p><strong>说明：</strong></p>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;string.h></span></span>\n<span>size_t</span> <span>strlen</span><span>(</span><span>const</span> <span>char</span> <span>*</span>s<span>)</span><span>;</span>\n    参数<span>1</span>：待求长度的字符串首地址\n    返回：有效的字符个数，<span>size_t</span> 为 <span>unsigned</span> <span>int</span> 类型\n</code></pre></div><p><strong>示例：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day05/12.png\" alt=\"\" loading=\"lazy\"></p>\n<h5 id=\"_4-4-5-1-sizeof-str-和-strlen-str-的区别\" tabindex=\"-1\"> 4.4.5.1 <code>sizeof(str)</code> 和 <code>strlen(str)</code> 的区别</h5>\n<div><pre><code>sizeof(str) 求的数组的长度，不管数组中的元素是什么。\nstrlen(str) 求的是字符串的长度，遇字符串结束标记 '\\0' 为止。\n</code></pre></div><h5 id=\"_4-4-5-2-自己实现-strlen-函数\" tabindex=\"-1\"> 4.4.5.2 自己实现 <code>strlen</code> 函数</h5>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day05/13.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>等价于 printf(\"%d\\n\", strlen(str));\n</code></pre></div><h3 id=\"_4-5-案例-字符串拼接\" tabindex=\"-1\"> 4.5 案例：字符串拼接</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day05/14.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_5-函数\" tabindex=\"-1\"> 5. 函数</h2>\n<h3 id=\"_5-1-函数的作用\" tabindex=\"-1\"> 5.1 函数的作用</h3>\n<div><pre><code>1. 提高代码的复用率；\n2. 提高程序模块化组织性。\n</code></pre></div><h3 id=\"_5-2-函数的分类-系统库函数-用户自定义函数\" tabindex=\"-1\"> 5.2 函数的分类（系统库函数 &amp; 用户自定义函数）</h3>\n<div><pre><code>系统库函数： \n    如：标准C库（libc）\n    使用方式：\n        1. 引入头文件 -- 即：声明函数\n        2. 根据函数原型调用。\n\n用户自定义:\n    使用方式：除了需要提供函数原型之外，还需要提供函数实现。\n</code></pre></div><h3 id=\"_5-3-函数定义\" tabindex=\"-1\"> 5.3 函数定义</h3>\n<p>函数定义包含：</p>\n<div><pre><code>1. 函数原型（返回值类型、函数名、形参列表）\n2. 函数体（花括号一对，具体代码实现）\n</code></pre></div><blockquote>\n<p>形参列表即形式参数列表，一定包含：类型名 形参名</p>\n</blockquote>\n<p><strong>定义语法：</strong></p>\n<div><pre><code>返回值类型 函数名(类型名 形参名, 类型名 形参名, ...)\n{\n    具体代码实现\n}\n</code></pre></div><p><strong>示例：</strong></p>\n<div><pre><code><span>int</span> add（<span>int</span> a<span>,</span> <span>int</span> b<span>,</span> <span>int</span> c）\n<span>{</span>\n    <span>return</span> a<span>+</span>b<span>+</span>c<span>;</span>\n<span>}</span>\n</code></pre></div><h3 id=\"_5-4-函数调用\" tabindex=\"-1\"> 5.4 函数调用</h3>\n<p>函数调用包含：</p>\n<div><pre><code>函数名(实参列表);\n</code></pre></div><blockquote>\n<p>实参(实际参数)：在调用时，传参必须严格按照形参填充（参数的个数、类型、顺序）</p>\n</blockquote>\n<p><strong>示例：</strong></p>\n<div><pre><code><span>int</span> ret <span>=</span> <span>add</span><span>(</span><span>10</span><span>,</span> <span>4</span><span>,</span> <span>28</span><span>)</span><span>;</span>\n</code></pre></div><h3 id=\"_5-5-函数声明\" tabindex=\"-1\"> 5.5 函数声明</h3>\n<p>函数声明包含：</p>\n<div><pre><code>函数原型（返回值类型、函数名、形参列表）+ \";\"\n</code></pre></div><p><strong>注意：</strong></p>\n<div><pre><code>1. 在函数调用之前，编译必须见过函数定义。否则，需要函数声明。\n\n2. 函数声明时，形参列表中可以省略形参名，只保留形参类型即可。\n    int add(int a, int b, int c);   &lt;=>   int add(int, int, int);\n\n3. #include &lt;xxx.h>  中包含函数的声明\n</code></pre></div><h4 id=\"_5-5-1-隐式声明-不要依赖这种方式\" tabindex=\"-1\"> 5.5.1 隐式声明（不要依赖这种方式）</h4>\n<div><pre><code>编译器默认做隐式声明函数时，返回都为 int ，根据调用语句 补全 函数名和形参列表。\n</code></pre></div><p><strong>示例1：编译器默认做隐式声明函数时的异常情况</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day05/15.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>如上图，报错 bubble_sort 函数重定义， 是由于编译器的隐式声明导致的。\n因为 main 函数定义之前未对 bubble_sort 函数做函数声明，而 main 函数中又调用了 bubble_sort 函数，\n所以，此时编译器会在 main 函数定义之前对 bubble_sort 函数做隐式声明：int bubble_sort(int arr[])\n从而导致了 bubble_sort 函数声明与其函数定义不同，报出了重定义的错误。\n</code></pre></div><p><strong>示例2：手动做函数声明的情况</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day05/16.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>示例3：编译器默认做隐式声明函数时的正常情况</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day05/17.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>如上图，若函数的函数类型是 int 型，则可以使用编译器默认的隐式声明，但不建议采用隐式声明。\n</code></pre></div><h3 id=\"_5-6-exit-函数-退出当前程序\" tabindex=\"-1\"> 5.6 <code>exit</code> 函数（退出当前程序）</h3>\n<p><strong>说明：</strong></p>\n<div><pre><code>#include &lt;stdlib.h>\n\nreturn 关键字：返回当前函数调用，将返回值返回给调用者。\n\nexit() 函数：退出当前程序。\n</code></pre></div><p><strong>示例：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day05/18.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_6-vs-的使用\" tabindex=\"-1\"> 6. <code>VS</code> 的使用</h2>\n<h3 id=\"_6-1-vs-解决方案中新建项目\" tabindex=\"-1\"> 6.1 <code>VS</code> 解决方案中新建项目</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day05/19.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>如上图所示，“多文件联编” 是当前解决方案中的一个新的项目。\n通过【右键解决方案 -> 添加 —> 新建项目】可以创建一个类似 “多文件联编” 这样的项目。\n</code></pre></div><h3 id=\"_6-2-vs-解决方案中设置启动项目\" tabindex=\"-1\"> 6.2 <code>VS</code> 解决方案中设置启动项目</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day05/20.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>如上图，若解决方案中包含多个项目，可以通过【右键某个项目 —> 设为启动项目】将项目设置为启动项目。\n启动项目中的 main 函数才是入口函数。\n</code></pre></div><h2 id=\"_7-多文件联编\" tabindex=\"-1\"> 7. 多文件联编</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day05/21.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>多文件联编就是指：将多个含有不同函数功能 .c 文件模块，编译到一起，生成一个 .exe 文件。\n</code></pre></div><p><strong>注意：</strong></p>\n<div><pre><code>使用 VS 生成的 exe 文件 在  \"...\\day05\\Debug\" 路径下，（其中 day05 文件夹表示解决方案）\n</code></pre></div><p><strong>使用 <code>gcc</code> 命令实现多文件联编</strong></p>\n<div><pre><code>gcc main.c add.c mul.c sub.c -o xxx.exe\n</code></pre></div><h2 id=\"_8-include-指令\" tabindex=\"-1\"> 8. <code>#include</code> 指令</h2>\n<div><pre><code>&lt;> 包裹的头文件为系统库头文件。\n\"\" 包裹的头文件为用户自定义头文件。\n</code></pre></div><h2 id=\"_9-防止头文件重复包含-即-头文件守卫\" tabindex=\"-1\"> 9. 防止头文件重复包含（即：头文件守卫）</h2>\n<p><strong>方式1：</strong></p>\n<div><pre><code><span><span>#</span><span>pragma</span> <span>once  </span><span>// 仅 windows 中适用</span></span>\n</code></pre></div><p><strong>方式2：</strong></p>\n<div><pre><code><span><span>#</span><span>ifndef</span> <span>__HEAD_H__   </span><span>// __HEAD_H__ 是通过 头文件名 head.h 来定义的，应该跟头文件名一一对应</span></span>\n<span><span>#</span><span>define</span> <span>__HEAD_H__</span></span>\n\n<span>// ... 头文件内容</span>\n\n<span><span>#</span><span>endif</span></span>\n</code></pre></div>",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-16T03:14:27.000Z",
      "authors": [],
      "tags": [
        "C语言基础"
      ]
    },
    {
      "title": "第06天（指针基础）",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day06.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day06.html",
      "content_html": "<h2 id=\"_1-指针和内存单元\" tabindex=\"-1\"> 1. 指针和内存单元</h2>\n<div><pre><code>指针：\n    即地址。\n\n内存单元： \n    计算机中内存最小的存储单位。\n    1 个内存单元的大小是 1 个字节。 \n    每一个内存单元都有一个唯一的编号（数），称这个内存单元的编号为 “地址”。\n\n指针变量：\n    存地址的变量。\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day06/01.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_2-指针定义和使用\" tabindex=\"-1\"> 2. 指针定义和使用</h2>\n<h3 id=\"_2-1-指针的定义\" tabindex=\"-1\"> 2.1 指针的定义</h3>\n<div><pre><code><span>int</span> a <span>=</span> <span>10</span><span>;</span>\n\n<span>// 写法1： int* p; (windows)</span>\n<span>// 写法2： int *p; (Linux)</span>\n<span>// 写法3： int * p; </span>\n<span>int</span> <span>*</span>p <span>=</span> <span>&amp;</span>a<span>;</span>        \n\n<span>int</span> a<span>,</span> <span>*</span>p<span>,</span> <span>*</span>q<span>,</span> b<span>;</span>\n</code></pre></div><h3 id=\"_2-2-指针的解引用-间接引用\" tabindex=\"-1\"> 2.2 指针的解引用（间接引用）</h3>\n<div><pre><code>对于 *p = 250;  其中 *p 称为指针的解引用，或间接引用。即：将 p 变量的内容取出，当成地址看待，找到该地址对应的内存空间。\n\n*p 如果做左值：存入数据到空间中。\n*p 如果做右值：取出空间中的数据。\n</code></pre></div><h2 id=\"_3-任意指针类型所占的内存大小-与指向的数据类型无关\" tabindex=\"-1\"> 3. 任意指针类型所占的内存大小（与指向的数据类型无关）</h2>\n<div><pre><code>指针的大小与所指向地址中的数据类型无关。只与当前使用的平台架构有关：\n- 32 位系统：4 字节。     \n- 64 位系统：8 字节。\n</code></pre></div><p><strong>示例1：32 位系统中指针类型所占的内存大小</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day06/02.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>示例2：64 位系统中指针类型所占的内存大小</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day06/03.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_4-野指针-注意-杜绝野指针\" tabindex=\"-1\"> 4. 野指针（注意：杜绝野指针）</h2>\n<p><strong>情形1：没有一个有效的地址空间的指针</strong></p>\n<div><pre><code><span>int</span> <span>*</span>p<span>;</span>\n<span>*</span>p <span>=</span> <span>1000</span><span>;</span>\n</code></pre></div><p><strong>情形2：<code>p</code> 变量有一个值，但该值不是可访问的内存区域</strong></p>\n<div><pre><code><span>int</span> <span>*</span>p <span>=</span> <span>10</span><span>;</span>\n<span>*</span>p <span>=</span> <span>2000</span><span>;</span>\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day06/04.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>如上图，调式模式下可看到，给指针 <code>p</code> 赋以地址编号 <code>10</code>，会产生访问权限的异常。</p>\n</blockquote>\n<h2 id=\"_5-空指针-null\" tabindex=\"-1\"> 5. 空指针（<code>NULL</code>）</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day06/05.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>如上图，vcruntime.h 文件中，NULL 是一个指针类型（void *）的数据 0，地址编号 0 是系统使用的，无访问权限。\n所以 int *p = NULL; 执行后，p 所对应的存储空间一定是一个无效的访问区域。\n</code></pre></div><h3 id=\"_5-1-判断指针是否有效\" tabindex=\"-1\"> 5.1 判断指针是否有效</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day06/06.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>如上图，常用 if(p != NULL) 判断指针 p 是否有效\n</code></pre></div><h2 id=\"_6-万能指针-又称泛型指针-void\" tabindex=\"-1\"> 6. 万能指针（又称泛型指针，<code>void*</code>）</h2>\n<p><strong>说明：</strong></p>\n<div><pre><code>可以接收任意一种变量地址。但是在使用时，【必须】借助 “强转” 具体化数据类型。\n</code></pre></div><p><strong>示例：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day06/07.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>如上图：\n1. p = &amp;ch; 表示泛型指针 p 可以接收任意一种变量地址\n\n2. *(char *)p 表示泛型指针 p 在使用时，必须借助强转，具体化为特定的数据类型，\n\n3. *(char *)p 还可以写成 *((char *)p)，\n   因为运算符 * 和 (类型) 优先级都为 2，按照从右到左的结合方向，所以写成 *(char *)p 也没问题\n</code></pre></div><h2 id=\"_7-const-关键字\" tabindex=\"-1\"> 7. <code>const</code> 关键字</h2>\n<h3 id=\"_7-1-修饰变量-常变量\" tabindex=\"-1\"> 7.1 修饰变量（常变量）</h3>\n<div><pre><code><span>const</span> <span>int</span> a <span>=</span> <span>20</span><span>;</span>\n<span>int</span> <span>*</span>p <span>=</span> <span>&amp;</span>a<span>;</span>\n<span>*</span>p <span>=</span> <span>650</span><span>;</span>\n<span>printf</span><span>(</span><span>\"%d\\n\"</span><span>,</span> a<span>)</span><span>;</span>\n</code></pre></div><div><pre><code>如上，const 关键字修饰的变量称为常变量，不能通过常变量 a 修改对应内存空间中的数据，\n但是，可以通过指针的方式来访问并修改对应内存空间中的数据。\n</code></pre></div><h3 id=\"_7-2-修饰指针\" tabindex=\"-1\"> 7.2 修饰指针</h3>\n<p><strong>说明：</strong></p>\n<div><pre><code>const 向右修饰，被修饰的部分即为只读。\n</code></pre></div><p><strong>常用于：</strong></p>\n<div><pre><code>在函数形参内，用来限制指针所指向的内存空间为只读。\n</code></pre></div><h4 id=\"_7-2-1-指针常量-const-修饰-指针本身-int-const-p\" tabindex=\"-1\"> 7.2.1 指针常量（<code>const</code> 修饰 指针本身）：<code>int * const p</code></h4>\n<p>指针的指向不可以修改，但指针所指向的内容可以修改。</p>\n<div><pre><code>int * const p;\n\n可以修改 *p\n不可以修改 p。\n</code></pre></div><h4 id=\"_7-2-2-常量指针-const-修饰-所指向的内容-const-int-p\" tabindex=\"-1\"> 7.2.2 常量指针（<code>const</code> 修饰 所指向的内容）：<code>const int *p</code></h4>\n<p>指针的指向可以修改，但指针所指向的内容不可以修改。</p>\n<div><pre><code>const int *p;  &lt;=>  int const *p;\n\n可以修改 p\n不可以修改 *p。\n</code></pre></div><h4 id=\"_7-2-3-const-int-const-p\" tabindex=\"-1\"> 7.2.3 <code>const int * const p</code></h4>\n<div><pre><code>const int *const p;\n\n不可以修改 p。\n不可以修改 *p。\n</code></pre></div><h2 id=\"_8-指针和数组\" tabindex=\"-1\"> 8. 指针和数组</h2>\n<h3 id=\"_8-1-数组名是指针常量\" tabindex=\"-1\"> 8.1 数组名是指针常量</h3>\n<div><pre><code>数组名是指针常量，所以不可以被赋值。  \n\n指针是变量，可以用数组名给指针赋值。 \n</code></pre></div><h4 id=\"_8-1-1-带有副作用的运算符不能作用在数组名\" tabindex=\"-1\"> 8.1.1 带有副作用的运算符不能作用在数组名</h4>\n<p>带有副作用的运算符是指：参与运算的操作数会受到运算结果的影响。</p>\n<div><pre><code>\"++\"、\"--\"、\"+=\"、\"-=\"、\"%=\"、\"/=\" 这些带有副作用的运算符不能作用在数组名上，但可以作用在指针上。\n</code></pre></div><h3 id=\"_8-2-取数组元素-arr-i\" tabindex=\"-1\"> 8.2 取数组元素：<code>*(arr+i)</code></h3>\n<div><pre><code><span>int</span> arr<span>[</span><span>]</span> <span>=</span> <span>{</span><span>1</span><span>,</span><span>3</span><span>,</span> <span>5</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>}</span><span>;</span>\n<span>int</span> <span>*</span>p <span>=</span> arr<span>;</span>  \narr<span>[</span>i<span>]</span>  <span>&lt;=</span><span>></span>  <span>*</span><span>(</span>arr<span>+</span>i<span>)</span>  <span>&lt;=</span><span>></span>  p<span>[</span>i<span>]</span>  <span>&lt;=</span><span>></span>  <span>*</span><span>(</span>p<span>+</span>i<span>)</span>   <span>// 汇编从采用的是 *(arr+i)、 *(p+i) 这种写法，所以这样写更高效</span>\n<span>*</span><span>(</span>p<span>+</span><span>0</span><span>)</span> <span>&lt;=</span><span>></span> <span>*</span>p\n</code></pre></div><h3 id=\"_8-3-指针和数组的区别\" tabindex=\"-1\"> 8.3 指针和数组的区别</h3>\n<div><pre><code>区别一：\n    指针是变量；数组名为常量（即指针常量）。\n\n区别二：\n    sizeof(指针) => 4字节 or 8字节 (指针类型的变量所占内存大小只跟操作系统（32、64位）有关，跟所指向的地址中存储的数据类型无关)\n    sizeof(数组) => 数组的实际字节数。\n</code></pre></div><h3 id=\"_8-4-指针-操作数组\" tabindex=\"-1\"> 8.4 &quot;指针++&quot; 操作数组</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day06/08.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_9-数据类型对指针的作用\" tabindex=\"-1\"> 9. 数据类型对指针的作用</h2>\n<p><strong>作用1：</strong></p>\n<div><pre><code>从间接引用的方面来说：决定了从指针存储的地址开始，向后读取的字节数。\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day06/09.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作用2：</strong></p>\n<div><pre><code>从加减运算的方面来说：决定了指针进行 +1/-1 操作后，向后/向前偏移的字节数。\n</code></pre></div><h2 id=\"_10-指针加减运算\" tabindex=\"-1\"> 10. 指针加减运算</h2>\n<h3 id=\"_10-1-指针变量不支持-、-、-运算\" tabindex=\"-1\"> 10.1 指针变量不支持 <code>*</code>、<code>/</code>、<code>%</code> 运算</h3>\n<div><pre><code>不能对指针变量进行 * 、 / 、 % 的运算\n</code></pre></div><h3 id=\"_10-2-指针-整数\" tabindex=\"-1\"> 10.2 指针 <code>+-</code> 整数</h3>\n<p><strong>1. 普通指针变量 <code>+-</code> 整数</strong></p>\n<div><pre><code>char  *p; 打印  p+1  偏过 1 字节。\nshort *p; 打印  p+1  偏过 2 字节。\nint   *p; 打印  p+1  偏过 4 字节。 \n</code></pre></div><p><strong>2. 在数组中 <code>+-</code> 整数</strong></p>\n<div><pre><code><span>int</span> arr<span>[</span><span>]</span> <span>=</span> <span>{</span><span>1</span><span>,</span> <span>3</span><span>,</span> <span>5</span><span>,</span> <span>8</span><span>}</span><span>;</span>\n<span>int</span> <span>*</span>p <span>=</span> arr<span>;</span>\np<span>+</span><span>3</span><span>;</span>  <span>// 向后（右）偏过 3 个元素，即 3x4=12 个字节</span>\np<span>-</span><span>2</span><span>;</span>  <span>// 向前（左）偏过 2 个元素，即 3x2=6  个字节</span>\n</code></pre></div><p><strong>3. <code>&amp;数组名 + 1</code></strong></p>\n<div><pre><code>加过一个数组的大小：数组元素个数 x sizeof(数组元素类型)\n</code></pre></div><p><strong>示例：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day06/10.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>如上图，<code>&amp;a+1</code> 表示向后偏移一个数组 <code>a</code> 的大小</p>\n</blockquote>\n<h3 id=\"_10-3-指针-指针\" tabindex=\"-1\"> 10.3 指针 <code>+-</code> 指针</h3>\n<div><pre><code>指针 + 指针：不支持，报错。\n指针 - 指针：\n    1. 对普通变量来说，语法允许，但无实际意义。【了解】\n    2. 对数组来说，偏移过的元素个数。\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day06/11.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>上图说明了，在数组中，指针 - 指针 表示偏移过的元素个数。</p>\n</blockquote>\n<h2 id=\"_11-指针实现-strlen-函数\" tabindex=\"-1\"> 11. 指针实现 <code>strlen</code> 函数</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day06/12.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_12-指针比较运算\" tabindex=\"-1\"> 12. 指针比较运算</h2>\n<div><pre><code>1. 对普通变量来说，语法允许，但无实际意义。\n2. 对数组来说：地址之间可以进行比较大小。可以得到元素存储的先后顺序。\n3. 与空指针 NULL 进行比较【常用】\n</code></pre></div><p><strong>示例：与空指针 <code>NULL</code> 进行比较</strong></p>\n<div><pre><code><span>int</span> <span>*</span>p<span>;</span>\np <span>=</span> <span>NULL</span><span>;</span>  <span>// 这两行等价于：int *p = NULL;</span>\n\n<span>if</span> <span>(</span>p <span>!=</span> <span>NULL</span><span>)</span>\n    <span>printf</span><span>(</span><span>\"p is not NULL\"</span><span>)</span><span>;</span>\n<span>else</span>\n    <span>printf</span><span>(</span><span>\"p is NULL\"</span><span>)</span><span>;</span>\n</code></pre></div><h2 id=\"_13-指针数组-存储地址的数组\" tabindex=\"-1\"> 13. 指针数组（存储地址的数组）</h2>\n<p>指针数组就是一个存储地址的数组。数组内部所有元素都是地址。</p>\n<h2 id=\"_14-指针数组和二维数组本质上都是二级指针\" tabindex=\"-1\"> 14. 指针数组和二维数组本质上都是二级指针</h2>\n<p><strong>示例1：指针数组的本质是一个二级指针</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day06/13.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>示例2：二维数组的本质也是一个二级指针</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day06/14.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_15-多级指针\" tabindex=\"-1\"> 15. 多级指针</h2>\n<div><pre><code>int a = 0;\n\nint *p = &amp;a;            一级指针是 变量的地址。\n\nint **pp = &amp;p;          二级指针是 一级指针的地址。\n\nint ***ppp = &amp;pp;       三级指针是 二级指针的地址。（int **p[] 二级指针数组，其本质是一个三级指针）   \n\nint ****pppp = &amp;ppp;    四级指针是 三级指针的地址。【了解】\n\n...\n</code></pre></div><p><strong>注意：</strong></p>\n<div><pre><code>多级指针，不能跳跃定义！\n</code></pre></div><p><strong>示例：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day06/15.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>对应关系：\nppp == &amp;pp;            三级指针\n\n*ppp == pp == &amp;p;             二级指针\n\n**ppp == *pp == p == &amp;a            一级指针\n\n***ppp == **pp == *p == a                普通整型变量\n</code></pre></div>",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-17T07:26:38.000Z",
      "authors": [],
      "tags": [
        "C语言基础"
      ]
    },
    {
      "title": "第07天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day07.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day07.html",
      "content_html": "<h2 id=\"_1-栈帧\" tabindex=\"-1\"> 1. 栈帧</h2>\n<div><pre><code>当函数调用时，系统会在 stack 空间上申请一块内存区域（即：栈帧），\n栈帧用来供函数调用，主要存放形参和局部变量（定义在函数内部）。\n当函数调用结束，这块内存区域（即：栈帧）自动被释放（消失）。\n</code></pre></div><h2 id=\"_2-传值-传址\" tabindex=\"-1\"> 2. 传值 &amp; 传址</h2>\n<p><strong>传值：</strong> 函数调用期间，实参将自己的值拷贝一份给形参。</p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day07/01.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>传址：</strong> 函数调用期间，实参将地址值拷贝一份给形参。</p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day07/02.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>传址即：传递地址值。通过地址在 <code>swap</code> 函数栈帧内部，修改了 <code>main</code> 函数栈帧内部的局部变量值。</p>\n</blockquote>\n<h2 id=\"_3-指针做函数参数\" tabindex=\"-1\"> 3. 指针做函数参数</h2>\n<div><pre><code>int swap2(int *a, int *b);\nint swap2(char *a, char *b);\n\n调用时，传有效的地址值。\n</code></pre></div><h2 id=\"_4-数组做函数参数\" tabindex=\"-1\"> 4. 数组做函数参数</h2>\n<div><pre><code>void BubbleSort(int arr[10])  &lt;=>  void BubbleSort(int arr[])  &lt;=>  void BubbleSort(int *arr)\n\n数组做函数时，传递不再是整个数组，而是数组的首地址（一个指针）。\n所以，当整型数组做函数参数时，我们通常在函数定义中，封装2个参数。一个表示数组首地址，一个表示元素个数。\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day07/03.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_5-指针做函数返回值-注意-不能返回局部变量的地址值\" tabindex=\"-1\"> 5. 指针做函数返回值（注意：不能返回局部变量的地址值）</h2>\n<div><pre><code>int *test_func(int a, int b);\n\n指针做函数返回值，不能返回【局部变量的地址值】，因为被调函数执行完毕后，会销毁对应的栈帧，从而栈帧中保留的局部变量无效。\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day07/04.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>如上图，当指针做函数 test_func2 的返回值，返回局部变量地址值时，\n由于 test_func2 函数调用结束后，其对应的栈帧销毁，从而局部变量 p 无效，无法得到预期的数据 1234。\n\n注意：函数 disturb_func 的作用是保证 test_func2 函数的调用栈帧销毁后，其栈帧空间被 disturb_func 函数复用，\n从而使得局部变量 p 中的数据被覆盖成一个不确定的数据。\n</code></pre></div><h2 id=\"_6-数组做函数返回值-c语言不允许\" tabindex=\"-1\"> 6. 数组做函数返回值（C语言不允许）</h2>\n<div><pre><code>C语言，不允许！！！只能写成指针形式。\n</code></pre></div><h2 id=\"_7-指针和字符串\" tabindex=\"-1\"> 7. 指针和字符串</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day07/05.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>如上图：\nchar str1[] = \"hello\"; 是把字符串常量 \"hello\" 复制到数组 str1 的内存空间\nchar *str2 = \"hello\";  是将指针 str2 指向字符串常量 \"hello\" 所在的内存地址\n\n因此，可以修改数组 str1 中存储的字符串常量的拷贝，但不能通过指针去直接修改字符串常量本身。\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day07/06.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>如上图：\nstr1 和 m 是两个不同的数组，各自存储着一份对字符串常量 \"hello\" 的拷贝\nstr2 和 n 是两个不同的指针，但是都指向同一个字符串常量 \"hello\" 的内存地址\n</code></pre></div><h2 id=\"_8-字符串初始化的方式\" tabindex=\"-1\"> 8. 字符串初始化的方式</h2>\n<div><pre><code><span>// 方式1</span>\n<span>char</span> str1<span>[</span><span>]</span> <span>=</span> <span>{</span><span>'h'</span><span>,</span> <span>'i'</span><span>,</span> <span>'\\0'</span><span>}</span><span>;</span>\n\n<span>// 方式2</span>\n<span>char</span> str2<span>[</span><span>]</span> <span>=</span> <span>\"hi\"</span><span>;</span>\n\n<span>// 方式3</span>\n<span>char</span> <span>*</span>str3 <span>=</span> <span>\"hi\"</span><span>;</span> \n\n<span>// 错误方式</span>\n<span>char</span> <span>*</span>str4 <span>=</span> <span>{</span><span>'h'</span><span>,</span> <span>'i'</span><span>,</span> <span>'\\0'</span><span>}</span><span>;</span>\n</code></pre></div><h2 id=\"_9-字符串-字符数组-字符指针-做函数实参\" tabindex=\"-1\"> 9. 字符串（字符数组/字符指针）做函数实参</h2>\n<div><pre><code>当字符串（字符数组），做函数参数时，不需要提供 2 个参数（1 个表示字符串首地址，1个表示字符串有效元素个数）。 \n因为每个字符串都有 '\\0'，可以借此判断是否遍历到了字符串的结尾\n</code></pre></div><h2 id=\"_10-字符串比较函数-strcmp-的实现\" tabindex=\"-1\"> 10. 字符串比较函数（<code>strcmp</code>）的实现</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day07/07.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_11-字符串拷贝函数-strcpy-的实现\" tabindex=\"-1\"> 11. 字符串拷贝函数（<code>strcpy</code>）的实现</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day07/08.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_12-字符串去空格\" tabindex=\"-1\"> 12. 字符串去空格</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day07/09.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_13-带参数的-main-函数-int-main-int-argc-char-argv\" tabindex=\"-1\"> 13. 带参数的 <code>main</code> 函数：<code>int main(int argc, char *argv[])</code></h2>\n<p><strong>无参 <code>main</code> 函数：</strong></p>\n<div><pre><code>int main(void)  &lt;=>  int main()\n</code></pre></div><p><strong>带参数的 <code>main</code> 函数：</strong></p>\n<div><pre><code>int main(int argc, char *argv[])   &lt;=>   int main(int argc, char **argv)\n\n参1：表示给 main 函数传递的参数的总个数。\n参2：是一个数组。数组的每一个元素都是字符串 char *\n</code></pre></div><p><strong>示例：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day07/10.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>如上图，参数 <code>argv</code> 数组中的第一个元素是 <strong>命令名称</strong>， 第二个元素开始才是 <strong>命令参数</strong>。</p>\n</blockquote>\n<p><strong><code>VS</code> 中设置命名参数的步骤：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day07/11.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_14-字符串操作函数-strstr-查找子串位置\" tabindex=\"-1\"> 14. 字符串操作函数：<code>strstr</code>（查找子串位置）</h2>\n<p><strong>作用：</strong></p>\n<div><pre><code>在 str 中，找 substr 出现的位置。\n</code></pre></div><p><strong>说明：</strong></p>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;string.h></span></span>\n<span>char</span> <span>*</span><span>strstr</span><span>(</span><span>char</span> <span>*</span>str<span>,</span> <span>char</span> <span>*</span>substr<span>)</span>\n    参数<span>1</span>：原串\n    参数<span>2</span>：子串\n    返回值：子串在原串中的位置。如果有，返回第 <span>1</span> 个子串的首地址值；如果没有，返回 <span>NULL</span>\n</code></pre></div><h2 id=\"_15-字符串中统计子串出现的次数\" tabindex=\"-1\"> 15. 字符串中统计子串出现的次数</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day07/12.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-17T07:26:38.000Z",
      "authors": [],
      "tags": [
        "C语言基础"
      ]
    },
    {
      "title": "第08天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day08.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day08.html",
      "content_html": "<h2 id=\"_1-求非空字符串元素个数\" tabindex=\"-1\"> 1. 求非空字符串元素个数</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/01.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_2-字符串逆置\" tabindex=\"-1\"> 2. 字符串逆置</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/02.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_3-回文字符串判断\" tabindex=\"-1\"> 3. 回文字符串判断</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/03.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_4-字符串处理函数\" tabindex=\"-1\"> 4. 字符串处理函数</h2>\n<h3 id=\"_4-1-字符串拷贝-strcpy-strncpy\" tabindex=\"-1\"> 4.1 字符串拷贝：<code>strcpy</code> &amp; <code>strncpy</code></h3>\n<p><strong><code>strcpy</code></strong></p>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;string.h></span></span>\n<span>char</span> <span>*</span><span>strcpy</span><span>(</span><span>char</span> <span>*</span>dest<span>,</span> <span>const</span> <span>char</span> <span>*</span>src<span>)</span><span>;</span>\n\n将 src 的内容，拷贝给 dest。返回 dest。 保证 dest 空间足够大。【不安全】，会发生缓冲区溢出。\n函数调用结束，返回值和 dest 参数结果一致。\n拷贝失败返回 <span>NULL</span>。\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/04.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>如上代码：\n1. 拷贝成功时，strcpy 返回的地址值和参数数组 dest 的地址值是一样的。\n2. 数组 dest 的大小 小于 被拷贝数组 src 的大小，此时会发生缓冲区溢出，\n   即 dest 数组内存范围之后的内存空间上也会存储着没拷贝完的 src 数组中的元素。\n   由于 printf 函数打印字符串时，遇 '\\0' 才结束，所以打印 dest 数组时，\n   dest 数组中没有 '\\0'，会继续打印 dest 数组内存范围之后的内容，从而把溢出的元素打印出来了。\n</code></pre></div><p><strong><code>strncpy</code></strong></p>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;string.h></span></span>\n<span>char</span> <span>*</span><span>strncpy</span><span>(</span><span>char</span> <span>*</span>dest<span>,</span> <span>const</span> <span>char</span> <span>*</span>src<span>,</span> <span>size_t</span> n<span>)</span><span>;</span> \n\n将 src 的内容，拷贝给 dest。只拷贝 n 个字节。 通常 n 与 dest 对应的空间一致。默认不添加 <span>'\\0'</span>\n\n特性：  \n<span>1.</span> n <span>></span> src：只拷贝 src 的大小\n<span>2.</span> n <span>&lt;</span> src：只拷贝 n 字节大小。不添加 <span>'\\0'</span>\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/05.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>如上代码：\nstrncpy(dest, src, 10) 只拷贝 10 个字符，即 \"hello worl\"，所以 dest 数组中也只有这 10 个字符，缺少 'd' 和 '\\0'\nprintf 函数将 dest 数组做字符串打印时，因为 dest 数组中没有 '\\0'，所以一直向后打印，\n从源数组 src 和 dest 数组的内存地址可以看出，printf 向后打印时，遇到 src 数组结尾处的 '\\0' 才停止。\n</code></pre></div><h3 id=\"_4-2-字符串拼接-strcat-strncat\" tabindex=\"-1\"> 4.2 字符串拼接：<code>strcat</code> &amp; <code>strncat</code></h3>\n<p><strong><code>strcat</code></strong></p>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;string.h></span></span>\n<span>char</span> <span>*</span><span>strcat</span><span>(</span><span>char</span> <span>*</span>dest<span>,</span> <span>const</span> <span>char</span> <span>*</span>src<span>)</span><span>;</span>\n\n将 src 的内容，拼接到 dest 后。返回拼接后的字符串。保证 dest 空间足够大。\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/06.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>如上代码：\n1. strcat 函数的返回的地址值就是参数数组 dest 的首地址；\n2. strcat 函数拼接字符串时，是直接往 dest 数组中追加字符，所以要保证 dest 数组的内存空间足够大，否则会导致缓冲区溢出。\n</code></pre></div><p><strong><code>strncat</code></strong></p>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;string.h></span></span>\n<span>char</span> <span>*</span><span>strncat</span><span>(</span><span>char</span> <span>*</span>dest<span>,</span> <span>const</span> <span>char</span> <span>*</span>src<span>,</span> <span>size_t</span> n<span>)</span><span>;</span>\n\n将 src 的前 n 个字符，拼接到 dest 后。返回拼接后的字符串。保证 dest 空间足够大。默认添加 <span>'\\0'</span>\n\n函数调用结束，返回值和 dest 参数结果一致。\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/07.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>如上代码：\n1. strncat 函数的返回的地址值就是参数数组 dest 的首地址；\n2. strncat 函数拼接字符串时，是直接往 dest 数组中追加字符，所以要保证 dest 数组的内存空间足够大，否则会导致缓冲区溢出；\n3. strlen 函数计算字符串长度时，不考虑存储字符串的数组的空间大小，以字符串结束标记 '\\0' 为准。\n</code></pre></div><h3 id=\"_4-3-字符串比较-strcmp-strncmp\" tabindex=\"-1\"> 4.3 字符串比较：<code>strcmp</code> &amp; <code>strncmp</code></h3>\n<blockquote>\n<p>注意：不能使用 <code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>==</code>、<code>!=</code> 比较字符串。</p>\n</blockquote>\n<p><strong><code>strcmp</code></strong></p>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;string.h></span></span>\n<span>int</span> <span>strcmp</span><span>(</span><span>const</span> <span>char</span> <span>*</span>s1<span>,</span> <span>const</span> <span>char</span> <span>*</span>s2<span>)</span><span>;</span>\n\n比较 s1 和 s2 两个字符串，如果相等返回 <span>0</span>；如果不相等，进一步比较 s1 和 s2 对应位的字符的 ASCII 码值。\ns1 <span>==</span> s2 返回  <span>0</span>\ns1 <span>></span> s2  返回  <span>1</span>\ns1 <span>&lt;</span> s2  返回 <span>-</span><span>1</span>\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/08.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>如上代码：\n1. strcmp 函数比较时，不考虑字符串的长短，仅以对应位字符的 ASCII 码作比较。\n</code></pre></div><p><strong><code>strncmp</code></strong></p>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;string.h></span></span>\n<span>int</span> <span>strncmp</span><span>(</span><span>const</span> <span>char</span> <span>*</span>s1<span>,</span> <span>const</span> <span>char</span> <span>*</span>s2<span>,</span> <span>size_t</span> n<span>)</span><span>;</span>\n\n比较 s1 和 s2 两个字符串的前 n 个字符，\n如果相等，返回 <span>0</span>。如果不相等，进一步比较 s1 和 s2 对应位的字符的 ASCII 码值。\ns1 <span>></span> s2 返回  <span>1</span>\ns1 <span>&lt;</span> s2 返回 <span>-</span><span>1</span>\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/09.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_4-4-字符串格式化输入输出-sprintf-sscanf\" tabindex=\"-1\"> 4.4 字符串格式化输入输出：<code>sprintf</code> &amp; <code>sscanf</code></h3>\n<p><strong><code>sprintf</code></strong></p>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>int</span> <span>sprintf</span><span>(</span><span>char</span> <span>*</span>str<span>,</span> <span>const</span> <span>char</span> <span>*</span>format<span>,</span> <span>.</span><span>.</span><span>.</span><span>)</span><span>;</span>\n\n对应 printf，将原来写到屏幕的 “格式化字符串”，写到参数<span>1</span> str 中。\n返回 str 所指向的字符串的长度，不包含 <span>'\\0'</span>\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/10.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong><code>sscanf</code></strong></p>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>int</span> <span>sscanf</span><span>(</span><span>const</span> <span>char</span> <span>*</span>str<span>,</span> <span>const</span> <span>char</span> <span>*</span>format<span>,</span> <span>.</span><span>.</span><span>.</span><span>)</span><span>;</span>\n\n对应 scanf，将原来从屏幕获取的 “格式化字符串”， 从参数<span>1</span> str 中获取。\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/11.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_4-5-字符串查找字符-strchr-strrchr\" tabindex=\"-1\"> 4.5 字符串查找字符：<code>strchr</code> &amp; <code>strrchr</code></h3>\n<p><strong><code>strchr</code></strong></p>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;string.h></span></span>\n<span>char</span> <span>*</span><span>strchr</span><span>(</span><span>const</span> <span>char</span> <span>*</span>s<span>,</span> <span>int</span> c<span>)</span><span>;</span>\n\n自左向右，在字符串 str 中找一个字符出现的位置。返回字符在字符串中的地址。\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/12.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong><code>strrchr</code></strong></p>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;string.h></span></span>\n<span>char</span> <span>*</span><span>strrchr</span><span>(</span><span>const</span> <span>char</span> <span>*</span>s<span>,</span> <span>int</span> c<span>)</span><span>;</span>\n\n自右向左，在字符串 str 中找一个字符出现的位置。返回字符在字符串中的地址。\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/13.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_4-6-字符串查找子串-strstr\" tabindex=\"-1\"> 4.6 字符串查找子串：<code>strstr</code></h3>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;string.h></span></span>\n<span>char</span> <span>*</span><span>strstr</span><span>(</span><span>const</span> <span>char</span> <span>*</span>str<span>,</span> <span>const</span> <span>char</span> <span>*</span>substr<span>)</span><span>;</span>\n\n在字符串 str 中，找子串 substr 第一次出现的位置。返回地址。\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/14.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_4-7-字符串分割-strtok\" tabindex=\"-1\"> 4.7 字符串分割：<code>strtok</code></h3>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;string.h></span></span>\n<span>char</span> <span>*</span><span>strtok</span><span>(</span><span>char</span> <span>*</span>str<span>,</span> <span>const</span> <span>char</span> <span>*</span>delim<span>)</span><span>;</span>\n    参数<span>1</span>：待拆分字符串\n    参数<span>2</span>：分割符组成的 “分割串”\n    返回：字符串拆分后的第 <span>1</span> 个拆分字符串首地址。拆分失败返回 <span>NULL</span>（如被拆分字符串为空字符串 <span>\"\"</span> 时返回 <span>NULL</span>）\n\n按照既定的分割符，来拆分字符串。\n“拆分” 就是：将分割字符用 <span>'\\0'</span> 替换。【重要】\n每调用一次，只拆分一次：<span>\"www.baidu.com\"</span> <span>-></span> <span>\"www\\0baidu.com\"</span>【重要】\n\n特性：\n<span>1.</span> strtok 拆分字符串是直接在原串上操作，所以要求参数<span>1</span>必须可读可写（<span>char</span> <span>*</span>str <span>=</span> <span>\"www.baidu.com\"</span> 不行！！！）\n<span>2.</span> 第一次拆分，参数<span>1</span>传入待拆分的原串。第 <span>1</span><span>+</span>i 次拆分时 <span>[</span>i<span>=</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3.</span><span>.</span><span>.</span><span>]</span>，参数<span>1</span>传入 <span>NULL</span>。\n</code></pre></div><p><strong>示例1：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/15.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>示例2：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/16.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_4-8-字符串转整数或浮点数-atoi-atof-atol\" tabindex=\"-1\"> 4.8 字符串转整数或浮点数：<code>atoi</code>/<code>atof</code>/<code>atol</code></h3>\n<div><pre><code>atoi/atof/atol：a（字符串）  to（转） i（int整数）/ f（浮点数）/ l（long整数）\n使用这类函数进行转换时要求：原串必须是可转换的字符串。\n错误使用：\"abc123\" -> 0;    \"12abc345\" -> 12;  \"123xyz\" -> 123\n</code></pre></div><p><strong><code>atoi</code> 字符串转整数</strong></p>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdlib.h></span></span>\n<span>int</span> <span>atoi</span><span>(</span><span>const</span> <span>char</span> <span>*</span>nptr<span>)</span><span>;</span>\n</code></pre></div><p><strong><code>atof</code> 字符串转浮点数</strong></p>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdlib.h></span></span>\n<span>double</span> <span>atof</span><span>(</span><span>const</span> <span>char</span> <span>*</span>nptr<span>)</span><span>;</span>\n</code></pre></div><p><strong><code>atol</code> 字符串转长整数</strong></p>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdlib.h></span></span>\n<span>long</span> <span>atol</span><span>(</span><span>const</span> <span>char</span> <span>*</span>nptr<span>)</span><span>;</span>\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/17.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_5-局部变量-及其作用域\" tabindex=\"-1\"> 5. 局部变量（及其作用域）</h2>\n<div><pre><code>概念：定义在函数内部的变量。\n作用域：从定义位置开始，到包裹该变量的第一个右大括号结束。\n</code></pre></div><h2 id=\"_6-全局变量-及其作用域\" tabindex=\"-1\"> 6. 全局变量（及其作用域）</h2>\n<div><pre><code>概念：定义在函数外部的变量。\n作用域：从定义位置开始，默认到本文件内部。其他文件如果想使用，可以通过声明方式（extern）将作用域导出。\n</code></pre></div><h2 id=\"_7-static-全局变量-及其作用域\" tabindex=\"-1\"> 7. <code>static</code> 全局变量（及其作用域）</h2>\n<div><pre><code>定义语法：在全局变量定义之前添加 static 关键字。如：static int a = 10；\n作用域：被限制在本文件内部，不允许通过声明导出到其他文件。\n</code></pre></div><h2 id=\"_8-static-局部变量-及其作用域\" tabindex=\"-1\"> 8. <code>static</code> 局部变量（及其作用域）</h2>\n<div><pre><code>定义语法：在局部变量定义之前添加 static 关键字。\n特性：静态局部变量只在全局位置上定义一次。 通常用来做计数器。\n作用域：从定义位置开始，到包裹该变量的第一个右大括号结束。（作用域跟非 static 局部变量一致，但生命周期不同）\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/18.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>如上图，对比可看出，右侧的静态局部变量 <code>a</code> 只定义了一次，即重复调用 <code>test</code> 函数时，不会再重复定义静态局部变量 <code>a</code>，从而达到了递增的目的。</p>\n</blockquote>\n<h2 id=\"_9-全局函数\" tabindex=\"-1\"> 9. 全局函数</h2>\n<div><pre><code>定义语法： 函数原型 + 函数体\n</code></pre></div><h2 id=\"_10-static-函数\" tabindex=\"-1\"> 10. <code>static</code> 函数</h2>\n<div><pre><code>定义语法：static + 函数原型 + 函数体\nstatic 函数只能在本文件内部使用。其他文件即使声明也无效。\n</code></pre></div><h2 id=\"_11-生命周期-生命周期和作用域之间没有关系\" tabindex=\"-1\"> 11. 生命周期（生命周期和作用域之间没有关系）</h2>\n<div><pre><code>局部变量：       从变量定义开始，函数调用完成。 --- 函数内部。\n\n全局变量：       程序启动开始，程序终止结束。  --- 程序执行期间。\n\nstatic局部变量： 程序启动开始，程序终止结束。  --- 程序执行期间。\n\nstatic全局变量： 程序启动开始，程序终止结束。  --- 程序执行期间。\n\n全局函数：       程序启动开始，程序终止结束。  --- 程序执行期间。\n\nstatic函数：     程序启动开始，程序终止结束。  --- 程序执行期间。\n</code></pre></div><h2 id=\"_12-内存四区模型-代码段-数据段-stack-heap\" tabindex=\"-1\"> 12. 内存四区模型：代码段 &amp; 数据段 &amp; <code>stack</code> &amp; <code>heap</code></h2>\n<div><pre><code>代码段：\n    .text段。 程序源代码（二进制形式）。\n\n数据段：\n    只读数据段 .rodata 段。（常量）\n    初始化数据段 .data 段。（初始化为非 0 的全局变量和静态变量【包括静态局部变量和静态全局变量】）\n    未初始化数据段 .bss 段。（初始化为 0 or 未初始化的全局变量和静态变量。程序加载执行前，会将该段整体赋值为 0）\n\nstack：\n    栈。 在其之上开辟栈帧。    \n    windows 1M --- 10M    Linux： 8M --- 16M\n\nheap：\n    堆。 给用户自定义数据提供空间。 约 1.3G+\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/19.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p><code>windows</code> 底层源码未开源，所以 <code>windows</code> 的内存4区模型只是大致的；</p>\n<p><code>Linux</code> 底层源码是开源的，所以上图 <code>Linux</code> 的内存4区模型就是实际的。</p>\n</blockquote>\n<h2 id=\"_13-申请-释放堆空间-heap-空间\" tabindex=\"-1\"> 13. 申请 &amp; 释放堆空间（<code>heap</code> 空间）</h2>\n<h3 id=\"_13-1-申请堆空间-void-malloc-size-t-size\" tabindex=\"-1\"> 13.1 申请堆空间：<code>void *malloc(size_t size)</code></h3>\n<div><pre><code><span>void</span> <span>*</span><span>malloc</span><span>(</span><span>size_t</span> size<span>)</span><span>;</span>  \n\n申请 size 大小的空间。\n返回实际申请到的内存空间首地址。【我们通常拿来当数组用】\n</code></pre></div><h3 id=\"_13-2-释放堆空间-void-free-void-ptr\" tabindex=\"-1\"> 13.2 释放堆空间：<code>void free(void *ptr)</code></h3>\n<div><pre><code><span>void</span> <span>free</span><span>(</span><span>void</span> <span>*</span>ptr<span>)</span><span>;</span>   \n\n参数 ptr：malloc 申请函数返回的地址值。\n</code></pre></div><p><strong>示例：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/20.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>如上代码：\n1. 形如 int arr[1000000] = {10, 20, 40}; 是在栈（stack）上申请内存空间，因为栈空间较小，所以当申请空间过大时，会发生栈溢出。  \n   而调用 malloc 函数，则是在堆（heap）上申请内存空间，因为堆空间远大于栈空间，所以并不会发生内存溢出。\n\n2. malloc 函数的返回值类型为 void * ，是可以隐式转换为 int * 的。 但是，为了使代码更明确，一般通过 (类型) 显示转换为指定类型。\n</code></pre></div><h3 id=\"_13-3-使用堆空间的注意事项\" tabindex=\"-1\"> 13.3 使用堆空间的注意事项</h3>\n<div><pre><code>1. 空间是连续。当成数组使用。\n2. free 后的空间，不会立即失效。通常将 free 后的地址置为 NULL。\n3. free 地址必须是 malloc 申请地址。否则出错。（如果 malloc 之后的地址一定会变化，那么使用临时变量 tmp 保存）\n</code></pre></div><p><strong>示例1：</strong></p>\n<div><pre><code>如下代码，虽然调用 free 函数后，指针 p 所指向的地址空间中的数据被清除了，\n但是指针 p 所指向的地址空间还是可以访问的，即该地址空间仍然有效，可以使用。\n因此，为了避免使用 free 后的地址空间，应该将指针 p 置为 NULL。\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/21.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>示例2：</strong></p>\n<div><pre><code>如下代码，原本指向 malloc 所申请空间首地址的指针 p 的指向发生了改变（p++;）\n此时，再调用 free(p); 所释放的地址就不是 malloc 所申请空间的首地址了，从而程序报错。\n解决方案：使用临时变量 tmp 保存 malloc 申请到的空间首地址。即：\n\n    char *tmp = p;\n    ...\n    p++;\n    ...\n    free(tmp);\n    p = NULL;\n    tmp = NULL;\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/22.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_13-4-二级指针对应的堆空间\" tabindex=\"-1\"> 13.4 二级指针对应的堆空间</h3>\n<div><pre><code>申请外层指针： \n    char **p = (char **)malloc(sizeof(char *) * 5);\n\n申请内层指针： \n    for(i = 0; i &lt; 5; i++)\n    {\n        p[i] = (char *)malloc(sizeof(char) *10);\n    }\n\n使用：不能修改 p 的值。\n    for(i = 0; i &lt; 5; i++)\n    {\n        strcpy(p[i], \"helloheap\");\n    }\n\n释放内层：\n    for(i = 0; i &lt; 5; i++)\n    {\n        free(p[i]);\n    }\n\n释放外层：\n    free(p);\n</code></pre></div><p><strong>示例：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/23.png\" alt=\"\" loading=\"lazy\"></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/24.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_14-内存常见问题\" tabindex=\"-1\"> 14. 内存常见问题</h2>\n<h3 id=\"_14-1-问题1-申请-0-字节空间\" tabindex=\"-1\"> 14.1 问题1：申请 <code>0</code> 字节空间</h3>\n<div><pre><code><span>int</span> <span>*</span>p <span>=</span> <span>(</span><span>int</span> <span>*</span><span>)</span><span>malloc</span><span>(</span><span>0</span><span>)</span><span>;</span> <span>// 此时指针 p 其实就是野指针</span>\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/25.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_14-2-问题2-多次-free-同一个指针\" tabindex=\"-1\"> 14.2 问题2：多次 <code>free</code> 同一个指针</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/26.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_14-3-问题3-free-空指针\" tabindex=\"-1\"> 14.3 问题3：<code>free</code> 空指针</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/27.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_14-4-问题4-越界访问\" tabindex=\"-1\"> 14.4 问题4：越界访问</h3>\n<h3 id=\"_14-5-问题5-free-后的地址\" tabindex=\"-1\"> 14.5 问题5：<code>free</code> ++后的地址</h3>\n<h3 id=\"_14-6-问题6-子函数-malloc-空间-main-中用\" tabindex=\"-1\"> 14.6 问题6：子函数 <code>malloc</code> 空间，<code>main</code> 中用</h3>\n<h2 id=\"_15-内存操作函数\" tabindex=\"-1\"> 15. 内存操作函数</h2>\n<h3 id=\"_15-1-内存填充-memset\" tabindex=\"-1\"> 15.1 内存填充：<code>memset</code></h3>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;string.h></span></span>\n<span>void</span> <span>*</span><span>memset</span><span>(</span><span>void</span> <span>*</span>s<span>,</span> <span>int</span> c<span>,</span> <span>size_t</span> n<span>)</span><span>;</span>\n    功能：将 s 指向的内存区域的前 n 个字节以参数 c 填入\n    参数：\n        s：需要操作内存 s 的首地址\n        c：填充的字符，c 虽然参数为i nt，但必须是 <span>unsigned</span> <span>char</span> <span>,</span> 范围为 <span>0</span><span>~</span><span>255</span>\n        n：指定需要设置的大小，单位：字节\n    返回值：s 的首地址\n</code></pre></div><p><strong>示例1：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/28.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>示例2：通常使用 <code>memset</code> 函数将内存空间重置为 <code>0</code></strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/29.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p><strong>注意：</strong> 如上代码所示，<code>memset</code> 函数还可以用来重置栈上的内存空间。</p>\n</blockquote>\n<h3 id=\"_15-2-内存拷贝-memcpy\" tabindex=\"-1\"> 15.2 内存拷贝：<code>memcpy</code></h3>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;string.h></span></span>\n<span>void</span> <span>*</span><span>memcpy</span><span>(</span><span>void</span> <span>*</span>dest<span>,</span> <span>const</span> <span>void</span> <span>*</span>src<span>,</span> <span>size_t</span> n<span>)</span><span>;</span>\n    功能：拷贝 src 所指的内存内容的前 n 个字节到 dest 所值的内存地址上。\n    参数：\n        dest：目的内存首地址\n        src：源内存首地址，注意：des t和 src 所指的内存空间不可重叠，可能会导致程序报错。\n        n：需要拷贝的字节数\n    返回值：dest 的首地址\n\n    memcpy 的错误用法（内存重叠）：\n    <span>int</span> a<span>[</span><span>10</span><span>]</span> <span>=</span> <span>{</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>,</span> <span>10</span> <span>}</span><span>;</span>\n    <span>memcpy</span><span>(</span><span>&amp;</span>a<span>[</span><span>3</span><span>]</span><span>,</span> a<span>,</span> <span>5</span> <span>*</span> <span>sizeof</span><span>(</span><span>int</span><span>)</span><span>)</span><span>;</span> <span>// err, 内存重叠，即：可能导致对同一个内存单元同时进行读和写的操作</span>\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/30.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_15-3-内存移动-memmove\" tabindex=\"-1\"> 15.3 内存移动：<code>memmove</code></h3>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;string.h></span></span>\n<span>void</span> <span>*</span><span>memcpy</span><span>(</span><span>void</span> <span>*</span>dest<span>,</span> <span>const</span> <span>void</span> <span>*</span>src<span>,</span> <span>size_t</span> n<span>)</span><span>;</span>\n    功能：拷贝 src 所指的内存内容的前 n 个字节到 dest 所值的内存地址上。\n    参数：\n        dest：目的内存首地址\n        src：源内存首地址，注意：dest 和 src 所指的内存空间不可重叠，可能会导致程序报错\n        n：需要拷贝的字节数\n    返回值：dest 的首地址\n\n    <span>memmove</span><span>(</span><span>)</span> 功能用法和 <span>memcpy</span><span>(</span><span>)</span> 一样，区别在于：\n        dest 和 src 所指的内存空间重叠时，<span>memmove</span><span>(</span><span>)</span>仍然能处理，不过执行效率比 <span>memcpy</span><span>(</span><span>)</span> 低些。\n        如果 dest 和 src 所指的内存空间没有重叠，两个函数效率一样\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/31.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_15-4-内存比较-memcmp\" tabindex=\"-1\"> 15.4 内存比较：<code>memcmp</code></h3>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;string.h></span></span>\n<span>int</span> <span>memcmp</span><span>(</span><span>const</span> <span>void</span> <span>*</span>s1<span>,</span> <span>const</span> <span>void</span> <span>*</span>s2<span>,</span> <span>size_t</span> n<span>)</span><span>;</span>\n    功能：比较 s1 和 s2 所指向内存区域的前 n 个字节\n    参数：\n        s1：内存首地址<span>1</span>\n        s2：内存首地址<span>2</span>\n        n：需比较的前 n 个字节\n    返回值：\n        相等：<span>=</span><span>0</span>\n        大于：<span>></span><span>0</span>\n        小于：<span>&lt;</span><span>0</span>\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day08/32.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-21T05:58:47.000Z",
      "authors": [],
      "tags": [
        "C语言基础"
      ]
    },
    {
      "title": "第09天（结构体&共用体&枚举）",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day09.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day09.html",
      "content_html": "<h2 id=\"_1-结构体的定义和使用\" tabindex=\"-1\"> 1. 结构体的定义和使用</h2>\n<p><strong>定义结构体类型：</strong></p>\n<div><pre><code>struct 结构体名称\n{\n   结构体成员列表\n};\n</code></pre></div><p><strong>定义结构体变量：</strong></p>\n<div><pre><code>struct 结构体名称 结构体变量名\n</code></pre></div><p><strong>为结构体成员变量赋值：</strong></p>\n<div><pre><code>结构体变量名.结构体成员变量 = 值\n</code></pre></div><blockquote>\n<p>如果结构体成员变量是字符串类型，那么需要使用 <code>strcpy</code> 进行赋值。</p>\n</blockquote>\n<p><strong>注意：定义结构体类型的时候不能为成员变量赋值</strong></p>\n<div><pre><code><span>struct</span> <span>student</span>\n<span>{</span>\n    <span>// int age = 18; //错误</span>\n    <span>.</span><span>.</span><span>.</span>\n<span>}</span>\n</code></pre></div><p><strong>示例1：定义结构体变量的同时，按照结构体顺序赋值</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/01.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>示例2：定义结构体变量的同时，为指定的结构体成员赋值</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/02.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>示例3：先定义结构体变量，再为结构体成员赋值</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/03.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>示例4：定义结构体类型的同时，声明结构体变量</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/04.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>示例5：定义结构体类型的同时，声明结构体变量，并初始化赋值</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/05.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>示例6：定义结构体类型的同时，声明多个结构体变量，并初始化赋值</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/06.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_2-结构体大小和在内存中的存储结构\" tabindex=\"-1\"> 2. 结构体大小和在内存中的存储结构</h2>\n<div><pre><code>结构体需要根据数据类型进行内存对齐，\n因此，以所占内存最大的成员变量数据类型的所占字节数，作为结构体变量进行内存对齐时的内存单元。\n</code></pre></div><p><strong>示例1：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/07.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>示例2：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/08.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>对比如上两个示例可以看出：通过调整结构体的成员列表，可以减少结构体所占的内存大小。\n一般地，按照成员变量所占内存从大到小的顺序定义成员列表，可以节省结构体所占的内存空间。但是，这样排列成员列表，可能不方便代码阅读。\n实际开发中，应该按照既方便代码阅读，又能节省内存空间的方式排列成员列表（即：二者之间取其平衡点）\n</code></pre></div><h3 id=\"_2-1-求结构体所占内存空间大小\" tabindex=\"-1\"> 2.1 求结构体所占内存空间大小</h3>\n<div><pre><code>1. 通过结构体变量求： sizeof(stu)\n2. 通过结构体类型求： sizeof(struct stus1)\n</code></pre></div><h2 id=\"_3-结构体数组\" tabindex=\"-1\"> 3. 结构体数组</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/09.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_4-结构体数组排序\" tabindex=\"-1\"> 4. 结构体数组排序</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/10.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_5-结构体中包含指针类型的成员变量\" tabindex=\"-1\"> 5. 结构体中包含指针类型的成员变量</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/11.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_6-指向结构体类型的指针-即结构体指针\" tabindex=\"-1\"> 6. 指向结构体类型的指针（即结构体指针）</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/12.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_7-在堆空间中创建结构体\" tabindex=\"-1\"> 7. 在堆空间中创建结构体</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/13.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_8-结构体案例\" tabindex=\"-1\"> 8. 结构体案例</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/14.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_9-结构体和函数\" tabindex=\"-1\"> 9. 结构体和函数</h2>\n<h3 id=\"_9-1-结构体变量作形参-值传递\" tabindex=\"-1\"> 9.1 结构体变量作形参（值传递）</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/15.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_9-2-结构体指针作形参-地址传递\" tabindex=\"-1\"> 9.2 结构体指针作形参（地址传递）</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/16.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_9-3-函数返回值类型为结构体类型\" tabindex=\"-1\"> 9.3 函数返回值类型为结构体类型</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/17.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_9-4-函数返回值类型为结构体指针类型\" tabindex=\"-1\"> 9.4 函数返回值类型为结构体指针类型</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/18.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_10-结构体嵌套\" tabindex=\"-1\"> 10. 结构体嵌套</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/19.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_11-共用体-联合体\" tabindex=\"-1\"> 11. 共用体（联合体）</h2>\n<div><pre><code>1. 共用体就是在同一个存储空间存储不同类型数据的类型；\n2. 共用体所占的内存长度，等于其最长成员的长度倍数；\n3. 同一内存段可以用来存放几种不同类型的成员，但每一瞬时只有一种起作用；\n4. 共用体变量中起作用的成员是最后一次存放的成员，在存入一个新的成员后原有的成员的值会被覆盖；\n5. 共用体变量的地址和它的各成员的地址都是同一地址。\n</code></pre></div><p><strong>示例1：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/20.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>示例2：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/21.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>示例3：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/22.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_12-枚举\" tabindex=\"-1\"> 12. 枚举</h2>\n<div><pre><code>1. 在枚举值表中应列出所有可用值，也称为枚举元素 or 枚举常量。\n    enum color { 枚举常量 };  =>  enum color { red, green, blue, black, pink, yellow };\n\n2. 枚举值是常量，不能在程序中用赋值语句再对它赋值。\n\n3. 枚举常量是整型常量。不能是浮点数。可以是负值。 \n   默认初值从 0 开始，后续常量较前一个常量 +1。\n   可以给任意一个常量赋任意初值。后续常量较前一个常量 +1\n</code></pre></div><p><strong>示例1：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/23.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>示例2：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/24.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_13-typedef-关键字-为数据类型起别名\" tabindex=\"-1\"> 13. <code>typedef</code> 关键字（为数据类型起别名）</h2>\n<div><pre><code>1. typedef 为C语言的关键字，作用是为一种数据类型（基本类型或自定义数据类型）定义一个新名字，不能创建新类型。\n2. 与 #define 不同，typedef 仅限于数据类型，而不是能是表达式或具体的值\n3. #define 发生在预处理，typedef 发生在编译阶段\n</code></pre></div><p><strong>示例1：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/25.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>示例2：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day09/26.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-21T05:58:47.000Z",
      "authors": [],
      "tags": [
        "C语言基础"
      ]
    },
    {
      "title": "第10天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day10.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day10.html",
      "content_html": "<h2 id=\"_1-printf-scanf-perror-函数与其对应的系统文件\" tabindex=\"-1\"> 1. <code>printf</code>/<code>scanf</code>/<code>perror</code> 函数与其对应的系统文件</h2>\n<p><code>printf</code>（标准输入）、<code>scanf</code>（标准输出）、<code>perror</code>（标准错误） 这三个函数分别用于向不同的系统文件（<code>stdin</code> 文件、<code>stdout</code> 文件、<code>stderr</code> 文件）中读写数据，然后再通过操作系统，将系统文件和物理设备关联起来。</p>\n<div><pre><code>scanf函数  -- 标准输入 -- stdin文件（编号0）  -- 键盘\n\nprintf函数 -- 标准输出 -- stdout文件（编号1） -- 屏幕\n\nperror函数 -- 标准错误 -- stderr文件（编号2） -- 屏幕\n</code></pre></div><h3 id=\"_1-1-系统文件的隐式回收\" tabindex=\"-1\"> 1.1 系统文件的隐式回收</h3>\n<p>应用程序启动时，自动被打开；程序执行结束时，自动被关闭。</p>\n<h2 id=\"_2-文件指针和普通指针的区别\" tabindex=\"-1\"> 2. 文件指针和普通指针的区别</h2>\n<p>与普通指针不同的是，文件指针的初始化、赋值等操作基本都是借助文件操作函数来实现的，如：</p>\n<ol>\n<li>\n<p>借助文件操作函数来改变 <code>fp</code> 为空、野指针的状况</p>\n<div><pre><code>FILE <span>*</span>fp <span>=</span> <span>NULL</span><span>;</span>\nfp <span>=</span> <span>fopen</span><span>(</span><span>\"test2.txt\"</span><span>,</span> <span>\"w\"</span><span>)</span><span>;</span> <span>// fopen() 函数相当于 fp = malloc();</span>\n</code></pre></div></li>\n<li>\n<p>操作文件，使用文件读写函数来完成。如：</p>\n<div><pre><code>fputc/fgetc\nfputs/fgets\nfwrite/fread\n</code></pre></div></li>\n</ol>\n<h3 id=\"_2-1-file-结构体\" tabindex=\"-1\"> 2.1 <code>FILE</code> 结构体</h3>\n<p><code>FILE</code> 是系统使用 <code>typedef</code> 定义出来的有关文件信息的一种结构体类型，结构中含有文件名、文件状态和文件当前位置等信息:</p>\n<div><pre><code><span>typedef</span> <span>struct</span>\n<span>{</span>\n    <span>short</span>           level<span>;</span>     <span>// 缓冲区\"满\"或者\"空\"的程度</span>\n    <span>unsigned</span>        flags<span>;</span>     <span>// 文件状态标志</span>\n    <span>char</span>            fd<span>;</span>        <span>// 文件描述符</span>\n    <span>unsigned</span> <span>char</span>   hold<span>;</span>      <span>// 如无缓冲区不读取字符</span>\n    <span>short</span>           bsize<span>;</span>     <span>// 缓冲区的大小</span>\n    <span>unsigned</span> <span>char</span>   <span>*</span>buffer<span>;</span>   <span>// 数据缓冲区的位置</span>\n    <span>unsigned</span>        ar<span>;</span>        <span>// 指针，当前的指向</span>\n    <span>unsigned</span>        istemp<span>;</span>    <span>// 临时文件，指示器</span>\n    <span>short</span>           token<span>;</span>     <span>// 用于有效性的检查</span>\n<span>}</span>FILE<span>;</span>\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day10/01.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_3-文件分类-设备文件-磁盘文件\" tabindex=\"-1\"> 3. 文件分类：设备文件 &amp; 磁盘文件</h2>\n<p><strong>设备文件</strong></p>\n<div><pre><code>屏幕、键盘、磁盘、网卡、声卡、显卡、扬声器 ...\n</code></pre></div><p><strong>磁盘文件</strong></p>\n<div><pre><code>文本文件：\n    ASCII\n\n二进制文件： \n    0101 二进制编码\n</code></pre></div><h2 id=\"_4-文件操作一般步骤\" tabindex=\"-1\"> 4. 文件操作一般步骤</h2>\n<div><pre><code>1. 打开文件 fopen() => 返回 FILE *fp 指针;\n\n2. 读写文件 fputc、fgetc、fputs、fgets、fread、fwrite\n\n3. 关闭文件 fclose()  \n</code></pre></div><h2 id=\"_5-打开、关闭文件函数-fopen-fclose\" tabindex=\"-1\"> 5. 打开、关闭文件函数：<code>fopen</code> &amp; <code>fclose</code></h2>\n<p><strong>打开文件</strong></p>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\nFILE <span>*</span> <span>fopen</span><span>(</span><span>const</span> <span>char</span> <span>*</span> filename<span>,</span> <span>const</span> <span>char</span> <span>*</span> mode<span>)</span><span>;</span>\n    参<span>1</span>：待打开文件的文件名（访问路径）\n    参<span>2</span>：文件打开权限：\n        <span>\"r\"</span>：只读方式打开文件，文件不存在，报错。存在，以只读方式打开。\n        <span>\"w\"</span>：只写方式打开文件，文件不存在，创建一个空文件。文件如果存在，清空并打开。\n        <span>\"w+\"</span>：读、写方式打开文件，文件不存在，创建一个空文件。文件如果存在，清空并打开。\n        <span>\"r+\"</span>：读、写方式打开文件<span>,</span> 文件不存在，报错。存在，以读写方式打开。\n        <span>\"a\"</span>：以追加的方式打开文件。\n        <span>\"b\"</span>：操作的文件是一个二进制文件\n             b 只是在 Windows 有效，在 Linux 用 r 和 rb 的结果是一样的，\n             这是因为文本方式和二进制方式在打开文件时的区别，仅仅体现在换行符的处理上，\n             而 Linux 下的换行符就是 \\n，所以文本文件方式和二进制方式无区别；\n             对于 Window 系统：\n                当对文件使用文本方式打开的时候，读写的 windows 文件中的换行符 \\r\\n 会被替换成 \\n 读到内存中，\n                当在 windows 下写入文件的时候，\\n 被替换成 \\r\\n 再写入文件。\n                如果使用二进制方式打开文件，则不进行 \\r\\n 和 \\n 之间的转换。\n                也就是说，<span>\"b\"</span> 的作用就在于：不进行 \\r\\n 和 \\n 之间的转换。 \n    返回值：\n        成功：返回打开文件的文件指针\n        失败：<span>NULL</span>\n</code></pre></div><p><strong>关闭文件</strong></p>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>int</span> <span>fclose</span><span>(</span>FILE <span>*</span> stream<span>)</span><span>;</span>\n    参<span>1</span>：打开文件的 fp（fopen 的返回值）\n    返回值：\n        成功： <span>0</span>， \n        失败：<span>-</span><span>1</span><span>;</span>\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day10/02.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_6-文件访问路径-绝对路径-相对路径\" tabindex=\"-1\"> 6. 文件访问路径：绝对路径 &amp; 相对路径</h2>\n<p><strong>绝对路径</strong></p>\n<div><pre><code>从系统磁盘的根盘符开始，找到待访问的文件路径。\nWindows 书写方法：\n    1. C:\\\\Users\\\\afei\\\\Desktop\\\\06-文件分类.avi\n    2. C:/Users/afei/Desktop/06-文件分类.avi  (也适用于 Linux)\n</code></pre></div><p><strong>相对路径</strong></p>\n<div><pre><code>1. 如果在 VS 环境下编译执行（Ctrl+F5），文件相对路径是指相对于 day10.vcxproj 所在目录位置。\n2. 如果是双击 xxx.exe 文件执行，文件的相对路径是相对于 xxx.exe 所在目录位置。\n</code></pre></div><h2 id=\"_7-按字符写文件-fputc\" tabindex=\"-1\"> 7. 按字符写文件：<code>fputc</code></h2>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>int</span> <span>fputc</span><span>(</span><span>int</span> ch<span>,</span> FILE <span>*</span> stream<span>)</span><span>;</span>\n    参<span>1</span>：待写入的字符\n    参<span>2</span>：打开文件的 fp（fopen 的返回值）\n    返回值：\n        成功：写入文件中的字符对应的 ASCII 码\n        失败：<span>-</span><span>1</span>\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day10/03.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_8-按字符读文件-fgetc\" tabindex=\"-1\"> 8. 按字符读文件：<code>fgetc</code></h2>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>int</span> <span>fgetc</span><span>(</span>FILE <span>*</span> stream<span>)</span><span>;</span>\n    参<span>1</span>：待读取的文件 fp（fopen 的返回值）\n    返回值： \n        成功：读到的字符对应的 ASCII 码\n        失败：<span>-</span><span>1</span>\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day10/04.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>文本文件的结束标记：<code>EOF</code></p>\n<div><pre><code><span><span>#</span><span>define</span> <span>EOF</span>  <span><span>(</span><span>-</span><span>1</span><span>)</span></span></span>\n</code></pre></div></blockquote>\n<h2 id=\"_9-判断是否到达文件结尾-feof\" tabindex=\"-1\"> 9. 判断是否到达文件结尾：<code>feof</code></h2>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>int</span> <span>feof</span><span>(</span>FILE <span>*</span> stream<span>)</span><span>;</span>\n    参<span>1</span>： fopen 的返回值\n    返回值： \n        到达文件结尾：非<span>0</span>【真】\n        没到达文件结尾：<span>0</span>【假】\n    作用：    \n        用来判断到达文件结尾。既可以判断文本文件；也可以判断二进制文件。\n    特性：\n        要想使用 <span>feof</span><span>(</span><span>)</span> 检测文件结束标记，必须在该函数调用之前，使用读文件函数。\n        即：<span>feof</span><span>(</span><span>)</span> 调用之前，必须有读文件函数调用。\n</code></pre></div><p><strong>示例1：使用 <code>if (ch == EOF)</code> 判断是否到达文件结尾的问题</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day10/05.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>如上图，使用 <code>ch == EOF</code> 判断是否到达文件结尾是存在 <code>bug</code> 的。</p>\n</blockquote>\n<p><strong>示例2：使用 <code>if (feof(fp))</code> 判断是否到达文件结尾</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day10/06.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>如上图，通过 <code>feof</code> 函数判断是否读到文件结尾，可以避免当写入了 <code>ASCII</code> 码为 <code>-1</code> 的文本后，所造成的读取时 <code>if(ch == EOF)</code> 引起误判的 <code>bug</code>。</p>\n</blockquote>\n<p><strong>示例3：调用 <code>feof</code> 函数前需要进行文件的读操作</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day10/07.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>如上图，在 <code>feof</code> 函数调用前，需要进行文件的读操作，否则 <code>feof</code> 函数总是返回假，即总是判定没有到达文件结尾。</p>\n</blockquote>\n<p><strong>示例4：避免将 <code>EOF</code> 打印出来</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day10/08.png\" alt=\"\" loading=\"lazy\"></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day10/09.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_10-从指定输入流中获取一个字符串-fgets\" tabindex=\"-1\"> 10. 从指定输入流中获取一个字符串：<code>fgets</code></h2>\n<blockquote>\n<p>参考：<a href=\"/zkq/c_and_cpp/_1_c-basic/day05.html#_4-4-2-%E4%BB%8E%E6%8C%87%E5%AE%9A%E8%BE%93%E5%85%A5%E6%B5%81%E4%B8%AD%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2-fgets\">day05-从指定输入流中获取一个字符串：fgets</a></p>\n</blockquote>\n<h2 id=\"_11-将一个字符串写出到指定输出流-fputs\" tabindex=\"-1\"> 11. 将一个字符串写出到指定输出流：<code>fputs</code></h2>\n<blockquote>\n<p>参考：<a href=\"/zkq/c_and_cpp/_1_c-basic/day05.html#_4-4-4-%E5%B0%86%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%86%99%E5%87%BA%E5%88%B0%E6%8C%87%E5%AE%9A%E8%BE%93%E5%87%BA%E6%B5%81-fputs\">day05-将一个字符串写出到指定输出流：fputs</a></p>\n</blockquote>\n<h2 id=\"_12-案例\" tabindex=\"-1\"> 12. 案例</h2>\n<h3 id=\"_12-1-案例1-获取用户键盘输入保存到文件\" tabindex=\"-1\"> 12.1 案例1：获取用户键盘输入保存到文件</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day10/10.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_12-2-案例2-文件版四则运算\" tabindex=\"-1\"> 12.2 案例2：文件版四则运算</h3>\n<p><strong>需求：</strong></p>\n<div><pre><code>将文件内容：\n    10/2=\n    10*3=\n    4+3=\n    8-6=\n\n读取出来，进行四则运算，再将结果写入到文件中：\n    10/2=5\n    10*3=30\n    4+3=7\n    8-6=2\n</code></pre></div><p><strong>思路：</strong></p>\n<div><pre><code>1. 调用 fgets 函数按行读取文件（fgets 函数遇换行符终止读取）\n    fgets(buf, 4096, 文件fp)  =>  \"10/2=\\n\" \n\n2. 对读取到的一行字符串进行分解 \n    \"10/2=\\n\"  =>  sscanf(buf, \"%d%c%d=\\n\", &amp;a, &amp;c, &amp;b);  =>  a=10, b=2, c='/'\n\n3. 根据分解得到的运算符进行不同的运算\n    switch (c) {\n        case '/':\n            a / b;\n            break;\n        case '+':\n            a + b;\n            break;\n        ....\n    }\n\n4. 将运算结果拼接到表达式上，再将多个带有结果的运算表达式拼接成一个字符串，最后再写入到原文件中\n    char result[];  sprintf()/strcat()  =>  \"10/2=5\\n10*3=30\\n4+3=7\\n8-6=2\\n\"  =>  fputs(result, fp)\n</code></pre></div><p><strong>代码实现：</strong></p>\n<div><pre><code>step1：\n    准备一份未写入运算结果的文件 test08.txt\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day10/11.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>step2:\n    a. 按行读取 test08.txt 中的运算表达式；\n    b. 解析运算表达式，并计算结果；\n    c. 将计算结果拼接到运算表达式上 \n    d. 将多个带有结果的运算表达式拼接成一个字符串\n    e. 再将拼接得到的字符串写入到 test08.txt 文件\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day10/12.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>step3:\n    main 函数\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day10/13.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-21T05:58:47.000Z",
      "authors": [],
      "tags": [
        "C语言基础"
      ]
    },
    {
      "title": "第11天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day11.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day11.html",
      "content_html": "<h2 id=\"_1-fprintf-函数\" tabindex=\"-1\"> 1. <code>fprintf</code> 函数</h2>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>int</span> <span>fprintf</span><span>(</span>FILE <span>*</span> stream<span>,</span> <span>const</span> <span>char</span> <span>*</span> format<span>,</span> <span>.</span><span>.</span><span>.</span><span>)</span><span>;</span>\n\n    功能：根据参数 format 字符串来转换并格式化数据，然后将结果输出到 stream 指定的文件中，指定出现字符串结束符 <span>'\\0'</span>  为止。\n\n    参数：\n        stream：已经打开的文件\n        format：字符串格式，用法和 <span>printf</span><span>(</span><span>)</span> 一样\n\n    返回值：\n        成功：实际写入文件的字符个数\n        失败：<span>-</span><span>1</span>\n</code></pre></div><h2 id=\"_2-printf-sprintf-fprintf-对比\" tabindex=\"-1\"> 2. <code>printf</code>/<code>sprintf</code>/<code>fprintf</code> 对比</h2>\n<p><strong>1. 函数原型对比</strong></p>\n<div><pre><code><span>/* printf */</span>\n<span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>int</span> <span>printf</span><span>(</span><span>const</span> <span>char</span> <span>*</span><span>const</span> _Format<span>,</span> <span>.</span><span>.</span><span>.</span><span>)</span>\n\n<span>/* sprintf */</span>\n<span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>int</span> <span>sprintf</span><span>(</span><span>char</span> <span>*</span>str<span>,</span> <span>const</span> <span>char</span> <span>*</span>format<span>,</span> <span>.</span><span>.</span><span>.</span><span>)</span>\n\n<span>/* fprintf */</span>\n<span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>int</span> <span>fprintf</span><span>(</span>FILE <span>*</span> stream<span>,</span> <span>const</span> <span>char</span> <span>*</span> format<span>,</span> <span>.</span><span>.</span><span>.</span><span>)</span>\n</code></pre></div><div><pre><code>1. 三者都是变参函数：即形参列表最后都是 \"...\"，\n2. 三个函数的形参列表中，最后一个变参之前的固参，通常是格式描述串（可能包含格式匹配符）。\n</code></pre></div><p><strong>2. 输出位置对比</strong></p>\n<div><pre><code><span>/* printf 输出到屏幕  */</span>\n<span>printf</span><span>(</span><span>\"hello\"</span><span>)</span><span>;</span> <span>// 只有一个固参（未包含格式匹配符的格式描述串）</span>\n<span>printf</span><span>(</span><span>\"%s\"</span><span>,</span> <span>\"hello\"</span><span>)</span><span>;</span>\n<span>printf</span><span>(</span><span>\"ret = %d+%d\\n\"</span><span>,</span> <span>10</span><span>,</span> <span>5</span><span>)</span><span>;</span>\n<span>printf</span><span>(</span><span>\"%d = %d%c%d\\n\"</span><span>,</span> <span>10</span><span>+</span><span>5</span><span>,</span> <span>10</span><span>,</span> <span>'+'</span><span>,</span> <span>5</span><span>)</span><span>;</span>  \n\n<span>/* sprintf 输出到内存 buf 中 */</span>\n<span>char</span> buf<span>[</span><span>1024</span><span>]</span><span>;</span>   <span>//缓冲区  </span>\n<span>sprintf</span><span>(</span>buf<span>,</span> <span>\"%d = %d%c%d\\n\"</span><span>,</span> <span>10</span><span>+</span><span>5</span><span>,</span> <span>10</span><span>,</span> <span>'+'</span><span>,</span> <span>5</span><span>)</span><span>;</span> \n\n<span>/* fprintf 输出到磁盘文件中 */</span>\nFILE <span>*</span> fp <span>=</span> <span>fopen</span><span>(</span><span>)</span><span>;</span>\n<span>fprintf</span><span>(</span>fp<span>,</span> <span>\"%d = %d%c%d\\n\"</span><span>,</span> <span>10</span><span>+</span><span>5</span><span>,</span> <span>10</span><span>,</span> <span>'+'</span><span>,</span> <span>5</span><span>)</span><span>;</span>    \n</code></pre></div><h2 id=\"_3-fscanf-函数\" tabindex=\"-1\"> 3. <code>fscanf</code> 函数</h2>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>int</span> <span>fscanf</span><span>(</span>FILE <span>*</span> stream<span>,</span> <span>const</span> <span>char</span> <span>*</span> format<span>,</span> <span>.</span><span>.</span><span>.</span><span>)</span>\n    功能：从 stream 指定的文件读取字符串，并根据参数 format 字符串来转换并格式化数据。\n    参数：\n        stream：已经打开的文件\n        format：字符串格式，用法和 <span>scanf</span><span>(</span><span>)</span> 一样\n    返回值：\n        成功：参数数目，成功转换的值的个数\n        失败：<span>-</span><span>1</span>\n</code></pre></div><p><strong>示例1：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day11/01.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>示例2：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day11/02.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_4-scanf-sscanf-fscanf-对比\" tabindex=\"-1\"> 4. <code>scanf</code>/<code>sscanf</code>/<code>fscanf</code> 对比</h2>\n<p><strong>函数原型对比</strong></p>\n<div><pre><code><span>/* scanf */</span>\n<span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>int</span> <span>scanf</span><span>(</span><span>const</span> <span>char</span> <span>*</span><span>const</span> _Format<span>,</span> <span>.</span><span>.</span><span>.</span><span>)</span>\n\n<span>/* sscanf */</span>\n<span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>int</span> <span>sscanf</span><span>(</span><span>const</span> <span>char</span> <span>*</span>str<span>,</span> <span>const</span> <span>char</span> <span>*</span>format<span>,</span> <span>.</span><span>.</span><span>.</span><span>)</span>\n\n<span>/* fscanf */</span>\n<span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>int</span> <span>fscanf</span><span>(</span>FILE <span>*</span> stream<span>,</span> <span>const</span> <span>char</span> <span>*</span> format<span>,</span> <span>.</span><span>.</span><span>.</span><span>)</span>\n</code></pre></div><h2 id=\"_5-处理文本文件的函数-fgetc-fputc、fgets-fputs、fprintf-fscanf\" tabindex=\"-1\"> 5. 处理文本文件的函数：<code>fgetc</code>/<code>fputc</code>、<code>fgets</code>/<code>fputs</code>、<code>fprintf</code>/<code>fscanf</code></h2>\n<div><pre><code>fgetc/fputc\nfgets/fputs\nfprintf/fscanf \n</code></pre></div><h2 id=\"_6-处理二进制文件的函数-也可用来处理文本文件\" tabindex=\"-1\"> 6. 处理二进制文件的函数（也可用来处理文本文件）</h2>\n<h3 id=\"_6-1-以数据块的方式向文件中写入内容-fwrite\" tabindex=\"-1\"> 6.1 以数据块的方式向文件中写入内容：<code>fwrite</code></h3>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>size_t</span> <span>fwrite</span><span>(</span><span>const</span> <span>void</span> <span>*</span>ptr<span>,</span> <span>size_t</span> size<span>,</span> <span>size_t</span> nmemb<span>,</span> FILE <span>*</span>stream<span>)</span>\n    功能：以数据块的方式给文件写入内容\n    参数：\n        ptr：准备写入文件数据的地址\n        size： <span>size_t</span> 为 <span>unsigned</span> <span>int</span> 类型，此参数指定写入文件内容的块数据大小\n        nmemb：写入文件的块数，写入文件数据总大小为：size <span>*</span> nmemb\n        stream：已经打开的文件指针\n    返回值：\n        成功：实际成功写入文件数据的块数目，此值和 nmemb 相等\n        失败：<span>0</span>\n\n通常将参数 size 传 <span>1.</span> 将参数 nmemb 传实际写出字节数。依此可判断，当成功时，若返回值 <span>==</span> nmemb，说明数据写入成功。\n</code></pre></div><p><strong>示例：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day11/03.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong><code>fwrite</code> 写入数据时的注意事项</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day11/04.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_6-2-以数据块的方式从文件中读取内容-fread\" tabindex=\"-1\"> 6.2 以数据块的方式从文件中读取内容：<code>fread</code></h3>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>size_t</span> <span>fread</span><span>(</span><span>void</span> <span>*</span>ptr<span>,</span> <span>size_t</span> size<span>,</span> <span>size_t</span> nmemb<span>,</span> FILE <span>*</span>stream<span>)</span>\n    功能：以数据块的方式从文件中读取内容\n    参数：\n        ptr：存放读取出来数据的内存空间\n        size： <span>size_t</span> 为 <span>unsigned</span> <span>int</span> 类型，此参数指定读取文件内容的块数据大小\n        nmemb：读取文件的块数，读取文件数据总大小为：size <span>*</span> nmemb\n        stream：已经打开的文件指针\n    返回值：\n        成功：实际成功读取到内容的块数，如果此值比 nmemb 小，但大于 <span>0</span>，说明读到文件的结尾。\n        失败：<span>0</span>\n        <span>0</span><span>:</span> 表示读到文件结尾。【<span>feof</span><span>(</span><span>)</span>】\n\n通常将参数 size 传 <span>1.</span> 将参数 nmemb 传欲读出的字节数。\n</code></pre></div><p><strong>示例：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day11/05.png\" alt=\"\" loading=\"lazy\"></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day11/06.png\" alt=\"\" loading=\"lazy\"></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day11/07.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_6-3-案例-文件拷贝\" tabindex=\"-1\"> 6.3 案例：文件拷贝</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day11/08.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_7-文件随机读写\" tabindex=\"-1\"> 7. 文件随机读写</h2>\n<h3 id=\"_7-1-移动文件读写指针-fseek\" tabindex=\"-1\"> 7.1 移动文件读写指针：<code>fseek</code></h3>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>int</span> <span>fseek</span><span>(</span>FILE <span>*</span>stream<span>,</span> <span>long</span> offset<span>,</span> <span>int</span> whence<span>)</span><span>;</span>\n    参<span>1</span>：文件\n    参<span>2</span>：\n        偏移量（矢量，<span>+</span> 向后，<span>-</span> 向前）\n        根据 whence 来移动的位移数（偏移量），可以是正数，也可以负数，\n        如果是正数，则相对于 whence 向右（后）移动。如果向右（后）移动的字节数超过了文件末尾，再次写入时将增大文件尺寸；\n        如果是负数，则相对于 whence 向左（前）移动。如果向左（前）移动的字节数超过了文件开头，则返回失败。\n    参<span>3</span>：    \n        <span>SEEK_SET</span>：文件开头位置\n        <span>SEEK_CUR</span>：当前位置\n        <span>SEEK_END</span>：文件结尾位置\n    返回值： \n        成功： <span>0</span> \n        失败：<span>-</span><span>1</span>\n</code></pre></div><h3 id=\"_7-2-获取文件读写指针的位置-ftell\" tabindex=\"-1\"> 7.2 获取文件读写指针的位置：<code>ftell</code></h3>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>long</span> <span>ftell</span><span>(</span>FILE <span>*</span>stream<span>)</span><span>;</span>\n    返回：从文件当前读写位置到起始位置（文件开头）的偏移量。\n\n注意：可以借助 <span>ftell</span><span>(</span>fp<span>)</span> <span>+</span> <span>fseek</span><span>(</span>fp<span>,</span> <span>0</span><span>,</span> <span>SEEK_END</span><span>)</span><span>;</span> 来获取文件大小。\n</code></pre></div><h3 id=\"_7-3-将文件读写指针移动到文件开头-回卷-rewind\" tabindex=\"-1\"> 7.3 将文件读写指针移动到文件开头（回卷）：<code>rewind</code></h3>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>void</span> <span>rewind</span><span>(</span>FILE <span>*</span>stream<span>)</span><span>;</span>\n\n回卷文件读写指针。将读写指针移动到起始位置（文件开头）。\n</code></pre></div><h3 id=\"_7-4-示例-fseek、ftell、rewind-的使用-获取文件大小\" tabindex=\"-1\"> 7.4 示例：<code>fseek</code>、<code>ftell</code>、<code>rewind</code> 的使用 &amp; 获取文件大小</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day11/09.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_7-5-一个文件内只有一个文件读写指针\" tabindex=\"-1\"> 7.5 一个文件内只有一个文件读写指针</h3>\n<div><pre><code>在一个文件内只有一个文件读写指针，即文件读和写时所用到的指针是同一个。\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day11/10.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_8-linux-和-windows-文件区别\" tabindex=\"-1\"> 8. <code>Linux</code> 和 <code>windows</code> 文件区别</h2>\n<div><pre><code>1. 对于二进制文件操作，Windows 使用 \"b\"， Linux 下二进制和文本没区别。\n\n2. windows 下，回车 \\r，换行 \\n。 \\r\\n， Linux 回车换行 \\n\n\n3. 对文件指针，\n    先写后读。windows 和 Linux 效果一致。\n    先读后写。Linux 无需修改。windows 下需要在写操作之前添加 fseek(fp, 0, SEEK_CUR); 来获取文件读写指针，使之生效。\n</code></pre></div><p><strong>示例：<code>windows</code> 下先读后写的问题与解决方式</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day11/11.png\" alt=\"\" loading=\"lazy\"></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day11/12.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_9-获取文件状态属性信息-int-stat-const-char-path-struct-stat-buf\" tabindex=\"-1\"> 9. 获取文件状态属性信息：<code>int stat(const char *path, struct stat *buf)</code></h2>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;sys/types.h></span></span>\n<span><span>#</span><span>include</span> <span>&lt;sys/stat.h></span></span>\n<span>int</span> <span>stat</span><span>(</span><span>const</span> <span>char</span> <span>*</span>path<span>,</span> <span>struct</span> <span>stat</span> <span>*</span>buf<span>)</span><span>;</span>\n    功能：获取文件状态信息\n    参数：\n        path：文件路径名\n        buf：保存文件信息的结构体\n    返回值：\n        成功： <span>0</span>\n        失败：<span>-</span><span>1</span>\n</code></pre></div><p><strong>保存文件状态的结构体 <code>stat</code></strong></p>\n<div><pre><code><span>struct</span> <span>stat</span> <span>{</span>\n    <span>dev_t</span>         st_dev<span>;</span>       <span>// 文件的设备编号</span>\n    <span>ino_t</span>         st_ino<span>;</span>       <span>// 节点</span>\n    <span>mode_t</span>        st_mode<span>;</span>      <span>// 文件的类型和存取的权限</span>\n    <span>nlink_t</span>       st_nlink<span>;</span>     <span>// 连到该文件的硬连接数目，刚建立的文件值为1</span>\n    <span>uid_t</span>         st_uid<span>;</span>       <span>// 用户ID</span>\n    <span>gid_t</span>         st_gid<span>;</span>       <span>// 组ID</span>\n    <span>dev_t</span>         st_rdev<span>;</span>      <span>// (设备类型)若此文件为设备文件，则为其设备编号</span>\n    <span>off_t</span>         st_size<span>;</span>      <span>// 文件字节数(文件大小)</span>\n    <span>unsigned</span> <span>long</span> st_blksize<span>;</span>   <span>// 块大小(文件系统的I/O 缓冲区大小)</span>\n    <span>unsigned</span> <span>long</span> st_blocks<span>;</span>    <span>// 块数</span>\n    <span>time_t</span>        st_atime<span>;</span>     <span>// 最后一次访问时间</span>\n    <span>time_t</span>        st_mtime<span>;</span>     <span>// 最后一次修改时间</span>\n    <span>time_t</span>        st_ctime<span>;</span>     <span>// 最后一次改变时间(指属性)</span>\n<span>}</span><span>;</span>\n</code></pre></div><p><strong>示例：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day11/13.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_10-删除文件-remove\" tabindex=\"-1\"> 10. 删除文件：<code>remove</code></h2>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>int</span> <span>remove</span><span>(</span><span>const</span> <span>char</span> <span>*</span>pathname<span>)</span><span>;</span>\n    参数：\n        pathname：文件名\n    返回值：\n        成功： <span>0</span>\n        失败：<span>-</span><span>1</span>\n</code></pre></div><h2 id=\"_11-重命名文件-rename\" tabindex=\"-1\"> 11. 重命名文件：<code>rename</code></h2>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>int</span> <span>rename</span><span>(</span><span>const</span> <span>char</span> <span>*</span>oldpath<span>,</span> <span>const</span> <span>char</span> <span>*</span>newpath<span>)</span><span>;</span>\n    功能：把 oldpath 的文件名改为 newpath\n    参数：\n        oldpath：旧文件名\n        newpath：新文件名\n    返回值：\n        成功： <span>0</span>\n        失败：<span>-</span><span>1</span>\n</code></pre></div><h2 id=\"_12-文件缓冲区-预读入、缓输出\" tabindex=\"-1\"> 12. 文件缓冲区（预读入、缓输出）</h2>\n<div><pre><code>ANSI C 标准采用 “缓冲文件系统” 处理数据文件。\n所谓缓冲文件系统，是指系统自动地在内存区，为程序中每一个正在使用的文件开辟一个文件缓冲区，\n从内存向磁盘输出数据，必须先送到内存中的缓冲区，装满缓冲区后，才一起送到磁盘去。\n如果从磁盘向计算机读入数据，则一次从磁盘文件将一批数据输入到内存缓冲区（充满缓冲区），\n然后再从缓冲区逐个地将数据送到程序数据区（给程序变量）\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day11/14.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_12-1-缓冲区刷新-行缓冲、全缓冲、无缓冲、隐式回收\" tabindex=\"-1\"> 12.1 缓冲区刷新（行缓冲、全缓冲、无缓冲、隐式回收）</h3>\n<div><pre><code>标准输出 -- stdout文件（磁盘） -- 标准输出缓冲区（内存） \n    写给屏幕的数据，都是先存缓冲区中，由缓冲区一次性刷新到物理设备（屏幕）\n\n标准输入 -- stdin文件（磁盘） -- 标准输入缓冲区（内存）  \n    从键盘读取的数据，直接读到缓冲区中，由缓冲区给程序提供数据。\n</code></pre></div><div><pre><code>行缓冲：\n    如 printf(); \n    遇到 \\n 就会将缓冲区中的数据刷新到物理设备上。\n\n全缓冲：\n    如 文件。 \n    缓冲区存满，数据刷新到物理设备上。\n\n无缓冲：\n    如 perror。 \n    缓冲区中只要有数据，就立即刷新到物理设备。\n\n文件关闭时，缓冲区会被自动刷新。  \n\n程序终止后，进行隐式回收：\n1. 关闭文件；\n2. 刷新缓冲区；\n3. 释放 malloc。\n</code></pre></div><p><strong>示例：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day11/15.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_12-2-使用缓冲区的优势\" tabindex=\"-1\"> 12.2 使用缓冲区的优势</h3>\n<div><pre><code>1. 减少了对硬盘的读写次数，提高了硬盘的寿命；\n2. 缓冲区位于内存中，读写内存 较 读写硬盘 的效率更高，即提高了读写效率。\n</code></pre></div><h3 id=\"_12-3-手动刷新缓冲区-实时刷新-int-fflush-file-stream\" tabindex=\"-1\"> 12.3 手动刷新缓冲区（实时刷新）：<code>int fflush(FILE *stream);</code></h3>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>\n<span>int</span> <span>fflush</span><span>(</span>FILE <span>*</span>stream<span>)</span><span>;</span>\n    功能：刷新缓冲区，让缓冲区的数据立马写到文件中。\n    参数：\n        stream：文件指针\n    返回值：\n        成功： <span>0</span>\n        失败：<span>-</span><span>1</span>\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day11/16.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-21T05:58:47.000Z",
      "authors": [],
      "tags": [
        "C语言基础"
      ]
    },
    {
      "title": "第12天（贪吃蛇小游戏）",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day12.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day12.html",
      "content_html": "<h2 id=\"_1-修改控制台光标位置-setconsolecursorposition\" tabindex=\"-1\"> 1. 修改控制台光标位置：<code>SetConsoleCursorPosition</code></h2>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;conio.h></span>   <span>// conio --> console io ： 控制台 输入/输出</span></span>\n<span><span>#</span><span>include</span> <span>&lt;Windows.h></span></span>\nBOOL <span>SetConsoleCursorPosition</span><span>(</span>HANDLE hConsoleOutput<span>,</span> COORD dwCursorPosition<span>)</span>\n    作用： \n        在处理 hConsoleOutput 指定的输出类型之前（如处理标准输出 or 标准错误之前），将光标移动到位置 dwCursorPosition 处\n\n    参数：\n        HANDLE 类型： \n            指定控制台的处理对象（可以是标准输入 or 标准输出 or 标准错误）\n            可通过 GetStdHandle 函数指定 HANDLE\n                <span>GetStdHandle</span><span>(</span>STD_INPUT_HANDLE<span>)</span>  获取标准输入对应的 HANDLE\n                <span>GetStdHandle</span><span>(</span>STD_OUTPUT_HANDLE<span>)</span> 获取标准输出对应的 HANDLE\n                <span>GetStdHandle</span><span>(</span>STD_ERROR_HANDLE<span>)</span>  获取标准错误对应的 HANDLE\n        \n        COORD类型： \n            COORD 是 Windows API 中定义的一种结构，表示一个字符在控制台屏幕上的坐标\n                <span>typedef</span> <span>struct</span> <span>_COORD</span> <span>{</span>\n                    SHORT X<span>;</span>\n                    SHORT Y<span>;</span>\n                <span>}</span>COORD<span>;</span>\n\n    返回值：\n        BOOL 类型： <span>typedef</span> <span>int</span>   BOOL<span>;</span>\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day12/01.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_2-不回显地接收用户输入-getch\" tabindex=\"-1\"> 2. 不回显地接收用户输入：<code>getch</code></h2>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;conio.h></span></span>\n<span>int</span> <span>_getch</span><span>(</span><span>void</span><span>)</span>\n    功能：\n        从控制台无回显地接收一个键盘输入字符\n        所谓回显，就是如 getchar 函数那样，在接收到一个键盘输入字符后，还会把接收到的字符打印在控制台上显示出来。\n        而 _getch 函数仅接收键盘输入的字符，并不会打印显示到控制台上。\n\n    用法：\n        <span>char</span> key <span>=</span> <span>_getch</span><span>(</span><span>)</span><span>;</span>\n\n    返回值：\n        读取的字符 ASCII 码\n\n注意：如果调用 <span>getch</span><span>(</span><span>)</span> 编译时出错，尝试使用 <span>_getch</span><span>(</span><span>)</span><span>;</span>\n</code></pre></div><h2 id=\"_3-以非阻塞方式检查当前是否有键盘输入-kbhit\" tabindex=\"-1\"> 3. 以非阻塞方式检查当前是否有键盘输入：<code>kbhit</code></h2>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;conio.h></span></span>\n<span>int</span> <span>_kbhit</span><span>(</span><span>void</span><span>)</span>\n    功能：\n        非阻塞地判断用户输入。\n        如 scanf 或 getchar 函数调用时，会阻塞并等待用户输入；\n        而通过 _kbhit 结合 _getch 或 getchar 函数，可实现非阻塞地接收用户输入：\n            <span>if</span><span>(</span><span>_kbhit</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                <span>char</span> ch <span>=</span> <span>_getch</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n\n    返回值：\n        有用户输入，返回 “真”，\n        否则返回 “假”。\n\n注意：如果调用 <span>kbhit</span><span>(</span><span>)</span> 编译时出错，尝试使用 <span>_kbhit</span><span>(</span><span>)</span><span>;</span>\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day12/02.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_4-设置控制台光标属性-setconsolecursorinfo\" tabindex=\"-1\"> 4. 设置控制台光标属性：<code>SetConsoleCursorInfo</code></h2>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;conio.h></span></span>\n<span><span>#</span><span>include</span> <span>&lt;Windows.h></span></span>\nBOOL <span>SetConsoleCursorInfo</span><span>(</span>HANDLE hConsoleOutput<span>,</span> <span>const</span> CONSOLE_CURSOR_INFO <span>*</span>lpConsoleCursorInfo<span>)</span>\n    作用：\n        在处理 hConsoleOutput 指定的输出类型之前（如处理标准输出 or 标准错误之前），设置光标属性信息\n\n    参数：\n        HANDLE 类型：\n            指定控制台的处理对象（可以是标准输入 or 标准输出 or 标准错误）\n            可通过 GetStdHandle 函数指定 HANDLE\n                <span>GetStdHandle</span><span>(</span>STD_INPUT_HANDLE<span>)</span>  获取标准输入对应的 HANDLE\n                <span>GetStdHandle</span><span>(</span>STD_OUTPUT_HANDLE<span>)</span> 获取标准输出对应的 HANDLE\n                <span>GetStdHandle</span><span>(</span>STD_ERROR_HANDLE<span>)</span>  获取标准错误对应的 HANDLE\n        \n        CONSOLE_CURSOR_INFO 类型：\n            CONSOLE_CURSOR_INFO 描述终端光标信息\n                <span>typedef</span> <span>struct</span> <span>_CONSOLE_CURSOR_INFO</span> <span>{</span>\n                    DWORD  dwSize<span>;</span> <span>// 光标大小</span>\n                    BOOL   bVisible<span>;</span> <span>// 光标是否可见</span>\n                <span>}</span> CONSOLE_CURSOR_INFO<span>;</span>\n\n    返回值：\n        BOOL 类型： <span>typedef</span> <span>int</span>   BOOL<span>;</span>\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day12/03.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_5-参考源码\" tabindex=\"-1\"> 5. 参考源码</h2>\n<p><a href=\"https://github.com/zengkaiqiang562/JavaGuide-Demo/blob/main/docs/zkq/c_and_cpp/_1_c-basic/%E8%B4%AA%E5%90%83%E8%9B%87%E5%B0%8F%E6%B8%B8%E6%88%8F/snake.h\" target=\"_blank\" rel=\"noopener noreferrer\">贪吃蛇小游戏<ExternalLinkIcon/></a></p>\n",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-21T08:28:13.000Z",
      "authors": [],
      "tags": [
        "C语言基础"
      ]
    },
    {
      "title": "第13天（Linux系统入门）",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day13.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_1_c-basic/day13.html",
      "content_html": "<h2 id=\"_1-linux-内核版本\" tabindex=\"-1\"> 1. <code>Linux</code> 内核版本</h2>\n<h3 id=\"_1-1-什么是内核\" tabindex=\"-1\"> 1.1 什么是内核</h3>\n<p>内核（<code>kernel</code>）是系统的心脏，是运行程序和管理像磁盘和打印机等硬件设备的核心程序，它提供了一个在裸设备与应用程序间的抽象层。</p>\n<p>可以把内核简单地理解为：<strong>除去应用程序之外的操作系统</strong>。</p>\n<h3 id=\"_1-2-内核源码网址-http-www-kernel-org\" tabindex=\"-1\"> 1.2 内核源码网址：<code>http://www.kernel.org</code></h3>\n<p>内核源码网址是 <a href=\"http://www.kernel.org\" target=\"_blank\" rel=\"noopener noreferrer\">http://www.kernel.org<ExternalLinkIcon/></a>，所有来自全世界的对 <code>Linux</code> 源码的修改最终都会汇总到这个网站。然后由 <code>Linus</code> 领导的开源社区对其进行甄别和修改最终决定是否进入到 <code>Linux</code> 主线内核源码中。</p>\n<h3 id=\"_1-3-内核版本分类\" tabindex=\"-1\"> 1.3 内核版本分类</h3>\n<h4 id=\"_1-3-1-稳定版-ubuntu-xx-04-测试版-ubuntu-xx-10\" tabindex=\"-1\"> 1.3.1 稳定版（<code>Ubuntu-XX.04</code>）&amp; 测试版（<code>Ubuntu-XX.10</code>）</h4>\n<p><code>Linux</code> 内核版本分为稳定版和开发版：</p>\n<ol>\n<li>\n<p>4月份发布的版本是稳定版，如 <code>Ubuntu-14.04</code></p>\n</li>\n<li>\n<p>10月份发布的版本是测试版，如 <code>Ubuntu-14.10</code></p>\n</li>\n</ol>\n<h4 id=\"_1-3-2-长期支持版-ubuntu-双数-xx-短期支持版-ubuntu-单数-xx\" tabindex=\"-1\"> 1.3.2 长期支持版(<code>Ubuntu-双数-XX</code>) &amp; 短期支持版(<code>Ubuntu-单数-XX</code>)</h4>\n<p>从 <code>Ubuntu-10</code> 开始，区分双数版本和单数版本：</p>\n<ol>\n<li>\n<p>双数版本，如 <code>Ubuntu-14</code> 为长期支持版本，即系统中的软件服务的有效期是3年（2016起为5年）</p>\n</li>\n<li>\n<p>而单数版本，如 <code>Ubuntu-13</code> 为短期支持版本，即系统中的软件服务的有效期是1年</p>\n</li>\n</ol>\n<h4 id=\"_1-3-2-推荐使用版本-长期支持的稳定版-ubunt-双数-04\" tabindex=\"-1\"> 1.3.2 推荐使用版本：长期支持的稳定版（<code>Ubunt-双数.04</code>）</h4>\n<p>作为普通用户下载 <code>Linux</code> 操作系统时，最好下载4月份版本的双数版本。</p>\n<h2 id=\"_2-linux-目录结构\" tabindex=\"-1\"> 2. <code>Linux</code> 目录结构</h2>\n<h3 id=\"_2-1-根目录\" tabindex=\"-1\"> 2.1 根目录：<code>/</code></h3>\n<div><pre><code>根目录，一般根目录下只存放目录，在 Linux 下有且只有一个根目录。\n</code></pre></div><h3 id=\"_2-2-放置可执行文件的目录-bin、-usr-bin\" tabindex=\"-1\"> 2.2 放置可执行文件的目录：<code>/bin</code>、<code>/usr/bin</code></h3>\n<div><pre><code>可执行二进制文件的目录，\n如常用的命令文件 ls、tar、mv、cat 等。\n</code></pre></div><h3 id=\"_2-3-放置系统启动相关文件的目录-boot\" tabindex=\"-1\"> 2.3 放置系统启动相关文件的目录：<code>/boot</code></h3>\n<div><pre><code>放置 linux 系统启动时用到的一些文件，\n如:\n    Linux 的内核文件：/boot/vmlinuz\n    系统引导管理器：/boot/grub\n</code></pre></div><h3 id=\"_2-4-放置设备文件的目录-dev\" tabindex=\"-1\"> 2.4 放置设备文件的目录：<code>/dev</code></h3>\n<div><pre><code>存放 linux 系统下的设备文件，访问该目录下某个文件，相当于访问某个设备。\n常用的是挂载光驱：\n    如执行命令 \"mount /dev/cdrom /mnt\" \n    将 /dev/cdrom 表示的光驱设备挂载到目录 /mnt 上，于是，访问目录 /mnt 即访问光驱内容\n</code></pre></div><h3 id=\"_2-5-放置配置文件的目录-etc\" tabindex=\"-1\"> 2.5 放置配置文件的目录：<code>/etc</code></h3>\n<div><pre><code>系统配置文件存放的目录，\n不建议在此目录下存放可执行文件，\n重要的配置文件有:\n    /etc/inittab、\n    /etc/fstab、\n    /etc/init.d、\n    /etc/X11、\n    /etc/sysconfig、\n    /etc/xinetd.d\n\n安装的应用程序的配置文件也是放在该目录下的。\n</code></pre></div><h3 id=\"_2-6-放置函数库文件的目录-lib、-usr-lib、-usr-local-lib\" tabindex=\"-1\"> 2.6 放置函数库文件的目录：<code>/lib</code>、<code>/usr/lib</code>、<code>/usr/local/lib</code></h3>\n<div><pre><code>系统使用的函数库的目录。\n程序在执行过程中，需要调用一些额外的参数时，需要函数库的协助。\n</code></pre></div><h3 id=\"_2-7-放置系统异常时遗失的片段-lost-fount\" tabindex=\"-1\"> 2.7 放置系统异常时遗失的片段：<code>/lost+fount</code></h3>\n<div><pre><code>系统异常产生错误时，会将一些遗失的片段放置于此目录下。\n</code></pre></div><h3 id=\"_2-8-挂载目录-mnt、-media\" tabindex=\"-1\"> 2.8 挂载目录：<code>/mnt</code>、<code>/media</code></h3>\n<div><pre><code>光盘默认挂载点，通常光盘挂载于 /mnt/cdrom 下。（也不一定，可以选择任意位置进行挂载）\n\n\"/mnt\", \"/media\", \"/dev\" 三者的区别:\n\n1. /mnt 是被系统管理员使用，手动挂载一些临时媒体设备的目录。\n\n2. /media 是自动挂载的目录。\n   比如我们的 U 盘插在 ubuntu 下时会自动挂载。即会在 /media 下生成一个目录，这个目录就是 U 盘所在目录（或者说文件）\n\n3. /dev 不是存放设备的驱动程序，而是作为访问外部设备文件的接口。\n   比如，我们的 U 盘插入到 linux 系统后，执行 \"fdisk -l\" 查看分区，显示文件为 /dev/sda1，\n   此时，若我们要将 u 盘挂载到 /mnt/usb1 下，执行 \"mount /dev/sda1 /mnt/usb1\" 即可。\n</code></pre></div><h3 id=\"_2-9-第三方软件的安装目录-opt\" tabindex=\"-1\"> 2.9 第三方软件的安装目录：<code>/opt</code></h3>\n<div><pre><code>给主机额外安装软件所摆放的目录。如作为 QQ、迅雷 等第三方应用程序的安装目录。\n</code></pre></div><h3 id=\"_2-10-放置内存中数据的目录-proc\" tabindex=\"-1\"> 2.10 放置内存中数据的目录：<code>/proc</code></h3>\n<div><pre><code>此目录的数据都在内存中，如系统核心，外部设备，网络状态。（由于数据都存放于内存中，所以不占用磁盘空间）\n进程相关的数据都存放在该目录下。\n\n比较重要的目录有：\n/proc/cpuinfo\n/proc/interrupts\n/proc/dma\n/proc/ioports\n/proc/net/* \n</code></pre></div><h3 id=\"_2-11-root-用户的家目录-root\" tabindex=\"-1\"> 2.11 <code>root</code> 用户的家目录：<code>/root</code></h3>\n<div><pre><code>系统管理员 root 的家目录（家目录的学名为：宿主目录）\n</code></pre></div><h3 id=\"_2-12-放置-root-用户使用的可执行文件-sbin、-usr-sbin、-usr-local-sbin\" tabindex=\"-1\"> 2.12 放置 <code>root</code> 用户使用的可执行文件：<code>/sbin</code>、<code>/usr/sbin</code>、<code>/usr/local/sbin</code></h3>\n<div><pre><code>放置系统管理员使用的可执行命令，如 fdisk、shutdown、mount 等。\n与 /bin 不同的是，这几个目录是给系统管理员 root 使用的命令，一般用户只能 \"查看\"，而不能设置和使用。\n</code></pre></div><h3 id=\"_2-13-放置临时文件的目录-tmp\" tabindex=\"-1\"> 2.13 放置临时文件的目录：<code>/tmp</code></h3>\n<div><pre><code>给一般用户或正在执行的程序，临时存放文件的目录。\n任何人都可以访问；\n重要数据不可放置在此目录下。\n</code></pre></div><h3 id=\"_2-14-放置服务启动后所访问数据的目录-srv\" tabindex=\"-1\"> 2.14 放置服务启动后所访问数据的目录：<code>/srv</code></h3>\n<div><pre><code>服务启动之后需要访问的数据目录。\n如 www 服务需要访问的网页数据存放在 /srv/www 内。\n</code></pre></div><h3 id=\"_2-15-应用程序存放目录-usr-unix-software-resource\" tabindex=\"-1\"> 2.15 应用程序存放目录：<code>/usr</code>（<code>unix software resource</code>）</h3>\n<div><pre><code>unix software resource：Unix软件系统资源目录，即应用程序存放目录。其中：\n\n/usr/bin：存放应用程序，\n/usr/share：存放共享数据，\n/usr/lib：存放不能直接运行的，却是许多程序运行所必需的一些函数库文件。\n/usr/local：存放软件升级包。\n/usr/share/doc：系统说明文件存放目录。\n/usr/share/man：程序说明文件存放目录\n/user/include：存放头文件\n    \n如：\n头文件 stdio.h 源码存放在 /usr/include 目录下；\n头文件 stdio.h 所生成的库文件 libc.so 存放在 /usr/lib/x86_64-linux-gnu 目录下。\n</code></pre></div><h3 id=\"_2-16-放置系统执行时变化数据的目录-var\" tabindex=\"-1\"> 2.16 放置系统执行时变化数据的目录：<code>/var</code></h3>\n<div><pre><code>放置系统执行过程中经常变化的文件，如：\n/var/log：随时更改的日志文件，\n/var/log/message：所有的登录文件存放目录，\n/var/spool/mail：邮件存放的目录，\n/var/run：程序或服务启动后，其 PID 存放在该目录下。\n</code></pre></div><h2 id=\"_3-linux-文件分类\" tabindex=\"-1\"> 3. <code>Linux</code> 文件分类</h2>\n<p>通常，<code>Unix/Linux</code> 系统中常用的文件类型有 <code>7</code> 种：</p>\n<div><pre><code>普通文件\n目录文件\n套接字文件\n管道文件\n软链接文件\n字符设备文件\n块设备文件\n\n其中，字符设备文件和块设备文件统称为设备文件。\n</code></pre></div><p>形如 <code>crw-rw----</code> 中的第1个字符用于文件分类：</p>\n<div><pre><code>- 表示普通文件\nd 表示目录文件\ns 表示套接字文件（多用于进程间的通信）\np 表示管道文件（通过命令 mkfifo 可创建管道文件）\nl 表示软链接文件（相当于 windows 中的快捷方式）\nc 表示字符设备文件（字符设备的存取以一个字符为单位）\nb 表示块设备文件（块设备的存取以字符块为单位）\n</code></pre></div><p><strong>示例：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day13/01.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>如上图，标准输入文件 <code>stdin</code>、 标准输出文件 <code>stdout</code>、 标准错误文件 <code>stderr</code> 都是软链接文件。</p>\n</blockquote>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day13/02.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>如上图，文件 <code>log</code> 是套接字文件。套接字文件可用于网络通信。</p>\n</blockquote>\n<h2 id=\"_4-查看帮助文档\" tabindex=\"-1\"> 4. 查看帮助文档</h2>\n<h3 id=\"_4-1-通过选项-help-查看帮助文档\" tabindex=\"-1\"> 4.1 通过选项 <code>--help</code> 查看帮助文档</h3>\n<div><pre><code>执行 \"命令名 --help\" 可以查看大部分 Linux 命令自带的帮助信息，但是并不是所有命令都自带这个选项。\n如我们想查看命令 ls 的用法：ls --help\n</code></pre></div><h3 id=\"_4-2-通过命令-man-查看帮助文档\" tabindex=\"-1\"> 4.2 通过命令 <code>man</code> 查看帮助文档</h3>\n<div><pre><code>man 是 Linux 提供的一个手册，包含了绝大部分的命令、函数使用说明。\n\n该手册分成很多章节（section），使用 man 时可以指定不同的章节来浏览不同的内容。\n\nman 中各个 section 意义如下：\n    1. Standard commands（标准命令）\n    2. System calls（系统调用，如 open、write）\n    3. Library functions（库函数，如 printf、fopen）\n    4. Special devices（设备文件的说明，/dev 下各种设备）\n    5. File formats（文件格式，如 passwd）\n    6. Games and toys（游戏和娱乐）\n    7. Miscellaneous（杂项、惯例与协定等，例如 Linux 档案系统、网络协定、ASCII 码；environ 全局变量）\n    8. Administrative Commands（管理员命令，如 ifconfig）\n\n执行命令 \"man man\" 可以查看 man 手册的使用说明\n\n执行命令 \"man ls\" 可以查看命令 ls 的使用说明\n（相当于执行 \"man 1 ls\"，其中 1 表示：指定在 man 手册的第1章内查找 ls 命令的使用说明 ）\n\n执行命令 \"man 3 printf\" 可以查看 man手册第3章 中 库函数 printf 的使用说明\n</code></pre></div><h2 id=\"_5-通配符-与\" tabindex=\"-1\"> 5. 通配符 <code>*</code> 与 <code>?</code></h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day13/03.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>如上图：\n* 通配 多个 字符\n? 通配 1个 字符\n</code></pre></div><h2 id=\"_6-输出重定向-与\" tabindex=\"-1\"> 6. 输出重定向 <code>&gt;</code> 与 <code>&gt;&gt;</code></h2>\n<p><code>Linux</code> 允许将命令执行结果重定向到一个文件，本应显示在终端上的内容保存到指定文件中，如：</p>\n<div><pre><code><span># test.txt 如果不存在，则创建，存在则覆盖其内容</span>\n<span>ls</span> <span>></span> test.txt\n</code></pre></div><div><pre><code>输出重定向 \">\" 会覆盖原来的内容， \n输出重定向 \">>\" 则会追加到文件的尾部。\n</code></pre></div><h2 id=\"_7-查看或者合并文件内容-cat\" tabindex=\"-1\"> 7. 查看或者合并文件内容：<code>cat</code></h2>\n<p><img src=\"@source/zkq/c_and_cpp/_1_c-basic/images/day13/04.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_8-拷贝文件-cp\" tabindex=\"-1\"> 8. 拷贝文件：<code>cp</code></h2>\n<div><pre><code>-a\n    该选项通常在复制目录时使用，\n    它保留链接、文件属性，并递归地复制目录，\n    简单而言，保持文件原有属性。\n-f\n    覆盖已经存在的目标文件而不提示\n-i\n    交互式复制，在覆盖目标文件之前将给出提示要求用户确认\n-r\n    若给出的源文件是目录文件，则 cp 将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名。\n-v\n    显示拷贝进度\n</code></pre></div><h2 id=\"_9-移动或重命名文件-mv\" tabindex=\"-1\"> 9. 移动或重命名文件：<code>mv</code></h2>\n<div><pre><code>可以使用 mv 命令来移动文件或目录；也可以重命名文件或目录。\n</code></pre></div><h2 id=\"_10-获取文件类型-file\" tabindex=\"-1\"> 10. 获取文件类型：<code>file</code></h2>\n<div><pre><code>Linux 系统文件类型不是根据文件扩展名分类的，通过 file 命令可以确认文件具体类型。\n</code></pre></div>",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-21T08:28:13.000Z",
      "authors": [],
      "tags": [
        "C语言基础"
      ]
    },
    {
      "title": "第01天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_2_c-advance/day01.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_2_c-advance/day01.html",
      "content_html": "<h2 id=\"_1-理解数据类型-固定大小内存的别名\" tabindex=\"-1\"> 1. 理解数据类型（固定大小内存的别名）</h2>\n<div><pre><code>1. 数据类型是为了更好进行内存的管理，让编译器能确定分配多少内存；\n2. 类型是对数据的抽象；\n3. 类型相同的数据具有相同的表示形式、存储格式以及相关操作；\n4. 程序中所有的数据都必定属于某种数据类型；\n5. 数据类型可以理解为创建变量的模具：固定大小内存的别名。\n</code></pre></div><h2 id=\"_2-typedef-的作用\" tabindex=\"-1\"> 2. <code>typedef</code> 的作用</h2>\n<p><code>typedef</code> 的作用：</p>\n<div><pre><code>1. 简化 struct 关键字\n2. 区分数据类型\n3. 提高移植性\n</code></pre></div><h3 id=\"_2-1-简化-struct-关键字\" tabindex=\"-1\"> 2.1 简化 <code>struct</code> 关键字</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/01.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>如上图，使用 <code>typedef</code> 可以简化 <code>struct</code> 关键字。</p>\n</blockquote>\n<h3 id=\"_2-2-更方便地区分数据类型\" tabindex=\"-1\"> 2.2 更方便地区分数据类型</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/02.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>如上图，使用 <code>typedef</code> 可以更方便地区分数据类型。</p>\n</blockquote>\n<h3 id=\"_2-3-提高可移植性\" tabindex=\"-1\"> 2.3 提高可移植性</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/03.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>如上图，若以后想将 int 类型替换为 long 类型，那么只需将 \"typedef int  MYINT;\" 修改为 \"typedef long  MYINT;\" 即可，\n而不需要挨个去查找 int 类型的变量进行修改，从而提高了可移植性。\n</code></pre></div><h2 id=\"_3-void-无类型-的使用\" tabindex=\"-1\"> 3. <code>void</code>（无类型）的使用</h2>\n<h3 id=\"_3-1-不能通过-void-无类型-创建变量\" tabindex=\"-1\"> 3.1 不能通过 void（无类型）创建变量</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/04.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_3-2-void-的使用场景-限定函数的返回值或参数\" tabindex=\"-1\"> 3.2 <code>void</code> 的使用场景：限定函数的返回值或参数</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/05.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_3-3-万能指针-void\" tabindex=\"-1\"> 3.3 万能指针：<code>void *</code></h3>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/06.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_4-sizeof-的使用\" tabindex=\"-1\"> 4. <code>sizeof</code> 的使用</h2>\n<h3 id=\"_4-1-sizeof-是一个操作符-不是函数\" tabindex=\"-1\"> 4.1 <code>sizeof</code> 是一个操作符，不是函数</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/07.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_4-2-sizeof-的返回值类型-unsigned-int-无符号整型\" tabindex=\"-1\"> 4.2 <code>sizeof</code> 的返回值类型：<code>unsigned int</code>（无符号整型）</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/08.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_4-3-sizeof-统计数组长度时的注意事项\" tabindex=\"-1\"> 4.3 <code>sizeof</code> 统计数组长度时的注意事项</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/09.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_5-变量-既能读又能写的内存对象\" tabindex=\"-1\"> 5. 变量（既能读又能写的内存对象）</h2>\n<p>既能读又能写的内存对象，称为变量。</p>\n<p>变量名的本质：一段连续内存空间的别名。</p>\n<div><pre><code>a. 程序通过变量来申请和命名内存空间 int a = 0；\nb. 通过变量名访问内存空间；\nc. 不是向变量名读写数据，而是向变量所代表的内存空间中读写数据\n</code></pre></div><h3 id=\"_5-1-变量的修改方式-直接修改-间接修改-通过指针修改\" tabindex=\"-1\"> 5.1 变量的修改方式：直接修改 &amp; 间接修改（通过指针修改）</h3>\n<p><strong>示例1：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/10.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>示例2：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/11.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_6-内存分区\" tabindex=\"-1\"> 6. 内存分区</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/12.png\" alt=\"\" loading=\"lazy\"></p>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/13.png\" alt=\"\" loading=\"lazy\"></p>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/14.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_6-1-运行前的分区-代码区、数据区、未初始化数据区\" tabindex=\"-1\"> 6.1 运行前的分区（代码区、数据区、未初始化数据区）</h3>\n<div><pre><code>在没有运行程序前，也就是说程序没有加载到内存前，可执行程序内部已经分好 3 段信息，分别为：\n1. 代码区（text）\n2. 数据区（data）\n3. 未初始化数据区（bss）\n\n有些人直接把 data 和 bss 合起来叫做静态区或全局区。\n\n代码区特点：共享、只读。\n\n疑问：常量是存放在 data 段，还是 rodata 段，或者是可以有条件地选择存放在二者之一中？\n</code></pre></div><h3 id=\"_6-2-运行后的分区-增加了栈区、堆区\" tabindex=\"-1\"> 6.2 运行后的分区（增加了栈区、堆区）</h3>\n<div><pre><code>程序在加载到内存前，代码区和全局区（data 和 bss）的大小就是固定的，程序运行期间不能改变。\n然后，运行可执行程序，操作系统把物理硬盘程序 load（加载）到内存。\n除了根据可执行程序的信息分出代码区（text）、数据区（data）和未初始化数据区（bss）之外，还额外增加了栈区、堆区。\n</code></pre></div><h3 id=\"_6-3-栈区的注意事项\" tabindex=\"-1\"> 6.3 栈区的注意事项</h3>\n<p><strong>调用函数时，不要返回局部变量的地址</strong>，因为栈中的局部变量在函数执行完毕后就被释放了。</p>\n<div><pre><code>这里说的局部变量的地址，指的是栈空间中的地址。\n如果该局部变量是一个指向堆空间地址的指针（malloc），那么只要函数执行完毕后没有 free，\n就可以返回该局部变量的值（即指针变量的内容，而不是指针变量的地址）\n</code></pre></div><h3 id=\"_6-4-堆区分配内存的注意事项\" tabindex=\"-1\"> 6.4 堆区分配内存的注意事项</h3>\n<p><strong>示例1：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/15.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>示例2：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/16.png\" alt=\"\" loading=\"lazy\"></p>\n<p>如上代码所示，若主调函数（<code>test02</code>）中没有分配内存，被调函数（<code>allocateSpace02</code>）需要 <strong>用更高级的指针去操作低级指针</strong>，进行分配内存。</p>\n<h2 id=\"_7-static-和-extern\" tabindex=\"-1\"> 7. <code>static</code> 和 <code>extern</code></h2>\n<h3 id=\"_7-1-static-修饰局部变量-只改变生命周期-不改变作用域\" tabindex=\"-1\"> 7.1 <code>static</code> 修饰局部变量（只改变生命周期，不改变作用域）</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/17.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_7-2-extern-在声明局部变量时的作用\" tabindex=\"-1\"> 7.2 <code>extern</code> 在声明局部变量时的作用</h3>\n<div><pre><code>如下代码所示：\n定义全局变量时，默认都隐式地添加了关键字 extern。表示当前文件中定义的全局变量可以被其他文件访问到。\n当其他文件中需要访问当前文件中定义的全局变量时，还需要先通过 extern 关键字声明变量，将全局变量的作用域 \"扩展\" 到当前文件中来。\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/18.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>如下代码所示：\n如果使用 extern 关键字声明变量时，在其他文件中未找到同名的全局变量，那么程序报错。\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/19.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_7-3-static-修饰全局变量-不能被其他文件访问到\" tabindex=\"-1\"> 7.3 <code>static</code> 修饰全局变量（不能被其他文件访问到）</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/20.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_8-常量\" tabindex=\"-1\"> 8. 常量</h2>\n<h3 id=\"_8-1-const-修饰的全局变量-保存在常量区-不可以间接修改\" tabindex=\"-1\"> 8.1 <code>const</code> 修饰的全局变量（保存在常量区，不可以间接修改）</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/21.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_8-2-const-修改的局部变量-仍然保存在栈中-可以间接修改\" tabindex=\"-1\"> 8.2 <code>const</code> 修改的局部变量（仍然保存在栈中，可以间接修改）</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/22.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_8-3-字符串常量\" tabindex=\"-1\"> 8.3 字符串常量</h3>\n<p><strong>示例1：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/23.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>示例2：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day01/24.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>注意：</strong></p>\n<div><pre><code>ANSI C（即 C89）标准并没有制定出字符串常量是否可以修改的标准，\n根据编译器不同，可能最终结果也是不同的。所以，尽量不要去修改字符串常量！\n</code></pre></div>",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-22T09:23:59.000Z",
      "authors": [],
      "tags": [
        "C高级编程"
      ]
    },
    {
      "title": "第02天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_2_c-advance/day02.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_2_c-advance/day02.html",
      "content_html": "<h2 id=\"_1-宏函数\" tabindex=\"-1\"> 1. 宏函数</h2>\n<div><pre><code>如下代码所示， MYADD 称为宏函数。\n\n宏函数的特点：\n1. 宏函数需要加小括号修饰，保证运算的完整性；\n2. 通常会将频繁、短小的函数写成宏函数；\n3. 宏函数会比普通函数在一定程度上效率高，因为省去了普通函数入栈、出栈时间上的开销。\n\n宏函数的优点可总结为：以空间换时间。\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day02/01.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>以上代码表示：宏函数需要加小括号修饰，以保证运算的完整性。</p>\n</blockquote>\n<h2 id=\"_2-栈-stack\" tabindex=\"-1\"> 2. 栈（<code>stack</code>）</h2>\n<p>栈（<code>stack</code>）是现代计算机程序里最为重要的概念之一，几乎每一个程序都使用了栈，<strong>没有栈就没有函数，没有局部变量</strong>。</p>\n<p>在经典的计算机科学中，栈被定义为一个特殊的容器，用户可以将数据压入栈中（入栈，或称为压栈，<code>push</code>），也可以将压入栈中的数据弹出（出栈，<code>pop</code>）。但是栈容器必须遵循一条规则：先入栈的数据最后出栈（<code>First In Last Out，FILO</code>）</p>\n<p><strong>注意：</strong></p>\n<div><pre><code>在经典的操作系统中，栈总是向下增长的。即：压栈的操作使得栈顶的地址减小，出栈操作使得栈顶地址增大。\n</code></pre></div><h2 id=\"_3-栈帧\" tabindex=\"-1\"> 3. 栈帧</h2>\n<p>栈中保存了一个函数调用所需要维护的信息，这通常被称为 <strong>栈帧（<code>Stack Frame</code>）</strong> 或者 <strong>活动记录（<code>Activate Record</code>）</strong>。</p>\n<h3 id=\"_3-1-栈帧中保存信息-即-函数调用过程所需的信息\" tabindex=\"-1\"> 3.1 栈帧中保存信息（即：函数调用过程所需的信息）</h3>\n<p>一个函数调用过程所需要的信息一般包括以下几个方面（即栈帧中保存的信息如下）：</p>\n<div><pre><code>1. 函数的返回地址；\n2. 函数的参数；\n3. 临时变量；\n4. 保存的上下文：包括在函数调用前后需要保持不变的寄存器。\n</code></pre></div><h2 id=\"_4-调用惯例-calling-convention\" tabindex=\"-1\"> 4. 调用惯例（<code>Calling Convention</code>）</h2>\n<h3 id=\"_4-1-什么是调用惯例\" tabindex=\"-1\"> 4.1 什么是调用惯例</h3>\n<p><strong>主调函数</strong> 和 <strong>被调函数</strong> 在函数调用时必须要有一致约定，才能正确的调用函数，这个约定我们称为 <strong>调用惯例（<code>Calling Convention</code>）</strong>。例如：</p>\n<div><pre><code>它们双方都一致的认为函数的参数是按照某个固定的方式压入栈中。如果不这样的话，函数将无法正确运行，即：\n如果主调函数（函数调用方）在传递参数的时候先压入参数 a，再压入参数 b，而被调函数则认为先压入的是 b，后压入的是 a，\n那么被调函数在使用 a，b 值时候，就会颠倒。\n</code></pre></div><h3 id=\"_4-2-调用惯例的规定内容\" tabindex=\"-1\"> 4.2 调用惯例的规定内容</h3>\n<h4 id=\"_4-2-1-函数参数的传递方式和传递顺序\" tabindex=\"-1\"> 4.2.1 函数参数的传递方式和传递顺序</h4>\n<p><strong>函数参数的传递方式</strong></p>\n<div><pre><code>函数参数的传递有很多种方式：\n1. 最常见的是通过栈传递，即：主调函数（函数调用方）将参数压入栈中，被调函数（函数自己）再从栈中将参数取出。\n2. 另外，有些调用惯例还允许使用寄存器传递参数，以提高性能。\n</code></pre></div><p><strong>函数参数的传递顺序</strong></p>\n<div><pre><code>对于有多个参数的函数，调用惯例还需要规定主调函数（函数调用方）将参数压栈的顺序：从左向右 or 从右向左。\n</code></pre></div><p>以上，调用惯例需要规定：</p>\n<div><pre><code>1. 函数参数是通过栈传递，还是通过寄存器传递；\n2. 以及当存在多个参数时，需要规定对参数列表的压栈顺序是从左向右，还是从右向左。\n</code></pre></div><h4 id=\"_4-2-2-栈的维护方式\" tabindex=\"-1\"> 4.2.2 栈的维护方式</h4>\n<div><pre><code>在主调函数将参数压入栈中之后，（被调函数的）函数体会被调用，\n函数体调用完毕后，需要将被压入栈中的参数全部弹出（出栈），以使得栈在函数调用前后保持一致。\n这个弹出的工作（出栈）可以由主调函数（函数调用方）来完成，也可以由被调函数（函数自己）来完成。\n</code></pre></div><p>以上，调用惯例需要规定：</p>\n<div><pre><code>出栈方是主调函数（函数调用方），还是被调函数（函数自己）。\n</code></pre></div><h4 id=\"_4-2-3-函数名称的修饰\" tabindex=\"-1\"> 4.2.3 函数名称的修饰</h4>\n<div><pre><code>为了在链接的时候对调用惯例进行区分，调用惯例需要要对函数本身（即被调函数）的名称进行修饰。\n不同的调用惯例有不同的名称修饰策略。\n</code></pre></div><p>以上，调用惯例需要规定：</p>\n<div><pre><code>函数名称的修饰策略。\n</code></pre></div><h3 id=\"_4-3-c-c-中的调用惯例-cdecl、stdcall、fastcall、pascal\" tabindex=\"-1\"> 4.3 <code>c/c++</code> 中的调用惯例：<code>cdecl</code>、<code>stdcall</code>、<code>fastcall</code>、<code>pascal</code></h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>调用惯例</strong></th>\n<th style=\"text-align:left\"><strong>出栈方</strong></th>\n<th style=\"text-align:left\"><strong>参数传递</strong></th>\n<th style=\"text-align:left\"><strong>名称修饰策略</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>cdecl</code>（默认）</td>\n<td style=\"text-align:left\">主调函数（函数调用方）</td>\n<td style=\"text-align:left\">从右至左参数入栈</td>\n<td style=\"text-align:left\">下划线+函数名</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>stdcall</code></td>\n<td style=\"text-align:left\">被调函数（函数本身）</td>\n<td style=\"text-align:left\">从右至左参数入栈</td>\n<td style=\"text-align:left\">下划线+函数名+<code>@</code>+参数字节数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>fastcall</code></td>\n<td style=\"text-align:left\">被调函数（函数本身）</td>\n<td style=\"text-align:left\">前两个参数由寄存器传递，其余参数通过堆栈传递</td>\n<td style=\"text-align:left\"><code>@</code>+函数名+<code>@</code>+参数的字节数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>pascal</code></td>\n<td style=\"text-align:left\">被调函数（函数本身）</td>\n<td style=\"text-align:left\">从左至右参数入栈</td>\n<td style=\"text-align:left\">较为复杂，参见相关文档</td>\n</tr>\n</tbody>\n</table>\n<div><pre><code>如上表所示，在 C/C++ 中存在着多个调用惯例，而默认的调用惯例是 cdecl，即：任何一个没有显示指定调用惯例的函数，都默认是 cdecl 惯例。也就是说：\n    int func(int a, int b);   等价于  int _cdecl func(int a, int b);\n\n注意：\n_cdecl 不是标准的关键字，在不同的编译器里可能有不同的写法，例如：gcc 里就不存在 _cdecl 这样的关键字，而是使用 __attribute__((cdecl))\n</code></pre></div><p><strong>示例：不同调用惯例的函数名称修饰策略</strong></p>\n<div><pre><code><span>// 1. cdecl 调用惯例：</span>\n<span>int</span> _cdecl <span>_func</span><span>(</span><span>int</span> a<span>,</span> <span>int</span> b<span>)</span><span>;</span>\n\n<span>// 2. stdcall 调用惯例：</span>\n<span>int</span> _stdcall _func@<span>8</span><span>(</span><span>int</span> a<span>,</span> <span>int</span> b<span>)</span><span>;</span>  <span>// 其中 8 表示两个参数变量所占的总字节数是 8 字节（int 占 4 字节）</span>\n</code></pre></div><h2 id=\"_5-变量在函数之间的传递分析\" tabindex=\"-1\"> 5. 变量在函数之间的传递分析</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day02/02.png\" alt=\"\" loading=\"lazy\"></p>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day02/03.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_6-栈的生长方向-从高地址向低地址扩展\" tabindex=\"-1\"> 6. 栈的生长方向（从高地址向低地址扩展）</h2>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day02/04.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_7-数据的内存存放方式-小端对齐方式\" tabindex=\"-1\"> 7. 数据的内存存放方式：小端对齐方式</h2>\n<div><pre><code>如下代码所示：\n对于 “高位字节数据存放在高地址；低位字节数据存放在低地址” 这种数据的内存存放方式，\n称为：小端对齐方式（即高位数据对应高地址，低位数据对应低地址）\n\n蓝色框的代码和打印日志表示：堆中的数据也是采用小端对齐方式存储的。\n\n注意：并非所有的操作系统都采用小端对齐方式存储数据，有的操作系统可能会采用大端对齐方式。\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day02/05.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_8-空指针-野指针\" tabindex=\"-1\"> 8. 空指针 &amp; 野指针</h2>\n<h3 id=\"_8-1-不允许向-null-和非法地址写入数据\" tabindex=\"-1\"> 8.1 不允许向 <code>NULL</code> 和非法地址写入数据</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day02/06.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>如上图，不允许向 <code>NULL</code> 和非法地址写入数据。</p>\n</blockquote>\n<h3 id=\"_8-2-导致出现野指针的情况\" tabindex=\"-1\"> 8.2 导致出现野指针的情况</h3>\n<h4 id=\"_8-2-1-情况1-指针变量未初始化\" tabindex=\"-1\"> 8.2.1 情况1：指针变量未初始化</h4>\n<div><pre><code>任何指针变量刚被创建时不会自动成为 NULL 指针，它的缺省值是随机的，它会乱指一气。\n所以，指针变量在创建的同时应当被初始化，要么将指针设置为 NULL，要么让它指向合法的内存。\n</code></pre></div><h4 id=\"_8-2-2-情况2-指针释放后未置空\" tabindex=\"-1\"> 8.2.2 情况2：指针释放后未置空</h4>\n<div><pre><code>有时指针在 free 或 delete 后未赋值 NULL，便会使人以为是合法的。\n别看 free 和 delete 的名字（尤其是 delete），它们只是把指针所指的内存给释放掉，但并没有把指针本身干掉。\n此时指针指向的就是 “垃圾” 内存。释放后的指针应立即将指针置为 NULL，防止产生 “野指针”。\n</code></pre></div><h4 id=\"_8-2-3-情况3-指针操作超越变量作用域\" tabindex=\"-1\"> 8.2.3 情况3：指针操作超越变量作用域</h4>\n<div><pre><code>不要返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放。\n</code></pre></div><h4 id=\"_8-2-4-示例1-出现野指针的异常代码\" tabindex=\"-1\"> 8.2.4 示例1：出现野指针的异常代码</h4>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day02/07.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_8-2-5-示例2-free-函数传入空指针不会报错\" tabindex=\"-1\"> 8.2.5 示例2：<code>free</code> 函数传入空指针不会报错</h4>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day02/08.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_8-3-规避野指针的方式\" tabindex=\"-1\"> 8.3 规避野指针的方式</h3>\n<blockquote>\n<p>操作野指针是非常危险的操作，应该规避野指针的出现。</p>\n</blockquote>\n<h4 id=\"_8-3-1-方式1-初始化指针变量时置为-null\" tabindex=\"-1\"> 8.3.1 方式1：初始化指针变量时置为 <code>NULL</code></h4>\n<div><pre><code>指针变量一定要初始化为 NULL，因为任何指针变量刚被创建时不会自动成为 NULL 指针，它的缺省值是随机的。\n</code></pre></div><h4 id=\"_8-3-2-方式2-释放指针变量时置为-null\" tabindex=\"-1\"> 8.3.2 方式2：释放指针变量时置为 <code>NULL</code></h4>\n<div><pre><code>当指针 p 指向的内存空间释放时，没有设置指针 p 的值为 NULL。\ndelete 和 free 只是把内存空间释放了，但是并没有将指针 p 的值赋为 NULL。\n通常判断一个指针是否合法，都是使用 if 语句测试该指针是否为 NULL。\n</code></pre></div><h2 id=\"_9-指针的步长\" tabindex=\"-1\"> 9. 指针的步长</h2>\n<p>指针的步长涵盖两个方面的内容：</p>\n<div><pre><code>1. +1 之后跳跃的字节数；\n2. 解引用所解出的字节数。\n</code></pre></div><h3 id=\"_9-1-指针-1-之后跳跃的字节数\" tabindex=\"-1\"> 9.1 指针 <code>+1</code> 之后跳跃的字节数</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day02/09.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_9-2-解引用解出的字节数\" tabindex=\"-1\"> 9.2 解引用解出的字节数</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day02/10.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_10-offsetof-宏函数-计算结构体成员相对于结构体首地址的偏移\" tabindex=\"-1\"> 10. <code>offsetof</code> 宏函数（计算结构体成员相对于结构体首地址的偏移）</h2>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stddef.h></span></span>\n<span><span>#</span><span>define</span> <span>offsetof</span><span><span>(</span>s<span>,</span>m<span>)</span> <span>(</span><span>(</span><span>size_t</span><span>)</span><span>&amp;</span><span>(</span><span>(</span><span>(</span>s<span>*</span><span>)</span><span>0</span><span>)</span><span>-></span>m<span>)</span><span>)</span></span></span>\n    功能：\n        计算结构体 s 中的成员变量 m 相对于结构体首地址的偏移量（单位：字节）\n    参数：\n        s：结构体类型名称\n        m：预计算偏移量的结构体成员变量\n</code></pre></div><p><strong>示例：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day02/11.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_11-指针做函数参数时的输入输出特性\" tabindex=\"-1\"> 11. 指针做函数参数时的输入输出特性</h2>\n<h3 id=\"_11-1-输入特性-主调函数分配内存-被调函数使用\" tabindex=\"-1\"> 11.1 输入特性：主调函数分配内存，被调函数使用</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day02/12.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_11-2-输出特性-在被调函数中分配内存-主调函数使用\" tabindex=\"-1\"> 11.2 输出特性：在被调函数中分配内存，主调函数使用</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day02/13.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_12-字符串强化练习\" tabindex=\"-1\"> 12. 字符串强化练习</h2>\n<h3 id=\"_12-1-八进制转义字符和十六进制转义字符的使用\" tabindex=\"-1\"> 12.1 八进制转义字符和十六进制转义字符的使用</h3>\n<div><pre><code>在 C 中有两种特殊的字符，八进制转义字符和十六进制转义字符：\n    八进制字符的一般形式是：'\\ddd'，其中，d 表示 0-7 的数字。\n    十六进制字符的一般形式是：'\\xhh'，其中，h 表示 0-9 或 A-F 内的一个。\n\n八进制字符和十六进制字符表示的是字符的 ASCII 码对应的数值。比如 ：\n    '\\063' 表示的是字符 '3'，因为 '3' 的 ASCII 码是 51；\n    '\\x41' 表示的是字符 'A'，因为 'A' 的 ASCII 码是 65。\n</code></pre></div><p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day02/14.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_12-2-拷贝字符串的三种方式\" tabindex=\"-1\"> 12.2 拷贝字符串的三种方式</h3>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day02/15.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-27T11:44:34.000Z",
      "authors": [],
      "tags": [
        "C高级编程"
      ]
    },
    {
      "title": "第03天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_2_c-advance/day03.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_2_c-advance/day03.html",
      "content_html": "<h2 id=\"_1-calloc-函数-申请一段初始化为0的内存空间\" tabindex=\"-1\"> 1. <code>calloc</code> 函数：申请一段初始化为0的内存空间</h2>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdlib.h></span></span>\n<span>void</span> <span>*</span><span>calloc</span><span>(</span><span>size_t</span> nmemb<span>,</span> <span>size_t</span> size<span>)</span><span>;</span>\n    功能：\n        在内存动态存储区中分配 nmemb 块长度为 size 字节的连续区域。calloc 自动将分配的内存置 <span>0</span>。\n    参数：\n        nmemb：所需内存单元数量\n        size：每个内存单元的大小（单位：字节）\n    返回值：\n        成功：分配空间的起始地址\n        失败：<span>NULL</span>\n</code></pre></div><h3 id=\"_1-1-calloc-与-malloc-函数的区别\" tabindex=\"-1\"> 1.1 <code>calloc</code> 与 <code>malloc</code> 函数的区别</h3>\n<p><code>calloc</code> 和 <code>malloc</code> 的主要区别在于：</p>\n<div><pre><code>calloc 申请到的内存空间做了初始化，初始值是<span>0</span>；\nmalloc 申请到的内存空间未做初始化，初始值是不确定的；\n</code></pre></div><p>另外，<code>calloc</code> 与 <code>malloc</code> 的函数声明对比如下：</p>\n<div><pre><code><span>/* calloc */</span>\n<span><span>#</span><span>include</span> <span>&lt;stdlib.h></span></span>\n<span>void</span> <span>*</span><span>calloc</span><span>(</span><span>size_t</span> nmemb<span>,</span> <span>size_t</span> size<span>)</span><span>;</span>\n\n<span>/* malloc */</span>\n<span><span>#</span><span>include</span> <span>&lt;stdlib.h></span></span>\n<span>void</span> <span>*</span><span>malloc</span> <span>(</span><span>size_t</span> size<span>)</span><span>;</span>\n</code></pre></div><p>从各自的函数声明来看，若 <code>calloc</code> 和 <code>malloc</code> 分别申请10个 <code>int</code> 大小的内存空间，则有如下区别：</p>\n<div><pre><code><span>/* calloc */</span>\n<span>calloc</span><span>(</span><span>10</span><span>,</span> <span>sizeof</span><span>(</span><span>int</span><span>)</span><span>)</span><span>;</span>\n\n<span>/* malloc */</span>\n<span>malloc</span><span>(</span><span>sizeof</span><span>(</span><span>int</span><span>)</span> <span>*</span> <span>10</span><span>)</span><span>;</span>\n</code></pre></div><p><strong>示例：</strong></p>\n<p><img src=\"@source/zkq/c_and_cpp/_2_c-advance/images/day03/01.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_2-realloc-函数-重新分配堆中申请了的内存空间\" tabindex=\"-1\"> 2. <code>realloc</code> 函数：重新分配堆中申请了的内存空间</h2>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdlib.h></span></span>\n<span>void</span> <span>*</span><span>realloc</span><span>(</span><span>void</span> <span>*</span>ptr<span>,</span> <span>size_t</span> size<span>)</span><span>;</span>\n    功能：\n        对通过 malloc 或 calloc 函数在堆中开辟的内存空间进行重新分配。\n    参数：\n        ptr：为之前用 malloc 或 calloc 分配的内存地址，如果此参数等于 <span>NULL</span>，那么和 realloc 与 malloc 功能一致\n        size：为重新分配内存的大小，单位：字节。\n    返回值：\n        成功：新分配的堆内存地址\n        失败：<span>NULL</span>\n</code></pre></div><p><strong>注意：</strong></p>\n<div><pre><code>当重新分配的内存空间比原来大时：\n    1. realloc 不会初始化新空间为 0，即新增的内存空间中的值是不确定的；\n    2. 如果 ptr 指向的地址后面有足够的连续空间，那么就会在已有地址基础上增加内存；\n    3. 如果 ptr 指向的地址后面没有空间了，那么 realloc 会重新分配新的连续内存，把旧内存的值拷贝到新内存，同时释放旧内存。\n\n当重新分配的内存空间比原来小时：\n    1. 会将原内存后面缩减了的部分空间释放掉。\n</code></pre></div><h2 id=\"_3-字符串格式化函数-sprintf\" tabindex=\"-1\"> 3. 字符串格式化函数：<code>sprintf</code></h2>\n<h2 id=\"_4-字符串格式化函数-sscanf\" tabindex=\"-1\"> 4. 字符串格式化函数：<code>sscanf</code></h2>\n<h2 id=\"_5-字符串格式化案例\" tabindex=\"-1\"> 5. 字符串格式化案例</h2>\n<h2 id=\"_6-一级指针易错点\" tabindex=\"-1\"> 6. 一级指针易错点</h2>\n<h3 id=\"_6-1-易错点1-越界-没有考虑到字符串结束标记字符-0\" tabindex=\"-1\"> 6.1 易错点1：越界（没有考虑到字符串结束标记字符 <code>'\\0'</code>）</h3>\n<h3 id=\"_6-2-易错点2-因改变原指针指向而导致-free-失败\" tabindex=\"-1\"> 6.2 易错点2：因改变原指针指向而导致 <code>free</code> 失败</h3>\n<h3 id=\"_6-3-易错点3-被调函数返回局部变量地址\" tabindex=\"-1\"> 6.3 易错点3：被调函数返回局部变量地址</h3>\n<h3 id=\"_6-4-易错点4-同一块内存释放多次-不可以释放野指针\" tabindex=\"-1\"> 6.4 易错点4：同一块内存释放多次（不可以释放野指针）</h3>\n<h2 id=\"_7-位运算-、-、-、\" tabindex=\"-1\"> 7. 位运算（<code>~</code>、<code>&amp;</code>、<code>|</code>、<code>^</code>）</h2>\n<h2 id=\"_8-两数交换的三种方式\" tabindex=\"-1\"> 8. 两数交换的三种方式</h2>\n<h3 id=\"_8-1-方式1-采用临时变量\" tabindex=\"-1\"> 8.1 方式1：采用临时变量</h3>\n<h3 id=\"_8-2-方式2-利用按位异或的特性\" tabindex=\"-1\"> 8.2 方式2：利用按位异或的特性</h3>\n<h3 id=\"_8-3-方式3-利用加减法的特性\" tabindex=\"-1\"> 8.3 方式3：利用加减法的特性</h3>\n",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-28T01:29:00.000Z",
      "authors": [],
      "tags": [
        "C高级编程"
      ]
    },
    {
      "title": "第04天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_2_c-advance/day04.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_2_c-advance/day04.html",
      "content_html": "",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": [
        "C高级编程"
      ]
    },
    {
      "title": "第05天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_2_c-advance/day05.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_2_c-advance/day05.html",
      "content_html": "",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": [
        "C高级编程"
      ]
    },
    {
      "title": "第06天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_2_c-advance/day06.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_2_c-advance/day06.html",
      "content_html": "",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": [
        "C高级编程"
      ]
    },
    {
      "title": "第07天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_2_c-advance/day07.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_2_c-advance/day07.html",
      "content_html": "",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": [
        "C高级编程"
      ]
    },
    {
      "title": "扩展01 - 详解宏定义（#define）",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_2_c-advance/ext01.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_2_c-advance/ext01.html",
      "content_html": "",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": [
        "C高级编程"
      ]
    },
    {
      "title": "第01天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_3_data-structure/day01.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_3_data-structure/day01.html",
      "content_html": "",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": [
        "c/c++ 数据结构"
      ]
    },
    {
      "title": "第02天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_3_data-structure/day02.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_3_data-structure/day02.html",
      "content_html": "",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": [
        "c/c++ 数据结构"
      ]
    },
    {
      "title": "第03天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_3_data-structure/day03.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_3_data-structure/day03.html",
      "content_html": "",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": [
        "c/c++ 数据结构"
      ]
    },
    {
      "title": "第01天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_4_cpp-core/day01.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_4_cpp-core/day01.html",
      "content_html": "",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": [
        "C++核心编程"
      ]
    },
    {
      "title": "第02天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_4_cpp-core/day02.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_4_cpp-core/day02.html",
      "content_html": "",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": [
        "C++核心编程"
      ]
    },
    {
      "title": "第03天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_4_cpp-core/day03.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_4_cpp-core/day03.html",
      "content_html": "",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": [
        "C++核心编程"
      ]
    },
    {
      "title": "第04天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_4_cpp-core/day04.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_4_cpp-core/day04.html",
      "content_html": "",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": [
        "C++核心编程"
      ]
    },
    {
      "title": "第05天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_4_cpp-core/day05.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_4_cpp-core/day05.html",
      "content_html": "",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": [
        "C++核心编程"
      ]
    },
    {
      "title": "第06天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_4_cpp-core/day06.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_4_cpp-core/day06.html",
      "content_html": "",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": [
        "C++核心编程"
      ]
    },
    {
      "title": "第07天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_4_cpp-core/day07.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_4_cpp-core/day07.html",
      "content_html": "",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": [
        "C++核心编程"
      ]
    },
    {
      "title": "第08天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_4_cpp-core/day08.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_4_cpp-core/day08.html",
      "content_html": "",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": [
        "C++核心编程"
      ]
    },
    {
      "title": "第09天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_4_cpp-core/day09.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_4_cpp-core/day09.html",
      "content_html": "",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": [
        "C++核心编程"
      ]
    },
    {
      "title": "扩展01 - C++ 11 中using的使用",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_4_cpp-core/ext01.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_4_cpp-core/ext01.html",
      "content_html": "",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": [
        "C++核心编程"
      ]
    },
    {
      "title": "扩展02 - 详解C++的模板中typename关键字的用法",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_4_cpp-core/ext02.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_4_cpp-core/ext02.html",
      "content_html": "",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": [
        "C++核心编程"
      ]
    },
    {
      "title": "第01天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_5_stl/day01.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_5_stl/day01.html",
      "content_html": "",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": [
        "STL"
      ]
    },
    {
      "title": "第02天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_5_stl/day02.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_5_stl/day02.html",
      "content_html": "",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": [
        "STL"
      ]
    },
    {
      "title": "第03天",
      "url": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_5_stl/day03.html",
      "id": "https://zengkaiqiang562.github.io/zkq/c_and_cpp/_5_stl/day03.html",
      "content_html": "",
      "date_published": "2023-03-10T09:53:05.000Z",
      "date_modified": "2023-03-10T09:53:05.000Z",
      "authors": [],
      "tags": [
        "STL"
      ]
    },
    {
      "title": "Books",
      "url": "https://zengkaiqiang562.github.io/zkq/books/",
      "id": "https://zengkaiqiang562.github.io/zkq/books/",
      "content_html": "",
      "date_published": "2023-03-09T15:22:56.000Z",
      "date_modified": "2023-03-09T15:22:56.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "第1章 Linux内核简介",
      "url": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_01_linux_kernel_introduction.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_01_linux_kernel_introduction.html",
      "content_html": "",
      "date_published": "2023-03-09T15:22:56.000Z",
      "date_modified": "2023-03-09T15:22:56.000Z",
      "authors": [],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "第2章 从内核出发",
      "url": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_02_begin_from_kernel.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_02_begin_from_kernel.html",
      "content_html": "",
      "date_published": "2023-03-09T15:22:56.000Z",
      "date_modified": "2023-03-09T15:22:56.000Z",
      "authors": [],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "第3章 进程管理",
      "url": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_03_process_manager.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_03_process_manager.html",
      "content_html": "",
      "date_published": "2023-03-09T15:22:56.000Z",
      "date_modified": "2023-03-09T15:22:56.000Z",
      "authors": [],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "第4章 进程调度",
      "url": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_04_process_dispatch.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_04_process_dispatch.html",
      "content_html": "",
      "date_published": "2023-03-09T15:22:56.000Z",
      "date_modified": "2023-03-09T15:22:56.000Z",
      "authors": [],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "第5章 系统调用",
      "url": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_05_system_call.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_05_system_call.html",
      "content_html": "",
      "date_published": "2023-03-09T15:22:56.000Z",
      "date_modified": "2023-03-09T15:22:56.000Z",
      "authors": [],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "第6章 内核数据结构",
      "url": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_06_kernel_data_structure.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_06_kernel_data_structure.html",
      "content_html": "",
      "date_published": "2023-03-09T15:22:56.000Z",
      "date_modified": "2023-03-09T15:22:56.000Z",
      "authors": [],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "第7章 中断和中断处理",
      "url": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_07_interrupt_and_deal.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_07_interrupt_and_deal.html",
      "content_html": "",
      "date_published": "2023-03-09T15:22:56.000Z",
      "date_modified": "2023-03-09T15:22:56.000Z",
      "authors": [],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "第8章 下半部和推后执行的工作",
      "url": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_08_bottom_half_and_defer_execute.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_08_bottom_half_and_defer_execute.html",
      "content_html": "",
      "date_published": "2023-03-09T15:22:56.000Z",
      "date_modified": "2023-03-09T15:22:56.000Z",
      "authors": [],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "第9章 内核同步介绍",
      "url": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_09_kernel_sync_introduction.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_09_kernel_sync_introduction.html",
      "content_html": "",
      "date_published": "2023-03-09T15:22:56.000Z",
      "date_modified": "2023-03-09T15:22:56.000Z",
      "authors": [],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "第10章 内核同步方法",
      "url": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_10_kernel_sync_method.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_10_kernel_sync_method.html",
      "content_html": "",
      "date_published": "2023-03-09T15:22:56.000Z",
      "date_modified": "2023-03-09T15:22:56.000Z",
      "authors": [],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "第11章 定时器和时间管理",
      "url": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_11_timer_and_manage.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_11_timer_and_manage.html",
      "content_html": "",
      "date_published": "2023-03-09T15:22:56.000Z",
      "date_modified": "2023-03-09T15:22:56.000Z",
      "authors": [],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "第12章 内存管理",
      "url": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_12_memory_manage.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_12_memory_manage.html",
      "content_html": "",
      "date_published": "2023-03-09T15:22:56.000Z",
      "date_modified": "2023-03-09T15:22:56.000Z",
      "authors": [],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "第13章 虚拟文件系统",
      "url": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_13_virtual_file_system.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_13_virtual_file_system.html",
      "content_html": "",
      "date_published": "2023-03-09T15:22:56.000Z",
      "date_modified": "2023-03-09T15:22:56.000Z",
      "authors": [],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "第14章 块I/O层",
      "url": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_14_block_io_layer.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_14_block_io_layer.html",
      "content_html": "",
      "date_published": "2023-03-09T15:22:56.000Z",
      "date_modified": "2023-03-09T15:22:56.000Z",
      "authors": [],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "第15章 进程地址空间",
      "url": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_15_process_addr_space.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_15_process_addr_space.html",
      "content_html": "",
      "date_published": "2023-03-09T15:22:56.000Z",
      "date_modified": "2023-03-09T15:22:56.000Z",
      "authors": [],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "第16章 页高速缓存和页回写",
      "url": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_16_page_high_cache_and_page_rewrite.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_16_page_high_cache_and_page_rewrite.html",
      "content_html": "",
      "date_published": "2023-03-09T15:22:56.000Z",
      "date_modified": "2023-03-09T15:22:56.000Z",
      "authors": [],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "第17章 设备与模块",
      "url": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_17_device_and_module.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_17_device_and_module.html",
      "content_html": "",
      "date_published": "2023-03-09T15:22:56.000Z",
      "date_modified": "2023-03-09T15:22:56.000Z",
      "authors": [],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "第18章 调试",
      "url": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_18_debug.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_18_debug.html",
      "content_html": "",
      "date_published": "2023-03-09T15:22:56.000Z",
      "date_modified": "2023-03-09T15:22:56.000Z",
      "authors": [],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "第19章 可移植性",
      "url": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_19_transplant.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_19_transplant.html",
      "content_html": "",
      "date_published": "2023-03-09T15:22:56.000Z",
      "date_modified": "2023-03-09T15:22:56.000Z",
      "authors": [],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "第20章 补丁、开发和社区",
      "url": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_20_patch_and_dev_community.html",
      "id": "https://zengkaiqiang562.github.io/zkq/books/linux-kernel-development/_20_patch_and_dev_community.html",
      "content_html": "",
      "date_published": "2023-03-09T15:22:56.000Z",
      "date_modified": "2023-03-09T15:22:56.000Z",
      "authors": [],
      "tags": [
        "Linux"
      ]
    }
  ]
}