<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.38" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://zengkaiqiang562.github.io/lango-tech/subject/surfaceflinger.html"><meta property="og:site_name" content="Android Guide"><meta property="og:title" content="GUI系统——SurfaceFlinger"><meta property="og:type" content="article"><meta property="og:image" content="https://zengkaiqiang562.github.io/"><meta property="og:updated_time" content="2024-04-30T10:39:15.000Z"><meta property="og:locale" content="zh-CN"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image:alt" content="GUI系统——SurfaceFlinger"><meta property="article:tag" content="专题"><meta property="article:modified_time" content="2024-04-30T10:39:15.000Z"><script>var _hmt = _hmt || [];
      (function() {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?5dd2e8c97962d57b7b8fea1737c01743";
        var s = document.getElementsByTagName("script")[0]; 
        s.parentNode.insertBefore(hm, s);
      })();</script><link rel="stylesheet" href="//at.alicdn.com/t/font_2922463_99aa80ii7cf.css"><title>GUI系统——SurfaceFlinger | Android Guide</title><meta name="description" content="Android 学习 && 面试指南">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/assets/style.c9a516cc.css">
    <link rel="modulepreload" href="/assets/app.2a01fc36.js"><link rel="modulepreload" href="/assets/surfaceflinger.html.3357f154.js"><link rel="modulepreload" href="/assets/surfaceflinger.html.8f57c5db.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container has-toc sidebar-open"><!--[--><header class="navbar"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><a href="/" class="home-link"><img class="logo" src="/logo.png" alt="Android Guide"><!----><span class="site-name hide-in-pad">Android Guide</span><!--[--><!----><!--]--></a><nav class="nav-links" style=""><div class="nav-item hide-in-mobile"><a href="/home.html" class="nav-link" arialabel="面试指南"><i class="icon iconfont icon-java"></i>面试指南<!----></a></div><div class="nav-item hide-in-mobile"><a href="/zhuanlan/" class="nav-link" arialabel="优质专栏"><i class="icon iconfont icon-recommend"></i>优质专栏<!----></a></div><div class="nav-item hide-in-mobile"><a href="/open-source-project/" class="nav-link" arialabel="项目精选"><i class="icon iconfont icon-github"></i>项目精选<!----></a></div><div class="nav-item hide-in-mobile"><a href="https://snailclimb.gitee.io/javaguide/#/" rel="noopener noreferrer" target="_blank" arialabel="旧版链接" class="nav-link"><i class="icon iconfont icon-java"></i>旧版链接<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="nav-item hide-in-mobile"><a href="https://javaguide.cn/feed.json" rel="noopener noreferrer" target="_blank" arialabel="RSS订阅" class="nav-link"><i class="icon iconfont icon-rss"></i>RSS订阅<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="nav-item hide-in-mobile"><a href="/about-the-author/" class="nav-link" arialabel="关于作者"><i class="icon iconfont icon-zuozhe"></i>关于作者<!----></a></div></nav><div class="nav-actions-wrapper"><!--[--><!----><!--]--><div class="nav-item"><!----></div><div class="nav-item"><a class="repo-link" href="https://github.com/zengkaiqiang562/JavaGuide" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewbox="0 0 1024 1024" arialabelledby="github" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><title id="github" lang="en">github icon</title><g fill="currentColor"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></g></svg></a></div><div class="nav-item hide-in-mobile"><button id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewbox="0 0 1024 1024" arialabelledby="auto" style="display:block;"><title id="auto" lang="en">auto icon</title><g fill="currentColor"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></g></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewbox="0 0 1024 1024" arialabelledby="dark" style="display:none;"><title id="dark" lang="en">dark icon</title><g fill="currentColor"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></g></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewbox="0 0 1024 1024" arialabelledby="light" style="display:none;"><title id="light" lang="en">light icon</title><g fill="currentColor"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></g></svg></button></div><form class="search-box" role="search"><input type="search" placeholder="搜索" autocomplete="off" spellcheck="false" value><!----></form><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button><!--[--><!----><!--]--></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">开发指引</span><span class="arrow right"></span></button><!--[--><!--[--><!----><!--]--><!----><!--]--></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">项目管理</span><span class="arrow right"></span></button><!--[--><!--[--><!----><!--]--><!----><!--]--></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">组件管理</span><span class="arrow right"></span></button><!--[--><!--[--><!----><!--]--><!----><!--]--></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable active"><!----><span class="title">专题</span><span class="arrow down"></span></button><!--[--><!--[--><ul class="sidebar-links"><li><!--[--><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" arialabel="GUI系统——SurfaceFlinger"><!---->GUI系统——SurfaceFlinger<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_1-opengl-es-与-egl" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1 OpenGL ES 与 EGL"><!---->1 OpenGL ES 与 EGL<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_2-android-的硬件接口-——-hal" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="2 Android 的硬件接口 —— HAL"><!---->2 Android 的硬件接口 —— HAL<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_3-gralloc-与-framebuffer" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="3 Gralloc 与 Framebuffer"><!---->3 Gralloc 与 Framebuffer<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_3-1-gralloc-模块的加载" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="3.1 Gralloc 模块的加载"><!---->3.1 Gralloc 模块的加载<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_3-2-gralloc-提供的接口" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="3.2 Gralloc 提供的接口"><!---->3.2 Gralloc 提供的接口<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_3-2-1-fb-设备的打开过程" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="3.2.1 fb 设备的打开过程"><!---->3.2.1 fb 设备的打开过程<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_3-2-2-gralloc-设备的打开过程" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="3.2.2 gralloc 设备的打开过程"><!---->3.2.2 gralloc 设备的打开过程<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_4-android-中的本地窗口" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="4 Android 中的本地窗口"><!---->4 Android 中的本地窗口<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_4-1-framebuffernativewindow" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="4.1 FramebufferNativeWindow"><!---->4.1 FramebufferNativeWindow<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_4-1-1-构造函数中的初始化操作" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="4.1.1 构造函数中的初始化操作"><!---->4.1.1 构造函数中的初始化操作<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_4-1-2-dequeuebuffer" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="4.1.2 dequeueBuffer"><!---->4.1.2 dequeueBuffer<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_4-2-surface" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="4.2 Surface"><!---->4.2 Surface<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_4-2-1-surface-的创建流程" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="4.2.1 Surface 的创建流程"><!---->4.2.1 Surface 的创建流程<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_4-2-本地窗口小结" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="4.2 本地窗口小结"><!---->4.2 本地窗口小结<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_5-bufferqueue-详解" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="5 BufferQueue 详解"><!---->5 BufferQueue 详解<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_5-1-bufferqueue-的内部原理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="5.1 BufferQueue 的内部原理"><!---->5.1 BufferQueue 的内部原理<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_5-2-bufferqueue-的缓冲区分配" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="5.2 BufferQueue 的缓冲区分配"><!---->5.2 BufferQueue 的缓冲区分配<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_5-3-应用程序的典型绘图流程" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="5.3 应用程序的典型绘图流程"><!---->5.3 应用程序的典型绘图流程<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_5-4-应用程序与-bufferqueue-的关系" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="5.4 应用程序与 BufferQueue 的关系"><!---->5.4 应用程序与 BufferQueue 的关系<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_6-surfaceflinger" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="6 SurfaceFlinger"><!---->6 SurfaceFlinger<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_6-1-黄油计划-project-butter" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="6.1 “黄油计划”（Project Butter）"><!---->6.1 “黄油计划”（Project Butter）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_6-2-surfaceflinger-的启动" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="6.2 SurfaceFlinger 的启动"><!---->6.2 SurfaceFlinger 的启动<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_6-3-接口的服务端-——-client" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="6.3 接口的服务端 —— Client"><!---->6.3 接口的服务端 —— Client<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_6-3-1-surfaceflinger-createconnection" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="6.3.1 SurfaceFlinger::createConnection"><!---->6.3.1 SurfaceFlinger::createConnection<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_6-3-2-client-createsurface" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="6.3.2 Client::createSurface"><!---->6.3.2 Client::createSurface<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_7-vsync-的产生和处理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="7 VSync 的产生和处理"><!---->7 VSync 的产生和处理<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_7-1-vsync-信号的产生和分发" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="7.1 VSync 信号的产生和分发"><!---->7.1 VSync 信号的产生和分发<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_7-1-1-硬件源" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="7.1.1 硬件源"><!---->7.1.1 硬件源<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_7-1-2-软件源" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="7.1.2 软件源"><!---->7.1.2 软件源<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_7-2-vsync-信号的处理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="7.2 VSync 信号的处理"><!---->7.2 VSync 信号的处理<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li></ul><!--]--></li></ul><!--]--><!----><!--]--></section><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->GUI系统——SurfaceFlinger</h1><div class="article-info"><span class="author-info" arialabel="作者🖊" isoriginal="false" pageview="false" color="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewbox="0 0 1024 1024" arialabelledby="author"><title id="author" lang="en">author icon</title><g fill="currentColor"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></g></svg><span><a class="author-item" href="https://zengkaiqiang562.github.io/" target="_blank" rel="noopener noreferrer">Zenk562</a></span><span property="author" content="Zenk562"></span></span><span class="category-info" arialabel="分类🌈" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewbox="0 0 1024 1024" arialabelledby="category"><title id="category" lang="en">category icon</title><g fill="currentColor"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></g></svg><ul class="categories-wrapper"><li class="category clickable" role="navigation">朗国科技</li><meta property="articleSection" content="朗国科技"></ul></span><span arialabel="标签🏷" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon tag-icon" viewbox="0 0 1024 1024" arialabelledby="tag"><title id="tag" lang="en">tag icon</title><g fill="currentColor"><path d="M939.902 458.563L910.17 144.567c-1.507-16.272-14.465-29.13-30.737-30.737L565.438 84.098h-.402c-3.215 0-5.726 1.005-7.634 2.913l-470.39 470.39a10.004 10.004 0 000 14.164l365.423 365.424c1.909 1.908 4.42 2.913 7.132 2.913s5.223-1.005 7.132-2.913l470.39-470.39c2.01-2.11 3.014-5.023 2.813-8.036zm-240.067-72.121c-35.458 0-64.286-28.828-64.286-64.286s28.828-64.285 64.286-64.285 64.286 28.828 64.286 64.285-28.829 64.286-64.286 64.286z"></path></g></svg><ul class="tags-wrapper"><li class="tag clickable" role="navigation">专题</li></ul><meta property="keywords" content="专题"></span><span class="date-info" arialabel="写作日期📅" isoriginal="false" pageview="false" color="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewbox="0 0 1024 1024" arialabelledby="calendar"><title id="calendar" lang="en">calendar icon</title><g fill="currentColor"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></g></svg><span>2024年4月30日</span><meta property="datePublished" content="2024-04-30T10:39:15.000Z"></span><!----><span class="words-info" arialabel="字数🔠" isoriginal="false" pageview="false" color="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon word-icon" viewbox="0 0 1024 1024" arialabelledby="word"><title id="word" lang="en">word icon</title><g fill="currentColor"><path d="M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z"></path><path d="M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z"></path></g></svg><span>约 30304 字</span><meta property="wordCount" content="30304"></span></div><hr></div><div class="toc-place-holder"><aside id="toc-list"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_1-opengl-es-与-egl" class="router-link-active router-link-exact-active toc-link level2">1 OpenGL ES 与 EGL</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_2-android-的硬件接口-——-hal" class="router-link-active router-link-exact-active toc-link level2">2 Android 的硬件接口 —— HAL</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_3-gralloc-与-framebuffer" class="router-link-active router-link-exact-active toc-link level2">3 Gralloc 与 Framebuffer</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_3-1-gralloc-模块的加载" class="router-link-active router-link-exact-active toc-link level3">3.1 Gralloc 模块的加载</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_3-2-gralloc-提供的接口" class="router-link-active router-link-exact-active toc-link level3">3.2 Gralloc 提供的接口</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_3-2-1-fb-设备的打开过程" class="router-link-active router-link-exact-active toc-link level4">3.2.1 fb 设备的打开过程</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_3-2-2-gralloc-设备的打开过程" class="router-link-active router-link-exact-active toc-link level4">3.2.2 gralloc 设备的打开过程</a></li><!----><!--]--></ul><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_4-android-中的本地窗口" class="router-link-active router-link-exact-active toc-link level2">4 Android 中的本地窗口</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_4-1-framebuffernativewindow" class="router-link-active router-link-exact-active toc-link level3">4.1 FramebufferNativeWindow</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_4-1-1-构造函数中的初始化操作" class="router-link-active router-link-exact-active toc-link level4">4.1.1 构造函数中的初始化操作</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_4-1-2-dequeuebuffer" class="router-link-active router-link-exact-active toc-link level4">4.1.2 dequeueBuffer</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_4-2-surface" class="router-link-active router-link-exact-active toc-link level3">4.2 Surface</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_4-2-1-surface-的创建流程" class="router-link-active router-link-exact-active toc-link level4">4.2.1 Surface 的创建流程</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_4-2-本地窗口小结" class="router-link-active router-link-exact-active toc-link level3">4.2 本地窗口小结</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_5-bufferqueue-详解" class="router-link-active router-link-exact-active toc-link level2">5 BufferQueue 详解</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_5-1-bufferqueue-的内部原理" class="router-link-active router-link-exact-active toc-link level3">5.1 BufferQueue 的内部原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_5-2-bufferqueue-的缓冲区分配" class="router-link-active router-link-exact-active toc-link level3">5.2 BufferQueue 的缓冲区分配</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_5-3-应用程序的典型绘图流程" class="router-link-active router-link-exact-active toc-link level3">5.3 应用程序的典型绘图流程</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_5-4-应用程序与-bufferqueue-的关系" class="router-link-active router-link-exact-active toc-link level3">5.4 应用程序与 BufferQueue 的关系</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_6-surfaceflinger" class="router-link-active router-link-exact-active toc-link level2">6 SurfaceFlinger</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_6-1-黄油计划-project-butter" class="router-link-active router-link-exact-active toc-link level3">6.1 “黄油计划”（Project Butter）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_6-2-surfaceflinger-的启动" class="router-link-active router-link-exact-active toc-link level3">6.2 SurfaceFlinger 的启动</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_6-3-接口的服务端-——-client" class="router-link-active router-link-exact-active toc-link level3">6.3 接口的服务端 —— Client</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_6-3-1-surfaceflinger-createconnection" class="router-link-active router-link-exact-active toc-link level4">6.3.1 SurfaceFlinger::createConnection</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_6-3-2-client-createsurface" class="router-link-active router-link-exact-active toc-link level4">6.3.2 Client::createSurface</a></li><!----><!--]--></ul><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_7-vsync-的产生和处理" class="router-link-active router-link-exact-active toc-link level2">7 VSync 的产生和处理</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_7-1-vsync-信号的产生和分发" class="router-link-active router-link-exact-active toc-link level3">7.1 VSync 信号的产生和分发</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_7-1-1-硬件源" class="router-link-active router-link-exact-active toc-link level4">7.1.1 硬件源</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_7-1-2-软件源" class="router-link-active router-link-exact-active toc-link level4">7.1.2 软件源</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/lango-tech/subject/surfaceflinger.html#_7-2-vsync-信号的处理" class="router-link-active router-link-exact-active toc-link level3">7.2 VSync 信号的处理</a></li><!----><!--]--></ul><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><!--[--><div class="language-text ext-text"><pre class="language-text"><code>Android 的 GUI 系统是基于 OpenGL/EGL 来实现的
</code></pre></div><h2 id="_1-opengl-es-与-egl" tabindex="-1"><a class="header-anchor" href="#_1-opengl-es-与-egl" aria-hidden="true">#</a> 1 <code>OpenGL ES</code> 与 <code>EGL</code></h2><p>如下图所示，描述了 <code>SurfaceFlinger</code> 与 <code>OpenGL ES</code> 等模块的关系。</p><p><img src="/assets/01.7c94b1b9.png" alt="" loading="lazy"></p><p>现在由 “底层到上层” 的顺序来逐步分析图中阐述的架构：</p><div class="language-text ext-text"><pre class="language-text"><code>（1）Linux 内核提供了统一的 framebuffer 显示驱动。
	设备节点 /dev/graphics/fb* 或者 /dev/fb*，其中 fb0 表示第一个 Monitor，当前系统实现中只用到了一个显示屏。

（2）Android 的 HAL 层提供了 Gralloc，包括 fb 和 gralloc 两个设备。
    前者负责打开内核中的 framebuffer、初始化配置，并提供了 post、setSwapInterval 等操作接口；
    后者则管理帧缓冲区的分配和释放。
    这就意味着上层元素只能通过 Gralloc 来间接访问帧缓冲区，从而保证了系统对 framebuffer 的有序使用和统一管理。

    另外，HAL层的另一重要模块是 “Composer” —— 如其名所示，它为厂商自定制“UI合成”提供了接口。
    Composer 的直接使用者是 SurfaceFlinger 中的 HWComposer（有两个 HWComposer，后面我们会详细讲解），
    后者除了管理 Composer 的 HAL 模块外，还负责 VSync 信号的产生和控制。
    VSync则是 “Project Butter” 工程中加入的一种同步机制，它既可以由硬件产生，也可以通过软件来模拟（VsyncThread），
    后续有专门的小节进行介绍。

（3）由于 OpenGL ES 是一个通用的函数库，在不同的平台系统上需要被 “本地化”，
    即把它与具体平台中的窗口系统建立起关联，这样才能保证正常工作。
    从 FramebufferNativeWindow 这个名称就能判断出来，它就是负责 OpenGL ES 在 Android 平台上本地化的中介之一。
    后面我们还会看到 Android 应用程序中所使用的另一个“本地窗口”。

    为 OpenGL ES 配置本地窗口的是 EGL。

（4）OpenG L或者 OpenGL ES 更多的只是一个接口协议，具体实现既可以采用软件，也可以依托于硬件。
    既然有多种实现的可能，那么 OpenGL ES 在动态运行时是如何取舍的呢？这也是 EGL 的作用之一。
    EGL 会去读取 egl.cfg 这个配置文件，然后根据用户的设定来动态加载 libagl（软件实现）或者 libhgl（硬件实现）。

（5）SurfaceFlinger 中持有一个成员数组 mDisplays 来描述系统中支持的各种 “显示设备”。
    具体有哪些 Display 是由 SurfaceFlinger 在 readyToRun 中判断并赋值的；
    并且 DisplayDevice 在初始化时还将调用 eglGetDisplay、eglCreateWindowSurface 等接口，
    并利用 EGL来 完成对 OpenGL ES 环境的搭建。

（6）很多模块都可以调用 OpenGL ES 提供的 API，包括 SurfaceFlinger、DisplayDevice 等模块。
  （这些 API 接口以 “gl” 为前缀，如 glViewport、glClear、glMatrixMode、glLoadIdentity 等），

（7）与 OpenGL ES 相关的模块可以分为如下几类。
    配置类：即帮助 OpenGL ES 完成配置的，包括 EGL、DisplayHardware 都可以归为这一类。
    依赖类：也就是 OpenGL ES 要正常运行起来所依赖的 “本地化” 的东西，上图中是指 FramebufferNativeWindow。
    使用类：使用者也可能是配置者，如 DisplayDevice 既扮演了构建 OpenGL ES 环境的角色，同时也是它的用户。
    
</code></pre></div><h2 id="_2-android-的硬件接口-——-hal" tabindex="-1"><a class="header-anchor" href="#_2-android-的硬件接口-——-hal" aria-hidden="true">#</a> 2 <code>Android</code> 的硬件接口 —— <code>HAL</code></h2><p>对于 <code>Android</code> 中很多子系统来说（如显示系统、音频系统等），<code>HAL</code> 都是必不可少的组成部分 —— <code>HAL</code> 是这些子系统与 <code>Linux Kernel</code> 驱动之间通信的统一接口。</p><p>对于 <code>Gralloc</code> 来说，它的硬件接口定义如下：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* hardware/libhardware/include/hardware/gralloc.h */</span>
<span class="token comment">/* 
 * Every hardware module must have a data structure named HAL_MODULE_INFO_SYM
 * and the fields of this data structure must begin with hw_module_t
 * followed by module specific information.
 */</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">gralloc_module_t</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">hw_module_t</span> common<span class="token punctuation">;</span>  
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>registerBuffer<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">gralloc_module_t</span> <span class="token keyword">const</span><span class="token operator">*</span> <span class="token keyword">module</span><span class="token punctuation">,</span> buffer_handle_t handle<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>unregisterBuffer<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">gralloc_module_t</span> <span class="token keyword">const</span><span class="token operator">*</span> <span class="token keyword">module</span><span class="token punctuation">,</span> buffer_handle_t handle<span class="token punctuation">)</span><span class="token punctuation">;</span>   

    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>lock<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">gralloc_module_t</span> <span class="token keyword">const</span><span class="token operator">*</span> <span class="token keyword">module</span><span class="token punctuation">,</span> buffer_handle_t handle<span class="token punctuation">,</span> 
                  <span class="token keyword">int</span> usage<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> t<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">,</span> <span class="token keyword">int</span> h<span class="token punctuation">,</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span> vaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>unlock<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">gralloc_module_t</span> <span class="token keyword">const</span><span class="token operator">*</span> <span class="token keyword">module</span><span class="token punctuation">,</span>buffer_handle_t handle<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>perform<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">gralloc_module_t</span> <span class="token keyword">const</span><span class="token operator">*</span> <span class="token keyword">module</span><span class="token punctuation">,</span><span class="token keyword">int</span> operation<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>lock_ycbcr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">gralloc_module_t</span> <span class="token keyword">const</span><span class="token operator">*</span> <span class="token keyword">module</span><span class="token punctuation">,</span>buffer_handle_t handle<span class="token punctuation">,</span>
					<span class="token keyword">int</span> usage<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> t<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">,</span> <span class="token keyword">int</span> h<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">android_ycbcr</span> <span class="token operator">*</span>ycbcr<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* reserved for future use */</span>
    <span class="token keyword">void</span><span class="token operator">*</span> reserved_proc<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span> gralloc_module_t<span class="token punctuation">;</span>
</code></pre></div><blockquote><p>从注释中可以看出：</p><ol><li>首先，每一个硬件模块都必须有一个名称为 <code>HAL_MODULE_INFO_SYM</code> 的变量。</li><li>其次，此变量的数据结构要以 <code>hw_module_t</code> 开头。</li></ol></blockquote><h2 id="_3-gralloc-与-framebuffer" tabindex="-1"><a class="header-anchor" href="#_3-gralloc-与-framebuffer" aria-hidden="true">#</a> 3 <code>Gralloc</code> 与 <code>Framebuffer</code></h2><p><code>Framebuffer</code> 是内核系统提供的图形硬件的抽象描述。之所以称为 <code>buffer</code>，是因为它也占用了系统存储空间的一部分，是一块包含屏幕显示信息的缓冲区。 由此可见，在 “一切都是文件” 的 <code>Linux</code> 系统中，<code>Framebuffer</code> 被看成了终端显示设备的 “化身”。</p><p>在 <code>Android</code> 系统中，<code>Framebuffer</code> 提供的设备文件节点是 <code>/dev/graphics/fb*</code>。 因为理论上支持多个屏幕显示，所以 <code>fb</code> 按数字序号进行排列，即 <code>fb0</code>、<code>fb1</code> 等。其中第一个 <code>fb0</code> 是主显示屏幕，必须存在。</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAO4AAAAvCAYAAADkWvYzAAAJoklEQVR4nO2dz2siyxbHv/fx/oi0NEP7Nu9tjRMJQ0P2EYfMZRYNokvFzQUDJmQxWSQLMYEId3FlXCqBXgx3LleSvSBDyEzin2AziJ3/4r1FVbfVP23tVrvz6gMDY2y7v3bXqTrnVNXxl3//51//BSfZyA30K1nHn8ddBTejiC9VV1HdGeDT6S20aE/NWYJfuOFyOMnjH9sWwOFwlocbLoeTQLjhcjgJhBsuh5NAuOEGQFLa6LeKkBYd02tAjomebSLX1eD65Ab6vSWOjzvG9zH+1Q/Wcpl/hvq0VMTVRQEvXtMOHtMU+v0ZTtSJz3FP+Fy+BjnlAY57NWQ8JLBTHnJdRZU50HGdlTjAr4cCxt24TH/ETc9r4gDHvRwey9cYIQ2l1cTueMk2NLpGaQSAfj6/JqXhDDcQrBG6IDfQr6Rwd65ApS1Rrquo9hpA+RojDHFTHnp+bjYlLyWlTeYXy7RByw30K00cT0POZco5ZPCEzxHPh65M3PSExWzoMUASsWO+eIOUALwMwnb862HrrrK8lwXGf5lGCwCj708AUhA9fac0lIL1c5paR4ldFDD6gjsdyOyFcVXIdfT7L94dz0aJm55XiD7DdNsaAuAcceUG+hXgcxeoVrIgI+Yjcr0aMtBxd17Hw34bl4eC+RGhoqJfMV4tGGHd2BEhAabRSWIKwAxTL19Q/oi8oOOu4zISLzj3/DtmgXEHpbbPOaR32BV0PHdcel0aJgiWP878j9GZFUeeYQYNDdy0+eiRFOszMTHOYzzX8heIrSbygu19A9+whXpD6KD0PcccR9oF2/niZQrNci5bu7Bfx+dZWEMgl2u5hGRLrRqzPafLXmH+XkVFv7JCm15ESM0ernIW1cIAn8qP+LV3hPetIzyfn2FWayL/4QBqu46SisUxrnGunooqfWWPO0dfB3h/UcBlL0VujtzA5aEA/f53jxtFR1t9gAffII+4OhhPV44F5Q8FCG7XoTd93FVwQkUSw7Ef4wwBLlsgxqt9w7NeQL5QhDRiPAU5RzrIr85G7KXHuPb8Wl7Gn0W1l4V+f4bS6YQ+vxqO5SF5flIRV3uPKJWv6fEkTqu2ipiy3kymhn7mCZ/LCkb0e1UvGpiyjTtTQ39ngE/la2hu5wkUC9L3BNZw0lDqRUhtpgOkz2LlkEi7xUn5ltzHzA/yfMyOLmKDBSLR7OkqjwfGgxIgvFhd2cCMrlEqK/N/5wPgsGnNtGm3OCmf4U4nBm40ds+EgPQOuwKrzx25XvM0AFOX32iLA+Qybtcx3PSOz003XNrfrSHA1wF04S32JQCYQB08AeZrqnsvC+g/XDolLz2AKAi2zwzxOIbpbbCMu8y91aZ4AbAjpunrW5xY7skED2MdEFIQLWexjkCjrwPoyCLHptRZ78LzPP5Iym/EszpnjWcCtc3cAzEFAbqZ6wjNy+odfWAi0Owx4lpPqus/V78Ci3aLP+7f4vIwBxlD8jAMN2XcQel0SHq9CxV5D9fJGHX+8OmpJKWNagYOw1kGSTnySAKRkXw88DN6cowgNNE/dL6bEkF899EjxpUadvfTULUJTON0yRh76wGmug5k3mJfuoVGR9xcBtDvv9nOY28szsSfPTNPsIUA9jjQ0gFEl8whHdICz2r0BXeFJvIXKvIIt7FCFOahhiSmAP3HeuLdCDRvIKvsBk08aWkoNWq01Eg1tY7StIF+hXHhDKQi3ns0bPMQI9Ybd0JMBaWxn/Fz14OxeDpqiD/vj3CZeQdJnUDzzBj769GmMwBZsyEAIDHjkt+fGK01hnSEAD68TLeRgZ1APVWgguqn+ZZlpgKtnVUN/V6N/r+Ay14homnFaDVv3HCtvSgZmfSxbUSfzqDDOf8rfyhAwBP+9rImGh8vTDotwi8pRbGPLqS3Nkamn5jpQEZ4g0UjkPbwA/ohGS3FPRJ/Or6erx7DLQ/buNIQd+DI8AdCErEDHc8RD0/EkyDudRBJozYTcxudYeDPkXg6NSCjn5mEC9OO1qg53HQQdZGCTrkYLuw8TiOxmHD4GxQ2zqMG+ugy2npOhdCAP5DRGqtbPFa1yB8KEDwbsKH5o7lKyule0vg1U8OVkvbXon3Dsy5gd7+IXEbH84PT+Pz1EAThjf91FjLBlPi7Zlzsmam2cIDji8X6VkFT/8IYWVQtq6pocsrzU7QDWjpWpclM5hyRhYgLWV5zyBF3iJtzEVcXrHsxT1w4HrzOLJCgjNoKUFdRZd08lyklw5g/u44q1OUGSDbT1EJYLoYw4kxv4x+1zyC2mma2XL8/Q+n7R2ZKDCQBBrIIxBLn6vZN6MTI8xUSMtx4JaU89UygdgbYvXB+72Wn5kbtDnK92nw6RB/gUzeFy4rtQKFgmTLR78+WdssdbUMw9LOu+hA35Z9QWk3meuR9zes8QAiPK3ySK8j3ikIz30hvg9zU2XqmAVZgsR4y9bPjcJV95oNDwCtgxIOtr5yKF0YSKC4rkwLosSzTc/59c+4eZ5PwEfc1wGtO/d/BDZfDSSDcVeZwEgg3XA4ngXDD5XASCDdcDieBLF6AYc9Y0gUEYpyzi1wz55Xjb7g++wYDb8+ybyaPeEGA6/XCagbmhuRY6bQGItC8nnpbnLji6ypL+28h6AP8uepcILPRnuzJ7WCcqa2t8h0QgWYc4Linor83w50epTJvwmqe19ui97n7BOGwieNNlJzkbAVfw2X3Jy7PfMvefBQZ4qb7BGSOLJsKoiS05lYN6Cootb9FpmkR4TSvq94WJ86E22TgqCvELhB333Au75Fj55vHN4yvZrJPMnb4avbBrd4W51XgUSyOXT5n3QliicMsdYVonFUr4uH0Fppjj6ZRp7aDu50a8gH2qgYmKs3RqImB5vD1tjjxxmm4TJ3bhetSbYkbUviNllARU0wFRLJTBV0FJ6M0FK/q5qsSleZNtvI1avatt8V5FUQ7j6tN8QKB1FSazqADgFjEVe8Is3NrxjQ2u1ZYzUnBR3MU9bY48Sdaw2W3mNHGla+k8HeZjcfYSgMxwGtbXJzx0BxNvS1OEojWcC1lJ0ndJYwfrXtJad1gtxItWyHq8p6bwE1zVPW2OIkgQsM9wHGF/VmQed2l+Xyi/ZhtEzc9QXDRvEy9Lc6rYOXpIFKBb0HtIbPu0vwnSlapTxQVQTQ76wHNj1/HxvRFLNYcZb0tTlLgG+k5nATCdwdxOAmEGy6Hk0C44XI4CYQbLoeTQLjhcjgJhBsuh5NAuOFyOAmEG24AJKWNfsvvF+LoMb0GNlF0IoiebSLX1eD6jF9OjPH3iSP/A4I83dYQN6qSAAAAAElFTkSuQmCC" alt="" loading="lazy"></p><p><code>Android</code> 的各子系统通常不会直接使用内核驱动，而是由 <code>HAL</code> 层来间接引用底层架构。显示系统中也同样如此 —— 它借助于 <code>HAL</code> 层来操作帧缓冲区，而完成这一中介任务的就是 <code>Gralloc</code>。</p><h3 id="_3-1-gralloc-模块的加载" tabindex="-1"><a class="header-anchor" href="#_3-1-gralloc-模块的加载" aria-hidden="true">#</a> 3.1 <code>Gralloc</code> 模块的加载</h3><p><code>Gralloc</code> 对应的模块是由 <code>FramebufferNativeWindow</code> 在构造函数中加载的。即：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token function">hw_get_module</span><span class="token punctuation">(</span>GRALLOC_HARDWARE_MODULE_ID<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token keyword">module</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><p>函数 <code>hw_get_module</code> 是上层使用者加载 <code>HAL</code> 库的入口，这意味着不论是哪个硬件厂商提供的 <code>HAL</code> 库（比如 <code>Gralloc</code> 库），我们都只需要通过这个函数来加载它们。</p></blockquote><p>可以看到，针对 <code>Gralloc</code> 传入的硬件模块 <code>ID</code> 名为：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">GRALLOC_HARDWARE_MODULE_ID</span> <span class="token string">&quot;gralloc&quot;</span></span>
</code></pre></div><p>按照 <code>hw_get_module</code> 的做法，它会在如下路径中查找与 <code>ID</code> 值匹配的库。</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">HAL_LIBRARY_PATH1</span> <span class="token string">&quot;/system/lib/hw&quot;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">HAL_LIBRARY_PATH2</span> <span class="token string">&quot;/vendor/lib/hw&quot;</span></span>
</code></pre></div><p><code>lib</code> 库名有如下几种形式：</p><div class="language-text ext-text"><pre class="language-text"><code>gralloc.[ro.hardware].so 
gralloc.[ro.product.board].so 
gralloc.[ro.board.platform].so 
gralloc.[ro.arch].so
</code></pre></div><p>或者当上述系统属性组成的文件名都不存在时，就使用默认的：</p><div class="language-text ext-text"><pre class="language-text"><code>gralloc.default.so
</code></pre></div><blockquote><p>这个 <code>default</code> 库是 <code>Android</code> 原生态的实现，源码位置在 <code>hardware/libhardware/modules/gralloc/</code> 中，它由 <code>gralloc.cpp</code>、<code>framebuffer.cpp</code> 和 <code>mapper.cpp</code> 三个主要源文件编译生成。</p></blockquote><h3 id="_3-2-gralloc-提供的接口" tabindex="-1"><a class="header-anchor" href="#_3-2-gralloc-提供的接口" aria-hidden="true">#</a> 3.2 <code>Gralloc</code> 提供的接口</h3><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* hardware/libhardware/include/hardware/gralloc.h */</span>
<span class="token comment">/* 
 * Every hardware module must have a data structure named HAL_MODULE_INFO_SYM
 * and the fields of this data structure must begin with hw_module_t
 * followed by module specific information.
 */</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">gralloc_module_t</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">hw_module_t</span> common<span class="token punctuation">;</span>  
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>registerBuffer<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">gralloc_module_t</span> <span class="token keyword">const</span><span class="token operator">*</span> <span class="token keyword">module</span><span class="token punctuation">,</span> buffer_handle_t handle<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>unregisterBuffer<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">gralloc_module_t</span> <span class="token keyword">const</span><span class="token operator">*</span> <span class="token keyword">module</span><span class="token punctuation">,</span> buffer_handle_t handle<span class="token punctuation">)</span><span class="token punctuation">;</span>   

    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>lock<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">gralloc_module_t</span> <span class="token keyword">const</span><span class="token operator">*</span> <span class="token keyword">module</span><span class="token punctuation">,</span> buffer_handle_t handle<span class="token punctuation">,</span> 
                  <span class="token keyword">int</span> usage<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> t<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">,</span> <span class="token keyword">int</span> h<span class="token punctuation">,</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span> vaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>unlock<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">gralloc_module_t</span> <span class="token keyword">const</span><span class="token operator">*</span> <span class="token keyword">module</span><span class="token punctuation">,</span>buffer_handle_t handle<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>perform<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">gralloc_module_t</span> <span class="token keyword">const</span><span class="token operator">*</span> <span class="token keyword">module</span><span class="token punctuation">,</span><span class="token keyword">int</span> operation<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>lock_ycbcr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">gralloc_module_t</span> <span class="token keyword">const</span><span class="token operator">*</span> <span class="token keyword">module</span><span class="token punctuation">,</span>buffer_handle_t handle<span class="token punctuation">,</span>
					<span class="token keyword">int</span> usage<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> t<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">,</span> <span class="token keyword">int</span> h<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">android_ycbcr</span> <span class="token operator">*</span>ycbcr<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* reserved for future use */</span>
    <span class="token keyword">void</span><span class="token operator">*</span> reserved_proc<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span> gralloc_module_t<span class="token punctuation">;</span>
</code></pre></div><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/*hardware/libhardware/include/hardware/Hardware.h*/</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">hw_module_t</span> <span class="token punctuation">{</span>
    …
    <span class="token keyword">struct</span> <span class="token class-name">hw_module_methods_t</span><span class="token operator">*</span> methods<span class="token punctuation">;</span> <span class="token comment">//一个 HAL 库必须提供的方法</span>
    …
<span class="token punctuation">}</span> hw_module_t<span class="token punctuation">;</span>


<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">hw_module_methods_t</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>open<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">hw_module_t</span><span class="token operator">*</span> <span class="token keyword">module</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> id<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">hw_device_t</span><span class="token operator">*</span><span class="token operator">*</span> device<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> hw_module_methods_t<span class="token punctuation">;</span>
</code></pre></div><p>以上给出了三个结构体的定义：<code>gralloc_module_t</code>、<code>hw_module_t</code>、<code>hw_module_methods_t</code>。注意：</p><div class="language-text ext-text"><pre class="language-text"><code>硬件接口的抽象涉及了继承关系 —— “抽象的硬件” 是父类，而 “具体的硬件” 则是子类。
这在 C++ 中很容易实现，但是 HAL 多数是由 C 语言实现的，怎么办呢？
其实很简单，只要让子类数据结构的第一个成员变量是父类结构即可。

类似于 Gralloc 的硬件接口定义（gralloc_module_t），
任何硬件设备的 HAL 库都必须实现 hw_module_methods_t。目前 hw_module_methods_t 结构体中只有一个函数指针变量，即 open。
当上层使用者调用 hw_get_module 时，系统首先在指定目录中查找并加载正确的 HAL 库，然后通过 open 方法来打开指定的设备。
</code></pre></div><p>在 <code>Gralloc</code> 中，<code>open</code> 接口可以帮助上层使用者打开两种设备。分别是：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">GRALLOC_HARDWARE_FB0</span> <span class="token string">&quot;fb0&quot;</span>   <span class="token comment">// fb0  就是我们前面所说的 “主屏幕”</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">GRALLOC_HARDWARE_GPU0</span> <span class="token string">&quot;gpu0&quot;</span> <span class="token comment">// gpu0 负责图形缓冲区的分配和释放</span></span>
</code></pre></div><p>这两个设备分别由 <code>FramebufferNativeWindow</code> 中的 <code>fbDev</code> 和 <code>grDev</code> 成员变量来管理：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/*frameworks/native/libs/ui/FramebufferNativeWindow.cpp*/</span>
<span class="token class-name">FramebufferNativeWindow</span><span class="token double-colon punctuation">::</span><span class="token function">FramebufferNativeWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">BASE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">fbDev</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">grDev</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">mUpdateOnDemand</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    err <span class="token operator">=</span> <span class="token function">framebuffer_open</span><span class="token punctuation">(</span><span class="token keyword">module</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>fbDev<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打开 fb 设备（即 framebuffer 设备）</span>
    err <span class="token operator">=</span> <span class="token function">gralloc_open</span><span class="token punctuation">(</span><span class="token keyword">module</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>grDev<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打开 gralloc 设备</span>
</code></pre></div><blockquote><p>上述代码段中的两个 <code>xxx_open</code> 函数由 <code>hardware/libhardware/include/hardware</code> 目录下的 <code>fb.h</code> 和<code> gralloc.h</code> 头文件提供，用于打开 <code>fb</code> 及 <code>gralloc</code> 设备。</p><p>注意：</p><ol><li><code>FramebufferNativeWindow.cpp</code> 在高版本的源代码中已经不存在了，但打开 <code>fb</code> 和 <code>gralloc</code> 设备还是会调用 <code>framebuffer_open</code> 和 <code>gralloc_open</code> 这两个函数。</li><li><code>framebuffer_open</code> 和 <code>gralloc_open</code> 最终调用的肯定还是 <code>hw_module_methods_t</code> 中的 <code>open</code> 方法，只是函数参数有所差异：</li></ol><div class="language-text ext-text"><pre class="language-text"><code>fb      对应的设备名为 GRALLOC_HARDWARE_FB0；
gralloc 对应的设备名为 GRALLOC_HARDWARE_GPU0。
</code></pre></div></blockquote><p><code>Android</code> 原生态的 <code>Gralloc</code> 实现在 hardware/libhardware/modules/gralloc 中，由 <code>gralloc.cpp</code>、<code>framebuffer.cpp</code> 和 <code>mapper.cpp</code> 三个主要源文件编译生成。</p><p>原生态的 <code>Gralloc</code> 实现中，<code>open</code> 方法接口对应的是 <code>gralloc_device_open@Gralloc.cpp</code>。这个函数会根据设备名来判断是打开 <code>fb</code> 还是 <code>gralloc</code> 设备。</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/*hardware/libhardware/modules/gralloc/gralloc.cpp*/</span>
<span class="token keyword">int</span> <span class="token function">gralloc_device_open</span><span class="token punctuation">(</span><span class="token keyword">const</span> hw_module_t<span class="token operator">*</span> <span class="token keyword">module</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">,</span> hw_device_t<span class="token operator">*</span><span class="token operator">*</span> device<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> status <span class="token operator">=</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> GRALLOC_HARDWARE_GPU0<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 打开 gralloc 设备</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        status <span class="token operator">=</span> <span class="token function">fb_device_open</span><span class="token punctuation">(</span><span class="token keyword">module</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> device<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 否则就是 fb 设备</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> status<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="_3-2-1-fb-设备的打开过程" tabindex="-1"><a class="header-anchor" href="#_3-2-1-fb-设备的打开过程" aria-hidden="true">#</a> 3.2.1 <code>fb</code> 设备的打开过程</h4><p><strong>先来大概看看 <code>fb</code> 设备（即 <code>framebuffer</code> 设备）的打开过程：</strong></p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/*hardware/libhardware/modules/gralloc/framebuffer.cpp*/</span>
<span class="token keyword">int</span> <span class="token function">fb_device_open</span><span class="token punctuation">(</span>hw_module_t <span class="token keyword">const</span><span class="token operator">*</span> <span class="token keyword">module</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">,</span> hw_device_t<span class="token operator">*</span><span class="token operator">*</span> device<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> status <span class="token operator">=</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> GRALLOC_HARDWARE_FB0<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 设备名是否正确</span>
       fb_context_t <span class="token operator">*</span>dev <span class="token operator">=</span> <span class="token punctuation">(</span>fb_context_t<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 分配 hw_device_t 空间，这是一个“壳” */</span>
       <span class="token function">memset</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 初始化</span>
       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
       dev<span class="token operator">-&gt;</span>device<span class="token punctuation">.</span>common<span class="token punctuation">.</span>close <span class="token operator">=</span> fb_close<span class="token punctuation">;</span> <span class="token comment">// 这几个接口是fb设备的核心</span>
       dev<span class="token operator">-&gt;</span>device<span class="token punctuation">.</span>setSwapInterval <span class="token operator">=</span> fb_setSwapInterval<span class="token punctuation">;</span>
       dev<span class="token operator">-&gt;</span>device<span class="token punctuation">.</span>post <span class="token operator">=</span> fb_post<span class="token punctuation">;</span>
       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
       private_module_t<span class="token operator">*</span> m <span class="token operator">=</span> <span class="token punctuation">(</span>private_module_t<span class="token operator">*</span><span class="token punctuation">)</span><span class="token keyword">module</span><span class="token punctuation">;</span>
       status <span class="token operator">=</span> <span class="token function">mapFrameBuffer</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 内存映射，以及参数配置</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
           <span class="token operator">*</span>device <span class="token operator">=</span> <span class="token operator">&amp;</span>dev<span class="token operator">-&gt;</span>device<span class="token punctuation">.</span>common<span class="token punctuation">;</span> <span class="token comment">// “壳” 和 “核心” 的关系</span>
       <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> status<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* hardware/libhardware/modules/gralloc/framebuffer.cpp */</span>
<span class="token keyword">struct</span> <span class="token class-name">fb_context_t</span> <span class="token punctuation">{</span>
    framebuffer_device_t  device<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* hardware/libhardware/include/hardware/fb.h */</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">framebuffer_device_t</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">hw_device_t</span> common<span class="token punctuation">;</span>

    <span class="token keyword">const</span> <span class="token keyword">uint32_t</span>  flags<span class="token punctuation">;</span>

    <span class="token keyword">const</span> <span class="token keyword">uint32_t</span>  width<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">uint32_t</span>  height<span class="token punctuation">;</span>

    <span class="token keyword">const</span> <span class="token keyword">int</span>       stride<span class="token punctuation">;</span>

    <span class="token keyword">const</span> <span class="token keyword">int</span>       format<span class="token punctuation">;</span>

    <span class="token keyword">const</span> <span class="token keyword">float</span>     xdpi<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">float</span>     ydpi<span class="token punctuation">;</span>

    <span class="token keyword">const</span> <span class="token keyword">float</span>     fps<span class="token punctuation">;</span>

    <span class="token keyword">const</span> <span class="token keyword">int</span>       minSwapInterval<span class="token punctuation">;</span>

    <span class="token keyword">const</span> <span class="token keyword">int</span>       maxSwapInterval<span class="token punctuation">;</span>

    <span class="token keyword">const</span> <span class="token keyword">int</span>       numFramebuffers<span class="token punctuation">;</span>

    <span class="token keyword">int</span> reserved<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>setSwapInterval<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">framebuffer_device_t</span><span class="token operator">*</span> window<span class="token punctuation">,</span> <span class="token keyword">int</span> interval<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>setUpdateRect<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">framebuffer_device_t</span><span class="token operator">*</span> window<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> top<span class="token punctuation">,</span> <span class="token keyword">int</span> width<span class="token punctuation">,</span> <span class="token keyword">int</span> height<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>post<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">framebuffer_device_t</span><span class="token operator">*</span> dev<span class="token punctuation">,</span> buffer_handle_t buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>compositionComplete<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">framebuffer_device_t</span><span class="token operator">*</span> dev<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>dump<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">framebuffer_device_t</span><span class="token operator">*</span> dev<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>buff<span class="token punctuation">,</span> <span class="token keyword">int</span> buff_len<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>enableScreen<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">framebuffer_device_t</span><span class="token operator">*</span> dev<span class="token punctuation">,</span> <span class="token keyword">int</span> enable<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">void</span><span class="token operator">*</span> reserved_proc<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span> framebuffer_device_t<span class="token punctuation">;</span>
</code></pre></div><p>数据类型 <code>fb_context_t</code> 里的唯一成员就是 <code>framebuffer_device_t</code>，这是对 <code>fb</code> 设备的统一描述。</p><p>一个标准的 <code>fb</code> 设备通常要提供如下接口实现：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* 将 buffer 数据 post 到显示屏上。要求 buffer 必须与屏幕尺寸一致，
	并且没有被locked。这样 buffer 内容将在下一次 VSYNC 中被显示出来。*/</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>post<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">framebuffer_device_t</span><span class="token operator">*</span> dev<span class="token punctuation">,</span> buffer_handle_t buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 设置两个缓冲区交换的时间间隔。</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>setSwapInterval<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">framebuffer_device_t</span><span class="token operator">*</span> window<span class="token punctuation">,</span> <span class="token keyword">int</span> interval<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 设置刷新区域，需要 framebuffer 驱动支持 “update-on-demand”。也就是说，在这个区域外的数据很可能被认为无效。</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>setUpdateRect<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">framebuffer_device_t</span><span class="token operator">*</span> window<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> top<span class="token punctuation">,</span> <span class="token keyword">int</span> width<span class="token punctuation">,</span> <span class="token keyword">int</span> height<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>我们再来解释下 <code>framebuffer_device_t</code> 中一些重要的成员变量，如下表所示。</p><table><tr align="left"><th>变量</th><th>描述</th></tr><tr><td>flags</td><td>标志位，指示 framebuffer 的属性配置</td></tr><tr><td>width、height</td><td>framebuffer 的宽和高,以像素为单位</td></tr><tr><td>format</td><td> framebuffer 的像素格式，比如： <ul><li>HAL_PIXEL_FORMAT_RGBA_88888</li><li>HAL_PIXEL_FORMAT_RGIBX_8888</li><li>HAL_PIXEL_FORMAT_RGB_888</li><li>HAL_PIXEL_FORMAT_RGB_565 等</li></ul></td></tr><tr><td>xdpi、ydpi</td><td>x 和 y 轴的密度（dot per inch）</td></tr><tr><td>xdpi、ydpi</td><td>x 和 y 轴的密度（dot per inch）</td></tr><tr><td>fps</td><td>屏幕的每秒刷新频率。假如无法从设备获取这个值，Android 系统会默认设置为 60Hz</td></tr><tr><td>minSwapInterval、maxSwapInterval</td><td>该 framebuffer 支持的最小和最大的缓冲交换时间</td></tr></table><p>系统打开 <code>Kernel</code> 层的 <code>fb</code> 设备以及对 <code>fb</code> 进行配置的操作是在 <code>mapFrameBuffer()</code> 中完成的。这个函数首先尝试打开如下路径中的 <code>fb</code> 设备：</p><blockquote><p><code>mapFrameBuffer</code> 函数内部调用 <code>open</code> 接口打开 <code>fb</code> 设备，权限为 <code>O_RDWR</code>。</p></blockquote><div class="language-text ext-text"><pre class="language-text"><code>&quot;/dev/graphics/fb%u&quot; 或者 &quot;/dev/fb%u&quot;
</code></pre></div><blockquote><p>其中 <code>%u</code> 表示不同的数字，代表不同的屏幕。</p></blockquote><div class="language-text ext-text"><pre class="language-text"><code>成功打开 fb 设备后，我们可以通过：

	ioctl(fd, FBIOGET_FSCREENINFO, &amp;finfo); 
	ioctl(fd, FBIOGET_VSCREENINFO, &amp;info)

来得到显示屏的一系列参数，同时通过：

	ioctl(fd, FBIOPUT_VSCREENINFO, &amp;info)

来对底层 fb 设备进行配置。
</code></pre></div><p>另外，函数 <code>mapFrameBuffer</code> 的另一重要任务就是为 <code>fb</code> 设备做内存映射。主要源码语句如下：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* hardware/libhardware/modules/gralloc/framebuffer.cpp */</span>
<span class="token comment">/* mapFrameBufferLocked 函数中 */</span>
<span class="token comment">/*
映射地址保存在 module-&gt;framebuffer-&gt;base。
变量 module 对应的是前面 hw_get_module(GRALLOC_HARDWARE_MODULE_ID, &amp;module) 得到的 hw_module_t
（hw_module_t 被强制类型转化为 private_module_t）。
*/</span>
<span class="token keyword">void</span><span class="token operator">*</span> vaddr <span class="token operator">=</span> <span class="token function">mmap</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> fbSize<span class="token punctuation">,</span> PROT_READ<span class="token operator">|</span>PROT_WRITE<span class="token punctuation">,</span> MAP_SHARED<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
<span class="token keyword">module</span><span class="token operator">-&gt;</span>framebuffer<span class="token operator">-&gt;</span>base <span class="token operator">=</span> <span class="token function">intptr_t</span><span class="token punctuation">(</span>vaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">memset</span><span class="token punctuation">(</span>vaddr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> fbSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="_3-2-2-gralloc-设备的打开过程" tabindex="-1"><a class="header-anchor" href="#_3-2-2-gralloc-设备的打开过程" aria-hidden="true">#</a> 3.2.2 <code>gralloc</code> 设备的打开过程</h4><p><strong>接下来再看看系统打开 <code>gralloc</code> 设备的过程，它相对于 <code>fb</code> 设备简单些。如下所示：</strong></p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code> <span class="token comment">/*hardware/libhardware/modules/gralloc/gralloc.cpp*/</span>
<span class="token keyword">int</span> <span class="token function">gralloc_device_open</span><span class="token punctuation">(</span><span class="token keyword">const</span> hw_module_t<span class="token operator">*</span> <span class="token keyword">module</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">,</span> hw_device_t<span class="token operator">*</span><span class="token operator">*</span> device<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> status <span class="token operator">=</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> GRALLOC_HARDWARE_GPU0<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        gralloc_context_t <span class="token operator">*</span>dev<span class="token punctuation">;</span> <span class="token comment">// 做法和 fb 类似</span>
        dev <span class="token operator">=</span> <span class="token punctuation">(</span>gralloc_context_t<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 分配空间</span>
        <span class="token comment">/* initialize our state here */</span>
        <span class="token function">memset</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        dev<span class="token operator">-&gt;</span>device<span class="token punctuation">.</span>alloc <span class="token operator">=</span> gralloc_alloc<span class="token punctuation">;</span> <span class="token comment">// 从提供的接口来看，gralloc 主要负责 “分配和释放” 操作</span>
        dev<span class="token operator">-&gt;</span>device<span class="token punctuation">.</span>free <span class="token operator">=</span> gralloc_free<span class="token punctuation">;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>上述代码段中与 <code>fb</code> 相似的部分我们就不多做介绍了。</p></blockquote><p>因为 <code>gralloc</code> 担负着图形缓冲区的分配与释放，所以它提供的两个最重要的接口是 <code>alloc</code> 和 <code>free</code>。这里暂时先不深入分析，后续会有讲解。</p><h2 id="_4-android-中的本地窗口" tabindex="-1"><a class="header-anchor" href="#_4-android-中的本地窗口" aria-hidden="true">#</a> 4 <code>Android</code> 中的本地窗口</h2><p>在 <a href="#_9-1-opengl-es-%E4%B8%8E-egl"><code>OpenGL ES</code> 与 <code>EGL</code></a> 小节中提到了 “本地窗口”（<code>Native Window</code>）这一概念。</p><p>本地窗口是 <code>OpenGL</code> 能否兼容多种系统（如 <code>Windows</code>，<code>Android</code>）的关键。</p><p>那么对于 <code>Android</code> 系统来说，它是如何将 <code>OpenGL ES</code> 本地化的呢？或者说，它提供了什么样的本地窗口？</p><p>根据整个 <code>Android</code> 系统的 <code>GUI</code> 设计理念，我们不难猜想到至少需要两种本地窗口。</p><div class="language-text ext-text"><pre class="language-text"><code>面向管理者（SurfaceFlinger）
	既然 SurfaceFlinger 扮演了系统中所有 UI 界面的管理者，那么它无可厚非需要直接或间接地持有 “本地窗口”。
	我们知道，这个窗口就是 FramebufferNativeWindow。

面向应用程序
	这类本地窗口是 Surface。
</code></pre></div><p>为什么需要两种本地窗口呢？</p><div class="language-text ext-text"><pre class="language-text"><code>因为一个系统设备中显然只会有一个帧缓冲区 framebuffer，但一个系统设备中可以同时运行多个 UI 程序。

为了能够让多个 UI 程序有序地进行显示，我们需要为每个 UI 程序单独地分配本地窗口，
为 UI 程序单独分配本地窗口其实就是单独分配一个内存缓存区来保存显示数据。

而 SurfaceFlinger 所持有的本地窗口就是能直接显示在屏幕上的帧缓冲区 framebuffer。
SurfaceFlinger 作为管理者，会收集所有 UI 程序的内存缓冲区中的显示数据，
并进行统一的图像混合操作，然后输出到帧缓冲区 framebuffer 中。
</code></pre></div><h3 id="_4-1-framebuffernativewindow" tabindex="-1"><a class="header-anchor" href="#_4-1-framebuffernativewindow" aria-hidden="true">#</a> 4.1 <code>FramebufferNativeWindow</code></h3><p>EGL 需要通过本地窗口来为<code> OpenGL/OpenGL ES</code> 创造环境。其函数原型如下：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code>EGLSurface <span class="token function">eglCreateWindowSurface</span><span class="token punctuation">(</span>EGLDisplay dpy<span class="token punctuation">,</span> EGLConfig config<span class="token punctuation">,</span> NativeWindowType window<span class="token punctuation">,</span> <span class="token keyword">const</span> EGLint <span class="token operator">*</span>attrib_list<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>从函数原型来看，不论是哪一类本地窗口，都必须要与 NativeWindowType 保持一致，否则就无法正常使用 EGL 了。</p><p>先从数据类型的定义来看看这个 window 参数有什么特别之处：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/*frameworks/native/opengl/include/egl/Eglplatform.h*/</span>
<span class="token keyword">typedef</span> EGLNativeWindowType NativeWindowType<span class="token punctuation">;</span> <span class="token comment">// NativeWindowType 其实就是 EGLNativeWindowType</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">defined</span><span class="token punctuation">(</span>_WIN32<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">defined</span><span class="token punctuation">(</span>__VC32__<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">defined</span><span class="token punctuation">(</span>__CYGWIN__<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">defined</span><span class="token punctuation">(</span>__SCITECH_SNAP__<span class="token punctuation">)</span></span></span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">typedef</span> HWND  EGLNativeWindowType<span class="token punctuation">;</span> <span class="token comment">/* Win32 和 WinCE系统下的定义 */</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">elif</span> <span class="token expression"><span class="token function">defined</span><span class="token punctuation">(</span>__WINSCW__<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">defined</span><span class="token punctuation">(</span>__SYMBIAN32__<span class="token punctuation">)</span>  </span></span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token operator">*</span>EGLNativeWindowType<span class="token punctuation">;</span> <span class="token comment">/* Symbian系统 */</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">elif</span> <span class="token expression"><span class="token function">defined</span><span class="token punctuation">(</span>__ANDROID__<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">defined</span><span class="token punctuation">(</span>ANDROID<span class="token punctuation">)</span></span></span>
<span class="token keyword">struct</span> <span class="token class-name">ANativeWindow</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">ANativeWindow</span><span class="token operator">*</span> EGLNativeWindowType<span class="token punctuation">;</span> <span class="token comment">/* Android系统 */</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">elif</span> <span class="token expression"><span class="token function">defined</span><span class="token punctuation">(</span>__unix__<span class="token punctuation">)</span></span></span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">typedef</span> Window   EGLNativeWindowType<span class="token punctuation">;</span> <span class="token comment">/* UNIX系统 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">error</span> <span class="token string">&quot;Platform not recognized&quot;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre></div><p>以上代码中，不同的操作系统平台下 <code>EGLNativeWindowType</code> 所对应的具体数据类型如下表所示：</p><table><thead><tr><th style="text-align:left;"><strong>操作系统</strong></th><th style="text-align:left;"><strong>数据类型</strong></th></tr></thead><tbody><tr><td style="text-align:left;">Win32、WinCE</td><td style="text-align:left;">HWND，即句柄</td></tr><tr><td style="text-align:left;">Symbian</td><td style="text-align:left;">Void*</td></tr><tr><td style="text-align:left;">Android`</td><td style="text-align:left;">ANativeWindow*</td></tr><tr><td style="text-align:left;">UNIX</td><td style="text-align:left;">Window</td></tr><tr><td style="text-align:left;">其他</td><td style="text-align:left;">暂时不支持</td></tr></tbody></table><p><code>ANativeWindow</code> 的定义在 <code>window.h</code> 头文件中：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/*system/core/include/system/window.h*/</span>
<span class="token keyword">struct</span> <span class="token class-name">ANativeWindow</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">const</span> <span class="token keyword">uint32_t</span> flags<span class="token punctuation">;</span> <span class="token comment">// 与 Surface 或 updater 有关的属性</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> minSwapInterval<span class="token punctuation">;</span> <span class="token comment">// 所支持的最小交换间隔时间</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> maxSwapInterval<span class="token punctuation">;</span> <span class="token comment">// 所支持的最大交换间隔时间</span>
    <span class="token keyword">const</span> <span class="token keyword">float</span> xdpi<span class="token punctuation">;</span> <span class="token comment">// 水平方向的密度，以 dpi 为单位</span>
    <span class="token keyword">const</span> <span class="token keyword">float</span> ydpi<span class="token punctuation">;</span> <span class="token comment">// 垂直方向的密度，以 dpi 为单位</span>
    intptr_t oem<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//为OEM定制驱动所保留的空间</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>setSwapInterval<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ANativeWindow</span><span class="token operator">*</span> window<span class="token punctuation">,</span> <span class="token keyword">int</span> interval<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>dequeueBuffer<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ANativeWindow</span><span class="token operator">*</span> window<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">ANativeWindowBuffer</span><span class="token operator">*</span><span class="token operator">*</span> buffer<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> fenceFd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>queueBuffer<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ANativeWindow</span><span class="token operator">*</span> window<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">ANativeWindowBuffer</span><span class="token operator">*</span> buffer<span class="token punctuation">,</span> <span class="token keyword">int</span> fenceFd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>cancelBuffer<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ANativeWindow</span><span class="token operator">*</span> window<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">ANativeWindowBuffer</span><span class="token operator">*</span> buffer<span class="token punctuation">,</span> <span class="token keyword">int</span> fenceFd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>query<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">ANativeWindow</span><span class="token operator">*</span> window<span class="token punctuation">,</span><span class="token keyword">int</span> what<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>perform<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ANativeWindow</span><span class="token operator">*</span> window<span class="token punctuation">,</span><span class="token keyword">int</span> operation<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span><span class="token operator">*</span> reserved_proc<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p><code>ANativeWindow</code> 结构体中几个重要成员函数如下表所示：</p><table><tr align="left"><th>Member Function</th><th>Description</th></tr><tr><td>setSwapInterval</td><td>设置交换间隔时间</td></tr><tr><td>dequeueBuffer</td><td>EGL 通过这个接口来申请一个 buffer。从前面我们所举的例子来说，两个本地窗口所提供的 buffer 分别来自于帧缓冲区和内存空间。<br> 单词 dequeue 的字面意思是出队列。这从侧面告诉我们，一个 Window 所包含的 buffer 很可能不止一份</td></tr><tr><td>queueBuffer</td><td>当 EGL 对一块 buffer 渲染完成后，它调用这个接口来 unlock 和 post buffer</td></tr><tr><td>cancelBuffer</td><td>这个接口可以用来取消一个已经 dequeued 的 buffer，但要特别注意同步的问题</td></tr><tr><td>query</td><td>用于向本地窗口咨询相关信息</td></tr><tr><td>perform</td><td> 用于执行本地窗口支持的各种操作，比如: <ul><li>NATIVE_WINDOW_SET_USAGE</li><li>NATIVE_WINDOW_SET_CROP</li><li>NATIVE_WINDOW_SET_BUFFER_COUNT</li><li>NATIVE_WINDOW_SET_BUFFERS_TRANSFORM</li><li>NATIVE_WINDOW_SET_BUFFERS_TIMESTAMP 等</li></ul></td></tr></table><p>从上面对 <code>ANativeWindow</code> 的描述可以看出，它更像一份 “协议”，规定了一个本地窗口的形态和功能。这对于支持多种本地窗口的系统是必需的，因为只有这样我们才能针对某种特定的平台窗口来填充具体的实现。</p><p>这个小节中我们需要分析 <code>FramebufferNativeWindow</code> 是如何履行这份 “协议” 的。</p><p><code>FramebufferNativeWindow</code> 本身代码并不多，下面分别选取其构造函数及 <code>dequeue</code> 函数来分析。其他部分的实现都类似，大家可以参考阅读。</p><blockquote><p>注意：</p><p>高版本中，<code>FramebufferNativeWindow</code> 已被移除，实现了 ANativeWindow 接口的子类只发现如下两个：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code>frameworks<span class="token operator">/</span>native<span class="token operator">/</span>services<span class="token operator">/</span>surfaceflinger<span class="token operator">/</span>CompositionEngine<span class="token operator">/</span>include<span class="token operator">/</span>compositionengine<span class="token operator">/</span>mock<span class="token operator">/</span>NativeWindow<span class="token punctuation">.</span>h
frameworks<span class="token operator">/</span>native<span class="token operator">/</span>libs<span class="token operator">/</span>gui<span class="token operator">/</span>include<span class="token operator">/</span>gui<span class="token operator">/</span>Surface<span class="token punctuation">.</span>h
</code></pre></div><p>高版本的差异再后续更新文档时再补充。</p></blockquote><h4 id="_4-1-1-构造函数中的初始化操作" tabindex="-1"><a class="header-anchor" href="#_4-1-1-构造函数中的初始化操作" aria-hidden="true">#</a> 4.1.1 构造函数中的初始化操作</h4><p>根据 FramebufferNativeWindow 所完成的功能，可以大概推测出它的构造函数里应该至少完成如下初始化操作。</p><div class="language-text ext-text"><pre class="language-text"><code>1. 加载 GRALLOC_HARDWARE_MODULE_ID 模块（即 Gralloc 模块），详细流程在 Gralloc 小节已经解释过了。
2. 分别打开 fb 和 gralloc 设备。我们在 Gralloc 小节也已经分析过，打开后的设备由全局变量 fbDev 和 grDev 管理。
3. 根据设备的属性来给 FramebufferNativeWindow 赋初值。
4. 根据 FramebufferNativeWindow 的实现来填充 ANativeWindow 中的 “协议”。
5. 其他一些必要的初始化。
</code></pre></div><p>下面从源码的角度来分析上述每个步骤具体是怎么实现的：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* frameworks/native/libs/ui/FramebufferNativeWindow.cpp */</span>
<span class="token class-name">FramebufferNativeWindow</span><span class="token double-colon punctuation">::</span><span class="token function">FramebufferNativeWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">BASE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">fbDev</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">grDev</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">mUpdateOnDemand</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    hw_module_t <span class="token keyword">const</span><span class="token operator">*</span> <span class="token keyword">module</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">hw_get_module</span><span class="token punctuation">(</span>GRALLOC_HARDWARE_MODULE_ID<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token keyword">module</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 加载模块</span>
		<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">int</span> stride<span class="token punctuation">;</span>
        <span class="token keyword">int</span> err<span class="token punctuation">;</span>
        <span class="token keyword">int</span> i<span class="token punctuation">;</span>
        err <span class="token operator">=</span> <span class="token function">framebuffer_open</span><span class="token punctuation">(</span><span class="token keyword">module</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>fbDev<span class="token punctuation">)</span><span class="token punctuation">;</span>
        err <span class="token operator">=</span> <span class="token function">gralloc_open</span><span class="token punctuation">(</span><span class="token keyword">module</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>grDev<span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token comment">// 分别打开 fb 和 gralloc</span>
        <span class="token comment">/*上面这部分内容我们在前几个小节已经分析过了，不清楚的可以回头看一下*/</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>fbDev<span class="token operator">-&gt;</span>numFramebuffers <span class="token operator">&gt;=</span> MIN_NUM_FRAME_BUFFERS <span class="token operator">&amp;&amp;</span>
            fbDev<span class="token operator">-&gt;</span>numFramebuffers <span class="token operator">&lt;=</span> MAX_NUM_FRAME_BUFFERS<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 根据fb设备属性获得buffer数</span>
            mNumBuffers <span class="token operator">=</span> fbDev<span class="token operator">-&gt;</span>numFramebuffers<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            mNumBuffers <span class="token operator">=</span> MIN_NUM_FRAME_BUFFERS<span class="token punctuation">;</span> <span class="token comment">// 否则就采用最少的 buffer 数值，即 2</span>
        <span class="token punctuation">}</span>
        mNumFreeBuffers <span class="token operator">=</span> mNumBuffers<span class="token punctuation">;</span> <span class="token comment">// 可用的 buffer 个数，初始时是所有 buffer 可用</span>
        mBufferHead <span class="token operator">=</span> mNumBuffers<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> mNumBuffers<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">// 给每个 buffer 初始化</span>
        <span class="token punctuation">{</span>
            buffers<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">NativeBuffer</span><span class="token punctuation">(</span>fbDev<span class="token operator">-&gt;</span>width<span class="token punctuation">,</span> fbDev<span class="token operator">-&gt;</span>height<span class="token punctuation">,</span> fbDev<span class="token operator">-&gt;</span>format<span class="token punctuation">,</span> GRALLOC_USAGE _HW_FB<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token operator">/</span> <span class="token operator">/</span>NativeBuffer是什么？

        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> mNumBuffers<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">// 给每个 buffer 分配空间</span>
        <span class="token punctuation">{</span>
            err <span class="token operator">=</span> grDev<span class="token operator">-&gt;</span><span class="token function">alloc</span><span class="token punctuation">(</span>grDev<span class="token punctuation">,</span> fbDev<span class="token operator">-&gt;</span>width<span class="token punctuation">,</span> fbDev<span class="token operator">-&gt;</span>height<span class="token punctuation">,</span> fbDev<span class="token operator">-&gt;</span>format<span class="token punctuation">,</span> GRALLOC_USAGE_HW_FB<span class="token punctuation">,</span> 
								<span class="token operator">&amp;</span>buffers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-&gt;</span>handle<span class="token punctuation">,</span> <span class="token operator">&amp;</span>buffers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-&gt;</span>stride<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token punctuation">}</span>

        <span class="token comment">/* 为本地窗口赋属性值 */</span>
        <span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">uint32_t</span><span class="token operator">&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>ANativeWindow<span class="token double-colon punctuation">::</span>flags<span class="token punctuation">)</span> <span class="token operator">=</span> fbDev<span class="token operator">-&gt;</span>flags<span class="token punctuation">;</span>
        <span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>ANativeWindow<span class="token double-colon punctuation">::</span>xdpi<span class="token punctuation">)</span> <span class="token operator">=</span> fbDev<span class="token operator">-&gt;</span>xdpi<span class="token punctuation">;</span>
        <span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>ANativeWindow<span class="token double-colon punctuation">::</span>ydpi<span class="token punctuation">)</span> <span class="token operator">=</span> fbDev<span class="token operator">-&gt;</span>ydpi<span class="token punctuation">;</span>
        <span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>ANativeWindow<span class="token double-colon punctuation">::</span>minSwapInterval<span class="token punctuation">)</span> <span class="token operator">=</span>fbDev<span class="token operator">-&gt;</span>minSwapInterval<span class="token punctuation">;</span>
        <span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>ANativeWindow<span class="token double-colon punctuation">::</span>maxSwapInterval<span class="token punctuation">)</span> <span class="token operator">=</span> fbDev<span class="token operator">-&gt;</span>maxSwapInterval<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">ALOGE</span><span class="token punctuation">(</span><span class="token string">&quot;Couldn&#39;t get gralloc module&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/* 以下代码段开始履行窗口 “协议” */</span>
    ANativeWindow<span class="token double-colon punctuation">::</span>setSwapInterval <span class="token operator">=</span> setSwapInterval<span class="token punctuation">;</span>
    ANativeWindow<span class="token double-colon punctuation">::</span>dequeueBuffer <span class="token operator">=</span> dequeueBuffer<span class="token punctuation">;</span>
    ANativeWindow<span class="token double-colon punctuation">::</span>queueBuffer <span class="token operator">=</span> queueBuffer<span class="token punctuation">;</span>
    ANativeWindow<span class="token double-colon punctuation">::</span>query <span class="token operator">=</span> query<span class="token punctuation">;</span>
    ANativeWindow<span class="token double-colon punctuation">::</span>perform <span class="token operator">=</span> perform<span class="token punctuation">;</span>

    <span class="token comment">/* 下面这几个接口已经被废弃了，不过为了保持兼容性，暂时还是保留的 */</span>
    ANativeWindow<span class="token double-colon punctuation">::</span>dequeueBuffer_DEPRECATED <span class="token operator">=</span> dequeueBuffer_DEPRECATED<span class="token punctuation">;</span>
    ANativeWindow<span class="token double-colon punctuation">::</span>lockBuffer_DEPRECATED <span class="token operator">=</span> lockBuffer_DEPRECATED<span class="token punctuation">;</span>
    ANativeWindow<span class="token double-colon punctuation">::</span>queueBuffer_DEPRECATED <span class="token operator">=</span> queueBuffer_DEPRECATED<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如上初始化代码中，我们重点关注 <code>FramebufferNativeWindow</code> 是如何分配 <code>buffer</code> 的。换句话说，其 <code>dequeue</code> 方法所获得的缓冲区是从何而来的。</p><div class="language-text ext-text"><pre class="language-text"><code>成员变量 mNumBuffers 代表了 FramebufferNativeWindow 所管理的 buffer 总数。它取决于两个方面：
1. 首先从 fb 设备中取值，即 numFramebuffers；
2. 否则就默认定义为 MIN_NUM_FRAME_BUFFERS。

如下所示：
    #define MIN_NUM_FRAME_BUFFERS 2 
    #define MAX_NUM_FRAME_BUFFERS 3

可见 Android 系统认为最少的 buffer 数为 2，最大为 3。
</code></pre></div><p>有人可能会觉得奇怪，既然 <code>FramebufferNativeWindow</code> 对应的是真实的物理屏幕，那么为什么还需要两个 <code>buffer</code> 呢？</p><p>考虑只有一个 <code>buffer</code> 的情况：</p><div class="language-text ext-text"><pre class="language-text"><code>这意味着绘制什么，屏幕上就要显示什么。
对于用户来说，将看到一个不断刷新的画面。通俗地讲，就是画面很 “卡”。
特别是对于图像刷新很频繁的场景（比如大型游戏），用户的体验就会更差。
</code></pre></div><p>那么，有什么解决的办法呢？</p><div class="language-text ext-text"><pre class="language-text"><code>我们知道，出现这种现象的原因就是程序直接以屏幕为绘图板，把还没有准备就绪的图像直接呈现给了用户。换句话说，
如果可以等到整幅图像绘制完成以后再刷新到屏幕上，那么用户在任何时候看到的都是正确而完整的画面，问题也就解决了。
</code></pre></div><p>也就是说，一个 <code>buffer</code> 用来保存绘制数据，一个 <code>buffer</code> 用来将保存的绘制数据刷新到屏幕上，如下图所示。</p><p><img src="/assets/03.431d864f.png" alt="" loading="lazy"></p><blockquote><p>上图表示的就是通常所称的 “双缓冲”（<code>Double-Buffering</code>）技术。 除此之外，其实还有三缓冲（<code>Triple Buffering</code>）、四缓冲（<code>Quad Buffering</code>）等， 我们将它们统称为 “多缓冲”（<code>Multiple Buffering</code>）机制。</p></blockquote><p>理解了为什么需要双缓冲以后，我们再回过头来看 <code>FramebufferNativeWindow</code> 的构造函数。</p><p>接下来要解决的另一个问题是：多个缓冲区空间是从哪里分配的？</p><p>通过前几个小节的知识可知，应该是要向 <code>HAL</code> 层的 <code>Gralloc</code> 申请。</p><div class="language-text ext-text"><pre class="language-text"><code>FramebufferNativeWindow 构造函数中的第一个 for 循环里先给各 buffer 创建相应的实例（new NativeBuffer），
其中的属性值都来源于 fbDev，如宽、高、格式等。

紧随其后的就是调用 Gralloc 设备的 alloc() 方法：

	/*
	函数原型：
	int (*alloc)(struct alloc_device_t* dev, int w, int h, int format, int usage, buffer_handle_t* handle, int* stride);
	*/
	err = grDev-&gt;alloc(grDev, fbDev-&gt;width, fbDev-&gt;height, fbDev-&gt;format, GRALLOC_USAGE_HW_FB, 
						&amp;buffers[i]-&gt;handle, &amp;buffers[i]-&gt;stride);

注意第 5 个参数，它代表所要申请的缓冲区的用途，
定义在 hardware/libhardware/include/hardware/gralloc.h 中，目前已经支持几十种。比如：

	GRALLOC_USAGE_HW_TEXTURE       // 缓冲区将用于OpenGL ES Texture。
	GRALLOC_USAGE_HW_RENDER        // 缓冲区将用于OpenGL ES的渲染。
	GRALLOC_USAGE_HW_2D            // 缓冲区会提供给2D 硬件图形设备。
	GRALLOC_USAGE_HW_COMPOSER      // 缓冲区用于HWComposer HAL模块。
	GRALLOC_USAGE_HW_FB            // 缓冲区用于framebuffer设备。
	GRALLOC_USAGE_HW_VIDEO_ENCODER // 缓冲区用于硬件视频编码器。

这里申请的缓冲区是要在终端屏幕上显示的，所以申请的 usage 类 型是 GRALLOC_USAGE_HW_FB，
对应的 Gralloc 中的实现是 gralloc_alloc_framebuffer@gralloc.cpp；

假如是其他用途的缓冲区申请，则对应 gralloc_alloc_buffer@gralloc.cpp。
不过，如果底层只允许一个 buffer（不支持 page-flipping 的情况），
那么 gralloc_alloc_framebuffer 也同样可能只返回一个 ashmem 中申请的 “内存空间”，真正的 “帧缓冲区” 则要在 post 时才会被用到。
</code></pre></div><p>所有申请到的缓冲区都需要由 <code>FramebufferNativeWindow</code> 中的全局变量 <code>buffers[MAX_NUM_FRAME_BUFFERS]</code> 来记录，</p><p>每个数据元素是一个 <code>NativeBuffer</code>。这个类的定义如下：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">NativeBuffer</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">ANativeObjectBase</span><span class="token operator">&lt;</span><span class="token class-name">ANativeWindowBuffer</span><span class="token punctuation">,</span> <span class="token class-name">NativeBuffer</span><span class="token punctuation">,</span> <span class="token class-name">LightRefBase</span><span class="token operator">&lt;</span><span class="token class-name">NativeBuffer</span><span class="token operator">&gt;&gt;</span></span>
<span class="token punctuation">{</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre></div><p>可见这个 “本地缓冲区” 继承了 <code>ANativeWindowBuffer</code> 的特性，后者的定义在 <code>/system/core/include/system/window.h</code> 中：</p><blockquote><p>高版本系统定义在了 <code>frameworks/native/libs/nativebase/include/nativebase/nativebase.h</code> 中。</p></blockquote><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">ANativeWindowBuffer</span>
<span class="token punctuation">{</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">int</span> width<span class="token punctuation">;</span> <span class="token comment">// 宽</span>
    <span class="token keyword">int</span> height<span class="token punctuation">;</span> <span class="token operator">/</span> <span class="token operator">/</span>高
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    buffer_handle_t handle<span class="token punctuation">;</span> <span class="token comment">/* 代表内存块的句柄，比如 ashmem 机制 */</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span> ANativeWindowBuffer_t<span class="token punctuation">;</span>
</code></pre></div><p>另外，当前可用（<code>free</code>）的 <code>buffer</code> 数量由 <code>mNumFreeBuffers</code> 管理，这个变量的初始值也是 <code>mNumBuffers</code>，即总共有 <code>2</code> 或 <code>3</code> 个可用缓冲区。</p><p>在程序后续的运行过程中，始终由 <code>mBufferHead</code> 来指向下一个将被申请的 <code>buffer</code>（注意：不是下一个可用 <code>buffer</code>）。</p><div class="language-text ext-text"><pre class="language-text"><code>也就是说，每当用户向 FramebufferNativeWindow 申请一个 buffer 时（dequeueBuffer），这个 mBufferHead 就会增加 1；
一旦它的值超过最大值，则还会变成 0，如此就实现了循环管理。后面在讲解 dequeueBuffer 时再详细解释。
</code></pre></div><p>一个本地窗口包含了很多属性值，如各种标志（<code>flags</code>）、横纵坐标的密度值等。这些数值都可以从 <code>fb</code> 设备中查询到，<code>我们需要将它们赋予刚生成的FramebufferNativeWindow</code> 实例的属性。</p><p>最后，就应该履行 <code>ANativeWindow</code> 的接口协议了。<code>FramebufferNativeWindow</code> 会将其对应的成员函数逐个填充到 <code>ANativeWindow</code> 的函数指针中，比如：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code>ANativeWindow<span class="token double-colon punctuation">::</span>setSwapInterval <span class="token operator">=</span> setSwapInterval<span class="token punctuation">;</span> 
ANativeWindow<span class="token double-colon punctuation">::</span>dequeueBuffer <span class="token operator">=</span> dequeueBuffer<span class="token punctuation">;</span>
</code></pre></div><p>这样子 <code>OpenGL ES</code> 才能通过一个 <code>ANativeWindow</code> 来与本地窗口系统建立正确的连接。</p><p>下面我们详细分析其中 <code>dequeueBuffer</code> 的实现。</p><h4 id="_4-1-2-dequeuebuffer" tabindex="-1"><a class="header-anchor" href="#_4-1-2-dequeuebuffer" aria-hidden="true">#</a> 4.1.2 <code>dequeueBuffer</code></h4><p>这个函数虽然很短（只有二十几行），却是 <code>FramebufferNativeWindow</code> 中的核心。<code>OpenGL ES</code> 就是通过它来分配一个可用于渲染的缓冲区的：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/*
	dequeueBuffer 在 ANativeWindow 中的函数原型：
	int (*dequeueBuffer)(struct ANativeWindow* window, struct ANativeWindowBuffer** buffer, int* fenceFd);
*/</span>
<span class="token keyword">int</span> <span class="token class-name">FramebufferNativeWindow</span><span class="token double-colon punctuation">::</span><span class="token function">dequeueBuffer</span><span class="token punctuation">(</span>ANativeWindow<span class="token operator">*</span> window<span class="token punctuation">,</span> ANativeWindowBuffer<span class="token operator">*</span><span class="token operator">*</span> buffer<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> fenceFd<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token comment">/* Step1 */</span>
    FramebufferNativeWindow<span class="token operator">*</span> self <span class="token operator">=</span> <span class="token function">getSelf</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span> 

	<span class="token comment">/* Step2 */</span>
    Mutex<span class="token double-colon punctuation">::</span>Autolock <span class="token function">_l</span><span class="token punctuation">(</span>self<span class="token operator">-&gt;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token comment">/* Step3. 计算 mBufferHead */</span>
    <span class="token keyword">int</span> index <span class="token operator">=</span> self<span class="token operator">-&gt;</span>mBufferHead<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>self<span class="token operator">-&gt;</span>mBufferHead <span class="token operator">&gt;=</span> self<span class="token operator">-&gt;</span>mNumBuffers<span class="token punctuation">)</span>
        self<span class="token operator">-&gt;</span>mBufferHead <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 循环</span>

    <span class="token comment">/* Step4. 如果当前没有可用缓冲区 */</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>self<span class="token operator">-&gt;</span>mNumFreeBuffers<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        self<span class="token operator">-&gt;</span>mCondition<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>self<span class="token operator">-&gt;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/* Step5. 如果有人释放了缓冲区 */</span>
    self<span class="token operator">-&gt;</span>mNumFreeBuffers<span class="token operator">--</span><span class="token punctuation">;</span>
    self<span class="token operator">-&gt;</span>mCurrentBufferIndex <span class="token operator">=</span> index<span class="token punctuation">;</span>
    <span class="token operator">*</span>buffer <span class="token operator">=</span> self<span class="token operator">-&gt;</span>buffers<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">*</span>fenceFd <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-text ext-text"><pre class="language-text"><code>Step1@FramebufferNativeWindow::dequeueBuffer

这里先将入参中 ANativeWindow 类型的变量 window 强制转化为 FramebufferNativeWindow。
因为前者是后者的父类，所以这样的转化当然是有效的。

不过细心的读者可能会发现，为什么函数入参中还要特别传入一个 ANativeWindow 对象的内存地址，
直接使用FramebufferNativeWindow的this指针不行吗？
这么做很可能是为了兼容各种平台。

大家应该注意到 ANativeWindow 是一个 Struct 数据类型，而在 C 语言中 Struct 是没有成员函数的，
所以我们通常是用函数指针的形式来模拟一个成员函数，如这个 dequeueBuffer 在 ANativeWindow 的定义就是一个函数指针，

而且系统并没有办法预先知道最终填充到 ANativeWindow 中的函数指针实现里是否可以使用 this 指针，
所以在参数中带入一个 window 变量就是必要的。
</code></pre></div><div class="language-text ext-text"><pre class="language-text"><code>Step2@FramebufferNativeWindow::dequeueBuffer

获得一个 Mutex 锁。
因为接下来的操作涉及资源互斥区，自然需要有一个保护措施。
这里采用的是 Autolock，意味着 dequeueBuffer 函数结束后会自动释放 Mutex。
</code></pre></div><div class="language-text ext-text"><pre class="language-text"><code>Step3@FramebufferNativeWindow::dequeueBuffer

前面我们介绍过 mBufferHead 变量，这里来看看它的实际使用。
首先 index 得到的是 mBufferHead 所代表的当前位置，然后 mBufferHead 增加 1。
由于我们是循环利用多个缓冲区的，所以如果这个变量的值大于或等于 mNumBuffers，那么就需要把它置为 0。
也就是说，mBufferHead 的值永远只能是 [0-2] 中的一个。
</code></pre></div><div class="language-text ext-text"><pre class="language-text"><code>Step4@FramebufferNativeWindow::dequeueBuffer

mBufferHead 并不代表它所指向的缓冲区是可用的。
假如当前的 mNumFreeBuffers 表明已经没有多余的缓冲区空间，那么我们就需要等待有人释放 buffer 后才能继续操作。
(这里使用到 Condition 这一同步机制。)
可以肯定的是，这里调用了 mCondition.wait，那么必然有其他地方要唤醒它 —— 具体的就是在 queueBuffer()中。
</code></pre></div><div class="language-text ext-text"><pre class="language-text"><code>Step5@FramebufferNativeWindow::dequeueBuffer

一旦成功获取到一个 buffer 后，程序要把可用的 buffer 计数值减 1（mNumFreeBuffers--）。
另外 mBufferHead 前面已经做过自增（++）处理，这里就不用再做特别工作。
</code></pre></div><p>这样我们就完成了 <code>Android</code> 系统中 <code>FramebufferNativeWindow</code> 本地窗口的分析。</p><p>接下来讲解另一个重要的本地窗口。</p><h3 id="_4-2-surface" tabindex="-1"><a class="header-anchor" href="#_4-2-surface" aria-hidden="true">#</a> 4.2 <code>Surface</code></h3><p><code>Surface</code> 是针对应用程序端的本地窗口，和 <code>FramebufferNativeWindow</code> 一样，它必须继承 <code>AnativeWindow</code>：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* frameworks/native/libs/gui/include/gui/Surface.h */</span>
<span class="token keyword">class</span> <span class="token class-name">Surface</span> <span class="token operator">:</span> <span class="token keyword">public</span> ANativeObjectBase<span class="token operator">&lt;</span>ANativeWindow<span class="token punctuation">,</span> Surface<span class="token punctuation">,</span> RefBase<span class="token operator">&gt;</span>
</code></pre></div><p>这个本地窗口当然也需要实现 <code>ANativeWindow</code> 所制定的 “协议”，我们关注的重点是它与前面的 <code>FramebufferNativeWindow</code> 有什么不同。</p><p><code>Surface</code> 的构造函数只是简单地给 <code>ANativeWindow::dequeueBuffer</code> 等函数指针及内部变量赋了初值。</p><p>由于整个函数的功能很简单，我们只摘录部分核心内容：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* frameworks/native/libs/gui/Surface.cpp */</span>
<span class="token class-name">Surface</span><span class="token double-colon punctuation">::</span><span class="token function">Surface</span><span class="token punctuation">(</span><span class="token keyword">const</span> sp<span class="token operator">&lt;</span>IGraphicBufferProducer<span class="token operator">&gt;</span><span class="token operator">&amp;</span> bufferProducer<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">mGraphicBufferProducer</span><span class="token punctuation">(</span>bufferProducer<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">/* 给 ANativeWindow 中的函数指针赋值 */</span>
    ANativeWindow<span class="token double-colon punctuation">::</span>setSwapInterval  <span class="token operator">=</span> hook_setSwapInterval<span class="token punctuation">;</span>
    ANativeWindow<span class="token double-colon punctuation">::</span>dequeueBuffer    <span class="token operator">=</span> hook_dequeueBuffer<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/* 为各内部变量赋值，因为此时用户还没有发起申请，所以大部分变量的初始值是 0 */</span>
    mReqWidth <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    mReqHeight <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    mDefaultWidth <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    mDefaultHeight <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    mUserWidth <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    mUserHeight <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>Surface</code> 是面向 <code>Android</code> 系统中所有 <code>UI</code> 应用程序的，即它承担着应用进程中的 <code>UI</code> 显示需求。</p><p>基于这点，可以推测出其内部实现至少要考虑以下几点：</p><div class="language-text ext-text"><pre class="language-text"><code>1. 面向上层实现（主要是 Java 层）提供绘制图像的 “画板”
    前面说过，这个本地窗口分配的内存空间不属于帧缓冲区，那么具体是由谁来分配的，又是如何管理的呢？

2. 它与 SurfaceFlinger 间是如何分工的
	显然 SurfaceFlinger 需要收集系统中所有应用程序绘制的图像数据，然后集中显示到物理屏幕上。
	在这个过程中，Surface 扮演了什么样的角色呢？
</code></pre></div><p>先来解释下 <code>Surface</code> 类中一些重要的成员变量，如下表所示。</p><table><tr><th>成员变量</th><th>说明</th></tr><tr><td>sp&lt;IGraphicBufferProducer&gt;mGraphicBufferProducer</td><td> 这个变量是 Surface 的核心，很多 “协议” 就是通过它实现的，后面会有详细讲解。 值得一提的是，它已经多次改名，4.1 的版本中叫作 mSurfaceTexture，后更名为 mBufferProducer， 而目前则是叫 mGraphicBufferProducer。 </td></tr><tr><td>BufferSlot mSlots[NUM_BUFFER_SLOTS]</td><td> 从名称上不难看出，这是 Surface 内部用于存储 buffer 的地方，容量 NUM_BUFFER_SLOTS 最多可达 32 个。 BufferSlot 类的内部又由一个 GraphicBuffer 和一个 dirtyRegion 组成，当用户 dequeueBuffer 时才会分配真正的空间 </td></tr><tr><td>uint32_t mReqWidth</td><td> Surface 中有多组相似的宽/高变量，它们之间是有区别的。 这里的宽和高是指下一次 dequeue 时将会申请的尺寸，初始值都是 1 </td></tr><tr><td>uint32_t mReqHeight</td><td></td></tr><tr><td>uint32_t mReqFormat</td><td> 和上面两个变量类似，这是指下次 dequeue 时将会申请的 buffer 的像素格式， 初始值是 PIXEL_FORMAT_RGBA_8888 </td></tr><tr><td>uint32_t mReqUsage</td><td>指下次 dequeue 时将会指定的 usage 类型</td></tr><tr><td>Rect mCrop</td><td> Crop 表示 “修剪”，这个变量将在下次 queue 时用于修剪缓冲区， 可以调用 setCrop 来设置具体的值 </td></tr><tr><td>int mScalingMode</td><td> 同样，这个变量将用于下次 queue 时对缓冲区进行 scale， 可以调用 setScalingMode 来设置具体的值 </td></tr><tr><td>uint32_t mTransform</td><td>用于下次 queue 时的图形翻转等操作（Transform）</td></tr><tr><td>uint32_t mDefaultWidth</td><td>默认情况下的缓冲区宽高值</td></tr><tr><td>uint32_t mDefaultHeight</td><td></td></tr><tr><td>uint32_t mUserWidth</td><td>如果不为零的话，就是应用层指定的值，而且会覆盖前面的 mDefaultWidth/mDefaultHeight</td></tr><tr><td>uint32_t mUserHeight</td><td></td></tr><tr><td>sp&lt;GraphicBuffer&gt; mLockedBuffer</td><td>访问这 3 个变量需要资源锁的保护，接下来还会有分析</td></tr><tr><td>sp&lt;GraphicBuffer&gt; mPostedBuffer</td><td></td></tr><tr><td>Region mDirtyRegion</td><td></td></tr></table><p>从上表中 <code>Surface</code> 类的内部变量的描述中，可以了解到两点：</p><div class="language-text ext-text"><pre class="language-text"><code>1. Surface 将通过 mGraphicBufferProducer 来获取 buffer，
2. 而且这些 buffer 缓冲区会被记录在 mSlots 数组中。
</code></pre></div><p>接下来我们分析其中的实现细节。</p><p>前面 <code>Surface</code> 构造函数中看到 <code>ANativeWindow</code> 中的函数指针赋予的是各种以 <code>hook</code> 开头的函数，而这些 <code>hook_XX</code> 内部又直接 “钩住” 了 <code>Surface</code> 中真正的实现。</p><blockquote><p>比如 <code>Surface::hook_dequeueBuffer</code> 对应的是 <code>Surface::dequeueBuffer</code>，这就好像 “钩子” 的功能一样，所以得名为 <code>hook</code>。</p></blockquote><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* frameworks/native/libs/gui/Surface.cpp */</span>
<span class="token keyword">int</span> <span class="token class-name">Surface</span><span class="token double-colon punctuation">::</span><span class="token function">dequeueBuffer</span><span class="token punctuation">(</span>android_native_buffer_t<span class="token operator">*</span><span class="token operator">*</span> buffer<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">*</span>fenceFd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    Mutex<span class="token double-colon punctuation">::</span>Autolock <span class="token function">lock</span><span class="token punctuation">(</span>mMutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> buf <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token comment">/* Step1. 宽高计算 */</span>
    <span class="token keyword">int</span> reqW <span class="token operator">=</span> mReqWidth <span class="token operator">?</span> mReqWidth <span class="token operator">:</span> mUserWidth<span class="token punctuation">;</span>
    <span class="token keyword">int</span> reqH <span class="token operator">=</span> mReqHeight <span class="token operator">?</span> mReqHeight <span class="token operator">:</span> mUserHeight<span class="token punctuation">;</span>

    <span class="token comment">/* Step2. dequeueBuffer 得到一个缓冲区 */</span>
    sp<span class="token operator">&lt;</span>Fence<span class="token operator">&gt;</span> fence<span class="token punctuation">;</span>
	<span class="token comment">/* 生产者发挥作用了 */</span>
    status_t result <span class="token operator">=</span> mGraphicBufferProducer<span class="token operator">-&gt;</span><span class="token function">dequeueBuffer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buf<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fence<span class="token punctuation">,</span> reqW<span class="token punctuation">,</span> reqH<span class="token punctuation">,</span> mReqFormat<span class="token punctuation">,</span> mReqUsage<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    sp<span class="token operator">&lt;</span>GraphicBuffer<span class="token operator">&gt;</span><span class="token operator">&amp;</span><span class="token function">gbuf</span><span class="token punctuation">(</span>mSlots<span class="token punctuation">[</span>buf<span class="token punctuation">]</span><span class="token punctuation">.</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 注意 buf 是一个 int 值，代表的是 mSlots 数组序号 */</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>result <span class="token operator">&amp;</span> IGraphicBufferProducer<span class="token double-colon punctuation">::</span>BUFFER_NEEDS_REALLOCATION<span class="token punctuation">)</span> <span class="token operator">||</span> gbuf <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        result <span class="token operator">=</span> mGraphicBufferProducer<span class="token operator">-&gt;</span><span class="token function">requestBuffer</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token operator">&amp;</span>gbuf<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 申请空间</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token operator">*</span>buffer <span class="token operator">=</span> gbuf<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-text ext-text"><pre class="language-text"><code>Step1@Surface::dequeueBuffer

图形缓冲区一定有宽高属性，具体的值由 mReqWidth/mReqHeight 或者 mUserWidth/mUserHeight 决定，
其中前者的优先级比后者高。
</code></pre></div><div class="language-text ext-text"><pre class="language-text"><code>Step2@Surface::dequeueBuffer

如前面所述，真正执行 dequeueBuffer 操作的确实是 mGraphicBufferProducer(IGraphicBufferProducer)。
Surface 中的这个核心成员变量的来源可以有两个：
	1. 作为 Surface 的构造函数参数传入；
	2. 或者 Surface 的子类通过直接调用 setIGraphicBufferProducer 来生成。
在应用进程环境中，属于后者。
</code></pre></div><h4 id="_4-2-1-surface-的创建流程" tabindex="-1"><a class="header-anchor" href="#_4-2-1-surface-的创建流程" aria-hidden="true">#</a> 4.2.1 <code>Surface</code> 的创建流程</h4><p>大致流程是：</p><div class="language-text ext-text"><pre class="language-text"><code>ViewRootImpl 持有一个 Java 层的 Surface 对象（即 mSurface），初始时是空的。
后续 ViewRootImpl 将向 WindowManagerService 发起 relayout 请求，此时 mSurface 才被赋予真正有效的值。

WindowManagerService 会先让 WindowStateAnimator 生成一个 SurfaceControl，
然后通过 Surface.copyFrom() 函数将其复制到 mSurface 中。

这个复制函数会通过 native 接口 nativeCreateFromSurfaceControl 来生成本地 Surface对象（C++ 对象），
具体是在 android_view_Surface.cpp 文件中。

JNI 函数 nativeCreateFromSurfaceControl 将从 SurfaceControl 中提取出 Surface（C++ ），
最终记录到 Surface（Java） 的成员变量中。

这样，后期我们就可以从 Surface（Java） 的成员变量中还原出底层的 Surface（C++ ） 对象了。
</code></pre></div><p><code>Surface</code> 的创建流程图大致如下：</p><p><img src="/assets/04.0f4e4fa4.png" alt="" loading="lazy"></p><p>从上图中可以看到，<code>Surface</code> 由 <code>SurfaceControl</code> 管理，而后者又由 <code>SurfaceComposerClient</code> 创建：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* frameworks/native/libs/gui/SurfaceComposerClient.cpp */</span>
sp<span class="token operator">&lt;</span>SurfaceControl<span class="token operator">&gt;</span> <span class="token class-name">SurfaceComposerClient</span><span class="token double-colon punctuation">::</span><span class="token function">createSurface</span><span class="token punctuation">(</span><span class="token keyword">const</span> String8<span class="token operator">&amp;</span> name<span class="token punctuation">,</span> <span class="token keyword">uint32_t</span> w<span class="token punctuation">,</span> <span class="token keyword">uint32_t</span> h<span class="token punctuation">,</span> 
															PixelFormat format<span class="token punctuation">,</span> <span class="token keyword">uint32_t</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    sp<span class="token operator">&lt;</span>SurfaceControl<span class="token operator">&gt;</span> sur<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mStatus <span class="token operator">==</span> NO_ERROR<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sp<span class="token operator">&lt;</span>IBinder<span class="token operator">&gt;</span> handle<span class="token punctuation">;</span>
        sp<span class="token operator">&lt;</span>IGraphicBufferProducer<span class="token operator">&gt;</span> gbp<span class="token punctuation">;</span>

        <span class="token comment">// 生成一个 Surface</span>
        status_t err <span class="token operator">=</span> mClient<span class="token operator">-&gt;</span><span class="token function">createSurface</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> w<span class="token punctuation">,</span> h<span class="token punctuation">,</span> format<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> <span class="token operator">&amp;</span>handle<span class="token punctuation">,</span> <span class="token operator">&amp;</span>gbp<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">==</span> NO_ERROR<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            sur <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">SurfaceControl</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> handle<span class="token punctuation">,</span> gbp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// SurfaceControl 是 “本地” 的对象</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> sur<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-text ext-text"><pre class="language-text"><code>上述代码段中，mClient 是一个 ISurfaceComposerClient 的 sp 指针，程序通过它来生成一个 Surface。
值得注意的是，SurfaceControl 对象并不是由 ISurfaceComposerClient 的 createSurface 直接生成的，
ISurfaceComposerClient::createSurface 函数的参数中包括了 gbp（IGraphicBufferProducer），即前面所说的 “buffer生产者”。
从中我们可以了解到，真正与 SurfaceFlinger 间有联系的应该就是 gbp（IGraphicBufferProducer）。
</code></pre></div><p>那么 <code>ISurfaceComposerClient</code> 的服务器端实现是谁？</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* frameworks/native/libs/gui/SurfaceComposerClient.cpp */</span>
<span class="token keyword">void</span> <span class="token class-name">SurfaceComposerClient</span><span class="token double-colon punctuation">::</span><span class="token function">onFirstRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sp<span class="token operator">&lt;</span>ISurfaceComposer<span class="token operator">&gt;</span> <span class="token function">sm</span><span class="token punctuation">(</span><span class="token class-name">ComposerService</span><span class="token double-colon punctuation">::</span><span class="token function">getComposerService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>sm <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sp<span class="token operator">&lt;</span>ISurfaceComposerClient<span class="token operator">&gt;</span> conn <span class="token operator">=</span> sm<span class="token operator">-&gt;</span><span class="token function">createConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>conn <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            mClient <span class="token operator">=</span> conn<span class="token punctuation">;</span>
            mStatus <span class="token operator">=</span> NO_ERROR<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>由此可见，<code>ISurfaceComposerClient</code> 是由 <code>ISurfaceComposer::createConnection</code> 生成的。在这一过程中，总共涉及了 3 个匿名的 <code>Binder Server</code>，它们所提供的接口如下表所示。</p><table><tr><th>匿名 Binder</th><th>提供的接口</th></tr><tr><td>ISurfaceComposer</td><td>createConnection</td></tr><tr><td>ISurfaceComposerClient</td><td> virtual status_t createSurface(..., sp&lt;IGraphicBufferProducer&gt;* gbp)=0;<br> virtual status_t destroySurface(const sp&lt;IBinder&gt;&amp; handle) = 0; </td></tr><tr><td>IGraphicBufferProducer</td><td> status_t requestBuffer(int slot, sp&lt;GraphicBuffer&gt;* buf);<br> status_t setBufferCount(int bufferCount);<br> status_t dequeueBuffer(...);<br> status_t queueBuffer(...);<br> void cancelBuffer(int slot);<br> int query(int what, int* value);<br> status_t setSynchronousMode(bool enabled);<br> status_t connect(int api, QueueBufferOutput* output);<br> status_t disconnect(int api); </td></tr></table><div class="language-text ext-text"><pre class="language-text"><code>匿名 Binder 一定是需要由一个实名 Binder 来提供的，它就是 SurfaceFlinger，
这个 SurfaceFlinger 系统服务是在 ServiceManager 中 “注册在案” 的。

具体是在 SurfaceComposerClient::onFirstRef() 这个函数中，
通过向 ServiceManager 查询名称为 “SurfaceFlinger” 的 Binder Server 来获得的。

不过和其他常见 Binder Server 不同的是，
SurfaceFlinger 虽然在 ServiceManager 中注册的名称为 “SurfaceFlinger”，
但它在服务器端实现的 Binder 接口却是 ISurfaceComposer，
因而 SurfaceComposerClient 得到的其实是 ISurfaceComposer。大家要特别注意这点，否则可能会引起混乱。

我们可以从 SurfaceFlinger 的继承关系中看出这一区别，如下代码片断：
</code></pre></div><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* frameworks/native/services/surfaceflinger/SurfaceFlinger.h */</span>
<span class="token keyword">class</span> <span class="token class-name">SurfaceFlinger</span> <span class="token operator">:</span>
	<span class="token keyword">public</span> BinderService<span class="token operator">&lt;</span>SurfaceFlinger<span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token comment">// 在ServiceManager 中注册为 “SurfaceFlinger”</span>
	<span class="token keyword">public</span> BnSurfaceComposer<span class="token punctuation">,</span> <span class="token comment">// 实现的接口却叫 ISurfaceComposer，不知道为什么要这么设计</span>
</code></pre></div><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* frameworks/native/services/surfaceflinger/SurfaceFlinger.h */</span>
<span class="token comment">/* 高版本中的声明 */</span>
<span class="token keyword">class</span> <span class="token class-name">SurfaceFlinger</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">BnSurfaceComposer</span><span class="token punctuation">,</span>
	<span class="token keyword">public</span> <span class="token class-name">PriorityDumper</span><span class="token punctuation">,</span>
	<span class="token keyword">private</span> IBinder<span class="token double-colon punctuation">::</span><span class="token class-name">DeathRecipient</span><span class="token punctuation">,</span>
	<span class="token keyword">private</span> HWC2<span class="token double-colon punctuation">::</span><span class="token class-name">ComposerCallback</span><span class="token punctuation">,</span>
	<span class="token keyword">private</span> <span class="token class-name">ICompositor</span><span class="token punctuation">,</span>
	<span class="token keyword">private</span> scheduler<span class="token double-colon punctuation">::</span><span class="token class-name">ISchedulerCallback</span><span class="token punctuation">,</span>
	<span class="token keyword">private</span> compositionengine<span class="token double-colon punctuation">::</span><span class="token class-name">ICEPowerCallback</span><span class="token punctuation">,</span>
	<span class="token keyword">private</span> scheduler<span class="token double-colon punctuation">::</span><span class="token class-name">IVsyncTrackerCallback</span>

<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token keyword">static</span> <span class="token keyword">char</span> <span class="token keyword">const</span><span class="token operator">*</span> <span class="token function">getServiceName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token class-name">ANDROID_API</span></span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token string">&quot;SurfaceFlinger&quot;</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>


<span class="token comment">/* frameworks/native/libs/gui/include/gui/ISurfaceComposer.h */</span>
<span class="token keyword">class</span> <span class="token class-name">BnSurfaceComposer</span><span class="token operator">:</span> <span class="token keyword">public</span> BnInterface<span class="token operator">&lt;</span>ISurfaceComposer<span class="token operator">&gt;</span>
</code></pre></div><p>绕了一大圈，我们接着分析前面 <code>Surface::dequeueBuffer</code> 函数的实现。</p><div class="language-text ext-text"><pre class="language-text"><code>目前我们已经清楚 mGraphicBufferProducer 的由来了。接下来程序利用这个变量来 dequeueBuffer。

那么，IGraphicBufferProducer 在服务器端又是由谁来实现的呢？
因为这里面牵扯到很多新的类，我们先不做过多解释，到后面 BufferQueue 小节再详细分析其中的依赖关系。

当 mGraphicBufferProducer-&gt;dequeueBuffer 返回后，buf 变量就是 mSlots[] 数组中可用的成员序号。
接下来就要通过这个序号来获取真正的 buffer 地址，即 mSlots[buf].buffer。
</code></pre></div><div class="language-text ext-text"><pre class="language-text"><code>Step3@Surface::dequeueBuffer

假如返回值 result 中的标志包含了 BUFFER_NEEDS_REALLOCATION，
说明 BufferQueue 需要为这个 Slot 重新分配空间，具体细节请参见下一个小节。
此时还需要另外调用 requestBuffer 来确定 gbuf 的值，其中又牵涉到很多东西，也放在下一小节统一解释。
</code></pre></div><h3 id="_4-2-本地窗口小结" tabindex="-1"><a class="header-anchor" href="#_4-2-本地窗口小结" aria-hidden="true">#</a> 4.2 本地窗口小结</h3><p>目前，已经介绍了显示系统中两个重要的本地窗口：<code>FramebufferNativewindow</code> 和 <code>Surface</code>。</p><div class="language-text ext-text"><pre class="language-text"><code>FramebufferNativewindow 是专门为 SurfaceFlinger 服务的，它由 Gralloc 提供支持；

Surface 虽然是为应用程序服务的，但本质上还是由 SurfaceFlinger 服务统一管理的，因而涉及很多跨进程的通信细节。
</code></pre></div><p>这个小节我们只是简单地勾勒出其中的框架，接下来就要分几个方面来做完整的分析了：</p><div class="language-text ext-text"><pre class="language-text"><code>1. BufferQueue
为应用程序服务的本地窗口 Surface，其依赖的 IGraphicBufferProducer 对象在 Server 端的实现是 BufferQueue。
我们将详细解析 BufferQueue 的内部实现，并结合应用程序端的使用流程来理解它们之间的关系。

2. Buffer，Consumer，Producer 是 “生产者-消费者” 模型中的 3 个参与对象，
如何协调好它们的工作是应用程序能否正常显示 UI 的关键。

接下来，我们先讲解 Buffer（BufferQueue）与 Producer（应用程序）间的交互，
然后转而切入 Consumer（SurfaceFlinger）做详细分析。
</code></pre></div><h2 id="_5-bufferqueue-详解" tabindex="-1"><a class="header-anchor" href="#_5-bufferqueue-详解" aria-hidden="true">#</a> 5 <code>BufferQueue</code> 详解</h2><p><code>BufferQueue</code> 是 <code>Surface</code> 实现本地窗口的关键。从逻辑上来推断，<code>BufferQueue</code> 应该是驻留在 <code>SurfaceFlinger</code> 这边的进程中。</p><p>我们需要进一步解决的疑惑是：</p><div class="language-text ext-text"><pre class="language-text"><code>1. 每个应用程序可以有几个 BufferQueue，即它们的关系是一对一、多对一，还是一对多？
2. 应用程序绘制 UI 所需的内存空间是由谁来分配的？
3. 应用程序与 SurfaceFlinger 如何互斥共享数据区？
4. 我们这里面临的是经典的 “生产者-消费者” 模型。Android 显示系统是如何协调好这两者对缓冲区的互斥访问的呢？
</code></pre></div><h3 id="_5-1-bufferqueue-的内部原理" tabindex="-1"><a class="header-anchor" href="#_5-1-bufferqueue-的内部原理" aria-hidden="true">#</a> 5.1 <code>BufferQueue</code> 的内部原理</h3><p>先来解析下 <code>BufferQueue</code> 的内部构造，如下图所示。</p><p><img src="/assets/05.c960f523.png" alt="" loading="lazy"></p><p>因为 BufferQueue 是 IGraphicBufferProducer 服务器端的实现，所以它必须重载接口中的各种虚函数：</p><div class="language-text ext-text"><pre class="language-text"><code>如 queueBuffer、requestBuffer、dequeueBuffer 等。
</code></pre></div><blockquote><p>注意：</p><p>高版本中，<code>IGraphicBufferProducer</code> 被抽取到 <code>BufferQueueProducer</code> 中实现了， <code>BufferQueue</code> 提供了 <code>BufferQueue::createBufferQueue</code> 方法，创建了 <code>BufferQueueProducer</code> 对象， 同时还创建了 <code>BufferQueueConsumer</code> 对象。</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* frameworks/native/libs/gui/include/gui/BufferQueue.h */</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">createBufferQueue</span><span class="token punctuation">(</span>sp<span class="token operator">&lt;</span>IGraphicBufferProducer<span class="token operator">&gt;</span><span class="token operator">*</span> outProducer<span class="token punctuation">,</span>
           sp<span class="token operator">&lt;</span>IGraphicBufferConsumer<span class="token operator">&gt;</span><span class="token operator">*</span> outConsumer<span class="token punctuation">,</span>
           <span class="token keyword">bool</span> consumerIsSurfaceFlinger <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* frameworks/native/libs/gui/include/gui/BufferQueueProducer.h */</span>
<span class="token keyword">class</span> <span class="token class-name">BufferQueueProducer</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">BnGraphicBufferProducer</span><span class="token punctuation">,</span>
                            <span class="token keyword">private</span> IBinder<span class="token double-colon punctuation">::</span><span class="token class-name">DeathRecipient</span></span> <span class="token punctuation">{</span>

<span class="token comment">/* frameworks/native/libs/gui/include/gui/IGraphicBufferProducer.h */</span>
<span class="token keyword">class</span> <span class="token class-name">BnGraphicBufferProducer</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">BnInterface</span><span class="token operator">&lt;</span><span class="token class-name">IGraphicBufferProducer</span><span class="token operator">&gt;</span></span>
<span class="token punctuation">{</span>
</code></pre></div></blockquote><p>另外，这个 <code>BufferQueue</code> 的内部有一个非常重要的成员数组，即 <code>mSlots[NUM_BUFFER_SLOTS]</code>。</p><p>在前面讲解的 <code>Surface</code> 类中也有一个一模一样的数组：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* frameworks/native/libs/gui/include/gui/Surface.h */</span>
<span class="token keyword">class</span> <span class="token class-name">Surface</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">ANativeObjectBase</span><span class="token operator">&lt;</span><span class="token class-name">ANativeWindow</span><span class="token punctuation">,</span> <span class="token class-name">Surface</span><span class="token punctuation">,</span> <span class="token class-name">RefBase</span><span class="token operator">&gt;</span></span>
<span class="token punctuation">{</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	BufferSlot mSlots<span class="token punctuation">[</span>NUM_BUFFER_SLOTS<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>虽然两个数组从形式上看一模一样，但要特别注意其中的 <code>BufferSlot</code> 定义并不相同：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* frameworks/native/libs/gui/include/gui/Surface.h */</span>
<span class="token keyword">struct</span> <span class="token class-name">BufferSlot</span> <span class="token punctuation">{</span>
	sp<span class="token operator">&lt;</span>GraphicBuffer<span class="token operator">&gt;</span> buffer<span class="token punctuation">;</span>
	Region dirtyRegion<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token comment">/* frameworks/native/libs/gui/include/gui/BufferSlot.h */</span>
<span class="token keyword">struct</span> <span class="token class-name">BufferSlot</span> <span class="token punctuation">{</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	sp<span class="token operator">&lt;</span>GraphicBuffer<span class="token operator">&gt;</span> mGraphicBuffer<span class="token punctuation">;</span>
	BufferState mBufferState<span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-text ext-text"><pre class="language-text"><code>后面一个 BufferSlot 中的 GraphicBuffer 变量（mGraphicBuffer）用于记录这个 Slot 所涉及的缓冲区；
另一个 BufferState 变量（mBufferState`）用于跟踪每个缓冲区的状态。比如：
</code></pre></div><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token keyword">enum</span> <span class="token class-name">BufferState</span> <span class="token punctuation">{</span>

    <span class="token comment">/* Buffer 当前可用，也就是说可以被dequeued。此时 Buffer 的 owner 可认为是 BufferQueue */</span>
	FREE <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> 

    <span class="token comment">/*
        Buffer 已经被 dequeued，还未被 queued 或 canceled。此时Buffer的owner可认为是producer（应用程序），
        这意味着 BufferQueue 和 SurfaceFlinger(consumer) 此时都不可以操作这块缓冲区
    */</span>
	DEQUEUED <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> 

    <span class="token comment">/*Buffe r已经被客户端 queued，不过还不能对它进行 dequeue，但可以 acquired。此时的 owner 是 BufferQueue*/</span>
	QUEUED <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> 

    <span class="token comment">/* Buffer 的 owner 改为 consumer，可以被 released，然后状态又返回 FREE*/</span>
	ACQUIRED <span class="token operator">=</span> <span class="token number">3</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">/* 高版本中，BufferState 作为一个结构体定义在 frameworks/native/libs/gui/include/gui/BufferSlot.h 中 */</span>
</code></pre></div><p>从上面的状态描述可以看出，一块 <code>Buffer</code> 在处理过程中经历的生命周期依次是 <code>FREE -&gt; DEQUEUED -&gt; QUEUED -&gt; ACQUIRED -&gt; FREE</code>。</p><p>从 <code>Owner</code> 的角度给出的 <code>Buffer</code> 状态迁移图如下所示：</p><p><img src="/assets/06.68976e1b.png" alt="" loading="lazy"></p><p>从 <code>Buffer</code> 状态迁移图中可以清楚地了解 <code>Buffer</code> 的各个状态、引起状态迁移的条件以及各状态下的 <code>Owner</code>。</p><p>参与 <code>Buffer</code> 管理的 <code>Owner</code> 对象有 3 个：</p><div class="language-text ext-text"><pre class="language-text"><code>BufferQueue
    我们可以认为 BufferQueue 是一个服务中心，其他两个 Owner 必须要通过它来管理 Buffer。
    比如当 Producer 想要获取一个 Buffer 时，它不能越过 BufferQueue 直接与 Consumer 进行联系，反之亦然。

Producer
    生产者就是 “填充” Buffer 数据的人，通常情况下当然就是应用程序。
    因为应用程序不断地刷新 UI，从而将产生的显示数据源源不绝地写到 Buffer 中。
    当 Producer 需要使用一块 Buffer 时，它首先会向 BufferQueue 发起 dequeue 申请，然后才能对指定的缓冲区进行操作。
    经过 dequeue 后 Buffer 就属于 producer 的了，它可以对 Buffer 进行任何必要的操作，而其他 Owner 此刻绝不能擅自插手。

    当生产者认为一块 Buffer 已经写入完成后，将进一步调用 BufferQueue 的 queue 接口。
    从字面上看这个函数是 “入列” 的意思，形象地表达了 Buffer 此时的操作 —— 把 Buffer 归还到 BufferQueue 的队列中。
    一旦 queue 成功，Owner 也就随之改变为 BufferQueue 了。

Consumer
    消费者是与生产者相对应的，它的操作同样受到 BufferQueue 的管控。
    当一块 Buffer 已经就绪后，Consumer 就可以开始工作了，细节我们会在后续 SurfaceFlinger 中描述。
</code></pre></div><p>这里需要特别留意的是，从各个对象所扮演的角色来看：</p><div class="language-text ext-text"><pre class="language-text"><code>BufferQueue 是中介机构，属于服务提供方；
Producer 属于 Buffer 内容的产出方，它对缓冲区的操作是一个 “主动” 的过程；
而 Consumer 对 Buffer 的处理则是 “被动” 的、“等待式” 的，即：它必须要等到一块 Buffer 填充完成后才能工作。
</code></pre></div><p>在这样的模型下，我们怎么保证 <code>Consumer</code> 可以及时处理 <code>Buffer</code> 呢？换句话说，当一块 <code>Buffer</code> 数据 <code>ready</code> 后，应该怎么告知 <code>Consumer</code> 来操作呢？</p><p>仔细观察，可以看到 <code>BufferQueue</code> 里同时还提供了一个特别的类，名称为 <code>ConsumerListener</code>。其中的函数接口包括：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">ConsumerListener</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token class-name">RefBase</span></span> <span class="token punctuation">{</span>      

    <span class="token comment">/* 当一块 buffer 可以被消费时，这个函数会被调用，特别注意此时没有共享锁的保护 */</span>  
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">onFrameAvailable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 

    <span class="token comment">/* BufferQueue 通知 consumer 它已经释放其 slot 中的一个或多个 GraphicBuffer 引用 */</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">onBuffersReleased</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">/* 
    高版本系统定义在 frameworks/native/libs/gui/include/gui/IConsumerListener.h 中
    声明略有不同，但函数名称都一样
 */</span>
</code></pre></div><p>这样就很清楚了，当有一帧数据准备就绪后，<code>BufferQueue</code> 就会调用 <code>onFrameAvailable()</code> 来通知 <code>Consumer</code> 进行消费。</p><h3 id="_5-2-bufferqueue-的缓冲区分配" tabindex="-1"><a class="header-anchor" href="#_5-2-bufferqueue-的缓冲区分配" aria-hidden="true">#</a> 5.2 <code>BufferQueue</code> 的缓冲区分配</h3><p>我们知道，<code>BufferQueue</code> 中有一个 <code>mSlots</code> 数组用于管理其内的各缓冲区，最大容量为 32。</p><p>从 <code>mSlots</code> 数组的声明方式来看，这个 <code>mSlots</code> 在程序一开始就静态分配了 32 个 <code>BufferSlot</code> 大小的空间。不过这并不代表其中的数据缓冲区也是一次性静态分配的，恰恰相反，从 <code>BufferSlot</code> 的内部变量指针 <code>mGraphicBuffer</code> 可以看出，缓冲区的空间分配应当是动态的（从下面的注释也能看出一些端倪）：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* frameworks/native/libs/gui/include/gui/BufferSlot.h */</span>
<span class="token comment">// mGraphicBuffer points to the buffer allocated for this slot or is NULL</span>
<span class="token comment">// if no buffer has been allocated.</span>
sp<span class="token operator">&lt;</span>GraphicBuffer<span class="token operator">&gt;</span> mGraphicBuffer<span class="token punctuation">;</span>
</code></pre></div><blockquote><p>注意：</p><p>高版本中，<code>mSlots</code> 数据定义在了 <code>BufferQueueProducer.h</code> 中，具体如下：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* frameworks/native/libs/gui/include/gui/BufferQueueProducer.h */</span>
BufferQueueDefs<span class="token double-colon punctuation">::</span>SlotsType<span class="token operator">&amp;</span> mSlots<span class="token punctuation">;</span>

<span class="token comment">// 在创建 BufferQueueProducer 对象时，在 BufferQueueProducer 的构造函数中初始化</span>
<span class="token comment">/* frameworks/native/libs/gui/BufferQueueProducer.cpp */</span>
<span class="token class-name">BufferQueueProducer</span><span class="token double-colon punctuation">::</span><span class="token function">BufferQueueProducer</span><span class="token punctuation">(</span><span class="token keyword">const</span> sp<span class="token operator">&lt;</span>BufferQueueCore<span class="token operator">&gt;</span><span class="token operator">&amp;</span> core<span class="token punctuation">,</span>
       <span class="token keyword">bool</span> consumerIsSurfaceFlinger<span class="token punctuation">)</span> <span class="token operator">:</span>
   <span class="token function">mCore</span><span class="token punctuation">(</span>core<span class="token punctuation">)</span><span class="token punctuation">,</span>
   <span class="token function">mSlots</span><span class="token punctuation">(</span>core<span class="token operator">-&gt;</span>mSlots<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 将 BufferQueueCore::mSlots 赋值给了 BufferQueueProducer::mSlots</span>

<span class="token comment">/* frameworks/native/libs/gui/include/gui/BufferQueueCore.h */</span>
BufferQueueDefs<span class="token double-colon punctuation">::</span>SlotsType mSlots<span class="token punctuation">;</span>

<span class="token comment">// BufferQueueDefs::SlotsType 类型的声明如下</span>
<span class="token comment">/* frameworks/native/libs/gui/include/gui/BufferQueueDefs.h */</span>
<span class="token comment">// BufferQueueDefs::SlotsType 是一个 BufferSlot 数组，数组长度是 NUM_BUFFER_SLOTS</span>
<span class="token keyword">typedef</span> BufferSlot SlotsType<span class="token punctuation">[</span>NUM_BUFFER_SLOTS<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// NUM_BUFFER_SLOTS 定义如下</span>
<span class="token comment">/* frameworks/native/libs/ui/include/ui/BufferQueueDefs.h */</span>
<span class="token keyword">static</span> <span class="token keyword">constexpr</span> <span class="token keyword">int</span> NUM_BUFFER_SLOTS <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span> <span class="token comment">// 也就是说，高版本中，mSlots 数组的容量扩充到了 64</span>
</code></pre></div></blockquote><p>现在的问题就转化为：在什么情况下会给一个 <code>Slot</code> 分配实际的空间呢？</p><p>首先能想到的就是 <code>dequeueBuffer</code> 。理由如下：</p><div class="language-text ext-text"><pre class="language-text"><code>1. 缓冲区的空间分配应该既要满足使用者的需求，又要防止浪费。
后面这一点 mSlots 已经满足了，因为它并没有采取一开始就静态预分配的方式。

2. 既然 Producer 对 buffer 的操作是 “主动” 的，那么就意味着它是整个需求的发起者。
换句话说，只要它没有 dequeueBuffer，或者 dequeueBuffer 时能获取到可用的缓冲区，那当然就没有必要再重新分配空间了。
</code></pre></div><p>下面详细分析 <code>dequeueBuffer</code> 函数，并验证我们上面的猜测：</p><blockquote><p>注意：</p><p>高版本中，<code>BufferQueue::dequeueBuffer</code> 函数对应 <code>BufferQueueProducer::dequeueBuffer</code> 函数。</p><p>目前任然以低版本的代码进行分析，后续再更新到高版本。</p></blockquote><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/*frameworks/native/libs/gui/BufferQueue.cpp*/</span>
status_t <span class="token class-name">BufferQueue</span><span class="token double-colon punctuation">::</span><span class="token function">dequeueBuffer</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>outBuf<span class="token punctuation">,</span> sp<span class="token operator">&lt;</span>Fence<span class="token operator">&gt;</span><span class="token operator">*</span> outFence<span class="token punctuation">,</span><span class="token keyword">uint32_t</span> w<span class="token punctuation">,</span> <span class="token keyword">uint32_t</span> h<span class="token punctuation">,</span>
        <span class="token keyword">uint32_t</span> format<span class="token punctuation">,</span> <span class="token keyword">uint32_t</span> usage<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    status_t  <span class="token function">returnFlags</span><span class="token punctuation">(</span>OK<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">{</span> <span class="token comment">// Scope for the lock</span>
        <span class="token comment">/* 
            这里采用了自动锁，所以上面需要加个 “{”，这样当 lock 变量生命周期结束后锁也就自动释放了。
            这种写法在 Android 中很常见 
        */</span>
        Mutex<span class="token double-colon punctuation">::</span>Autolock <span class="token function">lock</span><span class="token punctuation">(</span>mMutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">int</span> found <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> dequeuedCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">bool</span> tryAgain <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

        <span class="token comment">/* Step1. 循环查找符合要求的 Slot */</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>tryAgain<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                       
            found <span class="token operator">=</span> INVALID_BUFFER_SLOT<span class="token punctuation">;</span> <span class="token comment">// 初始值</span>
            foundSync <span class="token operator">=</span> INVALID_BUFFER_SLOT<span class="token punctuation">;</span>
            dequeuedCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> maxBufferCount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">const</span> <span class="token keyword">int</span> state <span class="token operator">=</span> mSlots<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>mBufferState<span class="token punctuation">;</span>

                <span class="token comment">/* Step2. 统计 dequeued buffer 数量，后面会用到 */</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> BufferSlot<span class="token double-colon punctuation">::</span>DEQUEUED<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    dequeuedCount<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>               

                <span class="token comment">/* Step3. 寻找符合要求的 Slot */</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> BufferSlot<span class="token double-colon punctuation">::</span>FREE<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>found <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> mSlots<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>mFrameNumber <span class="token operator">&lt;</span> mSlots<span class="token punctuation">[</span>found<span class="token punctuation">]</span><span class="token punctuation">.</span>mFrameNumber<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                          found <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">// 找到符合要求的 Slot</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token comment">// for 循环结束</span>

            <span class="token comment">/* Step4. 如果 Client 没有设置 buffer count 的话，就不允许 dequeue 一个以上的  */</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>mOverrideMaxBufferCount<span class="token operator">&amp;&amp;</span> dequeuedCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">ST_LOGE</span><span class="token punctuation">(</span><span class="token string">&quot;dequeueBuffer: can&#39;t dequeue multiple buffers without setting the buffer count&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            <span class="token comment">/* Step5. 判断是否要重试 */</span>
            tryAgain <span class="token operator">=</span> found <span class="token operator">==</span> INVALID_BUFFER_SLOT<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>tryAgain<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                mDequeueCondition<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>mMutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token comment">// while 循环结束</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>found <span class="token operator">==</span> INVALID_BUFFER_SLOT<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">/* 因为前面 while 循环如果没找到的话是不会退出的，所以理论上不会出现这种情况 */</span>
            <span class="token function">ST_LOGE</span><span class="token punctuation">(</span><span class="token string">&quot;dequeueBuffer: no available buffer slots&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token operator">-</span>EBUSY<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">const</span> <span class="token keyword">int</span> buf <span class="token operator">=</span> found<span class="token punctuation">;</span>
        <span class="token operator">*</span>outBuf <span class="token operator">=</span> found<span class="token punctuation">;</span> <span class="token comment">// 返回值</span>
        <span class="token comment">/* 成功找到可用的 Slot 序号，接下来就开始对这个指定的 Slot 进行初始操作，及状态变迁等 */</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token comment">/* Step6. Buffer 状态改变 */</span>
        mSlots<span class="token punctuation">[</span>buf<span class="token punctuation">]</span><span class="token punctuation">.</span>mBufferState <span class="token operator">=</span> BufferSlot<span class="token double-colon punctuation">::</span>DEQUEUED<span class="token punctuation">;</span>
        <span class="token keyword">const</span> sp<span class="token operator">&lt;</span>GraphicBuffer<span class="token operator">&gt;</span><span class="token operator">&amp;</span> <span class="token function">buffer</span><span class="token punctuation">(</span>mSlots<span class="token punctuation">[</span>buf<span class="token punctuation">]</span><span class="token punctuation">.</span>mGraphicBuffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>buffer <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token keyword">uint32_t</span><span class="token punctuation">(</span>buffer<span class="token operator">-&gt;</span>width<span class="token punctuation">)</span>  <span class="token operator">!=</span> w<span class="token punctuation">)</span> <span class="token operator">||</span>   
            <span class="token punctuation">(</span><span class="token keyword">uint32_t</span><span class="token punctuation">(</span>buffer<span class="token operator">-&gt;</span>height<span class="token punctuation">)</span> <span class="token operator">!=</span> h<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token keyword">uint32_t</span><span class="token punctuation">(</span>buffer<span class="token operator">-&gt;</span>format<span class="token punctuation">)</span> <span class="token operator">!=</span> format<span class="token punctuation">)</span>
                 <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">uint32_t</span><span class="token punctuation">(</span>buffer<span class="token operator">-&gt;</span>usage<span class="token punctuation">)</span> <span class="token operator">&amp;</span> usage<span class="token punctuation">)</span> <span class="token operator">!=</span> usage<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>   
            <span class="token comment">/* Step7. 为 BufferSlot 对象做初始化 */</span>
            mSlots<span class="token punctuation">[</span>buf<span class="token punctuation">]</span><span class="token punctuation">.</span>mAcquireCalled <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            mSlots<span class="token punctuation">[</span>buf<span class="token punctuation">]</span><span class="token punctuation">.</span>mGraphicBuffer <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
            mSlots<span class="token punctuation">[</span>buf<span class="token punctuation">]</span><span class="token punctuation">.</span>mRequestBufferCalled <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            mSlots<span class="token punctuation">[</span>buf<span class="token punctuation">]</span><span class="token punctuation">.</span>mEglFence <span class="token operator">=</span> EGL_NO_SYNC_KHR<span class="token punctuation">;</span>
            mSlots<span class="token punctuation">[</span>buf<span class="token punctuation">]</span><span class="token punctuation">.</span>mFence <span class="token operator">=</span> Fence<span class="token double-colon punctuation">::</span>NO_FENCE<span class="token punctuation">;</span>
            mSlots<span class="token punctuation">[</span>buf<span class="token punctuation">]</span><span class="token punctuation">.</span>mEglDisplay <span class="token operator">=</span> EGL_NO_DISPLAY<span class="token punctuation">;</span>

            returnFlags <span class="token operator">|=</span> IGraphicBufferProducer<span class="token double-colon punctuation">::</span>BUFFER_NEEDS_REALLOCATION<span class="token punctuation">;</span> <span class="token comment">/* 需要重新分配 */</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>  <span class="token comment">// 自动锁 lock 结束的地方</span>

    <span class="token comment">/* Step8. 如果上述判断结果是需要重新分配空间的话 */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>returnFlags <span class="token operator">&amp;</span> IGraphicBufferProducer<span class="token double-colon punctuation">::</span>BUFFER_NEEDS_REALLOCATION<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        status_t error<span class="token punctuation">;</span>
        <span class="token comment">/* 终于分配空间了 */</span>
        sp<span class="token operator">&lt;</span>GraphicBuffer<span class="token operator">&gt;</span> <span class="token function">graphicBuffer</span><span class="token punctuation">(</span>mGraphicBufferAlloc<span class="token operator">-&gt;</span><span class="token function">createGraphicBuffer</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> h<span class="token punctuation">,</span> format<span class="token punctuation">,</span> usage<span class="token punctuation">,</span> <span class="token operator">&amp;</span>error<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token punctuation">{</span> <span class="token comment">// Scope for the lock</span>
            Mutex<span class="token double-colon punctuation">::</span>Autolock <span class="token function">lock</span><span class="token punctuation">(</span>mMutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
               <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            mSlots<span class="token punctuation">[</span><span class="token operator">*</span>outBuf<span class="token punctuation">]</span><span class="token punctuation">.</span>mGraphicBuffer <span class="token operator">=</span> graphicBuffer<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> returnFlags<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>因为这个函数很长，我们只保留最核心的部分。从整体框架来看，<code>Step1～Step5</code> 是在查找一个可用的 <code>Slot</code> 序号。从 <code>Step6</code> 开始，就针对这一特定的 <code>Slot</code> 进行操作了。下面我们分步进行解析：</p><div class="language-text ext-text"><pre class="language-text"><code>Step1@ BufferQueue::dequeueBuffer

进入 while 循环，退出的条件是 tryAgain 为 false。
这个变量默认值是 true，如果一轮循环结束后 found 不再是 INVALID_BUFFER_SLOT，就会变成 false，从而结束整个 while 循环。

循环的主要功能就是查找符合要求的 Slot，其中 found 变量是一个 int 值，指的是这个 BufferSlot 在 mSlots 数组中的序号。
</code></pre></div><div class="language-text ext-text"><pre class="language-text"><code>Step2@ BufferQueue::dequeueBuffer

统计当前已经被 dequeued 的 buffer 数量，这将用于后面的判断，
即假如 Client 没有设置 buffer count，那么它会被禁止 dequeue 一个以上的 buffer。
</code></pre></div><div class="language-text ext-text"><pre class="language-text"><code>Step3@ BufferQueue::dequeueBuffer

假如当前的 buffer 状态是 FREE，那么这个 Slot 就可以进入备选了。
为什么只是备选而不是直接返回这一结果呢？
因为 mSlots 中很可能有多个符合条件的 Slot，当然需要挑选其中最匹配的。
判断的依据是当前符合要求的 Slot 的 mFrameNumber 是否比上一次选中的最优 Slot 的 mFrameNumber 小。具体代码如下：

    mSlots[i].mFrameNumber &lt; mSlots[found].mFrameNumber;
</code></pre></div><div class="language-text ext-text"><pre class="language-text"><code>Step4@ BufferQueue::dequeueBuffer

这里的判断来源于第二步的计算结果，一旦发现 dequeue 的数量“超标”，就直接出错返回。
</code></pre></div><div class="language-text ext-text"><pre class="language-text"><code>Step5@ BufferQueue::dequeueBuffer

经过上述几个步骤，我们已经扫描了一遍 mSlots 中的所有成员，这时就要判断是否可以退出循环。
前面已经说过，如果成功找到有效的 Slot 就可以不用再循环查找了，否则 tryAgain 仍然是 true。
假如是后一种情况，证明当前已经没有 FREE 的 Slot。这时如果直接进入下一轮循环，结果通常也是一样的，反而浪费了 CPU 资源。
所以，就需要使用条件锁来等待。代码如下：

    mDequeueCondition.wait(mMutex);

当有 Buffer 被释放时，这个锁的条件就会满足，然后程序才继续查找可用的 Slot。
</code></pre></div><div class="language-text ext-text"><pre class="language-text"><code>Step6@ BufferQueue::dequeueBuffer

根据前面的 Buffer 状态迁移图，当处于 FREE 状态的 Buffer 被 dequeue 成功后，
它将进入 DEQUEUED，所以这里我们需要改变其 mBufferState。
</code></pre></div><div class="language-text ext-text"><pre class="language-text"><code>Step7@ BufferQueue::dequeueBuffer

通过上述几个步骤的努力，现在我们已经成功地寻找到有效的 Slot 序号了。
但是这并不代表这个 Slot 可以直接使用，为什么？最直接的一个原因就是这个 Slot 可能还没有分配空间。

因为 BufferSlot::mGraphicBuffer 初始值是 NULL，假如我们是第一次使用它，必然是需要为它分配空间的。
另外，即便 mGraphicBuffer 不为空，
但如果用户所需要的 Buffer 属性（比如 width，height，format 等）和当前这个不符，那么还是要进行重新分配。
</code></pre></div><div class="language-text ext-text"><pre class="language-text"><code>Step8@ BufferQueue::dequeueBuffer

如果上一步的判断结果是 BUFFER_NEEDS_REALLOCATION，说明此 Slot 还未分配到有效的 buffer 空间，
具体分配操作使用的是 mGraphicBufferAlloc 这个 Allocator，
这里暂不深究其中的实现了，后续还会有详细分析。
</code></pre></div><p>如果重新分配了空间，那么最后的返回值中会加上 <code>BUFFER_NEEDS_REALLOCATION</code> 标志。</p><p>客户端在发现这个标志后，还应调用 <code>requestBuffer()</code> 来取得最新的 <code>buffer</code> 地址。</p><p><a href="#_9-4-2-surface">9.4.2 Surface</a> 小节中的 <code>Surface::dequeueBuffer()</code> 的 <code>Step3</code> 就是一个例子，这里结合起来分析。为了方便阅读，再把这部分代码简单地列出来：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code>frameworks<span class="token operator">/</span>native<span class="token operator">/</span>libs<span class="token operator">/</span>gui<span class="token operator">/</span>Surface<span class="token punctuation">.</span>cpp
<span class="token comment">/* frameworks/native/libs/gui/Surface.cpp */</span>
<span class="token keyword">int</span> <span class="token class-name">Surface</span><span class="token double-colon punctuation">::</span><span class="token function">dequeueBuffer</span><span class="token punctuation">(</span>android_native_buffer_t<span class="token operator">*</span><span class="token operator">*</span> buffer<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">*</span>fenceFd<span class="token punctuation">)</span> <span class="token punctuation">{</span>…
    Mutex<span class="token double-colon punctuation">::</span>Autolock <span class="token function">lock</span><span class="token punctuation">(</span>mMutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> buf <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">/* Step1. 宽高计算 */</span>
    <span class="token keyword">int</span> reqW <span class="token operator">=</span> mReqWidth <span class="token operator">?</span> mReqWidth <span class="token operator">:</span> mUserWidth<span class="token punctuation">;</span>
    <span class="token keyword">int</span> reqH <span class="token operator">=</span> mReqHeight <span class="token operator">?</span> mReqHeight <span class="token operator">:</span> mUserHeight<span class="token punctuation">;</span>

    <span class="token comment">/* Step2. dequeueBuffer 得到一个缓冲区 */</span>
    sp<span class="token operator">&lt;</span>Fence<span class="token operator">&gt;</span> fence<span class="token punctuation">;</span>
    <span class="token comment">/* 这一小节讲解的就是这个接口的实现 */</span>
    status_t result <span class="token operator">=</span> mGraphicBufferProducer<span class="token operator">-&gt;</span><span class="token function">dequeueBuffer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buf<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fence<span class="token punctuation">,</span> reqW<span class="token punctuation">,</span> reqH<span class="token punctuation">,</span> mReqFormat<span class="token punctuation">,</span> mReqUsage<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    sp<span class="token operator">&lt;</span>GraphicBuffer<span class="token operator">&gt;</span><span class="token operator">&amp;</span><span class="token function">gbuf</span><span class="token punctuation">(</span>mSlots<span class="token punctuation">[</span>buf<span class="token punctuation">]</span><span class="token punctuation">.</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 注意 buf 是一个 int 值， 代表的是 mSlots 数组序号 */</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>result <span class="token operator">&amp;</span> IGraphicBufferProducer<span class="token double-colon punctuation">::</span>BUFFER_NEEDS_REALLOCATION<span class="token punctuation">)</span> <span class="token operator">||</span> gbuf <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/* 因为这个 buffer 是需要重新分配得到的，所以还需要进一步调用 requestBuffer，后面有详细讲解 */</span>
        result <span class="token operator">=</span> mGraphicBufferProducer<span class="token operator">-&gt;</span><span class="token function">requestBuffer</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token operator">&amp;</span>gbuf<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token operator">*</span>buffer <span class="token operator">=</span> gbuf<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当 <code>mGraphicBufferProducer-&gt;dequeueBuffer</code> 成功返回后，<code>buf</code> 得到了 <code>mSlots</code> 中可用数组成员的序号（对应这一小节的 <code>found</code> 变量）。</p><p>但一个很明显的问题是：</p><div class="language-text ext-text"><pre class="language-text"><code>既然客户端和 BufferQueue 运行于两个不同的进程中，那么它们的 mSlots[buf] 会指向同一块物理内存吗？
</code></pre></div><p>这就是 <code>requestBuffer</code> 存在的意义。</p><p>先来看看 <code>BpGraphicBufferProducer</code> 中是如何发起 <code>Binder</code> 申请的：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* frameworks/native/libs/gui/IGraphicBufferProducer.cpp */</span>
<span class="token keyword">class</span> <span class="token class-name">BpGraphicBufferProducer</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">BpInterface</span><span class="token operator">&lt;</span><span class="token class-name">IGraphicBufferProducer</span><span class="token operator">&gt;</span></span>
<span class="token punctuation">{</span> 
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">virtual</span> status_t <span class="token function">requestBuffer</span><span class="token punctuation">(</span><span class="token keyword">int</span> bufferIdx<span class="token punctuation">,</span> sp<span class="token operator">&lt;</span>GraphicBuffer<span class="token operator">&gt;</span><span class="token operator">*</span> buf<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 函数参数有两个</span>
    Parcel data<span class="token punctuation">,</span> reply<span class="token punctuation">;</span>
    data<span class="token punctuation">.</span><span class="token function">writeInterfaceToken</span><span class="token punctuation">(</span><span class="token class-name">IGraphicBufferProducer</span><span class="token double-colon punctuation">::</span><span class="token function">getInterfaceDescriptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* 只写入了 bufferIdx 值，也就是说 BnGraphicBufferProducer 中实际上是看不到 buf 变量的 */</span>
    data<span class="token punctuation">.</span><span class="token function">writeInt32</span><span class="token punctuation">(</span>bufferIdx<span class="token punctuation">)</span><span class="token punctuation">;</span>

    status_t result <span class="token operator">=</span><span class="token function">remote</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">transact</span><span class="token punctuation">(</span>REQUEST_BUFFER<span class="token punctuation">,</span> data<span class="token punctuation">,</span> <span class="token operator">&amp;</span>reply<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 执行跨进程操作</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/* 这里读取的是什么？我们稍后可以去 BnGraphicBufferProducer 中确认下 */</span>
    <span class="token keyword">bool</span> nonNull <span class="token operator">=</span> reply<span class="token punctuation">.</span><span class="token function">readInt32</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nonNull<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">*</span>buf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">GraphicBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 生成一个 GraphicBuffer，看到没，这是一个本地实例</span>
        <span class="token comment">/* buf 是一个 sp 指针,那么 **sp 实际上得到的就是这个智能指针所指向的对象。在这个例子中指的是 mSlots[buf].buffer */</span>
        reply<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
    result <span class="token operator">=</span> reply<span class="token punctuation">.</span><span class="token function">readInt32</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 读取结果 */</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>Native</code> 层的 <code>BpXXX/BnXXX</code> 与 <code>Java</code> 层的不同之处在于：</p><div class="language-text ext-text"><pre class="language-text"><code>Java 层的通常都是依赖于 aidl来 自动生成这两个类，而 Native 层 的则是手工完成的。
</code></pre></div><p>也正因为是手工书写的，使用起来才更具灵活性。比如在 <code>IGraphicBufferProducer</code> 这个例子中：</p><div class="language-text ext-text"><pre class="language-text"><code>开发者 “耍” 了点技巧 —— Surface 中调用了

    IgraphicBuffer Producer::requestBuffer(int slot, sp&lt;GraphicBuffer&gt;* buf)

这个函数虽然形式上有两个参数，但只有第一个是入参，后一个则是出参。
在实际的 Binder 通信中，只有 Slot 序号这个 int 值（即 bufferIdx）传递给了对方进程，
而 buf 则自始至终都是 Surface 所在的本地进程在处理。
不过从调用者的角度来讲，好像是由 IGraphicBufferProducer 的 Server 端完成了对 buf 的赋值。
</code></pre></div><p>从 <code>BpGraphicBufferProducer::requestBuffer</code> 这个函数实现中可以看到，<code>Client</code> 端向 <code>Server</code> 端请求了一个 <code>REQUEST_BUFFER</code> 服务，然后通过读取返回值来获得缓冲区信息。</p><p>为了能看清楚这其中的细节，有必要再分析一下 <code>BnGraphicBufferProducer</code> 具体是如何响应这个服务请求的。如下所示：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* frameworks/native/libs/gui/IGraphicBufferProducer.cpp */</span>
status_t <span class="token class-name">BnGraphicBufferProducer</span><span class="token double-colon punctuation">::</span><span class="token function">onTransact</span><span class="token punctuation">(</span><span class="token keyword">uint32_t</span> code<span class="token punctuation">,</span> <span class="token keyword">const</span> Parcel<span class="token operator">&amp;</span> data<span class="token punctuation">,</span> Parcel<span class="token operator">*</span> reply<span class="token punctuation">,</span> <span class="token keyword">uint32_t</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">switch</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> REQUEST_BUFFER<span class="token operator">:</span> <span class="token punctuation">{</span>
            <span class="token function">CHECK_INTERFACE</span><span class="token punctuation">(</span>IGraphicBufferProducer<span class="token punctuation">,</span> data<span class="token punctuation">,</span> reply<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> bufferIdx   <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">readInt32</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 首先读取要处理的 Slot 序号</span>
            sp<span class="token operator">&lt;</span>GraphicBuffer<span class="token operator">&gt;</span> buffer<span class="token punctuation">;</span> <span class="token comment">// 生成一个 GraphicBuffer 智能指针</span>
            <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token function">requestBuffer</span><span class="token punctuation">(</span>bufferIdx<span class="token punctuation">,</span> <span class="token operator">&amp;</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用本地端的实现</span>
            reply<span class="token operator">-&gt;</span><span class="token function">writeInt32</span><span class="token punctuation">(</span>buffer <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 注意，第一个写入的值是判断 buffer 不为空，也就是一个 bool 值</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>buffer <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                reply<span class="token operator">-&gt;</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token operator">*</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 好，真正的内容在这里，后面我们详细解释</span>
            <span class="token punctuation">}</span>
            reply<span class="token operator">-&gt;</span><span class="token function">writeInt32</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 写入结果值</span>
            <span class="token keyword">return</span> NO_ERROR<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-text ext-text"><pre class="language-text"><code>BnGraphicBufferProducer 首先读取 Slot 序号，即 bufferIdx；
然后通过 BufferQueue 的接口 requestBuffer 来获取与之对应的正确的 GraphicBuffer，这里是指 mSlots[slot].mGraphicBuffer。

要特别注意的是，BnGraphicBufferProducer 在 reply 中第一个写入的是 bool 值（buffer!=0），
紧随其后的才是 GraphicBuffer，最后写入结果值，大功告成。
</code></pre></div><p>显然 <code>BpGraphicBufferProducer</code> 必须要按照与 <code>BnGraphicBufferProducer</code> 同样的写入顺序来读取数据，即：</p><div class="language-text ext-text"><pre class="language-text"><code>1. 因而 BpGraphicBufferProducer::requestBuffer 首先获取一个 int32 值，赋予 nonNull 变量。
这个 nonNull 值对应的是 BnGraphicBufferProducer::onTransact 中的 buffer != 0 的逻辑判断。
假如确实不为空，那说明我们可以接着读取 GraphicBuffer 了。

2. 客户端与服务器端对 GraphicBuffer 变量的 “写入和读取” 操作分别是：
    reply-&gt;write(*buffer); // BnGraphicBufferProducer::onTransact 写入 
    reply.read(**buf); // BpGraphicBufferProducer::requestBuffer 读取

3. 读取 result 结果值。
</code></pre></div><p>第 2 点中，<code>Server</code> 端写入的 <code>GraphicBuffer</code> 对象需要在 <code>Client</code> 中完整地复现出来。这就需要作为 <code>Binder</code> 对象的 <code>GraphicBuffer</code> 继承 <code>Flattenable</code>：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* frameworks/native/libs/ui/include/ui/GraphicBuffer.h */</span>
<span class="token keyword">class</span> <span class="token class-name">GraphicBuffer</span>
    <span class="token operator">:</span> <span class="token keyword">public</span> ANativeObjectBase<span class="token operator">&lt;</span>ANativeWindowBuffer<span class="token punctuation">,</span> GraphicBuffer<span class="token punctuation">,</span> LightRefBase<span class="token operator">&lt;</span>GraphicBuffer<span class="token operator">&gt;&gt;</span><span class="token punctuation">,</span> 
      <span class="token keyword">public</span> Flattenable

<span class="token comment">/* 高版本中的声明类似，如下： */</span>
<span class="token keyword">class</span> <span class="token class-name">GraphicBuffer</span>
    <span class="token operator">:</span> <span class="token keyword">public</span> ANativeObjectBase<span class="token operator">&lt;</span>ANativeWindowBuffer<span class="token punctuation">,</span> GraphicBuffer<span class="token punctuation">,</span> RefBase<span class="token operator">&gt;</span><span class="token punctuation">,</span>
      <span class="token keyword">public</span> Flattenable<span class="token operator">&lt;</span>GraphicBuffer<span class="token operator">&gt;</span>
</code></pre></div><p>接下来只需要看下 <code>GraphicBuffer</code> 是如何实现 <code>flatten</code> 和 <code>unflatten</code> 接口的，相信就能揭晓谜底了：</p><blockquote><p>谜题是：既然客户端和 <code>BufferQueue</code> 运行于两个不同的进程中，那么它们的 <code>mSlots[buf]</code> 会指向同一块物理内存吗？</p></blockquote><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* frameworks/native/libs/ui/GraphicBuffer.cpp */</span>
status_t <span class="token class-name">GraphicBuffer</span><span class="token double-colon punctuation">::</span><span class="token function">flatten</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> buffer<span class="token punctuation">,</span> size_t size<span class="token punctuation">,</span> <span class="token keyword">int</span> fds<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> size_t count<span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">int</span><span class="token operator">*</span> buf <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>handle<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        buf<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> handle<span class="token operator">-&gt;</span>numFds<span class="token punctuation">;</span>
        buf<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token operator">=</span> handle<span class="token operator">-&gt;</span>numInts<span class="token punctuation">;</span>
        native_handle_t <span class="token keyword">const</span><span class="token operator">*</span> <span class="token keyword">const</span> h <span class="token operator">=</span> handle<span class="token punctuation">;</span>
        <span class="token function">memcpy</span><span class="token punctuation">(</span>fds<span class="token punctuation">,</span> h<span class="token operator">-&gt;</span>data<span class="token punctuation">,</span> h<span class="token operator">-&gt;</span>numFds<span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buf<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span> h<span class="token operator">-&gt;</span>data <span class="token operator">+</span> h<span class="token operator">-&gt;</span>numFds<span class="token punctuation">,</span> h<span class="token operator">-&gt;</span>numInts<span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> NO_ERROR<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>GraphicBuffer::flatten</code> 函数中，我们最关心的是 <code>handle</code> 这个变量的 <code>flatten</code>，它实际上是 <code>GraphicBuffer</code> 中打开的一个 <code>ashmem</code> 句柄，这是两边进程实现共享缓冲区的关键。与 <code>handle</code> 相关的变量分别是 <code>buf[6]-buf[8]</code> 以及 <code>fds</code>，大家可以深入理解下它们的作用。</p><p>再来看看 <code>Client</code> 端是如何还原出一个 <code>GraphicBuffer</code> 的：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* frameworks/native/libs/ui/GraphicBuffer.cpp */</span>
status_t <span class="token class-name">GraphicBuffer</span><span class="token double-colon punctuation">::</span><span class="token function">unflatten</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token keyword">const</span><span class="token operator">*</span> buffer<span class="token punctuation">,</span> size_t size<span class="token punctuation">,</span> <span class="token keyword">int</span> fds<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> size_t count<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">int</span> <span class="token keyword">const</span><span class="token operator">*</span> buf <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span> <span class="token keyword">const</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>   
    <span class="token keyword">const</span> size_t numFds  <span class="token operator">=</span> buf<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> size_t numInts <span class="token operator">=</span> buf<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>numFds <span class="token operator">||</span> numInts<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        native_handle<span class="token operator">*</span> h <span class="token operator">=</span> <span class="token function">native_handle_create</span><span class="token punctuation">(</span>numFds<span class="token punctuation">,</span> numInts<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">memcpy</span><span class="token punctuation">(</span>h<span class="token operator">-&gt;</span>data<span class="token punctuation">,</span> fds<span class="token punctuation">,</span> numFds<span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">memcpy</span><span class="token punctuation">(</span>h<span class="token operator">-&gt;</span>data <span class="token operator">+</span> numFds<span class="token punctuation">,</span> <span class="token operator">&amp;</span>buf<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span> numInts<span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        
        handle <span class="token operator">=</span> h<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>handle <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        mBufferMapper<span class="token punctuation">.</span><span class="token function">registerBuffer</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> NO_ERROR<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>同样，<code>unflatten</code> 中的操作也是依据 <code>flatten</code> 时写入的格式。</p><p>其中最重要的两个函数是 <code>native_handle_create()</code> 和 <code>registerBuffer()</code>。</p><div class="language-text ext-text"><pre class="language-text"><code>native_handle_create() 函数生成 native_handle 实例，并将相关数据复制到其内部。

registerBuffer() 函数则属于 GraphicBufferMapper 类中的实现，
成员变量 mBufferMapper 是在 GraphicBuffer 构造函数中生成的，它所承担的任务是和 Gralloc 打交道。
</code></pre></div><p><code>GraphicBufferMapper</code> 构造函数的核心代码如下：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token class-name">GraphicBufferMapper</span><span class="token double-colon punctuation">::</span><span class="token function">GraphicBufferMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    hw_module_t <span class="token keyword">const</span><span class="token operator">*</span> <span class="token keyword">module</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> err <span class="token operator">=</span> <span class="token function">hw_get_module</span><span class="token punctuation">(</span>GRALLOC_HARDWARE_MODULE_ID<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token keyword">module</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这里出现了 <code>Gralloc</code> 的 <code>module id</code>，在 <a href="#_9-3-1-gralloc-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD">9.3.1 Gralloc 模块的加载</a> 小节中有介绍过。</p><p><code>GraphicBufferMapper::registerBuffer()</code> 只是起到了中介作用，它会直接调用 <code>gralloc_module_t::registerBuffer()</code>。</p><p>那么后者究竟完成了什么功能呢？因为这个函数的实现与具体平台有关，我们以 <code>msm7k</code> 为例来大概分析下：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* hardware/msm7k/libgralloc/Mapper.cpp */</span>
<span class="token keyword">int</span> <span class="token function">gralloc_register_buffer</span><span class="token punctuation">(</span>gralloc_module_t <span class="token keyword">const</span><span class="token operator">*</span> <span class="token keyword">module</span><span class="token punctuation">,</span> buffer_handle_t handle<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    private_handle_t<span class="token operator">*</span> hnd <span class="token operator">=</span> <span class="token punctuation">(</span>private_handle_t<span class="token operator">*</span><span class="token punctuation">)</span>handle<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    
    err <span class="token operator">=</span> <span class="token function">gralloc_map</span><span class="token punctuation">(</span><span class="token keyword">module</span><span class="token punctuation">,</span> handle<span class="token punctuation">,</span> <span class="token operator">&amp;</span>vaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> err<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以看到，通过 <code>handle</code> 句柄 <code>Client</code> 端可以将指定的内存区域映射到自己的进程空间中，而这块区域与 <code>BufferQueue</code> 中所指向的物理空间是一致的，从而成功地实现了两者的缓冲区共享。</p><p>这样在 <code>Surface::dequeueBuffer()</code> 函数的处理过程中，一旦遇到 <code>mGraphicBufferProducer-&gt;requestBuffer</code> 结果中包含有 <code>BUFFER_NEEDS_REALLOCATION</code> 的情况，就需要通过 <code>requestBuffer()</code> 得到的结果来 “刷新” <code>Client</code> 这端 <code>mSlots[]</code> 所管辖的缓冲区信息，以保证 <code>Surface</code> 与 <code>BufferQueue</code> 在任何情况下都能在 32 个 <code>BufferSlot</code> 中保持数据缓冲区上的高度一致。这也是后面它们能正确实施 “生产者-消费者” 模型的基础。</p><blockquote><p>注意：</p><p>高版本中将调用 <code>mBufferMapper.registerBuffer</code> 改成了调用 <code>mBufferMapper.importBuffer</code></p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* frameworks/native/libs/ui/GraphicBufferMapper.cpp */</span>
status_t <span class="token class-name">GraphicBufferMapper</span><span class="token double-colon punctuation">::</span><span class="token function">importBuffer</span><span class="token punctuation">(</span><span class="token keyword">const</span> native_handle_t<span class="token operator">*</span> rawHandle<span class="token punctuation">,</span> <span class="token keyword">uint32_t</span> width<span class="token punctuation">,</span>
                                           <span class="token keyword">uint32_t</span> height<span class="token punctuation">,</span> <span class="token keyword">uint32_t</span> layerCount<span class="token punctuation">,</span> PixelFormat format<span class="token punctuation">,</span>
                                           <span class="token keyword">uint64_t</span> usage<span class="token punctuation">,</span> <span class="token keyword">uint32_t</span> stride<span class="token punctuation">,</span>
                                           buffer_handle_t<span class="token operator">*</span> outHandle<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

    buffer_handle_t bufferHandle<span class="token punctuation">;</span>
    status_t error <span class="token operator">=</span> mMapper<span class="token operator">-&gt;</span><span class="token function">importBuffer</span><span class="token punctuation">(</span>rawHandle<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bufferHandle<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>error <span class="token operator">!=</span> NO_ERROR<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">ALOGW</span><span class="token punctuation">(</span><span class="token string">&quot;importBuffer(%p) failed: %d&quot;</span><span class="token punctuation">,</span> rawHandle<span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> error<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    error <span class="token operator">=</span> mMapper<span class="token operator">-&gt;</span><span class="token function">validateBufferSize</span><span class="token punctuation">(</span>bufferHandle<span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">,</span> format<span class="token punctuation">,</span> layerCount<span class="token punctuation">,</span> usage<span class="token punctuation">,</span>
                                        stride<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>error <span class="token operator">!=</span> NO_ERROR<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">ALOGE</span><span class="token punctuation">(</span><span class="token string">&quot;validateBufferSize(%p) failed: %d&quot;</span><span class="token punctuation">,</span> rawHandle<span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">freeBuffer</span><span class="token punctuation">(</span>bufferHandle<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>status_t<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token operator">*</span>outHandle <span class="token operator">=</span> bufferHandle<span class="token punctuation">;</span>

    <span class="token keyword">return</span> NO_ERROR<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* frameworks/native/libs/ui/include/ui/Gralloc.h */</span>
<span class="token keyword">class</span> <span class="token class-name">GrallocMapper</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">virtual</span> status_t <span class="token function">importBuffer</span><span class="token punctuation">(</span><span class="token keyword">const</span> native_handle_t<span class="token operator">*</span> rawHandle<span class="token punctuation">,</span>
                                  buffer_handle_t<span class="token operator">*</span> outBufferHandle<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token comment">/* 
    GrallocMapper 的子类实现有多个：Gralloc5Mapper、Gralloc4Mapper、Gralloc3Mapper、Gralloc2Mapper，
    分别声明在 Grallo5.h、 Grallo4.h、 Grallo3.h、 Grallo2.h
    分别定义在 Grallo5.cpp、 Grallo4.cpp、 Grallo3.cpp、 Grallo2.cpp
*/</span>

<span class="token comment">/* frameworks/native/libs/ui/GraphicBufferMapper.cpp */</span>
<span class="token class-name">GraphicBufferMapper</span><span class="token double-colon punctuation">::</span><span class="token function">GraphicBufferMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    mMapper <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">const</span> Gralloc5Mapper<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mMapper<span class="token operator">-&gt;</span><span class="token function">isLoaded</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        mMapperVersion <span class="token operator">=</span> Version<span class="token double-colon punctuation">::</span>GRALLOC_5<span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    mMapper <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">const</span> Gralloc4Mapper<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mMapper<span class="token operator">-&gt;</span><span class="token function">isLoaded</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        mMapperVersion <span class="token operator">=</span> Version<span class="token double-colon punctuation">::</span>GRALLOC_4<span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    mMapper <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">const</span> Gralloc3Mapper<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mMapper<span class="token operator">-&gt;</span><span class="token function">isLoaded</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        mMapperVersion <span class="token operator">=</span> Version<span class="token double-colon punctuation">::</span>GRALLOC_3<span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    mMapper <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">const</span> Gralloc2Mapper<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mMapper<span class="token operator">-&gt;</span><span class="token function">isLoaded</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        mMapperVersion <span class="token operator">=</span> Version<span class="token double-colon punctuation">::</span>GRALLOC_2<span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">LOG_ALWAYS_FATAL</span><span class="token punctuation">(</span><span class="token string">&quot;gralloc-mapper is missing&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 以 Gralloc5Mapper 为例</span>
<span class="token comment">/* frameworks/native/libs/ui/Gralloc5.cpp */</span>
status_t <span class="token class-name">Gralloc5Mapper</span><span class="token double-colon punctuation">::</span><span class="token function">importBuffer</span><span class="token punctuation">(</span><span class="token keyword">const</span> native_handle_t <span class="token operator">*</span>rawHandle<span class="token punctuation">,</span>
                                      buffer_handle_t <span class="token operator">*</span>outBufferHandle<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> mMapper<span class="token operator">-&gt;</span>v5<span class="token punctuation">.</span><span class="token function">importBuffer</span><span class="token punctuation">(</span>rawHandle<span class="token punctuation">,</span> outBufferHandle<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">Gralloc5Mapper</span><span class="token double-colon punctuation">::</span><span class="token function">Gralloc5Mapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    mMapper <span class="token operator">=</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mapper<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">const</span> Gralloc5 <span class="token operator">&amp;</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> Gralloc5 instance <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">auto</span> allocator <span class="token operator">=</span> <span class="token function">waitForAllocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>allocator<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> Gralloc5<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">void</span> <span class="token operator">*</span>so <span class="token operator">=</span> <span class="token function">loadIMapperLibrary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>so<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> Gralloc5<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 在动态链接库 so 中查找名为 AIMapper_loadIMapper 的符号</span>
        <span class="token keyword">auto</span> loadIMapper <span class="token operator">=</span> <span class="token punctuation">(</span>AIMapper_loadIMapperFn<span class="token punctuation">)</span><span class="token function">dlsym</span><span class="token punctuation">(</span>so<span class="token punctuation">,</span> <span class="token string">&quot;AIMapper_loadIMapper&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        AIMapper <span class="token operator">*</span>mapper <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
        AIMapper_Error error <span class="token operator">=</span> <span class="token function">loadIMapper</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mapper<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>error <span class="token operator">!=</span> AIMAPPER_ERROR_NONE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">ALOGE</span><span class="token punctuation">(</span><span class="token string">&quot;AIMapper_loadIMapper failed %d&quot;</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> Gralloc5<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> Gralloc5<span class="token punctuation">{</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>allocator<span class="token punctuation">)</span><span class="token punctuation">,</span> mapper<span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">loadIMapperLibrary</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span>imapperLibrary <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token punctuation">{</span>
        <span class="token keyword">auto</span> allocator <span class="token operator">=</span> <span class="token function">waitForAllocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>string mapperSuffix<span class="token punctuation">;</span>
        <span class="token keyword">auto</span> status <span class="token operator">=</span> allocator<span class="token operator">-&gt;</span><span class="token function">getIMapperLibrarySuffix</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mapperSuffix<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>status<span class="token punctuation">.</span><span class="token function">isOk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">ALOGE</span><span class="token punctuation">(</span><span class="token string">&quot;Failed to get IMapper library suffix&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">void</span><span class="token operator">*</span> so <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
        <span class="token comment">// TODO(b/322384429) switch this to __ANDROID_API_V__ when V is finalized</span>
        <span class="token keyword">if</span> <span class="token function">API_LEVEL_AT_LEAST</span><span class="token punctuation">(</span>__ANDROID_API_FUTURE__<span class="token punctuation">,</span> <span class="token number">202404</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            so <span class="token operator">=</span> <span class="token function">AServiceManager_openDeclaredPassthroughHal</span><span class="token punctuation">(</span><span class="token string">&quot;mapper&quot;</span><span class="token punctuation">,</span> mapperSuffix<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                                            RTLD_LOCAL <span class="token operator">|</span> RTLD_NOW<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>string lib_name <span class="token operator">=</span> <span class="token string">&quot;mapper.&quot;</span> <span class="token operator">+</span> mapperSuffix <span class="token operator">+</span> <span class="token string">&quot;.so&quot;</span><span class="token punctuation">;</span>
            so <span class="token operator">=</span> <span class="token function">android_load_sphal_library</span><span class="token punctuation">(</span>lib_name<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> RTLD_LOCAL <span class="token operator">|</span> RTLD_NOW<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>so<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">ALOGE</span><span class="token punctuation">(</span><span class="token string">&quot;Failed to load mapper.%s.so&quot;</span><span class="token punctuation">,</span> mapperSuffix<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> so<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> imapperLibrary<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* hardware/interfaces/graphics/mapper/stable-c/include/android/hardware/graphics/mapper/IMapper.h */</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">AIMapperV5</span> <span class="token punctuation">{</span>
    <span class="token function">AIMapper_Error</span> <span class="token punctuation">(</span><span class="token operator">*</span>_Nonnull importBuffer<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> native_handle_t<span class="token operator">*</span> _Nonnull handle<span class="token punctuation">,</span>
                                            buffer_handle_t _Nullable<span class="token operator">*</span> _Nonnull outBufferHandle<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></blockquote><h3 id="_5-3-应用程序的典型绘图流程" tabindex="-1"><a class="header-anchor" href="#_5-3-应用程序的典型绘图流程" aria-hidden="true">#</a> 5.3 应用程序的典型绘图流程</h3><p><code>BufferQueue</code> 可以有多达 32 个的 <code>BufferSlot</code>，为什么这样设计？</p><div class="language-text ext-text"><pre class="language-text"><code>一个可能的原因就是提高图形渲染速度。因为假如只有两个 buffer，可以想象一下，
当应用程序这个生产者的产出效率大于消费者的处理速度时，
很快就会 dequeue 完所有缓冲区而处于等待状态，从而导致不必要的麻烦。
当然，实际上 32 只是最大的容量，具体值是可以设置的，大家可以结合后面的 Project Butter 来进一步理解。
</code></pre></div><p>根据前面介绍的 <code>BufferQueue</code> 的内部原理，应用程序该如何与之配合的呢？</p><div class="language-text ext-text"><pre class="language-text"><code>解决这个疑惑的关键就是了解应用程序是如何执行绘图流程的，这也是本节内容的重点。

不过大家应该有个心理准备，即：应用程序并不会直接使用 BufferQueue（或者 Surface）。
和 Android 系统中很多其他地方一样，“层层封装” 在这里同样是存在的。
因而我们一方面要尽量抓住核心，另一方面也要辅以有效的分析手段，才能更快更好地从诸多错综复杂的类关系中找出问题的答案。
</code></pre></div><p>本小节选取 “系统开机动画” 这一应用程序为例，来分析应用程序图形绘制的流程。</p><blockquote><p>开机动画应用程序与 <code>SurfaceFlinger</code> 都是使用 <code>OpenGL ES</code> 来完成 <code>UI</code> 显示的。</p><p>不过因为开机动画是一个 <code>C++</code> 程序，所以不需要上层 <code>GLSurfaceView</code> 的支持。</p></blockquote><p>当一个 <code>Android</code> 设备上电后，正常情况下它会先后显示最多 4 个不同的开机画面。分别是：</p><div class="language-text ext-text"><pre class="language-text"><code>BootLoader
    这是第一个出现的画面。
    因为 boot-loader 只是负责系统后续模块的加载与启动，所以一般我们只让它显示一张静态的图片。

Kernel
    内核也有自己的显示画面。
    和 boot-loader 一样，默认情况下它也只是一张静态图片。

Android（最多 2 个）
    Android 是系统启动的最后一个阶段，也是最耗时间的一个。
    它的开机画面既可以是静态的文字、图片，也可以是动态的画面。
    另外，这一阶段可以包含最多两个开机画面：
        1. 通常前一个是文字或者静态图片（注意：默认是图片，但如果图片不存在的话，就显示文字）；
        2. 另外一个则是动画，如下图所示。
</code></pre></div><p><img src="/assets/07.f0964739.png" alt="" loading="lazy"></p><p>这个开机动画的实现类是 <code>BootAnimation</code>，它的内部就是借助于 SurfaceFlinger 来完成的。</p><p>另外，由于它并不是传统意义上的 <code>Java</code> 层应用程序，从而使得我们可以抛离很多上层的牵绊（比如一大堆 <code>JNI</code> 调用），进而以最直观的方式来审视 <code>BufferQueue</code> 的使用细节，这是分析本节问题的最佳选择。</p><p><code>BootAnimation</code> 是一个 <code>C++</code> 程序，其工程源码路径是：</p><p><img src="/assets/08.9d069137.png" alt="" loading="lazy"></p><p>和很多 <code>native</code> 应用一样，它也是在 <code>init</code> 脚本中被启动的。如下：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code>service bootanim <span class="token operator">/</span>system<span class="token operator">/</span>bin<span class="token operator">/</span>bootanimation
    <span class="token keyword">class</span> <span class="token class-name">main</span>
    user graphics
    group graphics
    disabled
    oneshot
</code></pre></div><blockquote><p>注意：</p><p>高版本中，略有不同，参考：</p><p><a href="https://cloud.tencent.com/developer/article/2358064" target="_blank" rel="noopener noreferrer">Android 开机动画启动流程<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p><a href="https://blog.csdn.net/m0_46857231/article/details/123066642" target="_blank" rel="noopener noreferrer">安卓 12 开机动画 Bootanimation 源码分析-启动流程<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></blockquote><p>当 <code>bootanimation</code> 被启动后，它首先会进入 <code>main</code> 函数（即 <code>main@bootanimation_main.cpp</code>）生成一个 <code>BootAnimation</code> 对象，并开启线程池（因为它需要与 <code>SurfaceFlinger</code> 等系统服务进行跨进程的通信）。在 <code>BootAnimation</code> 的构造函数中，同时会生成一个 <code>SurfaceComposerClient</code>：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* frameworks/base/cmds/bootanimation/BootAnimation.cpp */</span>
<span class="token class-name">BootAnimation</span><span class="token double-colon punctuation">::</span><span class="token function">BootAnimation</span><span class="token punctuation">(</span>sp<span class="token operator">&lt;</span>Callbacks<span class="token operator">&gt;</span> callbacks<span class="token punctuation">)</span>
        <span class="token operator">:</span> <span class="token function">Thread</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">mLooper</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Looper</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    mSession <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">SurfaceComposerClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>SurfaceComposerClient</code> 是每个 UI 应用程序与 <code>SurfaceFlinger</code> 间的独立纽带，后续很多操作都是通过它来完成的。</p><p>不过 <code>SurfaceComposerClient</code> 更多的只是一个封装，真正起作用的还是其内部的 <code>ISurfaceComposerClient</code>。</p><p>前面小节中我们已经讲解了 <code>IGraphicBufferProducer</code> 与 <code>ISurfaceComposerClient</code> 在应用程序中的获取顺序，那么两者有什么区别呢？</p><div class="language-text ext-text"><pre class="language-text"><code>简单来说，
ISurfaceComposerClient 是应用程序与 SurfaceFlinger 间的桥梁，
IgraphicBufferProducer 则是应用程序与 BufferQueue 间的传输通道。

这样的设计是合理的，体现了模块化的思想：
    SurfaceFlinger 的职责是 “Flinger”，即把系统中所有应用程序最终的 “绘图结果” 进行 “混合”，然后统一显示到物理屏幕上。
    它不应该也没有办法分出太多的精力去逐一关注各个应用程序的 “绘画过程”。
    这个任务自然而然地落在了 BufferQueue 的肩膀上，
    它是 SurfaceFlinger 派出的代表，也是每个应用程序 “一对一” 的辅导老师，
    指导着 UI 程序的 “画板申请”、“作画流程” 等一系列烦琐细节。
</code></pre></div><p>所以 BootAnimation 在其构造函数中就建立了与 SurfaceFlinger 的连接通道。</p><p>那么，它在什么时候会再去建立与 BufferQueue 的连接呢？</p><p>因为 BootAnimation 继承自 RefBase，当 main 函数中通过 sp 指针引用它时，会触发如下函数：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token class-name">BootAnimation</span><span class="token double-colon punctuation">::</span><span class="token function">onFirstRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 第一次被引用时</span>
    status_t err <span class="token operator">=</span> mSession<span class="token operator">-&gt;</span><span class="token function">linkToComposerDeath</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 监听死亡事件</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">==</span> NO_ERROR<span class="token punctuation">)</span> <span class="token punctuation">{</span>        
        <span class="token function">run</span><span class="token punctuation">(</span><span class="token string">&quot;BootAnimation&quot;</span><span class="token punctuation">,</span> PRIORITY_DISPLAY<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 开启线程</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>注意：</p><p>高版本中，<code>BootAnimation::run</code> 方法在 <code>main@bootanimation_main.cpp</code> 函数中执行：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">bool</span> noBootAnimation <span class="token operator">=</span> <span class="token function">bootAnimationDisabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>noBootAnimation<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sp<span class="token operator">&lt;</span>ProcessState<span class="token operator">&gt;</span> <span class="token function">proc</span><span class="token punctuation">(</span><span class="token class-name">ProcessState</span><span class="token double-colon punctuation">::</span><span class="token function">self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ProcessState</span><span class="token double-colon punctuation">::</span><span class="token function">self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">startThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// create the boot animation object (may take up to 200ms for 2MB zip)</span>
        sp<span class="token operator">&lt;</span>BootAnimation<span class="token operator">&gt;</span> boot <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">BootAnimation</span><span class="token punctuation">(</span>audioplay<span class="token double-colon punctuation">::</span><span class="token function">createAnimationCallbacks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        boot<span class="token operator">-&gt;</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token string">&quot;BootAnimation&quot;</span><span class="token punctuation">,</span> PRIORITY_DISPLAY<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 执行 BootAnimation::run 函数</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token class-name">IPCThreadState</span><span class="token double-colon punctuation">::</span><span class="token function">self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">joinThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></blockquote><p>当一个 <code>Client</code> 与远程 <code>Server</code> 建立了 <code>Binder</code> 通信后，它就可以使用这个 <code>Server</code> 的服务了，但前提是服务器运行正常。</p><p>换句话说，假如出现了 <code>Server</code> 异常的情况，<code>Client</code> 又如何知道呢？</p><div class="language-text ext-text"><pre class="language-text"><code>这就是 linkToComposerDeath 要解决的问题，
linkToComposerDeath 的第一个参数指明了接收 Binder Server 死亡事件的人，在本例中就是 BootAnimation 自身。
所以 BootAnimation 继承了I Binder::DeathRecipient，并实现了其中的 binderDied 接口。
</code></pre></div><p>如果 <code>BootAnimation::onFirstRef</code> 中 <code>err == NO_ERROR</code> 成立的话，那么接下来就要启动一个新线程来承载业务了。</p><p>为什么需要独立创建一个新的线程呢？</p><div class="language-text ext-text"><pre class="language-text"><code>前面 main 函数中，大家应该发现了 BootAnimation 启动了 Binder 线程池。
可以想象在只有一个线程的情况下，它是不可能既监听 Binder 请求，又去做开机动画绘制的。
</code></pre></div><p>当一个新的线程被 <code>run</code> 起来后，又触发了下列函数的调用：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* frameworks/base/cmds/bootanimation/BootAnimation.cpp */</span>
status_t <span class="token class-name">BootAnimation</span><span class="token double-colon punctuation">::</span><span class="token function">readyToRun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>…   
    <span class="token comment">/* 第一部分，向server端获取buffer空间，从而得到EGL需要的本地窗口 */</span>
    sp<span class="token operator">&lt;</span>SurfaceControl<span class="token operator">&gt;</span> control <span class="token operator">=</span> 
        <span class="token function">session</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">createSurface</span><span class="token punctuation">(</span><span class="token function">String8</span><span class="token punctuation">(</span><span class="token string">&quot;BootAnimation&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dinfo<span class="token punctuation">.</span>w<span class="token punctuation">,</span> dinfo<span class="token punctuation">.</span>h<span class="token punctuation">,</span> PIXEL_FORMAT_RGB_565<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">SurfaceComposerClient</span><span class="token double-colon punctuation">::</span><span class="token function">openGlobalTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    control<span class="token operator">-&gt;</span><span class="token function">setLayer</span><span class="token punctuation">(</span><span class="token number">0x40000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">SurfaceComposerClient</span><span class="token double-colon punctuation">::</span><span class="token function">closeGlobalTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    sp<span class="token operator">&lt;</span>Surface<span class="token operator">&gt;</span> s <span class="token operator">=</span> control<span class="token operator">-&gt;</span><span class="token function">getSurface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* 以下为第二部分，即 EGL 的配置流程 */</span>
    <span class="token keyword">const</span> EGLint attribs<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">/* 属性值较多，为了节约篇幅，我们省略具体内容 */</span>
    EGLint w<span class="token punctuation">,</span> h<span class="token punctuation">,</span> dummy<span class="token punctuation">;</span>
    EGLint numConfigs<span class="token punctuation">;</span> <span class="token comment">//总共有多少个 config</span>
    EGLConfig config<span class="token punctuation">;</span>
    EGLSurface surface<span class="token punctuation">;</span>
    EGLContext context<span class="token punctuation">;</span>
    <span class="token comment">// 第一步，得到默认的物理屏幕</span>
    EGLDisplay display <span class="token operator">=</span> <span class="token function">eglGetDisplay</span><span class="token punctuation">(</span>EGL_DEFAULT_DISPLAY<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token comment">// 第二步，初始化</span>
    <span class="token function">eglInitialize</span><span class="token punctuation">(</span>display<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token comment">// 第三步，选取最佳的 config</span>
    <span class="token function">eglChooseConfig</span><span class="token punctuation">(</span>display<span class="token punctuation">,</span> attribs<span class="token punctuation">,</span> <span class="token operator">&amp;</span>config<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>numConfigs<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token comment">// 第四步，通过本地窗口创建 Surface</span>
    surface <span class="token operator">=</span> <span class="token function">eglCreateWindowSurface</span><span class="token punctuation">(</span>display<span class="token punctuation">,</span> config<span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token comment">// 第五步，创建 context 环境</span>
    context <span class="token operator">=</span> <span class="token function">eglCreateContext</span><span class="token punctuation">(</span>display<span class="token punctuation">,</span> config<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">// 第六步，设置当前环境</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">eglMakeCurrent</span><span class="token punctuation">(</span>display<span class="token punctuation">,</span> surface<span class="token punctuation">,</span> surface<span class="token punctuation">,</span> context<span class="token punctuation">)</span> <span class="token operator">==</span> EGL_FALSE<span class="token punctuation">)</span>
        <span class="token keyword">return</span> NO_INIT<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> NO_ERROR<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>这个函数不但向我们展示了应用程序与 <code>BufferQueue</code> 的通信过程，</p><p>而且还有另外一个重要的学习点，即 <code>Opengl ES</code> 与 <code>EGL</code> 的使用流程。</p></blockquote><div class="language-text ext-text"><pre class="language-text"><code>函数 readyToRun 首先通过 session()-&gt;createSurface() 来获取一个 SurfaceControl。
其中 session() 得到的是 mSession 变量，也就是前面构造函数中生成的 SurfaceComposerClient 对象，
所以 SurfaceComposerClient::createSurface() 最终就是由 SurfaceFlinger 相关联的服务来实现的。
</code></pre></div><p>具体而言，<code>SurfaceComposerClient</code> 对应的 <code>Server</code> 端的实现是 <code>Client(C++)</code>：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* frameworks/native/libs/gui/SurfaceComposerClient.cpp */</span>
sp<span class="token operator">&lt;</span>SurfaceControl<span class="token operator">&gt;</span> <span class="token class-name">SurfaceComposerClient</span><span class="token double-colon punctuation">::</span><span class="token function">createSurface</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token function">createSurfaceChecked</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

status_t <span class="token class-name">SurfaceComposerClient</span><span class="token double-colon punctuation">::</span><span class="token function">createSurfaceChecked</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    binder<span class="token double-colon punctuation">::</span>Status status <span class="token operator">=</span> mClient<span class="token operator">-&gt;</span><span class="token function">createSurface</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
<span class="token comment">/* frameworks/native/libs/gui/include/gui/SurfaceComposerClient.h */</span>
<span class="token keyword">class</span> <span class="token class-name">SurfaceComposerClient</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">RefBase</span></span>
<span class="token punctuation">{</span>
    sp<span class="token operator">&lt;</span>ISurfaceComposerClient<span class="token operator">&gt;</span>  mClient<span class="token punctuation">;</span>

<span class="token comment">/* frameworks/native/services/surfaceflinger/Client.h */</span>
<span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> gui<span class="token double-colon punctuation">::</span><span class="token class-name">BnSurfaceComposerClient</span></span> 
<span class="token punctuation">{</span>

<span class="token comment">/*frameworks/native/services/surfaceflinger/Client.cpp*/</span>
status_t <span class="token class-name">Client</span><span class="token double-colon punctuation">::</span><span class="token function">createSurface</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    sp<span class="token operator">&lt;</span>MessageBase<span class="token operator">&gt;</span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">MessageCreateLayer</span><span class="token punctuation">(</span>mFlinger<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> w<span class="token punctuation">,</span> h<span class="token punctuation">,</span> format<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> handle<span class="token punctuation">,</span> gbp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    mFlinger<span class="token operator">-&gt;</span><span class="token function">postMessageSync</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 发送给 SurfaceFlinger 进行处理</span>
    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>MessageCreateLayer<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span> msg<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>Client::createSurface</code> 函数将用户的请求通过消息推送到前者的处理队列中，等到有结果后才返回。</p><blockquote><p>从 <code>postMessageSync</code> 名称可以看出，这是一个同步函数，</p><p>关于 <code>Client</code> 与 <code>SurfaceFlinger</code> 间的这种工作方式，我们会放在后续 <code>SurfaceFlinger</code> 小节作详细解释。</p></blockquote><p>因而最终还是要由 <code>SurfaceFlinger</code> 来执行操作，只不过 “操作的内容” 又是由 <code>Message</code> 本身提供的。</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">MessageCreateLayer</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">MessageBase</span></span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">virtual</span> <span class="token keyword">bool</span> <span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        result <span class="token operator">=</span> flinger<span class="token operator">-&gt;</span><span class="token function">createLayer</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> client<span class="token punctuation">,</span> w<span class="token punctuation">,</span> h<span class="token punctuation">,</span> format<span class="token punctuation">,</span> flags<span class="token punctuation">,</span>handle<span class="token punctuation">,</span> gbp<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><p>注意：</p><p>高版本中，<code>Client::createSurface</code> 函数中不再调用 <code>mFlinger-&gt;postMessageSync</code> 发消息，</p><p>而是直接调用 <code>mFlinger-&gt;createLayer</code>。</p></blockquote><p>现在的问题就转换为：<strong><code>createLayer</code> 生成了什么对象呢？</strong></p><p>没错，就是 <code>IGraphicBufferProducer</code>。</p><p>如下代码省略了中间一大段过程，只保留与问题相关的部分，更详细的分析可以参见后续小节：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code>status_t <span class="token class-name">SurfaceFlinger</span><span class="token double-colon punctuation">::</span><span class="token function">createLayer</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> sp<span class="token operator">&lt;</span>IBinder<span class="token operator">&gt;</span><span class="token operator">*</span> handle<span class="token punctuation">,</span> sp<span class="token operator">&lt;</span>IGraphicBufferProducer<span class="token operator">&gt;</span><span class="token operator">*</span> gbp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    status_t result <span class="token operator">=</span> NO_ERROR<span class="token punctuation">;</span>

    sp<span class="token operator">&lt;</span>Layer<span class="token operator">&gt;</span> layer<span class="token punctuation">;</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> ISurfaceComposerClient<span class="token double-colon punctuation">::</span>eFXSurfaceMask<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> ISurfaceComposerClient<span class="token double-colon punctuation">::</span>eFXSurfaceNormal<span class="token operator">:</span> <span class="token comment">// 普通 Surface</span>
            result <span class="token operator">=</span> <span class="token function">createNormalLayer</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span>name<span class="token punctuation">,</span> w<span class="token punctuation">,</span> h<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> format<span class="token punctuation">,</span>handle<span class="token punctuation">,</span> gbp<span class="token punctuation">,</span> <span class="token operator">&amp;</span>layer<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> ISurfaceComposerClient<span class="token double-colon punctuation">::</span>eFXSurfaceDim<span class="token operator">:</span>
            result <span class="token operator">=</span> <span class="token function">createDimLayer</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span>name<span class="token punctuation">,</span> w<span class="token punctuation">,</span> h<span class="token punctuation">,</span> flags<span class="token punctuation">,</span>handle<span class="token punctuation">,</span> gbp<span class="token punctuation">,</span> <span class="token operator">&amp;</span>layer<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
            result <span class="token operator">=</span> BAD_VALUE<span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>通过上面的代码段可以清楚地看到，<code>SurfaceFlinger</code> 不但生成了 <code>IGraphicBufferProducer</code> 对象，而且引入了新的概念：<strong><code>Layer</code></strong>。</p><div class="language-text ext-text"><pre class="language-text"><code>Layer 类在 SurfaceFlinger 中表示 “层”，通俗地讲就是代表了一个 “画面”，
最终物理屏幕上的显示结果就是通过对系统中同时存在的所有 “画面” 进行处理而得到的。

这就好比一排人（列队）各举着一张绘画作品，那么观察者从最前面往后看时，他首先看到的就是第一张画；
而假如第一张画恰好比第二张小，又或者第一张是透明/半透明的（这并非不可能，如作者是在玻璃上创作的），那么他就能看到第二张画。
依此类推，最终看到的就是这些 “画”（Layer）的混合（Flinger）结果。
</code></pre></div><p>以上类比告诉我们，<code>layer</code> 是有层级的，越靠近用户的那个 “层” 就越有优势。</p><p>了解了 <code>layer</code> 的层级概念后，函数 <code>BootAnimation::readyToRun</code> 接下来调用 <code>setLayer</code> 就不难理解了。</p><p>不过参数中传入了一个数值 <code>0x40000000</code>，这又是什么意思？</p><div class="language-text ext-text"><pre class="language-text"><code>其实这个值就是 layer 的层级，在显示系统中通常被称为 Z-Order，而且数字越大就越靠近用户。

BootAnimation 显示时因为整个系统中还只有开机画面一个应用程序，所以并不需要担心 Z-Order 的问题。
换句话说，0x40000000 这个值足矣。
</code></pre></div><p>设置完层级后，<code>BootAnimation::readyToRun</code> 接着调用 <code>control-&gt;getSurface()</code> 来得到一个 <code>Surface</code> 对象。</p><blockquote><p><code>Surface</code> 对象就是 “<code>Android</code> 中的本地窗口” 小节中介绍的其中一个本地窗口</p><p>详见： <a href="#_9-4-2-1-surface-%E7%9A%84%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B">9.4.2.1 Surface 的创建流程</a></p></blockquote><blockquote><p>涉及的相关类越来越多，为了避免混淆，我们先来整理下目前已经出现的各个类的关系：</p></blockquote><div class="language-text ext-text"><pre class="language-text"><code>ISurfaceComposerClient：
    应用程序与 SurfaceFlinger 间的通道，在应用进程中则被封装在 SurfaceComposerClient 这个类中。
    这是一个匿名的 Binder Server，
    由应用程序调用 SurfaceFlinger 这个实名 Binder 的 createConnection 方法来获取到，
    （具体位置在 SurfaceComposerClient::onFirstRef 中）
    服务端的实现是 frameworks/native/services/surfaceflinger/Client.h。

IGraphicBufferProducer：
    由应用程序调用 ISurfaceComposerClient::createSurface() 得到，
    同时在 SurfaceFlinger 这一进程中将会有一个 Layer 被创建，代表了一个 “画面”。
    ISurface 就是控制这一画面的 handle，它将保存在应用程序端的 SurfaceControl 中。

Surface：
    从逻辑关系上看，它是上述 ISurface 的使用者。
    从继承关系上看，它是一个本地窗口。
    Surface 内部持有 IGraphicBufferProducer，即 BufferQueue 的实现接口。
    换个角度来思考，当 EGL 想通过 Surface 这个本地窗口完成某些功能时，
    Surface 实际上又利用 ISurface 和 IGraphicBufferProducer 来取得远程服务端的对应服务，以完成 EGL 的请求。
</code></pre></div><p>回到 <code>BootAnimation::readyToRun()</code> 中。</p><div class="language-text ext-text"><pre class="language-text"><code>因为本地窗口 Surface 已经成功创建，接下来就该 EGL 上场了。
具体流程我们在代码中都加了注释，这里就不再赘述。
</code></pre></div><p>当 <code>EGL</code> 准备好环境后，意味着程序可以正常使用 <code>OpenGL ES</code> 提供的各种 <code>API</code> 函数进行绘图了。</p><blockquote><p>这部分实现就集中在随后的 <code>BootAnimation::threadLoop()</code></p><p>以及 <code>BootAnimation::android()/BootAnimation::movie()</code> 中。</p></blockquote><p>最后，对一个典型的应用程序使用 SurfaceFlinger 进行绘图的流程总结如下图所示：</p><blockquote><p>其中涉及 <code>IgraphicBufferProducer</code>、<code>Surface</code>、<code>SurfaceControl</code>、<code>Layer</code> 等太多元素，只选取部分重点类进行展示</p></blockquote><p><img src="/assets/09.10599114.png" alt="" loading="lazy"></p><h3 id="_5-4-应用程序与-bufferqueue-的关系" tabindex="-1"><a class="header-anchor" href="#_5-4-应用程序与-bufferqueue-的关系" aria-hidden="true">#</a> 5.4 应用程序与 <code>BufferQueue</code> 的关系</h3><p>现在我们已经明白了应用程序利用 <code>SurfaceFlinger</code> 进行绘制工作的大致流程，只不过在这个过程中直到最后才出现了 <code>BufferQueue</code>。</p><p><strong>那么，应用程序具体是如何借助 <code>BufferQueue</code> 来完成工作的呢？</strong></p><p>仔细观察不难发现，当应用程序端通过 <code>ISurfaceComposerClient::createSurface()</code> 来发起创建 <code>Surface</code> 的请求时，<code>SurfaceFlinger</code> 服务进程这边会创建一个 <code>Layer</code>。既然 <code>Layer</code> 代表了一个画面图层，那么它肯定需要存储 “图层数据” 的地方，因而我们选择以这里作为入口：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/*frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp*/</span>
status_t <span class="token class-name">SurfaceFlinger</span><span class="token double-colon punctuation">::</span><span class="token function">createLayer</span><span class="token punctuation">(</span><span class="token keyword">const</span> String8<span class="token operator">&amp;</span> name<span class="token punctuation">,</span> <span class="token keyword">const</span> sp<span class="token operator">&lt;</span>Client<span class="token operator">&gt;</span><span class="token operator">&amp;</span> client<span class="token punctuation">,</span>
        <span class="token keyword">uint32_t</span> w<span class="token punctuation">,</span> <span class="token keyword">uint32_t</span> h<span class="token punctuation">,</span> PixelFormat format<span class="token punctuation">,</span> <span class="token keyword">uint32_t</span> flags<span class="token punctuation">,</span>
        sp<span class="token operator">&lt;</span>IBinder<span class="token operator">&gt;</span><span class="token operator">*</span> handle<span class="token punctuation">,</span> sp<span class="token operator">&lt;</span>IGraphicBufferProducer<span class="token operator">&gt;</span><span class="token operator">*</span> gbp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span>
    status_t result <span class="token operator">=</span> NO_ERROR<span class="token punctuation">;</span>
    sp<span class="token operator">&lt;</span>Layer<span class="token operator">&gt;</span> layer<span class="token punctuation">;</span>

    <span class="token keyword">switch</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> ISurfaceComposerClient<span class="token double-colon punctuation">::</span>eFXSurfaceMask<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// Layer类型，目前只有两种</span>
        <span class="token keyword">case</span> ISurfaceComposerClient<span class="token double-colon punctuation">::</span>eFXSurfaceNormal<span class="token operator">:</span> <span class="token comment">// 普通 Layer</span>
            result <span class="token operator">=</span> <span class="token function">createNormalLayer</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span> name<span class="token punctuation">,</span> w<span class="token punctuation">,</span> h<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> format<span class="token punctuation">,</span> handle<span class="token punctuation">,</span> gbp<span class="token punctuation">,</span> <span class="token operator">&amp;</span>layer<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> ISurfaceComposerClient<span class="token double-colon punctuation">::</span>eFXSurfaceDim<span class="token operator">:</span> <span class="token comment">// Dim 效果的 Layer</span>
            result <span class="token operator">=</span> <span class="token function">createDimLayer</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span> name<span class="token punctuation">,</span> w<span class="token punctuation">,</span> h<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> handle<span class="token punctuation">,</span> gbp<span class="token punctuation">,</span> <span class="token operator">&amp;</span>layer<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
            result <span class="token operator">=</span> BAD_VALUE<span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> NO_ERROR<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">addClientLayer</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span> <span class="token operator">*</span>handle<span class="token punctuation">,</span> <span class="token operator">*</span>gbp<span class="token punctuation">,</span> layer<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 添加到全局的管理中</span>
        <span class="token function">setTransactionFlags</span><span class="token punctuation">(</span>eTransactionNeeded<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 设置业务标志</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个函数用于生成一个 <code>Layer</code>。</p><div class="language-text ext-text"><pre class="language-text"><code>从 enum 值定义来看，当前系统中有多达十几种 Layer 类型，只不过多数还没有真正实现。
目前能用的只有两个，即 eFXSurfaceNormal 和 eFXSurfaceDim。
1. 正常情况下的图层；
2. 带有 Dim 效果的图层。
更早前版本中还有一种 Blur 效果的 Layer。可能出于效率的考虑，当前系统中已经统一将它用 Dim 替代了。
相信在后续的 Android 版本中还会把它们再区分开来。
</code></pre></div><blockquote><p>注意：</p><p>高版本中 <code>SurfaceFlinger::createLayer</code> 的实现已有所不同。</p><p>不管哪种类型的 <code>Layer</code>，都统一调用 <code>SurfaceFlinger::createBufferStateLayer</code></p></blockquote><p>最终返回给调用者的有两个：即 <code>handle</code> 和 <code>gbp</code>。前者是一个 <code>IBinder</code> 对象，后者则是大家熟悉的 <code>IGraphicBufferProducer</code>。</p><blockquote><p>注意：</p><p>高版本中 返回数据的封装形式也不太一样了。</p></blockquote><p><code>Layer</code> 和 <code>handle</code> 及 <code>gbp</code> 有什么联系呢？我们选取 <code>eFXSurfaceNormal</code> 类型的图层来深入分析：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code>status_t <span class="token class-name">SurfaceFlinger</span><span class="token double-colon punctuation">::</span><span class="token function">createNormalLayer</span><span class="token punctuation">(</span><span class="token keyword">const</span> sp<span class="token operator">&lt;</span>Client<span class="token operator">&gt;</span><span class="token operator">&amp;</span> client<span class="token punctuation">,</span>
        <span class="token keyword">const</span> String8<span class="token operator">&amp;</span> name<span class="token punctuation">,</span> <span class="token keyword">uint32_t</span> w<span class="token punctuation">,</span> <span class="token keyword">uint32_t</span> h<span class="token punctuation">,</span> <span class="token keyword">uint32_t</span> flags<span class="token punctuation">,</span> PixelFormat<span class="token operator">&amp;</span> format<span class="token punctuation">,</span>
        sp<span class="token operator">&lt;</span>IBinder<span class="token operator">&gt;</span><span class="token operator">*</span> handle<span class="token punctuation">,</span> sp<span class="token operator">&lt;</span>IGraphicBufferProducer<span class="token operator">&gt;</span><span class="token operator">*</span> gbp<span class="token punctuation">,</span> sp<span class="token operator">&lt;</span>Layer<span class="token operator">&gt;</span><span class="token operator">*</span> outLayer<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// format 的赋值过程省略</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">// 生成 Layer 对象</span>
    <span class="token operator">*</span>outLayer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Layer</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> client<span class="token punctuation">,</span> name<span class="token punctuation">,</span> w<span class="token punctuation">,</span> h<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token comment">// 为 Layer 设置缓冲区</span>
    status_t err <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>outLayer<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">setBuffers</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> h<span class="token punctuation">,</span> format<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">==</span> NO_ERROR<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">*</span>handle <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>outLayer<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">getHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// handle 是通过这个函数获取的，后面我们再分析</span>
        <span class="token operator">*</span>gbp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>outLayer<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">getBufferQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// gbp 是从 Layer 中取出来的</span>
    <span class="token punctuation">}</span>
    <span class="token function">ALOGE_IF</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> <span class="token string">&quot;createNormalLayer() failed (%s)&quot;</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span><span class="token operator">-</span>err<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> err<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>注意：</p><p>高版本中，创建 <code>Layer</code> 对象的过程有所不同：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp */</span>
status_t <span class="token class-name">SurfaceFlinger</span><span class="token double-colon punctuation">::</span><span class="token function">createBufferStateLayer</span><span class="token punctuation">(</span>
                LayerCreationArgs<span class="token operator">&amp;</span> args<span class="token punctuation">,</span> sp<span class="token operator">&lt;</span>IBinder<span class="token operator">&gt;</span><span class="token operator">*</span> handle<span class="token punctuation">,</span> sp<span class="token operator">&lt;</span>Layer<span class="token operator">&gt;</span><span class="token operator">*</span> outLayer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">*</span>outLayer <span class="token operator">=</span> <span class="token function">getFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createBufferStateLayer</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">*</span>handle <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>outLayer<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">getHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> NO_ERROR<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* frameworks/native/services/surfaceflinger/SurfaceFlingerDefaultFactory.cpp */</span>
sp<span class="token operator">&lt;</span>Layer<span class="token operator">&gt;</span> <span class="token class-name">DefaultFactory</span><span class="token double-colon punctuation">::</span><span class="token function">createBufferStateLayer</span><span class="token punctuation">(</span><span class="token keyword">const</span> LayerCreationArgs<span class="token operator">&amp;</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 调用构造函数 Layer::Layer(const surfaceflinger::LayerCreationArgs&amp; args) 创建 Layer 对象</span>
    <span class="token keyword">return</span> <span class="token class-name">sp</span><span class="token operator">&lt;</span>Layer<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">make</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>

<span class="token comment">/* frameworks/native/services/surfaceflinger/Layer.cpp */</span>
<span class="token keyword">void</span> <span class="token class-name">Layer</span><span class="token double-colon punctuation">::</span><span class="token function">onFirstRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    mFlinger<span class="token operator">-&gt;</span><span class="token function">onLayerFirstRef</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp */</span>
<span class="token keyword">void</span> <span class="token class-name">SurfaceFlinger</span><span class="token double-colon punctuation">::</span><span class="token function">onLayerFirstRef</span><span class="token punctuation">(</span>Layer<span class="token operator">*</span> layer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    mNumLayers<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>layer<span class="token operator">-&gt;</span><span class="token function">isRemovedFromCurrentState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        mScheduler<span class="token operator">-&gt;</span><span class="token function">registerLayer</span><span class="token punctuation">(</span>layer<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 注意：高版本中，会把 Layer 注册到 Scheduler 中</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>并且，高版本中的 <code>Layer</code> 也没有提供 <code>Layer::getBufferQueue()</code> 函数了，只提供了 <code>Layer::getBuffer()</code> 函数</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* frameworks/native/services/surfaceflinger/Layer.h */</span>
<span class="token keyword">class</span> <span class="token class-name">Layer</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token class-name">RefBase</span></span> 
<span class="token punctuation">{</span>
    sp<span class="token operator">&lt;</span>GraphicBuffer<span class="token operator">&gt;</span> <span class="token function">getBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
</code></pre></div></blockquote><p><code>SurfaceFlinger::createNormalLayer</code> 这个函数的逻辑很简单：</p><div class="language-text ext-text"><pre class="language-text"><code>新建 Layer 对象，
设置 Buffers 的属性（setBuffers），
然后分别通过 getHandle 和 getBufferQueue 获得 handle 及 gbp。
</code></pre></div><p>先来看看 <code>handle</code> 到底是何方 “神圣”：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* frameworks/native/services/surfaceflinger/Layer.cpp */</span>
sp<span class="token operator">&lt;</span>IBinder<span class="token operator">&gt;</span> <span class="token class-name">Layer</span><span class="token double-colon punctuation">::</span><span class="token function">getHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Mutex<span class="token double-colon punctuation">::</span>Autolock <span class="token function">_l</span><span class="token punctuation">(</span>mLock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">class</span> <span class="token class-name">Handle</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">BBinder</span><span class="token punctuation">,</span> <span class="token keyword">public</span> <span class="token class-name">LayerCleaner</span></span> <span class="token punctuation">{</span> <span class="token comment">// Handle “真身” 在这里</span>
    wp<span class="token operator">&lt;</span><span class="token keyword">const</span> Layer<span class="token operator">&gt;</span> mOwner<span class="token punctuation">;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token function">Handle</span><span class="token punctuation">(</span><span class="token keyword">const</span> sp<span class="token operator">&lt;</span>SurfaceFlinger<span class="token operator">&gt;</span><span class="token operator">&amp;</span> flinger<span class="token punctuation">,</span> <span class="token keyword">const</span> sp<span class="token operator">&lt;</span>Layer<span class="token operator">&gt;</span><span class="token operator">&amp;</span> layer<span class="token punctuation">)</span>
            <span class="token operator">:</span> <span class="token function">LayerCleaner</span><span class="token punctuation">(</span>flinger<span class="token punctuation">,</span> layer<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">mOwner</span><span class="token punctuation">(</span>layer<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 空的，什么都没有</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">Handle</span><span class="token punctuation">(</span>mFlinger<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 新建一个 Handle 对象</span>
<span class="token punctuation">}</span>
</code></pre></div><p>由这段代码可以看出，<code>Handle</code> 几乎没有任何有用的内容。那么，其设计初衷是什么？</p><p>仔细观察可以发现，<code>Handle</code> 继承了 <code>LayerCleaner</code>。从字面意思来看，它是 “图层清理者”，清理时机如下所示：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code>Layer<span class="token double-colon punctuation">::</span>LayerCleaner<span class="token double-colon punctuation">::</span>～<span class="token function">LayerCleaner</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// destroy client resources</span>
    mFlinger<span class="token operator">-&gt;</span><span class="token function">onLayerDestroyed</span><span class="token punctuation">(</span>mLayer<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>也就是说，当 LayerCleaner（或者 Handle）进行析构操作时，会去主动调用 SurfaceFlinger 的 onLayerDestroyed 来收拾 “图层残局”。换句话说，一旦没有人引用此Handle对象，系统就会开始清理工作。</p><p>了解了 Handle 后，我们再来分析 Layer 中的另一个重要元素，即 BufferQueue：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* frameworks/native/services/surfaceflinger/Layer.cpp */</span>
sp<span class="token operator">&lt;</span>BufferQueue<span class="token operator">&gt;</span> <span class="token class-name">Layer</span><span class="token double-colon punctuation">::</span><span class="token function">getBufferQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> mSurfaceFlingerConsumer<span class="token operator">-&gt;</span><span class="token function">getBufferQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>SurfaceFlinger</code> 自认为是 “<code>Consumer</code>” 还是比较贴切的。而这个消费者的另一个职责居然是提供 <code>Buffer</code> 空间，真是 “一条龙服务”。</p><p>我们可以来看看 <code>SurfaceFlinger</code> 是如何提供的 <code>BufferQueue</code>，其中又涉及多个类的继承，如下图所示。</p><p><img src="/assets/10.801c9046.png" alt="" loading="lazy"></p><p>从图中可以看到，<code>SurfaceFlingerConsumer</code> 中真正持有 <code>BufferQueue</code> 对象的是成员变量 <code>ConsumerBase::mBufferQueu</code>e，那么这个变量又是怎么赋值的呢？其实还是在 <code>Layer</code> 中，即当有人第一次引用 <code>Layer</code> 时触发了它的 <code>onFirstRef</code>。此时：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token class-name">Layer</span><span class="token double-colon punctuation">::</span><span class="token function">onFirstRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    sp<span class="token operator">&lt;</span>BufferQueue<span class="token operator">&gt;</span> bq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">SurfaceTextureLayer</span><span class="token punctuation">(</span>mFlinger<span class="token punctuation">)</span><span class="token punctuation">;</span>
    mSurfaceFlingerConsumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">SurfaceFlingerConsumer</span><span class="token punctuation">(</span>mTextureName<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> GL_TEXTURE_EXTERNAL_OES<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> bq<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这样就基本清楚了：</p><div class="language-text ext-text"><pre class="language-text"><code>Layer 中直接或者间接地提供了 Handle 和 BufferQueue，而且两者都是匿名的 Binder Server。
当客户端应用程序调用 createSurface 时，它可以同时获取到这两个重要对象。
大家一定要记住，IGraphicBufferProducer 的 Server 端的实现是 BufferQueue。由于命名上的差异，这点很容易搞错。

因而应用程序与 BufferQueue 的关系就比较明朗了。
虽然中间经历了多次跨进程通信，但对于应用程序来说最终只使用到了 BufferQueue（通过 IGraphicBufferProducer）。
</code></pre></div><p>本小节可以从侧面证明如下几个关键点：</p><ol><li><p>应用程序可以调用 <code>createSurface</code> 来建立多个 <code>Layer</code>，它们是一对多的关系。</p><div class="language-text ext-text"><pre class="language-text"><code>理由就是 createSurface 中没有任何机制来限制应用程序的多次调用；
相反，它会对一个应用程序多次申请而产生的 Layer 进行统一管理。如下所示：
</code></pre></div><div class="language-cpp ext-cpp"><pre class="language-cpp"><code>status_t <span class="token class-name">SurfaceFlinger</span><span class="token double-colon punctuation">::</span><span class="token function">createLayer</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> NO_ERROR<span class="token punctuation">)</span> <span class="token punctuation">{</span>    
        <span class="token function">addClientLayer</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span> <span class="token operator">*</span>handle<span class="token punctuation">,</span> <span class="token operator">*</span>gbp<span class="token punctuation">,</span> layer<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 添加新增的 Layer 到全局管理中</span>
        <span class="token function">setTransactionFlags</span><span class="token punctuation">(</span>eTransactionNeeded<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><div class="language-text ext-text"><pre class="language-text"><code>为应用程序申请的 Layer，一方面需要告知 SurfaceFlinger，另一方面要记录到各 Client 内部中。
这两个步骤是由 addClientLayer() 分别调用 Client::attachLayer() 和 SurfaceFlinger::addLayer_l() 来完成的：
</code></pre></div><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token class-name">SurfaceFlinger</span><span class="token double-colon punctuation">::</span><span class="token function">addClientLayer</span><span class="token punctuation">(</span><span class="token keyword">const</span> sp<span class="token operator">&lt;</span>Client<span class="token operator">&gt;</span><span class="token operator">&amp;</span> client<span class="token punctuation">,</span><span class="token keyword">const</span> sp<span class="token operator">&lt;</span>IBinder<span class="token operator">&gt;</span><span class="token operator">&amp;</span> handle<span class="token punctuation">,</span>
        <span class="token keyword">const</span> sp<span class="token operator">&lt;</span>IGraphicBufferProducer<span class="token operator">&gt;</span><span class="token operator">&amp;</span> gbc<span class="token punctuation">,</span><span class="token keyword">const</span> sp<span class="token operator">&lt;</span>Layer<span class="token operator">&gt;</span><span class="token operator">&amp;</span> lbc<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// attach this layer to the client</span>
    client<span class="token operator">-&gt;</span><span class="token function">attachLayer</span><span class="token punctuation">(</span>handle<span class="token punctuation">,</span> lbc<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 让此 Layer 与 Client 相关联</span>

    <span class="token comment">// add this layer to the current state list</span>
    Mutex<span class="token double-colon punctuation">::</span>Autolock <span class="token function">_l</span><span class="token punctuation">(</span>mStateLock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    mCurrentState<span class="token punctuation">.</span>layersSortedByZ<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>lbc<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将 Layer 按顺序添加到全局变量中</span>
    mGraphicBufferProducerList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>gbc<span class="token operator">-&gt;</span><span class="token function">asBinder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将 gbc 也添加到全局变量中</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-text ext-text"><pre class="language-text"><code>对于 SurfaceFlinger，它需要对系统中当前所有的 Layer 进行 Z-Order 排序，以决定用户所能看到的 “画面” 是什么样的；
对于 Client，它则利用内部的 mLayers 成员变量来逐一记录新增（attachLayer）和移除（detachLayer）的图层。
从中不难看出，一个 Client 是可以包含多个 Layer 的。
</code></pre></div></li><li><p>每个 <code>Layer</code> 对应一个 <code>BufferQueue</code>。换句话说，一个应用程序可能对应多个 <code>BufferQueue</code>。另外，<code>Layer</code> 没有直接持有 <code>BufferQueue</code> 对象，而是由其内部的 <code>mSurfaceFlingerConsumer</code> 来管理。</p></li></ol><h2 id="_6-surfaceflinger" tabindex="-1"><a class="header-anchor" href="#_6-surfaceflinger" aria-hidden="true">#</a> 6 <code>SurfaceFlinger</code></h2><p>从本小节开始，我们正式切入 <code>SurfaceFlinger</code> 的分析。</p><p>为了保持讲解的连贯性，部分内容可能在前面的章节中已经有所涉及，接下来将会对其中的细节做更多的扩展讲解。</p><p>内容组织如下：</p><div class="language-text ext-text"><pre class="language-text"><code>1. 首先介绍从 Android 4.1 版本起引入的一个新特性（Project Butter）。
    理解这个项目是必要的，可以说 SurfaceFlinger 有很大一部分内容就是围绕它展开的。
2. SurfaceFlinger 的启动过程及工作方式。
3. SurfaceFlinger 与 BufferQueue 及应用程序间的关系。
4. SurfaceFlinger 对 VSYNC 信号的处理过程（重点）。
</code></pre></div><h3 id="_6-1-黄油计划-project-butter" tabindex="-1"><a class="header-anchor" href="#_6-1-黄油计划-project-butter" aria-hidden="true">#</a> 6.1 “黄油计划”（<code>Project Butter</code>）</h3><p>为什么会叫这个名字呢？</p><div class="language-text ext-text"><pre class="language-text"><code>一个可能的原因就是这个 Project 的目的是改善用户抱怨最多的 Android 几大缺陷之一，即 UI 响应速度。
Google 希望这一新计划可以让 Android 系统摆脱 “UI交互” 上的 “滞后” 感，而能像加了黄油一般 “顺滑”。
</code></pre></div><p><code>Google</code> 在 2012 年的 <code>I/O</code> 大会上宣布了这一计划，并在 <code>Android 4.1</code> 中正式搭载了具体的实现机制。</p><p>“黄油计划” 中有两个重要的组成部分，即 <strong><code>VSync</code> 和 <code>Triple Buffering</code></strong>。下面先分别介绍引入它们的原因。</p><p>当我们玩游戏或者看电影时，可能经常遇到以下情形。</p><div class="language-text ext-text"><pre class="language-text"><code>某些游戏场面好像由几个场景 “拼凑” 而成。
电影画面不连贯，好像被 “割裂” 了。
</code></pre></div><p>这样描述有点抽象，我们引用 <code>wikipedia</code> 上的一张图来看下实际效果，如下图所示。</p><p><img src="/assets/11.daa37838.png" alt="" loading="lazy"></p><p>以时间为横坐标来描述接下来会发生的事情，如下图所示。</p><p><img src="/assets/12.c87c1d5b.png" alt="" loading="lazy"></p><p>上半部分的方框表示在不同的时间点时显示屏的内容（加深的部分），下半部分则是同一时间点时 <code>Frame Buffer</code> 中的数据状态，编号表示第几个 <code>frame</code> 帧，不考虑清屏。</p><div class="language-text ext-text"><pre class="language-text"><code>0.01秒
    由于两者速率相差不少，此时buffer中已经准备好了第 1 帧数据，而显示器只显示了第 1 帧画面的 2/3。

0.015秒
    第 1 帧画面在显示屏上终于完整地显示了出来，而此时 buffer 中有 1/3 的部分已经被填充上第 2 帧数据了。

0.02秒
    Buffer 中已经准备好了第 2 帧数据，而显示屏出现了 Screen Tearing，
    即：有三分之一的内容属于第 2 帧，其余的则来源于第 1 帧画面。
</code></pre></div><p>在单缓冲区的情况下，这个问题是很难规避的。所以之前我们介绍的双缓冲技术（<a href="#_9-4-1-1-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%93%8D%E4%BD%9C">9.4.1.1 小节</a>），其基本原理就是采用了两块 <code>buffer</code>：</p><div class="language-text ext-text"><pre class="language-text"><code>一块 Back Buffer 用于 CPU/GPU 后台绘制，
一块 Frame Buffer 用于屏幕显示；
</code></pre></div><p>当 <code>Back Buffer</code> 准备就绪后，它们才进行交换。</p><p>不可否认，双缓冲技术（<code>Double Buffering</code>）可以在很大程度上降低 <code>Screen Tearing</code> 类型的错误，但它是万能的吗？</p><p><strong>一个需要考虑的问题是：我们应该每隔多少时间点进行两个缓冲区的交换呢？</strong></p><div class="language-text ext-text"><pre class="language-text"><code>假如是 Back Buffer 准备完成一帧数据以后就进行，那么如果此时屏幕还没有完整显示上一帧内容，肯定是会出问题的。
看来只能等到屏幕处理完一帧数据后，才可以执行这一操作。
</code></pre></div><p>一个典型的显示器有两个重要特性，即 “行频和场频”。</p><div class="language-text ext-text"><pre class="language-text"><code>行频（Horizontal Scanning Frequency）又称为 “水平扫描频率”，是屏幕每秒钟从左至右扫描的次数；
场频（Vertical Scanning Frequency）也称为 “垂直扫描频率”，是每秒钟整个屏幕刷新的次数。

由此也可以得出它们的关系：行频 = 场频 * 纵坐标分辨率
</code></pre></div><p>当扫描完一个屏幕后，设备需要重新回到第一行以进入下一轮的循环，此时有一段时间空隙，称为 <code>Vertical Blanking Interval</code>（<code>VBI</code>）。</p><p>这个时间点就是我们进行缓冲区交换的最佳时间。因为此时屏幕没有在刷新，也就避免了交换过程中出现 <code>Screen Tearing</code> 的状况。</p><p><code>Vsync</code>（垂直同步）是 <code>Vertical Synchronization</code> 的简写，它利用 <code>VBI</code> 时期出现的 <code>Vertical Sync Pulse</code> 来保证双缓冲能在最佳时间点进行交换。</p><blockquote><p>所以说 <code>VSync</code> 这个概念并不是 <code>Google</code> 首创的，而是在早些年前的 <code>PC</code> 领域就已经出现了。不过 <code>Android 4.1</code> 赋予了它新的功用，稍后就可以看到。</p></blockquote><p>上面我们讨论的情况其实是基于一个假设，即 “绘图速度大于显示速度”，那么当 “绘图速度小于显示速度” 呢？</p><p>先来分析绘图过程中当 “绘图速度小于显示速度”，且没有采用 <code>VSync</code> 同步时的情况，如下图所示。</p><p><img src="/assets/13.bf525034.png" alt="" loading="lazy"></p><p>上图中有 3 个元素：</p><div class="language-text ext-text"><pre class="language-text"><code>Display 表示显示屏幕，
GPU 和 CPU 负责渲染帧数据。每一帧以方框表示并以数字进行编号，如 0、1、2 等。
VSync 用于指导双缓冲区的交换。
</code></pre></div><p>以时间的顺序来看看当不采用 <code>VSync</code> 同步时将会发生什么异常。</p><div class="language-text ext-text"><pre class="language-text"><code>Step1. 
    Display 显示第 0 帧数据，此时 CPU 和 GPU 渲染第 1 帧画面，而且赶在 Display 显示下一帧（帧1）前完成。
Step2. 
    因为渲染及时，Display 在第 0 帧显示完成后，也就是第 1 个 VSync 后，正常显示第 1 帧。
Step3. 
    由于某些原因（比如 CPU 资源被占用），系统没能及时地处理第 2 帧，而是等到第 2 个 VSync 到来前才开始处理。
Step4. 
    第 2 个 VSync 来临时，由于第 2 帧数据还没有准备就绪，实际显示的还是第 1 帧的内容。
    这种情况被 Android 开发组命名为 “Jank”。
Step5. 
    当第 2 帧数据准备完成后，它并不会立即被显示，而是要等待下一个 VSync。
</code></pre></div><p>所以总的来说，就是屏幕 “平白无故” 地重复显示了一次第 1 帧。</p><p>原因大家应该都看到了，就是 <code>CPU</code> 没有及时地着手处理第 2 帧的渲染工作，以致 “延误军机”。</p><p><code>Android</code> 系统中一直存在着这个问题，直到 “黄油计划” 的引入。</p><p>从 <code>Android 4.1 Jelly Bean</code> 开始，<code>VSync</code> 得到了进一步的应用，即：系统在收到 <code>VSync Pulse</code> 后，将立即开始下一帧的渲染，如下图所示。</p><p><img src="/assets/14.8d49815d.png" alt="" loading="lazy"></p><p>上图中展示的是采用 <code>VSync</code> 进行显示同步的情况。</p><div class="language-text ext-text"><pre class="language-text"><code>一旦 VSync 信号出现，CPU 便不再犹豫，即刻开始执行 Buffer 的准备工作。
大部分的 Android 显示设备刷新频率是 60Hz，这也就意味着每一帧最多只能留给系统 1/60=16ms 左右的准备时间。
假如 CPU/GPU 的 FPS（Frames Per Second）高于这个值，那么这个方案是完美的，显示效果将很好。
</code></pre></div><p>可是我们没有办法保证所有设备的硬件配置都能达到要求。假如 <code>CPU/GPU</code> 的性能无法满足上图条件（即：<code>FPS</code> 低于屏幕刷新率），又会是什么情况呢？</p><p>在分析这一问题之前，我们先来看看采用 <code>VSync</code> 和双缓冲机制的情况，如下图所示。</p><p><img src="/assets/15.db128946.png" alt="" loading="lazy"></p><p>图中采用了双缓冲技术以及前面介绍的 <code>VSync</code> 同步机制，可以看到整个显示过程还是相当不错的。虽然 <code>CPU/GPU</code> 处理所用的时间时短时长，但总的来说都在 <code>16ms</code> 以内，因而不影响显示效果。</p><blockquote><p><code>A</code> 和 <code>B</code> 分别代表两个缓冲区，它们不断地互相交换以保证画面的正确显示。</p></blockquote><p>现在我们可以继续分析 <code>FPS</code> 低于屏幕刷新率的情况了，如下图所示。</p><p><img src="/assets/16.c2db6c77.png" alt="" loading="lazy"></p><div class="language-text ext-text"><pre class="language-text"><code>如果 CPU/GPU 的处理时间超过 16ms，那么第一个 VSync 到来时，缓冲区 B 中的数据还没有准备好，就只能继续显示之前 A 缓冲区中的内容。
而 B 完成后，又因为缺乏 VSync Pulse 信号，也只能等到下一轮才有机会交换了。
于是在这一过程中，有一大段时间是被浪费的。
当下一个 VSync 出现时，CPU/GPU 马上执行操作，此时它可操作的 Buffer 是 A，相应的显示屏对应的就是 B。这时看起来就是正常的。
只不过由于执行时间仍然超过 16ms，导致下一次应该执行的缓冲区交换又被推迟。
如此循环反复，便出现了越来越多的 “Jank”。
</code></pre></div><p>那么，有没有规避的办法呢？</p><div class="language-text ext-text"><pre class="language-text"><code>很显然，第一次的 Jank 看起来是没有办法的，除非升级硬件配置来加快 FPS。
我们关注的重点是被 CPU/GPU 浪费的时间段怎么才能充分利用起来。
分析上述过程，造成 CPU/GPU 无事可做的假象是因为当前已经没有可用的 buffer 了。
</code></pre></div><p>换句话说，如果增加一个 <code>Buffer</code>，情况会不会好转呢？如下图所示。</p><p><img src="/assets/17.f4371b5e.png" alt="" loading="lazy"></p><p><code>Triple Buffering</code> 是 <code>Multiple Buffering</code> 的一种，指的是系统使用 3 个缓冲区用于显示工作。</p><p>我们逐步分析下这个新机制是否有效。</p><div class="language-text ext-text"><pre class="language-text"><code>首先和预料中的一致，第一次 “Jank” 无可厚非。
不过当第一次 VSync 发生后，CPU 不用再等待了，它会使用第三个 Buffer C 来进行下一帧数据的准备工作。
虽然对缓冲区 C 的处理所需时间同样超过了 16ms，但这并不影响最终的显示，因为第二次 VSync 到来后，它选择 Buffer B 进行显示；
而到了第三次 VSync 时，它会接着采用 C，而不是像 Double Buffering 中所看到的只能再显示一遍 B。
这样就有效地降低了系统显示错误的概率。
</code></pre></div><blockquote><p>前面小节我们看到 <code>BufferQueue</code> 中最多有 32 个 <code>BufferSlot</code>，不过在实际使用时的具体值是可以设置的。</p></blockquote><p><code>TARGET_DISABLE_TRIPLE_BUFFERING</code> 这个宏用于<code> Disable Triple Buffering</code>。如果宏打开的话，<code>Layer.cpp</code> 在 <code>onFirstRef</code> 有如下操作。</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">TARGET_DISABLE_TRIPLE_BUFFERING</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">warning</span> <span class="token string">&quot;disabling triple buffering&quot;</span></span>
    mSurfaceFlingerConsumer<span class="token operator">-&gt;</span><span class="token function">setDefaultMaxBufferCount</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
    mSurfaceFlingerConsumer<span class="token operator">-&gt;</span><span class="token function">setDefaultMaxBufferCount</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre></div><p><code>mSurfaceFlingerConsumer::setDefaultMaxBufferCount</code> 将进一步调用 <code>BufferQueue::setDefaultMaxBufferCount</code>，然后把 <code>Buffer</code> 数（2 或者 3）保存到 <code>BufferQueue</code> 内部的 <code>mDefaultMaxBufferCount</code> 成员变量中。</p><p>对于应用程序来说，它也可以通过 <code>IGraphicBufferProducer::setBufferCount</code> 来告诉 <code>BufferQueue</code> 它所希望的 <code>Slot</code> 值，这个操作最终影响的是 <code>BufferQueue</code> 中的另一个成员变量 <code>mOverrideMaxBufferCount</code>（而不是 <code>mDefaultMaxBufferCount</code>）。默认情况下这个变量是 0，表示应用端不关心到底有多少 <code>Buffer</code> 可用。</p><p>在具体的实现中，以上两个变量都是要考虑到的，<code>BufferQueue</code> 会通过权衡各个值来选择最佳的解决方案。</p><h3 id="_6-2-surfaceflinger-的启动" tabindex="-1"><a class="header-anchor" href="#_6-2-surfaceflinger-的启动" aria-hidden="true">#</a> 6.2 <code>SurfaceFlinger</code> 的启动</h3><p><code>SurfaceFlinger</code> 的启动和 <code>ServiceManager</code> 有点类似，它们都属于系统的底层支撑服务，因而必须在设备开机的早期就运行起来：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/*frameworks/base/cmds/system_server/library/System_init.cpp*/</span>
<span class="token keyword">extern</span> <span class="token string">&quot;C&quot;</span> status_t <span class="token function">system_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    
    <span class="token function">property_get</span><span class="token punctuation">(</span><span class="token string">&quot;system_init.startsurfaceflinger&quot;</span><span class="token punctuation">,</span> propBuf<span class="token punctuation">,</span> <span class="token string">&quot;1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>propBuf<span class="token punctuation">,</span> <span class="token string">&quot;1&quot;</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">SurfaceFlinger</span><span class="token double-colon punctuation">::</span><span class="token function">instantiate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre></div><p>这个 <code>System_init.cpp</code> 会被编译到 <code>libsystem_server</code> 库中，然后由 <code>SystemServer</code> 在 <code>JNI</code> 层进行加载调用，从而启动包括 <code>SurfaceFlinger</code>，<code>SensorService</code> 等在内的系统服务。</p><blockquote><p>高版本中的启动入口已所有不同，后续再更新。</p></blockquote><p><code>system_init</code> 调用 <code>instantiate</code> 来创建一个 <code>Binder Server</code>，名称为 <code>&quot;SurfaceFlinger&quot;</code>；而且强指针的特性让它在第一次被引用时触发了 <code>onFirstRef</code>：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token class-name">SurfaceFlinger</span><span class="token double-colon punctuation">::</span><span class="token function">onFirstRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    mEventQueue<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//初始化事件队列</span>
    <span class="token function">run</span><span class="token punctuation">(</span><span class="token string">&quot;SurfaceFlinger&quot;</span><span class="token punctuation">,</span> PRIORITY_URGENT_DISPLAY<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//启动一个新的业务线程</span>
    mReadyToRunBarrier<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//等待新线程启动完毕</span>
<span class="token punctuation">}</span>
</code></pre></div><p>成员变量 <code>mEventQueue</code> 是一个 <code>MessageQueue</code> 类型的对象。既然有消息队列，那就一定会有配套的事件处理器 <code>Handler</code> 以及循环体 <code>Looper</code>，这些是在 <code>MessageQueue::init</code> 函数中创建的。即：</p><blockquote><p>虽然 <code>Java</code> 层的消息循环机制与 <code>SurfaceFlinger</code> 中用到的有一定差异，但其本质原理是一样的。</p></blockquote><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/*frameworks/native/services/surfaceflinger/MessageQueue.cpp*/</span>
<span class="token keyword">void</span> <span class="token class-name">MessageQueue</span><span class="token double-colon punctuation">::</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">const</span> sp<span class="token operator">&lt;</span>SurfaceFlinger<span class="token operator">&gt;</span><span class="token operator">&amp;</span> flinger<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    mFlinger <span class="token operator">=</span> flinger<span class="token punctuation">;</span>
    mLooper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Looper</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    mHandler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Handler</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//此Handler类是SurfaceFlinger自己定义的，后面有讲解</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>高版本中的差异：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* frameworks/native/services/surfaceflinger/Scheduler/MessageQueue.cpp */</span>
<span class="token class-name">MessageQueue</span><span class="token double-colon punctuation">::</span><span class="token function">MessageQueue</span><span class="token punctuation">(</span>ICompositor<span class="token operator">&amp;</span> compositor<span class="token punctuation">,</span> sp<span class="token operator">&lt;</span>Handler<span class="token operator">&gt;</span> handler<span class="token punctuation">)</span>
      <span class="token operator">:</span> <span class="token function">mCompositor</span><span class="token punctuation">(</span>compositor<span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token function">mLooper</span><span class="token punctuation">(</span><span class="token class-name">sp</span><span class="token operator">&lt;</span>Looper<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">make</span><span class="token punctuation">(</span>kAllowNonCallbacks<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token function">mHandler</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>handler<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div></blockquote><p>也就是说，这个 <code>MessageQueue</code> 类不但提供了消息队列，其内部还囊括了消息的处理机制。</p><p>那么，这个 <code>Looper</code> 会在什么时候运行起来呢？ 显然 <code>SurfaceFlinger</code> 需要先自行创建一个新的线程来承载这一 “业务”，否则就会阻塞 <code>SystemServer</code> 的主线程。</p><p><code>SurfaceFlinger::onFirstRef</code> 函数最后的 <code>mReadyToRunBarrier.wait()</code> 也可以证明这一点，即：<code>mReadyToRunBarrier</code> 在等待一个事件，在事件没有发生前其所在的线程就会处于等待状态。</p><blockquote><p>这是 <code>Android</code> 系统里两个线程间的一种典型交互方式。</p></blockquote><p>由此可见，<code>SurfaceFlinger</code> 新启动的这个线程中一定还会调用 <code>mReadyToRunBarrier.open</code> 来为等待它的线程解禁。</p><p>这样我们也能推断出 <code>SurfaceFlinger</code> 一定是继承自 <code>Thread</code> 线程类的。如下所示：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">SurfaceFlinger</span> <span class="token operator">:</span><span class="token keyword">public</span> BinderService<span class="token operator">&lt;</span>SurfaceFlinger<span class="token operator">&gt;</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">private</span> Thread<span class="token punctuation">,</span>
</code></pre></div><blockquote><p>高版本中 <code>SurfaceFlinger</code> 不在继承 <code>Thread</code> 了，后续会更新对高版本的分析。</p></blockquote><p>所以上面 <code>SurfaceFlinger::onFirstRef</code> 函数中可以调用 <code>Thread::run()</code> 方法来启动一个名为 <code>&quot;SurfaceFlinger&quot;</code> 的线程，并为其设置 <code>PRIORITY_URGENT_DISPLAY</code> 的优先级。这个优先级是在 <code>ThreadDefs.h</code> 中定义的，如下表所示。</p><table><thead><tr><th style="text-align:left;"><strong>Priority</strong></th><th style="text-align:left;"><strong>Value</strong></th><th style="text-align:left;"><strong>Description</strong></th></tr></thead><tbody><tr><td style="text-align:left;"><code>ANDROID_PRIORITY_LOWEST</code></td><td style="text-align:left;">19</td><td style="text-align:left;">最低优先级</td></tr><tr><td style="text-align:left;"><code>ANDROID_PRIORITY_BACKGROUND</code></td><td style="text-align:left;">10</td><td style="text-align:left;">用于 <code>Background Tasks</code></td></tr><tr><td style="text-align:left;"><code>ANDROID_PRIORITY_NORMAL</code></td><td style="text-align:left;">0</td><td style="text-align:left;">大部分线程都以这个优先级运行</td></tr><tr><td style="text-align:left;"><code>ANDROID_PRIORITY_FOREGROUND</code></td><td style="text-align:left;">-2</td><td style="text-align:left;">用户正在交互线程的优先级</td></tr><tr><td style="text-align:left;"><code>ANDROID_PRIORITY_DISPLAY</code></td><td style="text-align:left;">-4</td><td style="text-align:left;">UI 主线程优先级</td></tr><tr><td style="text-align:left;"><code>ANDROID_PRIORITY_URGENT_DISPLAY</code></td><td style="text-align:left;">-8</td><td style="text-align:left;">这个值由 <code>HAL_PRIORITY_URGENT_DISPLAY</code> 来指定，当前版本中是 -8。只在部分紧急状态下使用</td></tr><tr><td style="text-align:left;"><code>ANDROID_PRIORITY_AUDIO</code></td><td style="text-align:left;">-16</td><td style="text-align:left;">正常情况下的声音线程优先级</td></tr><tr><td style="text-align:left;"><code>ANDROID_PRIORITY_URGENT_AUDIO</code></td><td style="text-align:left;">-19</td><td style="text-align:left;">紧急声音线程优先级（通常情况下不使用）</td></tr><tr><td style="text-align:left;"><code>ANDROID_PRIORITY_HIGHEST</code></td><td style="text-align:left;">-20</td><td style="text-align:left;">最高优先级，禁止使用</td></tr><tr><td style="text-align:left;"><code>ANDROID_PRIORITY_DEFAULT</code></td><td style="text-align:left;">0</td><td style="text-align:left;">默认情况下就是 ANDROID_PRIORITY_NORMAL</td></tr><tr><td style="text-align:left;"><code>ANDROID_PRIORITY_MORE_FAVORABLE</code></td><td style="text-align:left;">-1</td><td style="text-align:left;">在上述各优先级定义的基础上，用于适当微调（加大）优先级</td></tr><tr><td style="text-align:left;"><code>ANDROID_PRIORITY_LESS_FAVORABLE</code></td><td style="text-align:left;">+1</td><td style="text-align:left;">在上述各优先级定义的基础上，用于适当微调（减小）优先级</td></tr></tbody></table><blockquote><p>数值越大的，优先级越小。</p><p>因为各等级间的数值并不是连续的，</p><p>所以我们还可以通过表中最后的 <code>ANDROID_PRIORITY_MORE_FAVORABLE</code>(-1) 来适当地提高优先级；</p><p>或者利用 <code>ANDROID_PRIORITY_LESS_FAVORABLE</code>(+1) 来降低优先级。</p></blockquote><div class="language-text ext-text"><pre class="language-text"><code>由此可见，SurfaceFlinger 工作线程所采用的优先级相对较高。
因为屏幕 UI 显示无疑是人机交互中与用户体验关联最直接的，任何滞后的响应速度都将大大降低产品的吸引力。
</code></pre></div><p>在执行了 <code>Thread::run()</code> 以后，<code>Thread</code> 会自动调用 <code>Thread::threadLoop()</code> 接口。即：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token keyword">bool</span> <span class="token class-name">SurfaceFlinger</span><span class="token double-colon punctuation">::</span><span class="token function">threadLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">waitForEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>其中<code> waitForEvent()</code> 是 <code>SurfaceFlinger</code> 中的成员函数，它会进一步调用 <code>mEventQueue.waitMessage()</code>：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* 
    此函数在高版本中未发生变化，只是 MessageQueue 文件的路径发生了变化：
    frameworks/native/services/surfaceflinger/Scheduler/MessageQueue.cpp
*/</span>
<span class="token keyword">void</span> <span class="token class-name">MessageQueue</span><span class="token double-colon punctuation">::</span><span class="token function">waitMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        <span class="token class-name">IPCThreadState</span><span class="token double-colon punctuation">::</span><span class="token function">self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">flushCommands</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int32_t</span> ret <span class="token operator">=</span> mLooper<span class="token operator">-&gt;</span><span class="token function">pollOnce</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">switch</span> <span class="token punctuation">(</span>ret<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">case</span> ALOOPER_POLL_WAKE<span class="token operator">:</span>
            <span class="token keyword">case</span> ALOOPER_POLL_CALLBACK<span class="token operator">:</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> ALOOPER_POLL_ERROR<span class="token operator">:</span>
                <span class="token function">ALOGE</span><span class="token punctuation">(</span><span class="token string">&quot;ALOOPER_POLL_ERROR&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> ALOOPER_POLL_TIMEOUT<span class="token operator">:</span>
                <span class="token comment">// timeout (should not happen)</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
            <span class="token keyword">default</span><span class="token operator">:</span>
                <span class="token comment">// should not happen</span>
                <span class="token function">ALOGE</span><span class="token punctuation">(</span><span class="token string">&quot;Looper::pollOnce() returned unknown status %d&quot;</span><span class="token punctuation">,</span> ret<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>可以看到程序在这里进入了一个死循环，而且即便 <code>pollOnce</code> 的执行结果是 <code>ALOOPER_POLL_TIMEOUT</code>，也同样不会跳出循环。</p><p>这是 <code>Android</code> 在对待严重错误时的一种普遍态度，即：如果不幸发生致命错误，就听天由命吧。</p></blockquote><p><strong><code>mLooper-&gt;pollOnce(-1)</code></strong> 在内部调用 <code>MessageQueue::mHandler</code> 来处理消息：</p><blockquote><p>注意：<code>pollOnce</code> 函数同样使用了一个死循环，它不断地读取消息进行处理。</p></blockquote><p><code>MessageQueue</code> 是消息循环处理机制的管理者，其下包含了一个 <code>Looper</code> 和一个 <code>Handler</code>。<code>Looper</code> 中的 <code>mMessageEnvelope</code> 才是真正存储消息的地方。</p><blockquote><p>高版本中，<code>Looper</code> 的文件位置如下：</p><div class="language-text ext-text"><pre class="language-text"><code>system/core/libutils/include/utils/Looper.h
system/core/libutils/Looper.cpp
</code></pre></div></blockquote><p>这样就构建了一个完整的循环消息处理框架，<code>SurfaceFlinger</code> 就是基于这个框架来完成各个应用程序的显示请求的。</p><p><code>MessageQueue::mHandler</code> 并非我们在消息机制中认识的那个 <code>Handler</code>，而是 <code>MessageQueue</code> 中自定义的一个事件处理器，即它是专门为 <code>SurfaceFlinger</code> 设计的：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/*frameworks/native/services/surfaceflinger/MessageQueue.cpp*/</span>
<span class="token keyword">void</span> MessageQueue<span class="token double-colon punctuation">::</span><span class="token class-name">Handler</span><span class="token double-colon punctuation">::</span><span class="token function">handleMessage</span><span class="token punctuation">(</span><span class="token keyword">const</span> Message<span class="token operator">&amp;</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>message<span class="token punctuation">.</span>what<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">case</span> INVALIDATE<span class="token operator">:</span>
           <span class="token function">android_atomic_and</span><span class="token punctuation">(</span>～eventMaskInvalidate<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mEventMask<span class="token punctuation">)</span><span class="token punctuation">;</span>
           mQueue<span class="token punctuation">.</span>mFlinger<span class="token operator">-&gt;</span><span class="token function">onMessageReceived</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span>what<span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token keyword">case</span> REFRESH<span class="token operator">:</span>
           <span class="token function">android_atomic_and</span><span class="token punctuation">(</span>～eventMaskRefresh<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mEventMask<span class="token punctuation">)</span><span class="token punctuation">;</span>
           mQueue<span class="token punctuation">.</span>mFlinger<span class="token operator">-&gt;</span><span class="token function">onMessageReceived</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span>what<span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token keyword">case</span> TRANSACTION<span class="token operator">:</span>
           <span class="token function">android_atomic_and</span><span class="token punctuation">(</span>～eventMaskTransaction<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mEventMask<span class="token punctuation">)</span><span class="token punctuation">;</span>
           mQueue<span class="token punctuation">.</span>mFlinger<span class="token operator">-&gt;</span><span class="token function">onMessageReceived</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span>what<span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如上述代码段所示，当 <code>mHandler</code> 收到 <code>INVALIDATE</code>，<code>REFRESH</code> 及 <code>TRANSACTION</code> 的请求时，将进一步回调 <code>SurfaceFlinger</code> 中的 <code>onMessageReceived</code>。等于绕了一个大圈，又回到 <code>SurfaceFlinger</code> 中了。</p><blockquote><p>高版中的差异：<code>SurfaceFlinger::onMessageReceived</code> 被 <code>Scheduler::onFrameSignal</code> 替代。</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* frameworks/native/services/surfaceflinger/Scheduler/MessageQueue.cpp */</span>
<span class="token keyword">void</span> MessageQueue<span class="token double-colon punctuation">::</span><span class="token class-name">Handler</span><span class="token double-colon punctuation">::</span><span class="token function">handleMessage</span><span class="token punctuation">(</span><span class="token keyword">const</span> Message<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    mFramePending<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/*
        mQueue 是 MessageQueue 的实现类 Scheduler
        [class Scheduler : public IEventThreadCallback, android::impl::MessageQueue]
        头文件路径：frameworks/native/services/surfaceflinger/Scheduler/Scheduler.h
        
    */</span>
    mQueue<span class="token punctuation">.</span><span class="token function">onFrameSignal</span><span class="token punctuation">(</span>mQueue<span class="token punctuation">.</span>mCompositor<span class="token punctuation">,</span> mVsyncId<span class="token punctuation">,</span> mExpectedVsyncTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></blockquote><h3 id="_6-3-接口的服务端-——-client" tabindex="-1"><a class="header-anchor" href="#_6-3-接口的服务端-——-client" aria-hidden="true">#</a> 6.3 接口的服务端 —— <code>Client</code></h3><p><code>SurfaceFlinger</code> 运行于 <code>SystemServer</code> 这一系统进程中，需要显示 <code>UI</code> 界面的应用程序则通过 <code>Binder</code> 服务与它进行跨进程通信。每个应用程序在 <code>SurfaceFlinger</code> 中都有 <code>Client</code> 为其提供服务。</p><p><code>Client</code> 这个类名并没有完全表达出它的真正含义，因为在 <code>Android</code> 系统的很多其他地方都可以找到同名的类。</p><p>应用程序与 <code>Client</code> 间的 <code>Binder</code> 接口是 <code>ISurfaceComposerClient</code>，所以作为接口的服务端实现，<code>Client</code> 继承自 <code>BnSurfaceComposerClient</code>：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/*frameworks/native/include/gui/ISurfaceComposerClient.h*/</span>
<span class="token keyword">class</span> <span class="token class-name">ISurfaceComposerClient</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">IInterface</span></span>
<span class="token punctuation">{</span>   
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">virtual</span> status_t <span class="token function">createSurface</span><span class="token punctuation">(</span><span class="token keyword">const</span> String8<span class="token operator">&amp;</span> name<span class="token punctuation">,</span> <span class="token keyword">uint32_t</span> w<span class="token punctuation">,</span> <span class="token keyword">uint32_t</span> h<span class="token punctuation">,</span> PixelFormat format<span class="token punctuation">,</span>
                        <span class="token keyword">uint32_t</span> flags<span class="token punctuation">,</span> sp<span class="token operator">&lt;</span>IBinder<span class="token operator">&gt;</span><span class="token operator">*</span> handle<span class="token punctuation">,</span> sp<span class="token operator">&lt;</span>IGraphicBufferProducer<span class="token operator">&gt;</span><span class="token operator">*</span> gbp<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">virtual</span> status_t <span class="token function">destroySurface</span><span class="token punctuation">(</span><span class="token keyword">const</span> sp<span class="token operator">&lt;</span>IBinder<span class="token operator">&gt;</span><span class="token operator">&amp;</span> handle<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>上述接口方法中最重要的两个是 <code>createSurface()</code> 和 <code>destroySurface()</code>，分别用于向 <code>SurfaceFlinger</code> 申请和销毁一个 <code>Surface</code>。</p><blockquote><p>更早期版本的系统中 <code>createSurface</code> 返回的是一个叫作 <code>ISurface</code> 的 <code>Binder</code> 接口，目前已经不复存在。</p><p>但 <code>createSurface</code> 这个函数名称还没有变。<strong>我们可以认为 <code>Surface</code> 在服务器端对应的是 <code>Layer</code></strong>。</p></blockquote><p>值得一提的是，<code>SurfaceFlinger</code> 的客户端程序拥有的 <code>Surface</code> 数量很可能不止一个。</p><div class="language-text ext-text"><pre class="language-text"><code>通常情况下，同一个 Activity 中的 UI 布局共用系统分配的 Surface 进行绘图，
但像 SurfaceView 这种 UI 组件却是特例 —— 它独占一个 Surface 进行绘制。
</code></pre></div><p>换句话说，如果我们制作一个带 <code>SurfaceView</code> 的视频播放器，其所在的应用程序最终就会有不止一个的 <code>Surface</code> 存在。</p><blockquote><p>这样的设计是必需的，因为播放视频对刷新频率要求很高，采用单独的 <code>Surface</code> 既可以保证视频的流畅度，同时也可以让用户的交互动作（比如触摸事件）得到及时的响应。</p></blockquote><p>下面我们从源码角度来分析客户端与 <code>SurfaceFlinger</code> 连接并创建 <code>Layer</code> 的两个重要接口。</p><h4 id="_6-3-1-surfaceflinger-createconnection" tabindex="-1"><a class="header-anchor" href="#_6-3-1-surfaceflinger-createconnection" aria-hidden="true">#</a> 6.3.1 <code>SurfaceFlinger::createConnection</code></h4><p><code>Client</code> 属于匿名 <code>Binder</code> 服务，外界的进程不可能直接获取到，因而它首先需要借助于 <code>SurfaceFlinger</code> 这一实名 <code>Binder Server</code>。源码实现如下：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code>sp<span class="token operator">&lt;</span>ISurfaceComposerClient<span class="token operator">&gt;</span> <span class="token class-name">SurfaceFlinger</span><span class="token double-colon punctuation">::</span><span class="token function">createConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    sp<span class="token operator">&lt;</span>ISurfaceComposerClient<span class="token operator">&gt;</span> bclient<span class="token punctuation">;</span>
    sp<span class="token operator">&lt;</span>Client<span class="token operator">&gt;</span> <span class="token function">client</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Client</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    status_t err <span class="token operator">=</span> client<span class="token operator">-&gt;</span><span class="token function">initCheck</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">==</span> NO_ERROR<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        bclient <span class="token operator">=</span> client<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> bclient<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>首先生成一个 <code>Client</code> 本地对象，然后调用 <code>initCheck</code> 进行必要的有效性检查（当前实现中直接返回 <code>NO_ERROR</code>）。</p><p>如果 <code>initCheck</code> 没有错误，程序就会把新生成的 <code>Client</code> 对象以 <code>ISurfaceComposerClient</code> 强指针的形式返回。</p><p>这样应用程序内部就拥有一个 <code>Client</code> 服务了。</p><blockquote><p>高版本的差异：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp */</span>
binder<span class="token double-colon punctuation">::</span>Status <span class="token class-name">SurfaceComposerAIDL</span><span class="token double-colon punctuation">::</span><span class="token function">createConnection</span><span class="token punctuation">(</span>sp<span class="token operator">&lt;</span>gui<span class="token double-colon punctuation">::</span>ISurfaceComposerClient<span class="token operator">&gt;</span><span class="token operator">*</span> outClient<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> sp<span class="token operator">&lt;</span>Client<span class="token operator">&gt;</span> client <span class="token operator">=</span> <span class="token class-name">sp</span><span class="token operator">&lt;</span>Client<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">make</span><span class="token punctuation">(</span>mFlinger<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建 Client 对象</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>client<span class="token operator">-&gt;</span><span class="token function">initCheck</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> NO_ERROR<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">*</span>outClient <span class="token operator">=</span> client<span class="token punctuation">;</span> <span class="token comment">// 将 Client 对象以 ISurfaceComposerClient 强指针的形式返回</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">return</span> binder<span class="token double-colon punctuation">::</span><span class="token class-name">Status</span><span class="token double-colon punctuation">::</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token operator">*</span>outClient <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">binderStatusFromStatusT</span><span class="token punctuation">(</span>BAD_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></blockquote><h4 id="_6-3-2-client-createsurface" tabindex="-1"><a class="header-anchor" href="#_6-3-2-client-createsurface" aria-hidden="true">#</a> 6.3.2 <code>Client::createSurface</code></h4><p><code>Client</code> 只是 <code>SurfaceFlinger</code> 分派给应用程序的一个 “代表”，真正的图形层（<code>Layer</code>）创建需要另外申请，即调用 <code>Client</code> 提供的 <code>createSurface</code> 接口。这个接口的实现在前几个小节已经有过粗略的分析，下面再从 <code>SurfaceFlinger</code> 的角度来审视下：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* frameworks/native/services/surfaceflinger/Client.cpp */</span>
status_t <span class="token class-name">Client</span><span class="token double-colon punctuation">::</span><span class="token function">createSurface</span><span class="token punctuation">(</span><span class="token keyword">const</span> String8<span class="token operator">&amp;</span> name<span class="token punctuation">,</span> <span class="token keyword">uint32_t</span> w<span class="token punctuation">,</span> <span class="token keyword">uint32_t</span> h<span class="token punctuation">,</span> 
            PixelFormat format<span class="token punctuation">,</span> <span class="token keyword">uint32_t</span> flags<span class="token punctuation">,</span>sp<span class="token operator">&lt;</span>IBinder<span class="token operator">&gt;</span><span class="token operator">*</span> handle<span class="token punctuation">,</span> sp<span class="token operator">&lt;</span>IGraphicBufferProducer<span class="token operator">&gt;</span><span class="token operator">*</span> gbp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">class</span> <span class="token class-name">MessageCreateLayer</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">MessageBase</span></span> <span class="token punctuation">{</span>
        SurfaceFlinger<span class="token operator">*</span> flinger<span class="token punctuation">;</span> <span class="token comment">// SurfaceFlinger 服务</span>
        Client<span class="token operator">*</span> client<span class="token punctuation">;</span> <span class="token comment">// 表明此消息来源于哪个 Client</span>
        sp<span class="token operator">&lt;</span>IBinder<span class="token operator">&gt;</span><span class="token operator">*</span> handle<span class="token punctuation">;</span> <span class="token comment">// 与 Layer 相对应的 Handle</span>
        sp<span class="token operator">&lt;</span>IGraphicBufferProducer<span class="token operator">&gt;</span><span class="token operator">*</span> gbp<span class="token punctuation">;</span> <span class="token comment">// 与 Layer 相对应的 gbp</span>
        status_t result<span class="token punctuation">;</span>
        <span class="token keyword">const</span> String8<span class="token operator">&amp;</span> name<span class="token punctuation">;</span>
        <span class="token keyword">uint32_t</span> w<span class="token punctuation">,</span> h<span class="token punctuation">;</span>
        PixelFormat format<span class="token punctuation">;</span>
        <span class="token keyword">uint32_t</span> flags<span class="token punctuation">;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token function">MessageCreateLayer</span><span class="token punctuation">(</span>SurfaceFlinger<span class="token operator">*</span> flinger<span class="token punctuation">,</span> <span class="token keyword">const</span> String8<span class="token operator">&amp;</span> name<span class="token punctuation">,</span> Client<span class="token operator">*</span> client<span class="token punctuation">,</span> uint32_tw<span class="token punctuation">,</span>
                           <span class="token keyword">uint32_t</span> h<span class="token punctuation">,</span> PixelFormat format<span class="token punctuation">,</span> <span class="token keyword">uint32_t</span> flags<span class="token punctuation">,</span>
                           sp<span class="token operator">&lt;</span>IBinder<span class="token operator">&gt;</span><span class="token operator">*</span> handle<span class="token punctuation">,</span> sp<span class="token operator">&lt;</span>IGraphicBufferProducer<span class="token operator">&gt;</span><span class="token operator">*</span> gbp<span class="token punctuation">)</span>
            <span class="token operator">:</span> <span class="token function">flinger</span><span class="token punctuation">(</span>flinger<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">client</span><span class="token punctuation">(</span>client<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">handle</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">gbp</span><span class="token punctuation">(</span>gbp<span class="token punctuation">)</span><span class="token punctuation">,</span>
              <span class="token function">name</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">w</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">h</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">format</span><span class="token punctuation">(</span>format<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">flags</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">}</span>
        status_t <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> result<span class="token punctuation">;</span> <span class="token punctuation">}</span>
        <span class="token keyword">virtual</span> <span class="token keyword">bool</span> <span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// SurfaceFlinger 将回调这个 handler 来执行具体的事务</span>
            result <span class="token operator">=</span> flinger<span class="token operator">-&gt;</span><span class="token function">createLayer</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> client<span class="token punctuation">,</span> w<span class="token punctuation">,</span> h<span class="token punctuation">,</span> format<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> handle<span class="token punctuation">,</span> gbp<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    sp<span class="token operator">&lt;</span>MessageBase<span class="token operator">&gt;</span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">MessageCreateLayer</span><span class="token punctuation">(</span>mFlinger<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            name<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> w<span class="token punctuation">,</span> h<span class="token punctuation">,</span> format<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> handle<span class="token punctuation">,</span> gbp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 生成一个消息</span>
    mFlinger<span class="token operator">-&gt;</span><span class="token function">postMessageSync</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将这一 Message 推送到 SurfaceFlinger 线程中</span>
    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>MessageCreateLayer<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回结果</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>值得注意的是，<code>createSurface</code> 这个函数需要从 <code>OpenGL ES</code> 的环境线程中被调用，这样它才能访问到后者提供的服务。</p></blockquote><p>这个函数比较特别的地方，是它先在内部创建了一个 <code>MessageCreateLayer</code> 类，剩余部分代码就是围绕这个类来展开的。</p><p><code>MessageCreateLayer</code> 继承自 <code>MessageBase</code>，所以 <code>MessageCreateLayer</code> 是一个 <code>Message</code> 的承载体，并且内部提供了处理这条 <code>Message</code> 的 <code>handler()</code> 函数。</p><p>在 <code>Client::createSurface</code> 函数最后调用 <code>SurfaceFlinger::postMessageSync</code> 将一个 <code>MessageCreateLayer</code> 对象 <code>msg</code> 发送到了 <code>SurfaceFlinger</code> 中。</p><p>函数 <code>SurfaceFlinger::postMessageSync</code> 通过 <code>mEventQueue</code> 将 <code>msg</code> 压入其消息队列中，并且会进入等待状态。代码如下：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code>status_t <span class="token class-name">SurfaceFlinger</span><span class="token double-colon punctuation">::</span><span class="token function">postMessageSync</span><span class="token punctuation">(</span><span class="token keyword">const</span> sp<span class="token operator">&lt;</span>MessageBase<span class="token operator">&gt;</span><span class="token operator">&amp;</span> msg<span class="token punctuation">,</span>nsecs_t reltime<span class="token punctuation">,</span> uint <span class="token number">32</span>_t flags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    status_t res <span class="token operator">=</span> mEventQueue<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> reltime<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>res <span class="token operator">==</span> NO_ERROR<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        msg<span class="token operator">-&gt;</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>MessageBase::wait()</code> 调用内部的 <code>Barrier::wait</code> 来实现等待，这意味着发送消息的线程将暂时停止执行，那么什么时候才能继续呢？显然得先唤醒它才行。这个唤醒的地方隐藏在 <code>MessageBase::handleMessage()</code> 中。即：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* frameworks/native/services/surfaceflinger/MessageQueue.cpp */</span>
<span class="token keyword">void</span> <span class="token class-name">MessageBase</span><span class="token double-colon punctuation">::</span><span class="token function">handleMessage</span><span class="token punctuation">(</span><span class="token keyword">const</span> Message<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token operator">-&gt;</span><span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    barrier<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>总的来说，就是 <code>Client</code> 一旦收到来自客户端的请求，并不会马上让 <code>SurfaceFlinger</code> 执行，而是间接地把请求先投递到后者的消息队列中，这样一方面保证这个请求不会丢失，另一方面也使 <code>SurfaceFlinger</code> 不至于中断当前的操作。</p><p>绕了一圈，其实 <code>Client::createSurface</code> 函数的作用就是通过执行 <code>SurfaceFlinger::createLayer</code> 函数来创建 <code>Layer</code>。</p><blockquote><p><code>SurfaceFlinger::createLayer</code> 创建图层的过程分析见 <a href="#_9-5-4-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E-bufferqueue-%E7%9A%84%E5%85%B3%E7%B3%BB">9.5.4 应用程序与 BufferQueue 的关系</a> 小节。</p></blockquote><h2 id="_7-vsync-的产生和处理" tabindex="-1"><a class="header-anchor" href="#_7-vsync-的产生和处理" aria-hidden="true">#</a> 7 <code>VSync</code> 的产生和处理</h2><p><code>VSync</code> 同步是从 <code>Android 4.1</code> 开始引入的显示系统新特性，也是 “黄油计划” 的一个重要核心。</p><p>在 <a href="#_9-6-1-%E9%BB%84%E6%B2%B9%E8%AE%A1%E5%88%92-project-butter">9.6.1 “黄油计划”</a> 小节中，我们从理论的角度分析了采用这一机制的必要性和运作机理，那么 <code>SurfaceFlinger</code> 具体是如何实施的呢？</p><p>先来思考一下 <code>SurfaceFlinger</code> 实现 <code>VSync</code> 同步有哪些要点：</p><div class="language-text ext-text"><pre class="language-text"><code>VSync 信号的产生和分发
    如果有硬件主动发出这一信号，那是最好的；
    否则就得通过软件模拟产生。

VSync 信号的处理
    当信号产生后，SurfaceFlinger 如何在最短的时间内做出响应。
    另外，具体的处理流程是怎样的。
</code></pre></div><h3 id="_7-1-vsync-信号的产生和分发" tabindex="-1"><a class="header-anchor" href="#_7-1-vsync-信号的产生和分发" aria-hidden="true">#</a> 7.1 <code>VSync</code> 信号的产生和分发</h3><p><code>Android</code> 源码工程的 <code>surfaceflinger</code> 目录下有一个 <code>displayhardware</code> 文件夹，其中 <code>HWComposer</code> 的主要职责之一，就是用于产生 <code>VSync</code> 信号：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* frameworks/native/services/surfaceflinger/displayhardware/HWComposer.cpp */</span>
<span class="token class-name">HWComposer</span><span class="token double-colon punctuation">::</span><span class="token function">HWComposer</span><span class="token punctuation">(</span><span class="token keyword">const</span> sp<span class="token operator">&lt;</span>SurfaceFlinger<span class="token operator">&gt;</span><span class="token operator">&amp;</span> flinger<span class="token punctuation">,</span> EventHandler<span class="token operator">&amp;</span> handler<span class="token punctuation">)</span>
      <span class="token operator">:</span> <span class="token function">mFlinger</span><span class="token punctuation">(</span>flinger<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">mFbDev</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">mHwc</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">mNumDisplays</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">mCBContext</span><span class="token punctuation">(</span><span class="token keyword">new</span> cb_context<span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token function">mEventHandler</span><span class="token punctuation">(</span>handler<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">mVSyncCount</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">mDebugForceFakeVSync</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">char</span> value<span class="token punctuation">[</span>PROPERTY_VALUE_MAX<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">property_get</span><span class="token punctuation">(</span><span class="token string">&quot;debug.sf.no_hw_vsync&quot;</span><span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token string">&quot;0&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取系统属性</span>
    mDebugForceFakeVSync <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">bool</span> needVSyncThread <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 是否需要软件模拟产生 VSync 信号，默认是 true</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    
    <span class="token function">loadHwcModule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 打开 HWC 的 HAL 模块</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mHwc<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>mHwc<span class="token operator">-&gt;</span>registerProcs<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 注册硬件回调事件</span>
            mCBContext<span class="token operator">-&gt;</span>hwc <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
            mCBContext<span class="token operator">-&gt;</span>procs<span class="token punctuation">.</span>invalidate <span class="token operator">=</span> <span class="token operator">&amp;</span>hook_invalidate<span class="token punctuation">;</span>
            mCBContext<span class="token operator">-&gt;</span>procs<span class="token punctuation">.</span>vsync <span class="token operator">=</span> <span class="token operator">&amp;</span>hook_vsync<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">hwcHasApiVersion</span><span class="token punctuation">(</span>mHwc<span class="token punctuation">,</span> HWC_DEVICE_API_VERSION_1_1<span class="token punctuation">)</span><span class="token punctuation">)</span>
                mCBContext<span class="token operator">-&gt;</span>procs<span class="token punctuation">.</span>hotplug <span class="token operator">=</span> <span class="token operator">&amp;</span>hook_hotplug<span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                mCBContext<span class="token operator">-&gt;</span>procs<span class="token punctuation">.</span>hotplug <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
            <span class="token function">memset</span><span class="token punctuation">(</span>mCBContext<span class="token operator">-&gt;</span>procs<span class="token punctuation">.</span>zero<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>mCBContext<span class="token operator">-&gt;</span>procs<span class="token punctuation">.</span>zero<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            mHwc<span class="token operator">-&gt;</span><span class="token function">registerProcs</span><span class="token punctuation">(</span>mHwc<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mCBContext<span class="token operator">-&gt;</span>procs<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>


        <span class="token comment">// don&#39;t need a vsync thread if we have a hardware composer</span>
        needVSyncThread <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment">//不需要软件模拟</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>needVSyncThread<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果需要软件模拟 VSync 信号的话，启动一个 VSyncThread 线程</span>
        <span class="token comment">// we don&#39;t have VSYNC support, we need to fake it</span>
        mVSyncThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">VSyncThread</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个函数的核心就是决定 <code>VSync</code> 的 “信号发生源” —— 硬件实现或者软件模拟。</p><div class="language-text ext-text"><pre class="language-text"><code>假如当前系统可以成功地加载名称为 HWC_HARDWARE_MODULE_ID=&quot;hwcomposer&quot; 的 HAL 模块，
并且通过这个库模块能顺利打开设备（hwc_composer_device_t），其版本号又大于 HWC_DEVICE_API_VERSION_1_1，
我们就采用 “硬件源”（此时 needVSyncThread 为 false）；
否则需要创建一个新的 VSync 线程来模拟产生信号。
</code></pre></div><blockquote><p>高版本的差异：<code>HWComposer</code> 中产生信号发生源的代码存在差异：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp */</span>
<span class="token class-name">HWComposer</span><span class="token double-colon punctuation">::</span><span class="token function">HWComposer</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> composerServiceName<span class="token punctuation">)</span>
      <span class="token operator">:</span> <span class="token function">HWComposer</span><span class="token punctuation">(</span>Hwc2<span class="token double-colon punctuation">::</span><span class="token class-name">Composer</span><span class="token double-colon punctuation">::</span><span class="token function">create</span><span class="token punctuation">(</span>composerServiceName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">/* frameworks/native/services/surfaceflinger/DisplayHardware/ComposerHal.cpp */</span>
std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Composer<span class="token operator">&gt;</span> <span class="token class-name">Composer</span><span class="token double-colon punctuation">::</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> serviceName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">AidlComposer</span><span class="token double-colon punctuation">::</span><span class="token function">isDeclared</span><span class="token punctuation">(</span>serviceName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>AidlComposer<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>serviceName<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>HidlComposer<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>serviceName<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></blockquote><h4 id="_7-1-1-硬件源" tabindex="-1"><a class="header-anchor" href="#_7-1-1-硬件源" aria-hidden="true">#</a> 7.1.1 硬件源</h4><blockquote><p>高版本存在差异，后续再更新。</p></blockquote><p>如果 <code>mHwc-&gt;registerProcs</code> 不为空，我们注册硬件回调 <code>mCBContext.procs</code>。定义如下：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp */</span>
status_t <span class="token class-name">SurfaceFlinger</span><span class="token double-colon punctuation">::</span><span class="token function">readyToRun</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    mHwc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">HWComposer</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token operator">*</span><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>HWComposer<span class="token double-colon punctuation">::</span>EventHandler <span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>从中可以看出，<code>HWComposer</code> 中的 <code>mEventHandler</code> 就是 <code>SurfaceFlinger</code> 对象， 所以 <code>SurfaceFlinger</code> 必须要继承自 <code>HWComposer::EventHandler</code>，这样才能处理 <code>callback</code> 函数 <code>onVSyncReceived</code>：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">SurfaceFlinger</span> <span class="token operator">:</span> <span class="token keyword">public</span> BinderService<span class="token operator">&lt;</span>SurfaceFlinger<span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token keyword">private</span> HWComposer<span class="token double-colon punctuation">::</span>EventHandler
</code></pre></div><h4 id="_7-1-2-软件源" tabindex="-1"><a class="header-anchor" href="#_7-1-2-软件源" aria-hidden="true">#</a> 7.1.2 软件源</h4><p>软件源和硬件源相比最大区别是它需要启动一个新线程 <code>VSyncThread</code>，其运行优先级与 <code>SurfaceFlinger</code> 的工作线程是一样的。</p><blockquote><p>从理论的角度来讲，任何通过软件定时来实现的机制都不可能是 100% 可靠的，即使优先级再高也可能出现延迟和意外。</p><p>不过如果 “不可靠” 的概率很小，而且就算出现意外时也不至于是致命错误，那么还是可以接受的。</p><p>所以说 <code>VSyncThread</code> 从实践的角度来讲，的确起到了很好的作用。</p></blockquote><p>来看看 <code>VSyncThread</code> 都做了些什么工作：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token keyword">bool</span> HWComposer<span class="token double-colon punctuation">::</span><span class="token class-name">VSyncThread</span><span class="token double-colon punctuation">::</span><span class="token function">threadLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">/* Step1. 判断系统是否使能了 VSync 信号发生机制 */</span>
    <span class="token punctuation">{</span> <span class="token comment">// 自动锁控制范围</span>
        Mutex<span class="token double-colon punctuation">::</span>Autolock <span class="token function">_l</span><span class="token punctuation">(</span>mLock<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>mEnabled<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//VSync信号开关</span>
            mCondition<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>mLock<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/* Step2. 计算需要产生 VSync 信号的时间点 */</span>
    <span class="token keyword">const</span> nsecs_t period <span class="token operator">=</span> mRefreshPeriod<span class="token punctuation">;</span> <span class="token comment">// 信号的产生间隔</span>
    <span class="token keyword">const</span> nsecs_t now <span class="token operator">=</span> <span class="token function">systemTime</span><span class="token punctuation">(</span>CLOCK_MONOTONIC<span class="token punctuation">)</span><span class="token punctuation">;</span>
    nsecs_t next_vsync <span class="token operator">=</span> mNextFakeVSync<span class="token punctuation">;</span> <span class="token comment">// 产生信号的时间</span>
    nsecs_t sleep <span class="token operator">=</span> next_vsync <span class="token operator">-</span> now<span class="token punctuation">;</span> <span class="token comment">// 需要休眠的时长</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>sleep <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//已经过了时间点</span>
        sleep <span class="token operator">=</span> <span class="token punctuation">(</span>period <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>now <span class="token operator">-</span> next_vsync<span class="token punctuation">)</span> <span class="token operator">%</span> period<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        next_vsync <span class="token operator">=</span> now <span class="token operator">+</span> sleep<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    mNextFakeVSync <span class="token operator">=</span> next_vsync <span class="token operator">+</span> period<span class="token punctuation">;</span> <span class="token comment">// 下一次的 VSync 时间</span>
    <span class="token keyword">struct</span> <span class="token class-name">timespec</span> spec<span class="token punctuation">;</span>
    spec<span class="token punctuation">.</span>tv_sec  <span class="token operator">=</span> next_vsync <span class="token operator">/</span> <span class="token number">1000000000</span><span class="token punctuation">;</span>
    spec<span class="token punctuation">.</span>tv_nsec <span class="token operator">=</span> next_vsync <span class="token operator">%</span> <span class="token number">1000000000</span><span class="token punctuation">;</span>


    <span class="token keyword">int</span> err<span class="token punctuation">;</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        err <span class="token operator">=</span> <span class="token function">clock_nanosleep</span><span class="token punctuation">(</span>CLOCK_MONOTONIC<span class="token punctuation">,</span> TIMER_ABSTIME<span class="token punctuation">,</span> <span class="token operator">&amp;</span>spec<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 进入休眠</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>err<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> errno <span class="token operator">==</span> EINTR<span class="token punctuation">)</span><span class="token punctuation">;</span>


    <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        mHwc<span class="token punctuation">.</span>mEventHandler<span class="token punctuation">.</span><span class="token function">onVSyncReceived</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> next_vsync<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 和硬件源是一样的回调</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-text ext-text"><pre class="language-text"><code>Step1@VSyncThread::threadLoop

mEnabled 是用于控制是否产生 VSync 信号的一个使能变量。
当系统希望关闭 VSync 信号发生源时，可以调用 VSyncThread::setEnabled(false)；否则调用 setEnabled (true)。
假如 mEnabled 为 false，VSyncThread 就处于等待状态，直到有人再次使能这个线程。
</code></pre></div><div class="language-text ext-text"><pre class="language-text"><code>Step2@VSyncThread::threadLoop

接下来的代码用于真正产生一个 VSync 信号。可以思考一下，无非就是以下步骤：
1. 计算下一次产生 VSync 信号的时间；
2. 进入休眠；
3. 休眠时间到了后，发出 VSync 信号，通知感兴趣的人；
4. 循环往复。
</code></pre></div><p>变量 <code>mRefreshPeriod</code> 指定了产生 <code>VSync</code> 信号的间隔。它的计算过程分为几种情况：</p><div class="language-text ext-text"><pre class="language-text"><code>1. 首选是从硬件设备获得真实的值；
2. 否则就采用如下办法：
    if (disp.refresh == 0) {
        disp.refresh = nsecs_t(1e9 / mFbDev-&gt;fps);
    }
    if (disp.refresh == 0) {
        disp.refresh = nsecs_t(1e9 / 60.0);
    }

也就是说从硬件设备获取不到后，取值先由 nsecs_t(1e9 / mFbDev-&gt;fps) 计算得到的
如果还不行，那就只能采用默认值了，即：nsecs_t(1e9 / 60.0)，此时，mRefreshPeriod 差不多是 16ms
</code></pre></div><p>因为 <code>mNextFakeVSync</code> 代表的是 “下一次” 产生信号的时间点，所以首先通过 <code>next_vsync = mNextFakeVSync</code> 来确定 <code>next_vsync</code> 的值。</p><p>接着计算 <code>sleep</code>，也就是距离产生信号的时间点还有多长（同时也是需要休眠的时间）。</p><p>那么，如果 <code>sleep</code> 的结果小于 0 呢？代表我们已经错过了这一次产生信号的最佳时间点（这是有可能发生的）。</p><p>在这种情况下，就只能计算下一个最近的 <code>VSync</code> 离现在还剩多少时间。公式如下：</p><div class="language-text ext-text"><pre class="language-text"><code>sleep = (period - ((now - next_vsync) % period));
</code></pre></div><p>我们采用这个公式的依据如下图所示。</p><p><img src="/assets/18.33026ab1.png" alt="" loading="lazy"></p><blockquote><p>上图的前提是 <code>now</code> 超时时间不能超过一个 <code>period</code>，因而 <code>sleep</code> 公式中还要加上 <code>%period</code>。</p></blockquote><p>计算完成 <code>sleep</code> 后，<code>mNextFakeVSync = next_vsync + period</code>。</p><div class="language-text ext-text"><pre class="language-text"><code>这是因为 mNextFakeVSync 代表的是下一次 threadLoop 需要用到的时间点，
而 next_vsync 是指下一次（最近一次）产生 VSync 的时间点。
</code></pre></div><p>这样我们就计算出来下一次产生信号的时间点了，那么如何在指定的时间点产生信号呢？有两种方法：</p><div class="language-text ext-text"><pre class="language-text"><code>其一是采用定时器回调；
其二就是采用休眠的形式主动等待
</code></pre></div><blockquote><p><code>HWCompose</code> 采用休眠的形式主动等待。</p></blockquote><p>可想而知这里对时间精度的要求比较高，所以采用的单位是 <code>nanosecond</code>，即纳秒级。</p><blockquote><p>函数 <code>clock_nanosleep</code> 的第一个入参是 <code>CLOCK_MONOTONIC</code>，这种类型的时钟更加稳定，且不受系统时间的影响。</p></blockquote><p>休眠时间一到，表示产生信号的时刻到了。根据前面的分析，就是通过 <code>mEventHandler.onVSyncReceived()</code> 回调来通知对消息感兴趣的人，无论软件还是硬件发生源，其回调方式都是一样的。</p><blockquote><p>高版本中通过 <code>IComposerCallback::onVsync</code> 回调来通知 <code>Vsync</code> 信号的产生。</p></blockquote><p>当产生完一次信号后，<code>VSyncThread::threadLoop</code> 这个函数就直接返回 <code>true</code> 了。</p><blockquote><p>怎么没有看到循环的地方？这是因为当 <code>threadLoop</code> 返回值 <code>true</code> 时，它将被系统再一次调用，如此循环往复。</p></blockquote><p><strong>接下来我们分析下 <code>SurfaceFlinger</code> 是如何处理这个 <code>VSync</code> 信号的。</strong></p><p>在 <code>SurfaceFlinger::onVSyncReceived</code> 中：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token class-name">SurfaceFlinger</span><span class="token double-colon punctuation">::</span><span class="token function">onVSyncReceived</span><span class="token punctuation">(</span><span class="token keyword">int</span> type<span class="token punctuation">,</span> nsecs_t timestamp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">uint32_t</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token operator">&lt;</span> DisplayDevice<span class="token double-colon punctuation">::</span>NUM_DISPLAY_TYPES<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// we should only receive DisplayDevice::DisplayType from the vsync callback        </span>
        mEventThread<span class="token operator">-&gt;</span><span class="token function">onVSyncReceived</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> timestamp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// EventThread 是什么？</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>SurfaceFlinger</code> 直接调用了 <code>EventThread</code> 的 <code>onVSyncReceived</code> 实现。</p><p>从名称上可以猜测到，<code>EventThread</code> 是 <code>SurfaceFilnger</code> 中专门用于处理事件的线程。这个 <code>EventThread</code> 线程对象是在 <code>SurfaceFlinger::readyToRun</code> 生成的：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code>status_t <span class="token class-name">SurfaceFlinger</span><span class="token double-colon punctuation">::</span><span class="token function">readyToRun</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    mEventThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">EventThread</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    mEventQueue<span class="token punctuation">.</span><span class="token function">setEventThread</span><span class="token punctuation">(</span>mEventThread<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// EventQueue 与 EventThread 进行了绑定</span>
</code></pre></div><p><code>EventThread</code> 的启动并不是由 <code>SurfaceFlinger</code> 决定的，而是取决于引用它的人，因为 <code>EventThread</code> 继承自 <code>Thread</code>，后者又是 <code>RefBase</code> 的子类，所以当第一次有人用智能指针引用它时，会自动调用 <code>onFirstRef</code> 函数，继而把这个线程 <code>run</code> 起来。</p><blockquote><p><code>EventThread</code> 线程优先级为 <code>PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE</code>。</p></blockquote><blockquote><p>高版本的差异：</p><div class="language-text ext-text"><pre class="language-text"><code>SurfaceFlinger 不再直接引用 EventThread， 而是把 EventThread 保存在了 Scheduler::mConnections 中，
Scheduler::mConnects 是一个 Map 集合，存放 &lt;ConnectionHandle, Connection&gt; 键值对，
键值对中，Connection 持有 EventThread 对象的引用。外界通过 ConnectionHandle 从 Scheduler 中获取 Connection。

涉及到的函数：
    Scheduler::createEventThread
    Scheduler::createConnection
    EventThread::createEventConnection
</code></pre></div></blockquote><p>介绍了 <code>EventThread</code> 的创建和启动过程后，再来看看它是如何处理消息的：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* frameworks/native/services/surfaceflinger/EventThread.cpp*/</span>
<span class="token keyword">void</span> <span class="token class-name">EventThread</span><span class="token double-colon punctuation">::</span><span class="token function">onVSyncReceived</span><span class="token punctuation">(</span><span class="token keyword">int</span> type<span class="token punctuation">,</span> nsecs_t timestamp<span class="token punctuation">)</span> <span class="token punctuation">{</span>…    
    Mutex<span class="token double-colon punctuation">::</span>Autolock <span class="token function">_l</span><span class="token punctuation">(</span>mLock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">&lt;</span> HWC_NUM_DISPLAY_TYPES<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 显示类型目前有两种</span>
        mVSyncEvent<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">.</span>header<span class="token punctuation">.</span>type <span class="token operator">=</span> DisplayEventReceiver<span class="token double-colon punctuation">::</span>DISPLAY_EVENT_VSYNC<span class="token punctuation">;</span>
        mVSyncEvent<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">.</span>header<span class="token punctuation">.</span>id <span class="token operator">=</span> type<span class="token punctuation">;</span>
        mVSyncEvent<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">.</span>header<span class="token punctuation">.</span>timestamp <span class="token operator">=</span> timestamp<span class="token punctuation">;</span>
        mVSyncEvent<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">.</span>vsync<span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
        mCondition<span class="token punctuation">.</span><span class="token function">broadcast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 条件满足，唤醒谁？</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>EventThread::onVSyncReceived</code> 函数对 <code>mVSyncEvent[type]</code> 数组中的 <code>DisplayEventReceiver::Event</code> 对象的成员进行数据填充（包括：<code>Event</code> 类型、时间戳、信号计数等）。</p><p>最重要的是，<code>EventThread::onVSyncReceived</code> 函数最后通过 <code>mCondition.broadcast()</code> 来通知等待 <code>Event</code> 的人 —— 会是谁呢？没错，是 <code>EventThread</code> 所在的线程。</p><p>可能有人会觉得奇怪，<code>onVSyncReceived</code> 不就是属于 <code>EventThread</code> 吗，怎么还能处于等待中？</p><div class="language-text ext-text"><pre class="language-text"><code>由上面的分析可以看出，
EventThread::onVSyncReceived 其实是由 SurfaceFlinger 所在线程调用的，所以它的执行也是由 SurfaceFlinger 所在线程完成的。
不过 onVSyncReceived 并没有对信号做具体的处理。打个比方：
    SurfaceFlinger 线程只是到了 EventThread 家的厨房（onVSyncReceived）里，
    然后把 “食材” 通过 DisplayEventReceiver::Event 准备好，放在 mVSyncEvent 中，
    然后唤醒正在等待的 EventThread —— 东西都准备好了，开动吧！
    于是接下来的处理工作就正式移交到 EventThread 线程了。
</code></pre></div><p>这点我们从下面这个代码段中也能得到验证：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token keyword">bool</span> <span class="token class-name">EventThread</span><span class="token double-colon punctuation">::</span><span class="token function">threadLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    DisplayEventReceiver<span class="token double-colon punctuation">::</span>Event event<span class="token punctuation">;</span>
    Vector<span class="token operator">&lt;</span> sp<span class="token operator">&lt;</span>EventThread<span class="token double-colon punctuation">::</span>Connection<span class="token operator">&gt;&gt;</span> signalConnections<span class="token punctuation">;</span>
    signalConnections <span class="token operator">=</span> <span class="token function">waitForEvent</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// EventThread 就是在这里面开始等待的</span>
    <span class="token keyword">const</span> size_t count <span class="token operator">=</span> signalConnections<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i<span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;</span>count <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 开始 dispatch 消息给所有感兴趣的人</span>
        <span class="token keyword">const</span> sp<span class="token operator">&lt;</span>Connection<span class="token operator">&gt;</span><span class="token operator">&amp;</span> <span class="token function">conn</span><span class="token punctuation">(</span>signalConnections<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        status_t err <span class="token operator">=</span> conn<span class="token operator">-&gt;</span><span class="token function">postEvent</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 通过 Connection “通道” 通知对方</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 返回 true 后系统将再次调用 threadLoop</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>高版本的代码存在差异，但流程类似：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* frameworks/native/services/surfaceflinger/Scheduler/EventThread.cpp */</span>
<span class="token keyword">void</span> <span class="token class-name">EventThread</span><span class="token double-colon punctuation">::</span><span class="token function">threadMain</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span><span class="token operator">&amp;</span> lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    DisplayEventConsumers consumers<span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>mState <span class="token operator">!=</span> State<span class="token double-colon punctuation">::</span>Quit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>optional<span class="token operator">&lt;</span>DisplayEventReceiver<span class="token double-colon punctuation">::</span>Event<span class="token operator">&gt;</span> event<span class="token punctuation">;</span>

        <span class="token comment">// Determine next event to dispatch.</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>mPendingEvents<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            event <span class="token operator">=</span> mPendingEvents<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            mPendingEvents<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token punctuation">}</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>consumers<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">dispatchEvent</span><span class="token punctuation">(</span><span class="token operator">*</span>event<span class="token punctuation">,</span> consumers<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// dispatch 消息给所有感兴趣的人</span>
            consumers<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>mPendingEvents<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// mPendingEvents 中还有未处理完的 DisplayEventReceiver::Event</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>mState <span class="token operator">==</span> State<span class="token double-colon punctuation">::</span>Idle<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            mCondition<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 等待 VSync 信号的到来</span>
        <span class="token punctuation">}</span> 
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// cancel any pending vsync event before exiting</span>
    mVsyncRegistration<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></blockquote><p><code>EventThread</code> 线程在 <code>mCondition.broadcast()</code> 得到唤醒。接着 <code>EventThread</code> 会统计所有对 <code>Event</code> 感兴趣的人，即记录在 <code>signalConnections</code> 中的元素。然后它通过与这些元素间的纽带（<code>Connection</code>）来通知它们有事件发生了。</p><p>变量 <code>signalConnections</code> 是在 <code>waitForEvent</code> 中准备的，根据 <code>Event</code> 的实际情况从 <code>EventThread</code> 的全局变量 <code>mDisplayEventConnections</code> 中挑选出来的。换句话说，所有对 <code>Event</code> 感兴趣的人都需要被记录到 <code>mDisplayEventConnections</code> 中。具体而言，有两种类型的 “忠实听众”：</p><div class="language-text ext-text"><pre class="language-text"><code>1. SurfaceFlinger
毋庸置疑，SurfaceFlinger 一定会收听 VSync 信号的产生。
这一工作由它内部的 EventQueue，即 “事件队列管家” 来完成。
当 SurfaceFlinger::readyToRun 中生成 EventThread 对象后，
会马上调用 MessageQueue::setEventThread 来把它设置到内部的 mEventThread 变量中；
同时，MessageQueue 还会通过接口 EventThread::createEventConnection 来创建一个 Connection 连接。

2. 需要刷新 UI 的各进程
SurfaceFlinger 只是负责最后的 UI 数据合成，而各应用程序才是真正的数据生产者，所以它们也必定是要监听 VSync 信号的。
SurfaceFlinger 提供了 createDisplayEventConnection 接口来满足各应用程序的需求，
这个接口同样调用了 EventThread::createEventConnection 来创建一个 Connection 连接。
</code></pre></div><p>那么，什么情况下这些创建的 <code>Connection</code> 会添加到 <code>EventThread</code> 的 <code>mDisplayEventConnections</code> 中呢？</p><div class="language-text ext-text"><pre class="language-text"><code>当这些 Connection 被第一次引用的时候，它会自动调用 registerDisplayEventConnection 来注册到 EventThread 中。
</code></pre></div><h3 id="_7-2-vsync-信号的处理" tabindex="-1"><a class="header-anchor" href="#_7-2-vsync-信号的处理" aria-hidden="true">#</a> 7.2 <code>VSync</code> 信号的处理</h3><p>经过上一小节的分析，现在我们已经明白了系统是如何通过硬件设备或者软件模拟来产生 <code>VSync</code> 信号了，也明白了它的流转过程。</p><p><code>VSync</code> 最终会被 <code>EventThread::threadLoop()</code> 分发给各监听者，如 <code>SurfaceFlinger</code> 进程中就是 <code>MessageQueue</code>。<code>MessageQueue</code> 通过与 <code>EventThread</code> 建立一个 <code>Connection</code> 来监听事件。</p><div class="language-text ext-text"><pre class="language-text"><code>对 VSYNC 等事件感兴趣的对象（如 MessageQueue），
首先要通过调用接口 EventThread::createEventConnection() 来建立一个连接（应用进程是间接由 SurfaceFlinger 完成的），
实际上就是生成了一个 EventThread::Connection 对象。这个对象将对双方产生如下影响：

影响1：
当 Connection::onFirstRef() 时，即 “连接” 第一次被引用时，
它会主动调用 EventThread::registerDisplayEventConnection() 来把自己添加到 EventThread 的 mDisplayEventConnections 中，
这是保证事件发生后 EventThread 能找到符合要求的 “连接” 的关键一步。

影响2：
当 MessageQueue 得到 Connection 后，它会马上调用 getDataChannel 来获得一个 BitTube。
从逻辑关系上看，Connection 只是双方业务上的连接，而 BitTube 则是数据传输通道，各种 Event 信息就是通过这里传输的。
</code></pre></div><p>下面以 <code>MessageQueue</code> 为例来分析各个进程是如何与 <code>MessageThread</code> 进行交互的：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token class-name">MessageQueue</span><span class="token double-colon punctuation">::</span><span class="token function">setEventThread</span><span class="token punctuation">(</span><span class="token keyword">const</span> sp<span class="token operator">&lt;</span>EventThread<span class="token operator">&gt;</span><span class="token operator">&amp;</span> eventThread<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    mEventThread <span class="token operator">=</span> eventThread<span class="token punctuation">;</span>
    mEvents <span class="token operator">=</span> eventThread<span class="token operator">-&gt;</span><span class="token function">createEventConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 建立一个 Connection</span>
    mEventTube <span class="token operator">=</span> mEvents<span class="token operator">-&gt;</span><span class="token function">getDataChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 立即获取 BitTube</span>
    mLooper<span class="token operator">-&gt;</span><span class="token function">addFd</span><span class="token punctuation">(</span>mEventTube<span class="token operator">-&gt;</span><span class="token function">getFd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>
                    ALOOPER_EVENT_INPUT<span class="token punctuation">,</span>MessageQueue<span class="token double-colon punctuation">::</span>cb_eventReceiver<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>从扮演的角色来看，<code>EventThread</code> 是 <code>Server</code>，不断地往 <code>Tube</code> 中写入数据；而 <code>MessageQueue</code> 是 <code>Client</code>，负责读取数据。</p><blockquote><p><code>MessageQueue</code> 如何得知有 <code>Event</code> 到来，然后去读取它呢？答案就是它们之间的数据读写模式采用的是 <code>Socket</code>（<code>AF_UNIX</code> 域）。</p></blockquote><p>上面这个函数的末尾通过 <code>Looper</code> 添加了一个 <code>fd</code>，这实际上就是 <code>Socket Pair</code> 中的一端。 然后 <code>Looper</code> 将这个 <code>fd</code> 与其 <code>callback</code> 函数（即 <code>MessageQueue::cb_eventReceiver</code>）加入全局的 <code>mRequests</code> 进行管理：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code>KeyedVector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> Request<span class="token operator">&gt;</span> mRequests<span class="token punctuation">;</span>
</code></pre></div><p>这个 <code>mRequests</code> 集合中会持有所有需要监测的 <code>fd</code>。这样当 <code>Looper</code> 进行 <code>pollInner</code> 时，只要有事件需要处理，它就可以通过 <code>callback</code> 函数通知 “接收者”。这里面的实现细节主要包括 <code>BitTube.cpp</code> 和 <code>Looper.cpp</code> 两个源文件。</p><p>当 <code>Event</code> 发生后，<code>MessageQueue::cb_eventReceiver</code> 开始执行，进而调用 <code>eventReceiver</code>。如果 <code>event</code> 的类型是 <code>DisplayEventReceiver::DISPLAY_EVENT_VSYNC</code>，则正是我们想要监听的事件。这时会有两种情况：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>buffer<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>header<span class="token punctuation">.</span>type <span class="token operator">==</span> DisplayEventReceiver<span class="token double-colon punctuation">::</span>DISPLAY_EVENT_VSYNC<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">INVALIDATE_ON_VSYNC</span></span>
    mHandler<span class="token operator">-&gt;</span><span class="token function">dispatchInvalidate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
    mHandler<span class="token operator">-&gt;</span><span class="token function">dispatchRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre></div><p>宏 <code>INVALIDATE_ON_VSYNC</code> 默认情况下被 <code>define</code> 为 1，什么意思呢？</p><div class="language-text ext-text"><pre class="language-text"><code>我们知道在把 UI 刷新到屏幕上（refresh）之前，各 UI 进程需要先准备好数据（invalidate）。分两种情况：
1. SurfaceFlinger 在 VSYNC 来临时再做数据的准备工作，然后立即刷新到屏幕上；
2. 平常就开始准备，而当 VSYNC 来临时把数据刷新到屏幕上。

当 INVALIDATE_ON_VSYNC 为 1 时，程序执行情况 1 的操作；否则就是情况 2。
</code></pre></div><p>函数 <code>dispatchInvalidate</code> 和 <code>dispatchRefresh</code> 在 <code>SurfaceFlinger</code> 中的处理过程是有一定差异的，对比如下表所示。</p><table><tr><th>dispatchInvalidate</th><th>dispatchRefresh</th></tr><tr><td> case MessageQueue::INVALIDATE:<br>     handleMessageTransaction();<br>     handleMessageInvalidate();<br>     signalRefresh(); </td><td> case MessageQueue::REFRESH:<br>     handleMessageRefresh(); </td></tr></table><p>先来看看 <code>handleMessageRefresh</code> 所要做的工作（这也是我们后续几个小节的阐述重点）：</p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token class-name">SurfaceFlinger</span><span class="token double-colon punctuation">::</span><span class="token function">handleMessageRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">ATRACE_CALL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
    <span class="token function">preComposition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 合成前的准备</span>
    <span class="token function">rebuildLayerStacks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 重新建立 Layer 堆栈</span>
    <span class="token function">setUpHWComposer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// HWComposer 的设定</span>
    <span class="token function">doDebugFlashRegions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">doComposition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 正式的合成工作</span>
    <span class="token function">postComposition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//合成后期工作</span>
<span class="token punctuation">}</span>
</code></pre></div><p>整个 <code>UI</code> 合成过程包括了如上几个函数，再加上 <code>handleMessageTransaction</code>、<code>handleMessageInvalidate</code>，基本涵盖了 <code>SurfaceFlinger</code> 的所有功能。</p><blockquote><p>从分发 <code>VSync</code> 信号，到进行 <code>UI</code> 合成过程，高版本中的差异较大，后续再更新。</p></blockquote><!--]--></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/zengkaiqiang562/JavaGuide/edit/main/docs/lango-tech/subject/surfaceflinger.md" rel="noopener noreferrer" target="_blank" arialabel="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewbox="0 0 1024 1024" arialabelledby="edit"><title id="edit" lang="en">edit icon</title><g fill="currentColor"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></g></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item update-time"><span class="label">上次编辑于: </span><span class="info">2024/4/30 18:39:15</span></div><div class="meta-item contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: kaiqiang.zeng@lango-tech.cn">zengkaiqiang</span><!--]--><!--]--></div></footer><!----><!----><!----></main><!--]--><footer class="footer-wrapper"><div class="footer"></div><div class="copyright">Copyright © 2024 Zenk562</div></footer></div><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app.2a01fc36.js" defer></script>
  </body>
</html>
