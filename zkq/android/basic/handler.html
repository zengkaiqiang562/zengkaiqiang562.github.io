<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.38" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://zengkaiqiang562.github.io/zkq/android/basic/handler.html"><meta property="og:site_name" content="Android Guide"><meta property="og:title" content="Android的消息机制（TODO）"><meta property="og:type" content="article"><meta property="og:image" content="https://zengkaiqiang562.github.io/"><meta property="og:updated_time" content="2022-07-08T06:42:00.000Z"><meta property="og:locale" content="zh-CN"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image:alt" content="Android的消息机制（TODO）"><meta property="article:tag" content="android"><meta property="article:modified_time" content="2022-07-08T06:42:00.000Z"><script>var _hmt = _hmt || [];
      (function() {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?5dd2e8c97962d57b7b8fea1737c01743";
        var s = document.getElementsByTagName("script")[0]; 
        s.parentNode.insertBefore(hm, s);
      })();</script><link rel="stylesheet" href="//at.alicdn.com/t/font_2922463_99aa80ii7cf.css"><title>Android的消息机制（TODO） | Android Guide</title><meta name="description" content="Android 学习 && 面试指南">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/assets/style.5a38b724.css">
    <link rel="modulepreload" href="/assets/app.625aa393.js"><link rel="modulepreload" href="/assets/handler.html.4f76fffb.js"><link rel="modulepreload" href="/assets/handler.html.4a4034b5.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container has-toc sidebar-open"><!--[--><header class="navbar"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><a href="/" class="home-link"><img class="logo" src="/logo.png" alt="Android Guide"><!----><span class="site-name hide-in-pad">Android Guide</span><!--[--><!----><!--]--></a><nav class="nav-links" style=""><div class="nav-item hide-in-mobile"><a href="/home.html" class="nav-link" arialabel="面试指南"><i class="icon iconfont icon-java"></i>面试指南<!----></a></div><div class="nav-item hide-in-mobile"><a href="/zhuanlan/" class="nav-link" arialabel="优质专栏"><i class="icon iconfont icon-recommend"></i>优质专栏<!----></a></div><div class="nav-item hide-in-mobile"><a href="/open-source-project/" class="nav-link" arialabel="项目精选"><i class="icon iconfont icon-github"></i>项目精选<!----></a></div><div class="nav-item hide-in-mobile"><a href="https://snailclimb.gitee.io/javaguide/#/" rel="noopener noreferrer" target="_blank" arialabel="旧版链接" class="nav-link"><i class="icon iconfont icon-java"></i>旧版链接<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="nav-item hide-in-mobile"><a href="https://javaguide.cn/feed.json" rel="noopener noreferrer" target="_blank" arialabel="RSS订阅" class="nav-link"><i class="icon iconfont icon-rss"></i>RSS订阅<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="nav-item hide-in-mobile"><a href="/about-the-author/" class="nav-link" arialabel="关于作者"><i class="icon iconfont icon-zuozhe"></i>关于作者<!----></a></div></nav><div class="nav-actions-wrapper"><!--[--><!----><!--]--><div class="nav-item"><!----></div><div class="nav-item"><a class="repo-link" href="https://github.com/zengkaiqiang562/JavaGuide" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewbox="0 0 1024 1024" arialabelledby="github" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><title id="github" lang="en">github icon</title><g fill="currentColor"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></g></svg></a></div><div class="nav-item hide-in-mobile"><button id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewbox="0 0 1024 1024" arialabelledby="auto" style="display:block;"><title id="auto" lang="en">auto icon</title><g fill="currentColor"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></g></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewbox="0 0 1024 1024" arialabelledby="dark" style="display:none;"><title id="dark" lang="en">dark icon</title><g fill="currentColor"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></g></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewbox="0 0 1024 1024" arialabelledby="light" style="display:none;"><title id="light" lang="en">light icon</title><g fill="currentColor"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></g></svg></button></div><form class="search-box" role="search"><input type="search" placeholder="搜索" autocomplete="off" spellcheck="false" value><!----></form><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button><!--[--><!----><!--]--></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable active"><!----><span class="title">基础</span><span class="arrow down"></span></button><!--[--><ul class="sidebar-links"><li><!--[--><a href="/zkq/android/basic/activity.html" class="nav-link sidebar-link sidebar-page" arialabel="Activity"><!---->Activity<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/zkq/android/basic/fragment.html" class="nav-link sidebar-link sidebar-page" arialabel="Fragment（TODO）"><!---->Fragment（TODO）<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/zkq/android/basic/service.html" class="nav-link sidebar-link sidebar-page" arialabel="Service"><!---->Service<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/zkq/android/basic/broadcast.html" class="nav-link sidebar-link sidebar-page" arialabel="BroadcastReceiver"><!---->BroadcastReceiver<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/zkq/android/basic/contentprovider.html" class="nav-link sidebar-link sidebar-page" arialabel="ContentProvider"><!---->ContentProvider<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/zkq/android/basic/serialize.html" class="nav-link sidebar-link sidebar-page" arialabel="对象序列化（TODO）"><!---->对象序列化（TODO）<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/zkq/android/basic/asynctask.html" class="nav-link sidebar-link sidebar-page" arialabel="AsyncTask"><!---->AsyncTask<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/zkq/android/basic/handler.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" arialabel="Android的消息机制（TODO）"><!---->Android的消息机制（TODO）<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/android/basic/handler.html#_1-概述" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1. 概述"><!---->1. 概述<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/android/basic/handler.html#_2-handler-消息机制的工作过程" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="2. Handler 消息机制的工作过程"><!---->2. Handler 消息机制的工作过程<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/android/basic/handler.html#_2-1-handler-发送消息" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="2.1 Handler 发送消息"><!---->2.1 Handler 发送消息<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/android/basic/handler.html#_2-2-从生产者消费者模式的角度理解-handler-机制" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="2.2 从生产者消费者模式的角度理解 Handler 机制"><!---->2.2 从生产者消费者模式的角度理解 Handler 机制<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/android/basic/handler.html#_3-messagequeue-消息队列是由单链表实现的优先级队列" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="3. MessageQueue 消息队列是由单链表实现的优先级队列"><!---->3. MessageQueue 消息队列是由单链表实现的优先级队列<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/android/basic/handler.html#_4-保证一个线程中只有一个-looper-对象-构造方法私有化-threadlocal" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="4. 保证一个线程中只有一个 Looper 对象（构造方法私有化 + ThreadLocal）"><!---->4. 保证一个线程中只有一个 Looper 对象（构造方法私有化 + ThreadLocal）<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/android/basic/handler.html#_4-1-threadlocal-如何将-looper-对象与线程绑定" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="4.1 ThreadLocal 如何将 Looper 对象与线程绑定？"><!---->4.1 ThreadLocal 如何将 Looper 对象与线程绑定？<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/android/basic/handler.html#_5-messagequeue-的创建时机" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="5. MessageQueue 的创建时机"><!---->5. MessageQueue 的创建时机<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/android/basic/handler.html#_6-handler-messagequeue-looper-三者之间的引用关系" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="6. Handler &amp; MessageQueue &amp; Looper 三者之间的引用关系"><!---->6. Handler &amp; MessageQueue &amp; Looper 三者之间的引用关系<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/android/basic/handler.html#_7-handler-消息机制中的等待唤醒机制" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="7. Handler 消息机制中的等待唤醒机制"><!---->7. Handler 消息机制中的等待唤醒机制<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/android/basic/handler.html#_8-消息入队和消息出队时的加锁原因" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="8. 消息入队和消息出队时的加锁原因"><!---->8. 消息入队和消息出队时的加锁原因<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/android/basic/handler.html#_9-handler-消息机制的退出流程" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="9. Handler 消息机制的退出流程"><!---->9. Handler 消息机制的退出流程<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/android/basic/handler.html#_10-messagequeue-消息队列的容量没有限制" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="10. MessageQueue 消息队列的容量没有限制"><!---->10. MessageQueue 消息队列的容量没有限制<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/android/basic/handler.html#_11-消息池-享元设计模式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="11. 消息池 &amp; 享元设计模式"><!---->11. 消息池 &amp; 享元设计模式<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/android/basic/handler.html#_12-同步屏障" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="12. 同步屏障"><!---->12. 同步屏障<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/android/basic/handler.html#_12-1-同步屏障的含义及作用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="12.1 同步屏障的含义及作用："><!---->12.1 同步屏障的含义及作用：<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/android/basic/handler.html#_12-2-同步屏障的实现方式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="12.2 同步屏障的实现方式："><!---->12.2 同步屏障的实现方式：<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/android/basic/handler.html#_12-3-同步屏障的应用-刷新-ui" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="12.3 同步屏障的应用：刷新 UI"><!---->12.3 同步屏障的应用：刷新 UI<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/android/basic/handler.html#_13-handlerthread" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="13. HandlerThread"><!---->13. HandlerThread<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/android/basic/handler.html#_14-intentservice" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="14. IntentService"><!---->14. IntentService<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/android/basic/handler.html#_14-1-示例-intentservice-的使用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="14.1 示例：IntentService 的使用"><!---->14.1 示例：IntentService 的使用<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/android/basic/handler.html#_15-handler-面试题" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="15. Handler 面试题"><!---->15. Handler 面试题<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/android/basic/handler.html#_15-1-一个线程有几个-handler" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="15.1 一个线程有几个 Handler？"><!---->15.1 一个线程有几个 Handler？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/android/basic/handler.html#_15-2-一个线程有几个-looper-如何保证" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="15.2 一个线程有几个 Looper？如何保证？"><!---->15.2 一个线程有几个 Looper？如何保证？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/android/basic/handler.html#_15-3-handler-内存泄漏原因-为什么其他的内部类没有说过这个问题" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="15.3 Handler 内存泄漏原因？为什么其他的内部类没有说过这个问题？"><!---->15.3 Handler 内存泄漏原因？为什么其他的内部类没有说过这个问题？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/android/basic/handler.html#_15-4-为何主线程可以-new-handler" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="15.4 为何主线程可以 new Handler？"><!---->15.4 为何主线程可以 new Handler？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/android/basic/handler.html#_15-5-如果想要在子线程中-new-handler-要做些什么准备" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="15.5 如果想要在子线程中 new Handler 要做些什么准备？"><!---->15.5 如果想要在子线程中 new Handler 要做些什么准备？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/android/basic/handler.html#_15-6-消息队列无消息时的处理方案是什么-有什么用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="15.6 消息队列无消息时的处理方案是什么？有什么用？"><!---->15.6 消息队列无消息时的处理方案是什么？有什么用？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/android/basic/handler.html#_15-7-多个-handler-在不同线程中发消息时-如何保证线程安全" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="15.7 多个 Handler 在不同线程中发消息时，如何保证线程安全？"><!---->15.7 多个 Handler 在不同线程中发消息时，如何保证线程安全？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/android/basic/handler.html#_15-8-使用-message-时应该如何创建它" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="15.8 使用 Message 时应该如何创建它？"><!---->15.8 使用 Message 时应该如何创建它？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/android/basic/handler.html#_15-9-looper-死循环为什么不会导致应用卡死" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="15.9 Looper 死循环为什么不会导致应用卡死？"><!---->15.9 Looper 死循环为什么不会导致应用卡死？<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li></ul><!--]--></li><li><!--[--><a href="/zkq/android/basic/custom-view.html" class="nav-link sidebar-link sidebar-page" arialabel="自定义View（TODO）"><!---->自定义View（TODO）<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/zkq/android/basic/ui-draw-process.html" class="nav-link sidebar-link sidebar-page" arialabel="UI绘制流程（DOING）"><!---->UI绘制流程（DOING）<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/zkq/android/basic/event-dispatch-mechanism.html" class="nav-link sidebar-link sidebar-page" arialabel="事件分发机制"><!---->事件分发机制<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul><!----><!--]--></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">绘图基础</span><span class="arrow right"></span></button><!--[--><!----><!----><!--]--></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">动画</span><span class="arrow right"></span></button><!--[--><!----><!----><!--]--></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">UI</span><span class="arrow right"></span></button><!--[--><!----><!----><!--]--></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Jetpack</span><span class="arrow right"></span></button><!--[--><!----><!----><!--]--></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">NDK</span><span class="arrow right"></span></button><!--[--><!----><!----><!--]--></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">IPC</span><span class="arrow right"></span></button><!--[--><!----><!----><!--]--></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">蓝牙开发</span><span class="arrow right"></span></button><!--[--><!----><!----><!--]--></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">性能优化</span><span class="arrow right"></span></button><!--[--><!----><!----><!--]--></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">系统源码分析</span><span class="arrow right"></span></button><!--[--><!----><!----><!--]--></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">其他</span><span class="arrow right"></span></button><!--[--><!----><!----><!--]--></section><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->Android的消息机制（TODO）</h1><div class="article-info"><span class="author-info" arialabel="作者🖊" isoriginal="false" pageview="false" color="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewbox="0 0 1024 1024" arialabelledby="author"><title id="author" lang="en">author icon</title><g fill="currentColor"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></g></svg><span><a class="author-item" href="https://zengkaiqiang562.github.io/" target="_blank" rel="noopener noreferrer">Zenk562</a></span><span property="author" content="Zenk562"></span></span><span class="category-info" arialabel="分类🌈" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewbox="0 0 1024 1024" arialabelledby="category"><title id="category" lang="en">category icon</title><g fill="currentColor"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></g></svg><ul class="categories-wrapper"><li class="category clickable" role="navigation">android</li><meta property="articleSection" content="android"></ul></span><span arialabel="标签🏷" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon tag-icon" viewbox="0 0 1024 1024" arialabelledby="tag"><title id="tag" lang="en">tag icon</title><g fill="currentColor"><path d="M939.902 458.563L910.17 144.567c-1.507-16.272-14.465-29.13-30.737-30.737L565.438 84.098h-.402c-3.215 0-5.726 1.005-7.634 2.913l-470.39 470.39a10.004 10.004 0 000 14.164l365.423 365.424c1.909 1.908 4.42 2.913 7.132 2.913s5.223-1.005 7.132-2.913l470.39-470.39c2.01-2.11 3.014-5.023 2.813-8.036zm-240.067-72.121c-35.458 0-64.286-28.828-64.286-64.286s28.828-64.285 64.286-64.285 64.286 28.828 64.286 64.285-28.829 64.286-64.286 64.286z"></path></g></svg><ul class="tags-wrapper"><li class="tag clickable" role="navigation">android</li></ul><meta property="keywords" content="android"></span><span class="date-info" arialabel="写作日期📅" isoriginal="false" pageview="false" color="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewbox="0 0 1024 1024" arialabelledby="calendar"><title id="calendar" lang="en">calendar icon</title><g fill="currentColor"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></g></svg><span>2022年7月8日</span><meta property="datePublished" content="2022-07-08T06:42:00.000Z"></span><!----><span class="words-info" arialabel="字数🔠" isoriginal="false" pageview="false" color="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon word-icon" viewbox="0 0 1024 1024" arialabelledby="word"><title id="word" lang="en">word icon</title><g fill="currentColor"><path d="M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z"></path><path d="M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z"></path></g></svg><span>约 6389 字</span><meta property="wordCount" content="6389"></span></div><hr></div><div class="toc-place-holder"><aside id="toc-list"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/android/basic/handler.html#_1-概述" class="router-link-active router-link-exact-active toc-link level2">1. 概述</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/android/basic/handler.html#_2-handler-消息机制的工作过程" class="router-link-active router-link-exact-active toc-link level2">2. Handler 消息机制的工作过程</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/android/basic/handler.html#_2-1-handler-发送消息" class="router-link-active router-link-exact-active toc-link level3">2.1 Handler 发送消息</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/android/basic/handler.html#_2-2-从生产者消费者模式的角度理解-handler-机制" class="router-link-active router-link-exact-active toc-link level3">2.2 从生产者消费者模式的角度理解 Handler 机制</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/android/basic/handler.html#_3-messagequeue-消息队列是由单链表实现的优先级队列" class="router-link-active router-link-exact-active toc-link level2">3. MessageQueue 消息队列是由单链表实现的优先级队列</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/android/basic/handler.html#_4-保证一个线程中只有一个-looper-对象-构造方法私有化-threadlocal" class="router-link-active router-link-exact-active toc-link level2">4. 保证一个线程中只有一个 Looper 对象（构造方法私有化 + ThreadLocal）</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/android/basic/handler.html#_4-1-threadlocal-如何将-looper-对象与线程绑定" class="router-link-active router-link-exact-active toc-link level3">4.1 ThreadLocal 如何将 Looper 对象与线程绑定？</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/android/basic/handler.html#_5-messagequeue-的创建时机" class="router-link-active router-link-exact-active toc-link level2">5. MessageQueue 的创建时机</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/android/basic/handler.html#_6-handler-messagequeue-looper-三者之间的引用关系" class="router-link-active router-link-exact-active toc-link level2">6. Handler &amp; MessageQueue &amp; Looper 三者之间的引用关系</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/android/basic/handler.html#_7-handler-消息机制中的等待唤醒机制" class="router-link-active router-link-exact-active toc-link level2">7. Handler 消息机制中的等待唤醒机制</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/android/basic/handler.html#_8-消息入队和消息出队时的加锁原因" class="router-link-active router-link-exact-active toc-link level2">8. 消息入队和消息出队时的加锁原因</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/android/basic/handler.html#_9-handler-消息机制的退出流程" class="router-link-active router-link-exact-active toc-link level2">9. Handler 消息机制的退出流程</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/android/basic/handler.html#_10-messagequeue-消息队列的容量没有限制" class="router-link-active router-link-exact-active toc-link level2">10. MessageQueue 消息队列的容量没有限制</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/android/basic/handler.html#_11-消息池-享元设计模式" class="router-link-active router-link-exact-active toc-link level2">11. 消息池 &amp; 享元设计模式</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/android/basic/handler.html#_12-同步屏障" class="router-link-active router-link-exact-active toc-link level2">12. 同步屏障</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/android/basic/handler.html#_12-1-同步屏障的含义及作用" class="router-link-active router-link-exact-active toc-link level3">12.1 同步屏障的含义及作用：</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/android/basic/handler.html#_12-2-同步屏障的实现方式" class="router-link-active router-link-exact-active toc-link level3">12.2 同步屏障的实现方式：</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/android/basic/handler.html#_12-3-同步屏障的应用-刷新-ui" class="router-link-active router-link-exact-active toc-link level3">12.3 同步屏障的应用：刷新 UI</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/android/basic/handler.html#_13-handlerthread" class="router-link-active router-link-exact-active toc-link level2">13. HandlerThread</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/android/basic/handler.html#_14-intentservice" class="router-link-active router-link-exact-active toc-link level2">14. IntentService</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/android/basic/handler.html#_14-1-示例-intentservice-的使用" class="router-link-active router-link-exact-active toc-link level3">14.1 示例：IntentService 的使用</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/android/basic/handler.html#_15-handler-面试题" class="router-link-active router-link-exact-active toc-link level2">15. Handler 面试题</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/android/basic/handler.html#_15-1-一个线程有几个-handler" class="router-link-active router-link-exact-active toc-link level3">15.1 一个线程有几个 Handler？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/android/basic/handler.html#_15-2-一个线程有几个-looper-如何保证" class="router-link-active router-link-exact-active toc-link level3">15.2 一个线程有几个 Looper？如何保证？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/android/basic/handler.html#_15-3-handler-内存泄漏原因-为什么其他的内部类没有说过这个问题" class="router-link-active router-link-exact-active toc-link level3">15.3 Handler 内存泄漏原因？为什么其他的内部类没有说过这个问题？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/android/basic/handler.html#_15-4-为何主线程可以-new-handler" class="router-link-active router-link-exact-active toc-link level3">15.4 为何主线程可以 new Handler？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/android/basic/handler.html#_15-5-如果想要在子线程中-new-handler-要做些什么准备" class="router-link-active router-link-exact-active toc-link level3">15.5 如果想要在子线程中 new Handler 要做些什么准备？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/android/basic/handler.html#_15-6-消息队列无消息时的处理方案是什么-有什么用" class="router-link-active router-link-exact-active toc-link level3">15.6 消息队列无消息时的处理方案是什么？有什么用？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/android/basic/handler.html#_15-7-多个-handler-在不同线程中发消息时-如何保证线程安全" class="router-link-active router-link-exact-active toc-link level3">15.7 多个 Handler 在不同线程中发消息时，如何保证线程安全？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/android/basic/handler.html#_15-8-使用-message-时应该如何创建它" class="router-link-active router-link-exact-active toc-link level3">15.8 使用 Message 时应该如何创建它？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/android/basic/handler.html#_15-9-looper-死循环为什么不会导致应用卡死" class="router-link-active router-link-exact-active toc-link level3">15.9 Looper 死循环为什么不会导致应用卡死？</a></li><!----><!--]--></ul><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><!--[--><h2 id="_1-概述" tabindex="-1"><a class="header-anchor" href="#_1-概述" aria-hidden="true">#</a> 1. 概述</h2><p><code>Android</code> 的消息机制主要是指 <code>Handler</code> 的运行机制，以及 <code>Handler</code> 所附带的 <code>MessageQueue</code> 和 <code>Looper</code> 的工作过程。</p><blockquote><p><code>Handler</code>、<code>MessageQueue</code>、<code>Looper</code> 这三者实际上是一个整体，只不过在开发过程中比较多地接触 <code>Handler</code> 而已。</p></blockquote><p><code>Handler</code> 的主要作用是将一个任务切换到某个指定的线程中去执行。</p><h2 id="_2-handler-消息机制的工作过程" tabindex="-1"><a class="header-anchor" href="#_2-handler-消息机制的工作过程" aria-hidden="true">#</a> 2. <code>Handler</code> 消息机制的工作过程</h2><p><code>Handler</code> 机制的工作过程如下：</p><p><img src="/assets/02.ee13d32a.png" alt="" loading="lazy"></p><h3 id="_2-1-handler-发送消息" tabindex="-1"><a class="header-anchor" href="#_2-1-handler-发送消息" aria-hidden="true">#</a> 2.1 <code>Handler</code> 发送消息</h3><p><img src="/assets/01.13cea3ea.png" alt="" loading="lazy"></p><blockquote><p>如上图所示，<code>Handler.sendXxx</code> 和 <code>Handler.postXxx</code> 方法最终都是调用了 <code>Handler.enqueueMessage</code> 方法。</p></blockquote><h3 id="_2-2-从生产者消费者模式的角度理解-handler-机制" tabindex="-1"><a class="header-anchor" href="#_2-2-从生产者消费者模式的角度理解-handler-机制" aria-hidden="true">#</a> 2.2 从生产者消费者模式的角度理解 <code>Handler</code> 机制</h3><p><code>Handler</code> 机制符合生产者消费值模式，其中：</p><ol><li><code>Handler</code> 作为生产者，用来生产 <code>Message</code>；</li><li><code>MessageQueue</code> 作为存储容器，用来存放生产的 <code>Message</code>；</li><li><code>Looper</code> 作为消费值，用来从 <code>MessageQueue</code> 取出 <code>Message</code> 进行消费。</li></ol><p>从生产者消费者模式的角度理解 <code>Handler</code> 的线程切换：</p><ol><li><p><code>Handler</code> 生产 <code>Message</code> 是通过调用 Handler.enqueueMessage 方法实现的：</p></li><li><p><code>Looper</code> 消费 <code>Message</code> 的实现过程是通过 “死循环 + 等待唤醒机制” 从 <code>MessageQueue</code> 中取出 <code>Message</code>，然后调用 <code>Handler.dispatchMessage</code> 方法处理消息的。</p></li></ol><p>也就是说，<code>Handler.enqueueMessage</code> 方法是在生产线程中执行的；<code>Handler.dispatchMessage</code> 方法是在消费线程中执行的。 <code>Handler</code> 机制的线程切换其实就是 <code>Handler.enqueueMessage</code> 方法和 <code>Handler.dispatchMessage</code> 方法的执行线程的切换。</p><h2 id="_3-messagequeue-消息队列是由单链表实现的优先级队列" tabindex="-1"><a class="header-anchor" href="#_3-messagequeue-消息队列是由单链表实现的优先级队列" aria-hidden="true">#</a> 3. <code>MessageQueue</code> 消息队列是由单链表实现的优先级队列</h2><p><code>MessageQueue</code> 消息队列的说明：</p><ol><li>头节点是 <code>MessageQueue.mMessages</code>，</li><li>队列中节点的类型是 <code>Message</code>，</li><li><code>Message</code> 节点中维护一个 <code>Message.next</code> 指针，指向队列中的下一个节点。（并没有指向上一个节点的指针）</li><li>队列中的节点在插入时会按照 <code>Message.when</code> （消息被处理的时间）的先后顺序进行排序。</li></ol><div class="language-java ext-java"><pre class="language-java"><code><span class="token comment">/* MessageQueue.java */</span>

<span class="token comment">// 消息入队</span>
<span class="token keyword">boolean</span> <span class="token function">enqueueMessage</span><span class="token punctuation">(</span><span class="token class-name">Message</span> msg<span class="token punctuation">,</span> <span class="token keyword">long</span> when<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        msg<span class="token punctuation">.</span>when <span class="token operator">=</span> when<span class="token punctuation">;</span>
        <span class="token class-name">Message</span> p <span class="token operator">=</span> mMessages<span class="token punctuation">;</span> <span class="token comment">// mMessages 是消息队列的队头</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token comment">/*
            消息在入队时，按照消息被处理的时间 msg.when 从小到大排列，
            msg.when 越小，则越先被处理。
            队头节点 mMessages 指向最先被处理的消息。
        */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> when <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> when <span class="token operator">&lt;</span> p<span class="token punctuation">.</span>when<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 当前插入的消息 msg 最先被处理，所以放在队头</span>
            msg<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>
            mMessages <span class="token operator">=</span> msg<span class="token punctuation">;</span>
            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            <span class="token class-name">Message</span> prev<span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                prev <span class="token operator">=</span> p<span class="token punctuation">;</span>
                p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> when <span class="token operator">&lt;</span> p<span class="token punctuation">.</span>when<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 插入时，按照 msg.when 从小（先）到大（后）顺序进行排列。</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            <span class="token punctuation">}</span>
            msg<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>
            prev<span class="token punctuation">.</span>next <span class="token operator">=</span> msg<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>needWake<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">nativeWake</span><span class="token punctuation">(</span>mPtr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 唤醒消费 Message 的线程</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-java ext-java"><pre class="language-java"><code><span class="token comment">/* MessageQueue.java */</span>

<span class="token comment">// 消息出队</span>
<span class="token class-name">Message</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/*
        在消费 Message 的线程中执行 next 方法，
        通过 “死循环 + 等待唤醒机制” 取出队列中的消息，返回给 Looper。
    */</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token function">nativePollOnce</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> nextPollTimeoutMillis<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 休眠 nextPollTimeoutMillis 时间</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">final</span> <span class="token keyword">long</span> now <span class="token operator">=</span> <span class="token class-name">SystemClock</span><span class="token punctuation">.</span><span class="token function">uptimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Message</span> prevMsg <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token class-name">Message</span> msg <span class="token operator">=</span> mMessages<span class="token punctuation">;</span> <span class="token comment">// 从队头取消息，取到的消息就应该是最先被处理的消息（不考虑异步消息）</span>
            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>msg <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>now <span class="token operator">&lt;</span> msg<span class="token punctuation">.</span>when<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// </span>
                    <span class="token comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span>
                    <span class="token comment">/*
                        如果最先被处理的消息 msg 在当前时间 now 都还没到被处理的时候，
                        那么就休眠到消息 msg 应该被处理的时间 msg.when 到来为止，即休眠 (msg.when - now) 时间
                    */</span>
                    nextPollTimeoutMillis <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>when <span class="token operator">-</span> now<span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
                    <span class="token comment">/*
                        如果最先被处理的消息 msg 在当前时间 now 可以被处理了，
                        那么就将消息 msg 返回给 Looper，并从消息队列中移除。
                    */</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>prevMsg <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        prevMsg<span class="token punctuation">.</span>next <span class="token operator">=</span> msg<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                        mMessages <span class="token operator">=</span> msg<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    msg<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
                    <span class="token keyword">return</span> msg<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token punctuation">}</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_4-保证一个线程中只有一个-looper-对象-构造方法私有化-threadlocal" tabindex="-1"><a class="header-anchor" href="#_4-保证一个线程中只有一个-looper-对象-构造方法私有化-threadlocal" aria-hidden="true">#</a> 4. 保证一个线程中只有一个 <code>Looper</code> 对象（构造方法私有化 + <code>ThreadLocal</code>）</h2><p>通过以下 <code>2</code> 点保证一个线程中只有一个 <code>Looper</code> 对象：</p><ol><li><p><code>Looper</code> 的构造方法私有化，只能通过静态方法 <code>static void prepare(boolean quitAllowed)</code> 来创建 <code>Looper</code> 对象；</p><div class="language-java ext-java"><pre class="language-java"><code><span class="token comment">/* Looper.java */</span>

<span class="token comment">/*
    Looper 类只提供了这一个私有的构造方法。
    参数 quitAllowed 表示是否允许退出消息循环机制。true 允许；false 不允许。
*/</span>
<span class="token keyword">private</span> <span class="token class-name">Looper</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> quitAllowed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    mQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageQueue</span><span class="token punctuation">(</span>quitAllowed<span class="token punctuation">)</span><span class="token punctuation">;</span>
    mThread <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/*
    prepare(quitAllowed) 方法是私有的，对外只提供了如下两个方法来创建 Looper 对象：
        1. prepare()：在子线程中通过该方法来创建 Looper 对象。消息循环机制是允许退出的。
        2. prepareMainLooper()：在主线程中通过该方法来创建 Looper 对象。消息循环机制是不允许退出的。
*/</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">prepareMainLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p><code>Android</code> 系统已经在 <code>ActivityThread.main</code> 方法中调用了 <code>prepareMainLooper()</code> 方法，为 <code>App</code> 进程的主线程创建了一个 <code>Looper</code> 对象。</p></blockquote></li><li><p>在 <code>prepare(quitAllowed)</code> 方法中通过静态的 <code>ThreadLocal&lt;Looper&gt;</code> 类型的对象 <code>sThreadLocal</code> 保证一个线程中只能有一个 <code>Looper</code> 对象。</p><div class="language-java ext-java"><pre class="language-java"><code><span class="token comment">/* Looper.java */</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Looper</span><span class="token punctuation">&gt;</span></span> sThreadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Looper</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/*
    prepare(quitAllowed) 方法只能在一个线程中调用一次，否则就会抛出异常。
    （也就是说，对外提供的 prepare() 或 prepareMainLooper() 只能在线程中调用一次）

    因为一个线程中只能调用一次 prepare(quitAllowed) 方法，
    而在该方法中，会创建一个 Looper 对象，并通过 ThreadLocal 与当前线程绑定起来。
    所以就保证了一个线程中只有一个 Looper 对象。
*/</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> quitAllowed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>sThreadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">&quot;Only one Looper may be created per thread&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    sThreadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Looper</span><span class="token punctuation">(</span>quitAllowed<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ol><h3 id="_4-1-threadlocal-如何将-looper-对象与线程绑定" tabindex="-1"><a class="header-anchor" href="#_4-1-threadlocal-如何将-looper-对象与线程绑定" aria-hidden="true">#</a> 4.1 <code>ThreadLocal</code> 如何将 <code>Looper</code> 对象与线程绑定？</h3><ol><li><p><code>Thread</code> 线程对象中维护了一个以 <code>ThreadLocal</code> 对象为键，<code>Object</code> 对象为值的键值对数组。</p><div class="language-text ext-text"><pre class="language-text"><code>Thread 对象通过 threadLocals 属性引用了 ThreadLocal.ThreadLocalMap 对象。
ThreadLocalMap 对象中保存了 ThreadLocalMap.Entry[] 类型的数组 table。
Entry 表示以 ThreadLocal&lt;T&gt; 为键，以 T 为值的键值对。
</code></pre></div></li><li><p>调用 <code>sThreadLocal.set(looper)</code> 方法，就是将以 <code>sThreadLocal</code> 为键，以 <code>looper</code> 为值的键值对保存到当前线程对象维护的键值对数组中。</p><div class="language-java ext-java"><pre class="language-java"><code><span class="token comment">/* ThreadLocal.java */</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">T</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">ThreadLocalMap</span> map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// map = t.threadLocals</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// t.threadLocals.table[index] = new Entry(this, value)</span>
    <span class="token keyword">else</span>
        <span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// t.threadLocals = new ThreadLocalMap(this, value);</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-text ext-text"><pre class="language-text"><code>调用 ThreadLocal&lt;Looper&gt; 对象的 set(Looper) 方法，
就是将以 ThreadLocal&lt;Looper&gt; 对象为键，以 Looper 参数为值的键值对 Entry 对象，
保存到 set 方法的执行线程对象所维护的 threadLocals.table 数组中。
</code></pre></div></li><li><p>调用 <code>sThreadLocal.get()</code> 方法，就是从当前线程对象维护的键值对数组中取出以 <code>sThreadLocal</code> 为键的值。</p><div class="language-java ext-java"><pre class="language-java"><code><span class="token comment">/* ThreadLocal.java */</span>
<span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">ThreadLocalMap</span> map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// map = t.threadLocals</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ThreadLocalMap<span class="token punctuation">.</span>Entry</span> e <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">getEntry</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">T</span> result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span>e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
            <span class="token keyword">return</span> result<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-text ext-text"><pre class="language-text"><code>调用 ThreadLocal&lt;Looper&gt; 对象的 get() 方法，
就是在 get 方法的执行线程对象所维护的 threadLocals.table 数组中，
获取到以 ThreadLocal&lt;Looper&gt; 对象为键的键值对 Entry 对象，并将作为值的 Looper 对象取出来。
</code></pre></div></li></ol><p>因为 <code>sThreadLocal</code> 作为 <code>Looper</code> 类的静态属性，是唯一存在的，且 <code>prepare(quitAllowed)</code> 方法只能在一个线程中调用一次，所以在一个线程中，以 <code>sThreadLocal</code> 为键获得的 <code>Looper</code> 对象在这个线程中也是唯一的。</p><p>注意：</p><ol><li><p>一个线程中可以保存多个 <code>ThreadLocal&lt;T&gt;</code> 和 <code>T</code> 构成的键值对。</p></li><li><p><strong>一个 <code>ThreadLocal&lt;T&gt;</code> 可以在不同的线程中对应有不同的 <code>T</code> 值</strong>。</p></li><li><p>通过 <code>ThreadLocal&lt;T&gt;</code> 保存在线程中的 <code>T</code> 值是线程私有的。</p><blockquote><p>即：在线程 <code>A</code> 中调用 <code>sThreadLocal.set(looper)</code> 保存在线程 <code>A</code> 中的 <code>looper</code> 对象，是无法在线程 <code>B</code> 中通过调用 <code>sThreadLocal.get()</code> 方法获取到的。</p></blockquote></li><li><p><code>T</code> 值是被线程对象持有的，而不是被 <code>ThreadLocal&lt;T&gt;</code> 对象持有的。<code>ThreadLocal&lt;T&gt;</code> 对象只是作为键，对线程相关的 <code>T</code> 值进行存取。</p></li></ol><h2 id="_5-messagequeue-的创建时机" tabindex="-1"><a class="header-anchor" href="#_5-messagequeue-的创建时机" aria-hidden="true">#</a> 5. <code>MessageQueue</code> 的创建时机</h2><div class="language-java ext-java"><pre class="language-java"><code><span class="token comment">/* Looper.java */</span>
<span class="token keyword">private</span> <span class="token class-name">Looper</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> quitAllowed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    mQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageQueue</span><span class="token punctuation">(</span>quitAllowed<span class="token punctuation">)</span><span class="token punctuation">;</span>
    mThread <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>MessageQueue</code> 对象 是在 <code>Looper</code> 的构造方法中创建的。即在线程中调用 <code>Looper</code> 的静态方法 <code>prepare</code> 后就创建好了 <code>Looper</code> 和 <code>MessageQueue</code> 对象。</p><p>因为 <code>Looper</code> 对象是线程唯一的，所以在 <code>Looper</code> 的构造方法中创建的 <code>MessageQueue</code> 对象也是线程唯一的。</p><h2 id="_6-handler-messagequeue-looper-三者之间的引用关系" tabindex="-1"><a class="header-anchor" href="#_6-handler-messagequeue-looper-三者之间的引用关系" aria-hidden="true">#</a> 6. <code>Handler</code> &amp; <code>MessageQueue</code> &amp; <code>Looper</code> 三者之间的引用关系</h2><ol><li><p>一个线程中最多只有一个 <code>Looper</code> 对象，和一个 <code>MessageQueue</code> 对象。（但在一个线程中可以创建多个 <code>Handler</code> 对象）</p></li><li><p><code>Handler</code> 对象中通过属性 <code>mLooper</code> 持有 <code>Looper</code> 对象的引用，通过属性 <code>mQueue</code> 持有 <code>MessageQueue</code> 对象的引用。其中，<code>Handler.mQueue</code> 就是引用了 <code>mLooper.mQueue</code>，即 <code>Handler</code> 对象中引用的 <code>MessageQueue</code> 就是在 <code>mLooper</code> 对象中创建的。（即：<code>Handler</code> 对象绑定了 <code>Looper</code> 对象，同时也就绑定了 <code>MessageQueue</code> 对象）</p><p><img src="/assets/03.3c6c91ba.png" alt="" loading="lazy"></p><blockquote><p>如上图所示，创建 <code>Handler</code> 对象时：</p><ol><li><p>如果没有传入 <code>Looper</code> 对象，那么 <code>Handler</code> 对象绑定的 <code>Looper</code> 对象就是当前线程中的 <code>Looper</code> 对象。（注意：如果当前线程中还没有调用 <code>Looper.prepare</code> 方法创建 <code>Looper</code> 对象，就会报错）</p></li><li><p>在子线程中使用 <code>Handler</code> 机制时，则需要传入一个与该子线程相关的 <code>Looper</code> 对象。</p></li></ol></blockquote></li><li><p>多个 <code>Handler</code> 对象可以绑定同一个 <code>Looper</code> 对象。此时，通过这些 <code>Handler</code> 对象发送的消息都会按照消息的被处理时间 <code>msg.when</code> 插入到同一个 <code>MessageQueue</code> 消息队列中。</p></li></ol><h2 id="_7-handler-消息机制中的等待唤醒机制" tabindex="-1"><a class="header-anchor" href="#_7-handler-消息机制中的等待唤醒机制" aria-hidden="true">#</a> 7. <code>Handler</code> 消息机制中的等待唤醒机制</h2><div class="language-java ext-java"><pre class="language-java"><code><span class="token comment">/* MessageQueue.java */</span>

<span class="token comment">// 消息出队（在消费消息的线程中执行）</span>
<span class="token class-name">Message</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/*
        调用 nativePollOnce(ptr, nextPollTimeoutMillis) 会让 next 方法的执行线程（即消费消息的线程）进入等待状态，其中：
            1. nextPollTimeoutMillis = 0 时，不会进入等待状态
            2. nextPollTimeoutMillis &gt; 0 时，进入计时等待状态，
                当调用 nativeWake(mPtr) 方法 或经过 nextPollTimeoutMillis 时间后才会唤醒
            3. nextPollTimeoutMillis = -1 时，进入无限等待状态，只有调用 nativeWake(mPtr) 才会唤醒
    */</span>
    <span class="token keyword">final</span> <span class="token keyword">long</span> ptr <span class="token operator">=</span> mPtr<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">int</span> nextPollTimeoutMillis <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 1. 默认不进入等待状态</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token function">nativePollOnce</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> nextPollTimeoutMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            
            <span class="token keyword">final</span> <span class="token keyword">long</span> now <span class="token operator">=</span> <span class="token class-name">SystemClock</span><span class="token punctuation">.</span><span class="token function">uptimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Message</span> prevMsg <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token class-name">Message</span> msg <span class="token operator">=</span> mMessages<span class="token punctuation">;</span>
            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>msg <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>now <span class="token operator">&lt;</span> msg<span class="token punctuation">.</span>when<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 2. 当前时间还没有可处理的消息，等待 nextPollTimeoutMillis = msg.when - now 时间后才能取出最先被处理的消息</span>
                    nextPollTimeoutMillis <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>when <span class="token operator">-</span> now<span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    mBlocked <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>prevMsg <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        prevMsg<span class="token punctuation">.</span>next <span class="token operator">=</span> msg<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                        mMessages <span class="token operator">=</span> msg<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    msg<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
                    <span class="token keyword">return</span> msg<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token comment">// 3. 消息队列中没有消息了，进入无限等待状态</span>
                nextPollTimeoutMillis <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            <span class="token comment">/*
                执行到这里，nextPollTimeoutMillis 一定不为 0，
                不考虑添加了 IdleHandler 的情况，pendingIdleHandlerCount &lt;= 0 总是成立
                即当消费消息的线程进入等待状态时，mBlocked 置为 true
            */</span> 
            <span class="token keyword">if</span> <span class="token punctuation">(</span>pendingIdleHandlerCount <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                mBlocked <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token punctuation">}</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-java ext-java"><pre class="language-java"><code><span class="token comment">/* MessageQueue.java */</span>

<span class="token comment">// 消息入队（在生产消息的线程中执行）</span>
<span class="token keyword">boolean</span> <span class="token function">enqueueMessage</span><span class="token punctuation">(</span><span class="token class-name">Message</span> msg<span class="token punctuation">,</span> <span class="token keyword">long</span> when<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/*
        在消息入队时，以下情况中需要唤醒消费消息的线程：
        1. 当前插入的消息 msg 最先被处理时，若消费消息的线程处于等待状态，则需要唤醒；
        2. 在开启了同步屏障，且处于优先遍历异步消息的条件下，即：队头消息是屏障消息（mMessages.target == null），
            如果当前插入的消息 msg 是异步消息，且是最先被处理的异步消息，那么，若消费消息的线程处于等待状态，则需要唤醒；
        3. 如果当前插入的消息 msg 不是应该被最先处理的，那么就算消费消息的线程处于等待状态，也不需要唤醒。
            因为此时，若消费消息的线程处于等待状态，说明先于 msg 被处理的上一个消息还在等待处理，不应该提前唤醒。
    */</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        msg<span class="token punctuation">.</span>when <span class="token operator">=</span> when<span class="token punctuation">;</span>
        <span class="token class-name">Message</span> p <span class="token operator">=</span> mMessages<span class="token punctuation">;</span>
        <span class="token keyword">boolean</span> needWake<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> when <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> when <span class="token operator">&lt;</span> p<span class="token punctuation">.</span>when<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 情况 1</span>
            msg<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>
            mMessages <span class="token operator">=</span> msg<span class="token punctuation">;</span>
            needWake <span class="token operator">=</span> mBlocked<span class="token punctuation">;</span> 
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// 情况 2 和 3</span>
            needWake <span class="token operator">=</span> mBlocked <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span>target <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> msg<span class="token punctuation">.</span><span class="token function">isAsynchronous</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Message</span> prev<span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                prev <span class="token operator">=</span> p<span class="token punctuation">;</span>
                p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> when <span class="token operator">&lt;</span> p<span class="token punctuation">.</span>when<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>needWake <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span><span class="token function">isAsynchronous</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    needWake <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            msg<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span> 
            prev<span class="token punctuation">.</span>next <span class="token operator">=</span> msg<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        
        <span class="token keyword">if</span> <span class="token punctuation">(</span>needWake<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">nativeWake</span><span class="token punctuation">(</span>mPtr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 唤醒消费消息的线程</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_8-消息入队和消息出队时的加锁原因" tabindex="-1"><a class="header-anchor" href="#_8-消息入队和消息出队时的加锁原因" aria-hidden="true">#</a> 8. 消息入队和消息出队时的加锁原因</h2><p>如上所示的消息出队（<code>MessageQueue.next</code>）和消息入队（<code>MessageQueue.enqueueMessage</code>）的代码中，都使用了同一个锁对象（<code>synchronized(this)</code>）进行了加锁。这是因为：</p><div class="language-text ext-text"><pre class="language-text"><code>1. 生产消息的线程可以有多个，即 MessageQueue.enqueueMessage 方法可以在多个线程中调用。
    （也就是 Handler.sendXxx 和 Handler.postXxx 方法可以在多个不同的线程中调用）
2. 消费消息的线程只有一个，即调用 Looper.preapre 方法的那个线程。
于是：
    消息入队时加锁 this，保证同一时间只有一个消息入队；
    消息出队时加锁 this，保证入队和出队不会在同一时间发生。从而使得：
        即使最优先消息后入队，也能在接下来的出队操作中及时取出来。（即保证插入消息能得到及时处理）
</code></pre></div><h2 id="_9-handler-消息机制的退出流程" tabindex="-1"><a class="header-anchor" href="#_9-handler-消息机制的退出流程" aria-hidden="true">#</a> 9. <code>Handler</code> 消息机制的退出流程</h2><div class="language-java ext-java"><pre class="language-java"><code><span class="token comment">/* MessageQueue.java */</span>

<span class="token comment">// 退出消息循环</span>
<span class="token keyword">void</span> <span class="token function">quit</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> safe<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>mQuitAllowed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">&quot;Main thread not allowed to quit.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>mQuitting<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">/*
            mQuitting 置为 true 表示退出消息循环机制。
            在 next 方法中根据该变量判断是否退出消息循环。
        */</span>
        mQuitting <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> 

        <span class="token comment">/*
            如果 safe 为 true，则只会清空队列中 msg.when &gt; now 的消息（removeAllFutureMessagesLocked），
                即当队列中 msg.when &lt;= now 的消息处理完之后，才会退出消息循环。
            如果 safe 为 false，则会清空队列中的所有消息（removeAllMessagesLocked），
                即立即退出消息循环。
        */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>safe<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">removeAllFutureMessagesLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token function">removeAllMessagesLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        
        <span class="token comment">/*
            为了避免消费消息的线程处于等待状态而无法退出消息循环，
            所以不管消费消息的线程是否处于等待状态，都调用下 nativeWake(mPtr) 方法唤醒下
        */</span> 
        <span class="token function">nativeWake</span><span class="token punctuation">(</span>mPtr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-java ext-java"><pre class="language-java"><code><span class="token comment">/* MessageQueue.java */</span>

<span class="token comment">// 消息出队（在消费消息的线程中执行）</span>
<span class="token class-name">Message</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token keyword">long</span> ptr <span class="token operator">=</span> mPtr<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">int</span> nextPollTimeoutMillis <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token function">nativePollOnce</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> nextPollTimeoutMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            
            <span class="token keyword">final</span> <span class="token keyword">long</span> now <span class="token operator">=</span> <span class="token class-name">SystemClock</span><span class="token punctuation">.</span><span class="token function">uptimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Message</span> prevMsg <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token class-name">Message</span> msg <span class="token operator">=</span> mMessages<span class="token punctuation">;</span>
            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>msg <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>now <span class="token operator">&lt;</span> msg<span class="token punctuation">.</span>when<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    nextPollTimeoutMillis <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>when <span class="token operator">-</span> now<span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    mBlocked <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
                    <span class="token comment">// 从队列中移除 msg</span>
                    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
                    <span class="token keyword">return</span> msg<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                nextPollTimeoutMillis <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span>mQuitting<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//  只有当退出消息循环机制时，才会返回 null。否则没消息处理时只会进入等待状态</span>
                <span class="token function">dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>pendingIdleHandlerCount <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                mBlocked <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token punctuation">}</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-java ext-java"><pre class="language-java"><code><span class="token comment">/* Looper.java */</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">Looper</span> me <span class="token operator">=</span> <span class="token function">myLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>me <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 先调用 Looper.prepare 后，才能调用 Looper.loop()</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">&quot;No Looper; Looper.prepare() wasn&#39;t called on this thread.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">final</span> <span class="token class-name">MessageQueue</span> queue <span class="token operator">=</span> me<span class="token punctuation">.</span>mQueue<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/*
            当队列中没有消息，或者消息的处理时间还没到，则 queue.next() 方法会阻塞
            只有当退出消息循环机制时，queue.next() 才会返回 null，结束消息循环。
        */</span>
        <span class="token class-name">Message</span> msg <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token keyword">if</span> <span class="token punctuation">(</span>msg <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        msg<span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">dispatchMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 处理消息</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        msg<span class="token punctuation">.</span><span class="token function">recycleUnchecked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 回收消息</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_10-messagequeue-消息队列的容量没有限制" tabindex="-1"><a class="header-anchor" href="#_10-messagequeue-消息队列的容量没有限制" aria-hidden="true">#</a> 10. <code>MessageQueue</code> 消息队列的容量没有限制</h2><p>在调用 <code>MessageQueue.enqueueMessage(msg, when)</code> 方法，将消息 <code>msg</code> 入队时，没有限制消息队列的容量。即可以无限制地将消息插入到队列中。</p><p>于是，当消息队列中存放了过多的消息对象时，就有可能导致内存溢出。</p><p>因此，尽量不要使用 <code>Handler</code> 来做定时任务。</p><h2 id="_11-消息池-享元设计模式" tabindex="-1"><a class="header-anchor" href="#_11-消息池-享元设计模式" aria-hidden="true">#</a> 11. 消息池 &amp; 享元设计模式</h2><p>在设计 <code>Message</code> 的时候采用了 <strong>享元设计模式</strong>（享元设计模式就是通过 <strong>对象池</strong> 来实现对象共享，避免创建多对象）。</p><p>因为 <code>App</code> 在运行过程中，会频繁地使用 <code>Handler</code> 消息机制来处理任务，也就是说会造成 <code>Message</code> 对象的频繁创建和销毁，从而出现 <strong>内存抖动</strong>，并产生大量的 <strong>内存碎片</strong>，使得堆中可能没有足够大的连续内存空间来存放占用内存较大的对象（如 <code>Bitmap</code>），导致内存溢出（<code>OOM</code>）的发生。</p><p>所以，为了避免这种问题，应该调用 <code>Message.obtain</code> 方法尝试从对象池 <code>sPool</code> 中获取一个可复用的 <code>Message</code> 对象，而不是直接 <code>new</code> 一个 <code>Message</code> 对象。并且在 <code>Message</code> 对象使用完毕后，调用 <code>Message.recycleUnchecked()</code> 方法清除掉 <code>Message</code> 对象的消息数据，再将其回收到对象池 <code>sPool</code> 中，以便下一次能够继续复用。</p><p><img src="/assets/04.1726c581.png" alt="" loading="lazy"></p><blockquote><p>优先通过重载的 <code>obtain</code> 静态方法获取 <code>Message</code> 对象。</p></blockquote><div class="language-java ext-java"><pre class="language-java"><code><span class="token comment">/* Message.java */</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> sPoolSync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 同步锁</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Message</span> sPool<span class="token punctuation">;</span> <span class="token comment">// 消息池采用单链表结构，sPool 是链表的头节点</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> sPoolSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MAX_POOL_SIZE</span> <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span> <span class="token comment">// 消息池的容量为 50。（即最多缓存 50 个 Message 对象）</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Message</span> <span class="token function">obtain</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>sPoolSync<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>sPool <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 优先复用消息池中缓存的 Message 对象</span>
            <span class="token class-name">Message</span> m <span class="token operator">=</span> sPool<span class="token punctuation">;</span>
            sPool <span class="token operator">=</span> m<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            m<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            m<span class="token punctuation">.</span>flags <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 
            sPoolSize<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> m<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">recycleUnchecked</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    flags <span class="token operator">=</span> <span class="token constant">FLAG_IN_USE</span><span class="token punctuation">;</span>
    what <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    arg1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    arg2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    obj <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    replyTo <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    sendingUid <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    when <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    target <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    callback <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    data <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>sPoolSync<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>sPoolSize <span class="token operator">&lt;</span> <span class="token constant">MAX_POOL_SIZE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 将回收的当前 Message 对象插入到消息池链表的头部</span>
            next <span class="token operator">=</span> sPool<span class="token punctuation">;</span>
            sPool <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
            sPoolSize<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-java ext-java"><pre class="language-java"><code><span class="token comment">/* Looper.java */</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">Looper</span> me <span class="token operator">=</span> <span class="token function">myLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>me <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">&quot;No Looper; Looper.prepare() wasn&#39;t called on this thread.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">final</span> <span class="token class-name">MessageQueue</span> queue <span class="token operator">=</span> me<span class="token punctuation">.</span>mQueue<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Message</span> msg <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token keyword">if</span> <span class="token punctuation">(</span>msg <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        msg<span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">dispatchMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        msg<span class="token punctuation">.</span><span class="token function">recycleUnchecked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 回收消息</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_12-同步屏障" tabindex="-1"><a class="header-anchor" href="#_12-同步屏障" aria-hidden="true">#</a> 12. 同步屏障</h2><h3 id="_12-1-同步屏障的含义及作用" tabindex="-1"><a class="header-anchor" href="#_12-1-同步屏障的含义及作用" aria-hidden="true">#</a> 12.1 同步屏障的含义及作用：</h3><div class="language-text ext-text"><pre class="language-text"><code>屏蔽同步消息（isAsynchronous() 返回 false的消息），
优先处理异步消息（isAsynchronous() 返回 true 的消息）
</code></pre></div><h3 id="_12-2-同步屏障的实现方式" tabindex="-1"><a class="header-anchor" href="#_12-2-同步屏障的实现方式" aria-hidden="true">#</a> 12.2 同步屏障的实现方式：</h3><div class="language-text ext-text"><pre class="language-text"><code>在通过 Handler 发送异步消息之前，调用 MessageQueue 的 postSyncBarrier() 方法，向消息队列中插入一个作为同步屏障的消息，
在通过 Handler 发送异步消息之后，当循环到消息队列中作为同步屏障的消息时，就只会从消息队列中取出位于同步屏障之后的异步消息，
直到调用 removeSyncBarrier 方法将作为同步屏障的消息从消息队列中移除后，
才会从消息队列的头部节点开始，依次挨个地取出每个消息，而不考虑取出的是同步消息还是异步消息。
</code></pre></div><p><img src="/assets/05.f490f0d7.png" alt="" loading="lazy"></p><h3 id="_12-3-同步屏障的应用-刷新-ui" tabindex="-1"><a class="header-anchor" href="#_12-3-同步屏障的应用-刷新-ui" aria-hidden="true">#</a> 12.3 同步屏障的应用：刷新 <code>UI</code></h3><p>为了保证 <code>UI</code> 界面的流畅，在刷新频率为 <code>60Hz</code> 的安卓屏幕中，应该保证每 <code>16ms</code> 刷新一帧屏幕图像。（<code>60hz =&gt; 1000s/60f = 16.666ms/s</code>）。</p><p>也就是说，当使用 <code>Handler</code> 消息机制来刷新屏幕时，必须保证每 <code>16ms</code> 能够处理一次 <code>UI</code> 刷新的消息，而不能受到其它同步消息的影响。</p><p>因此，通过同步屏障，将 <code>UI</code> 刷新的消息设置为异步消息，就能够避免同步消息产生的干扰。从而在同步屏障的保证下，每 <code>16ms</code> 处理一次 <code>UI</code> 刷新的异步消息。</p><p><code>UI</code> 绘制中使用同步屏障的相关源码分析如下：</p><div class="language-text ext-text"><pre class="language-text"><code>在刷新界面时（如调用 View.requestLayout 方法），会执行 ViewRootImpl.scheduleTraversals() 方法来请求一次 UI 绘制流程，
在 scheduleTraversals() 方法中，会先调用 MessageQueue.postSyncBarrier 方法开启同步屏障，
然后调用 Choreographer.postCallback 方法发送一系列的异步消息，
在同步屏障的作用下，会从消息队列中取出绘制 UI 的异步消息进行处理，
处理过程中就会执行 TraversalRunnable.run() 方法，进而调用 doTraversal() 方法，
因此，可以在 doTraversal() 方法中调用 MessageQueue.removeSyncBarrier 方法停止同步屏障。
</code></pre></div><p><img src="/assets/06.a0436178.png" alt="" loading="lazy"></p><h2 id="_13-handlerthread" tabindex="-1"><a class="header-anchor" href="#_13-handlerthread" aria-hidden="true">#</a> 13. <code>HandlerThread</code></h2><p><code>HandlerThread</code> 是 <code>Thread</code> 的子类。也就是说，<code>HandlerThread</code> 表示一个线程。</p><p><code>HandlerThread</code> 作为一个线程，其特殊之处就在于：它会在线程中创建并绑定一个 <code>Looper</code>。</p><p><code>HandlerThread</code> 的作用就是：</p><ol><li><p>方便使用：包括方便初始化、方便获取线程绑定的 <code>Looper</code>。</p></li><li><p>保证了线程安全。</p></li></ol><p><code>HandlerThread</code> 的内部实现主要如下：</p><div class="language-text ext-text"><pre class="language-text"><code>HandlerThread 内部通过同步锁，保证在其它线程中能够安全地调用 getLooper() 方法获取到一个不为 null 的 Looper 对象。
如果不使用 HandlerThread，而是 new 一个 Thread，重写 Thread.run() 方法，在 run 方法中调用 Looper.prepare 和 Looper.loop 方法，
那么在其它线程中获取这个新创建线程中的 Looper 对象时，可能获取到的是一个 null，
这是因为，新创建线程中的 run 方法，在其它线程调用 getLooper 时可能还未执行，从而新创建线程中的 Looper 对象还未创建。
</code></pre></div><p><img src="/assets/07.afe8e599.png" alt="" loading="lazy"></p><h2 id="_14-intentservice" tabindex="-1"><a class="header-anchor" href="#_14-intentservice" aria-hidden="true">#</a> 14. <code>IntentService</code></h2><p><code>Service</code> 一般用于处理后台耗时任务。</p><p>对于如下需求：</p><div class="language-text ext-text"><pre class="language-text"><code>一项任务分成几个子任务，子任务按顺序先后执行，子任务全部执行完后，这项任务才算成功。
</code></pre></div><p>这个需求可以用多个线程来处理，一个线程处理 -&gt; 下一个线程 -&gt; 下一个线程</p><p><code>IntentService</code> 可以完成这个需求，而且能够很好的管理线程，保证只有一个子线程处理工作，而且是一个一个地完成任务，有条不紊地进行。</p><p><code>IntentService</code> 的实现如下：</p><div class="language-text ext-text"><pre class="language-text"><code>IntentService 内部维护了一个在子线程中运行的 Handler 消息机制。
在不停止 IntentService 的情况下，
每次启动 IntentService 时，都会将一个持有最新 startId 的消息（msg.arg1 = startId）放到消息队列中，
在从消息队列中取出消息并进行处理的过程中，每个消息被处理完成后，都会尝试调用 stopSelf(msg.arg1) 停止 IntentService，
但是，只有最后一个消息才会持有最新的 startId。
也就是说，当消息队列中还存在消息时，正在被处理的消息是无法通过 stopSelf(msg.arg1) 将 IntentService 给停下来的。
除非在重写的 onHandleIntent 中调用 stopSelf()、stopSelf(-1)、stopService(intent) 才会立即将 IntentService 停下来。
</code></pre></div><p><img src="/assets/08.8586c72a.png" alt="" loading="lazy"></p><h3 id="_14-1-示例-intentservice-的使用" tabindex="-1"><a class="header-anchor" href="#_14-1-示例-intentservice-的使用" aria-hidden="true">#</a> 14.1 示例：<code>IntentService</code> 的使用</h3><p><img src="/assets/09.07da3606.png" alt="" loading="lazy"></p><h2 id="_15-handler-面试题" tabindex="-1"><a class="header-anchor" href="#_15-handler-面试题" aria-hidden="true">#</a> 15. <code>Handler</code> 面试题</h2><h3 id="_15-1-一个线程有几个-handler" tabindex="-1"><a class="header-anchor" href="#_15-1-一个线程有几个-handler" aria-hidden="true">#</a> 15.1 一个线程有几个 <code>Handler</code>？</h3><div class="language-text ext-text"><pre class="language-text"><code>一个线程中可以 new 无数个 Handler 对象，
但一个线程只能有一个 Handler 消息机制，即只能绑定一个 Looper 对象和 一个 MessageQueue 对象。
</code></pre></div><h3 id="_15-2-一个线程有几个-looper-如何保证" tabindex="-1"><a class="header-anchor" href="#_15-2-一个线程有几个-looper-如何保证" aria-hidden="true">#</a> 15.2 一个线程有几个 <code>Looper</code>？如何保证？</h3><div class="language-text ext-text"><pre class="language-text"><code>一个线程中只有一个 Looper 对象。保证措施：
1. Looper 的构造方法私有化
2. 通过静态方法 Looper.prepare 创建 Looper 对象时，使用 ThreadLocal 保证一个线程对象中只绑定一个 Looper 对象
</code></pre></div><h3 id="_15-3-handler-内存泄漏原因-为什么其他的内部类没有说过这个问题" tabindex="-1"><a class="header-anchor" href="#_15-3-handler-内存泄漏原因-为什么其他的内部类没有说过这个问题" aria-hidden="true">#</a> 15.3 <code>Handler</code> 内存泄漏原因？为什么其他的内部类没有说过这个问题？</h3><div class="language-text ext-text"><pre class="language-text"><code>以 Activity 为例，通常我们会将 Handler 作为 Activity 的内部类。
由于内部类持有外部类的引用，因此，Handler 对象引用了 Activity 对象。
并且，在发送消息并将消息入队时，会通过 msg.target = this; 使得消息对象引用 Handler 对象，
于是，消息对象间接引用了 Activity 对象。
如果在消息队列中的消息对象在 Activity 对象的生命周期结束后仍然没有出队，那么依据垃圾回收时的根搜索算法，
Activity 对象可达，不被认为是垃圾，无法回收。从而导致了由于 Activity 对象无法被回收而引用的内存泄漏。
</code></pre></div><h3 id="_15-4-为何主线程可以-new-handler" tabindex="-1"><a class="header-anchor" href="#_15-4-为何主线程可以-new-handler" aria-hidden="true">#</a> 15.4 为何主线程可以 <code>new Handler</code>？</h3><div class="language-text ext-text"><pre class="language-text"><code>在 ActivityThread.main 方法中，已经依次调用过 Looper 的 prepare 和 loop 方法了，所以主线程中可以直接 new Handler。
</code></pre></div><h3 id="_15-5-如果想要在子线程中-new-handler-要做些什么准备" tabindex="-1"><a class="header-anchor" href="#_15-5-如果想要在子线程中-new-handler-要做些什么准备" aria-hidden="true">#</a> 15.5 如果想要在子线程中 <code>new Handler</code> 要做些什么准备？</h3><div class="language-text ext-text"><pre class="language-text"><code>而如果在子线程中 new Handler，那么需要先依次调用 Looper 的 prepare 和 loop 方法。
</code></pre></div><h3 id="_15-6-消息队列无消息时的处理方案是什么-有什么用" tabindex="-1"><a class="header-anchor" href="#_15-6-消息队列无消息时的处理方案是什么-有什么用" aria-hidden="true">#</a> 15.6 消息队列无消息时的处理方案是什么？有什么用？</h3><div class="language-text ext-text"><pre class="language-text"><code>消息队列中无消息时，会调用 nativePollOnce(ptr, -1) 方法，使消费消息的线程进入无限等待状态。
从而交出 CPU 的执行权给其他线程使用。
</code></pre></div><h3 id="_15-7-多个-handler-在不同线程中发消息时-如何保证线程安全" tabindex="-1"><a class="header-anchor" href="#_15-7-多个-handler-在不同线程中发消息时-如何保证线程安全" aria-hidden="true">#</a> 15.7 多个 <code>Handler</code> 在不同线程中发消息时，如何保证线程安全？</h3><div class="language-text ext-text"><pre class="language-text"><code>通过对 MessageQueue 的 enqueueMessage 方法中的消息入队过程和 MessageQueue 的 next 方法中的消息出队过程，
分别加上相同的同步锁，从而保证线程安全。
</code></pre></div><h3 id="_15-8-使用-message-时应该如何创建它" tabindex="-1"><a class="header-anchor" href="#_15-8-使用-message-时应该如何创建它" aria-hidden="true">#</a> 15.8 使用 <code>Message</code> 时应该如何创建它？</h3><div class="language-text ext-text"><pre class="language-text"><code>Message 类在设计时采用来了享元设计模式，通过静态变量 sPool 来维护一个消息对象池，使得可以复用已存在的 Message 对象，
Message 类提供静态方法 obtain 返回一个 Message 对象：
    1. 当 sPool 中存在消息对象时，返回 sPool 中的消息对象；
    2. 当 sPool 中不存在消息对象时，返回一个新创建的对象。
也就是说，为了避免频繁地创建和销毁 Message 对象所造成的内存抖动，应该使用 Message.obtain 方法来创建 Message。
</code></pre></div><h3 id="_15-9-looper-死循环为什么不会导致应用卡死" tabindex="-1"><a class="header-anchor" href="#_15-9-looper-死循环为什么不会导致应用卡死" aria-hidden="true">#</a> 15.9 <code>Looper</code> 死循环为什么不会导致应用卡死？</h3><div class="language-text ext-text"><pre class="language-text"><code>Looper 死循环的目的只是为了将消息队列中存在的消息出队，当消息队列中没有消息时，Looper 循环所在的线程进入阻塞状态，
此时，调度器就会将 CPU 资源分配给其它线程使用，执行其它线程中的代码。
应用卡死就是说出现了 ANR，ANR 出现的场景可分为：
    1. Input 事件（如点击，触摸）的处理时间超过 5s；
    2. Broadcast 广播的处理时间超过 10s
    3. Service 前台服务的处理时间超过 20s
也就是说，导致 ANR 出现的原因是对某个任务的处理为按时完成。
而在 App 中，一切任务都是通过发送 Message 消息来处理的。
换句话说，导致 ANR 出现的原因是 Message 消息出队后的处理过程未按时完成！
这就意味着，只有当存在 Message 消息的情况下，才有可能出现 ANR，即出现应用卡死的现象。
而由于不存在 Message 消息，导致的 Looper 所在线程进入阻塞状态，跟应该卡死没有任何关系。
而 Looper 死循环的目的只是不停地将消息出队，跟消息出队后的处理过程无关，也就是说跟 ANR 无关，因此也跟应该卡死无关。
</code></pre></div><!--]--></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/zengkaiqiang562/JavaGuide/edit/main/docs/zkq/android/basic/handler.md" rel="noopener noreferrer" target="_blank" arialabel="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewbox="0 0 1024 1024" arialabelledby="edit"><title id="edit" lang="en">edit icon</title><g fill="currentColor"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></g></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item update-time"><span class="label">上次编辑于: </span><span class="info">2022/7/8 14:42:00</span></div><div class="meta-item contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: zengkaiqiang562@163.com">zengk</span><!--]--><!--]--></div></footer><nav class="page-nav"><a href="/zkq/android/basic/asynctask.html" class="nav-link prev" arialabel="AsyncTask"><div class="hint"><span class="arrow left"></span>上一页</div><div class="link"><!---->AsyncTask</div></a><a href="/zkq/android/basic/custom-view.html" class="nav-link next" arialabel="自定义View（TODO）"><div class="hint">下一页<span class="arrow right"></span></div><div class="link">自定义View（TODO）<!----></div></a></nav><!----><!----></main><!--]--><footer class="footer-wrapper"><div class="footer"></div><div class="copyright">Copyright © 2023 Zenk562</div></footer></div><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app.625aa393.js" defer></script>
  </body>
</html>
