<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.38" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://zengkaiqiang562.github.io/zkq/java/jmm.html"><meta property="og:site_name" content="Android Guide"><meta property="og:title" content="Java 内存模型（JMM）"><meta property="og:type" content="article"><meta property="og:image" content="https://zengkaiqiang562.github.io/"><meta property="og:updated_time" content="2022-07-07T15:59:00.000Z"><meta property="og:locale" content="zh-CN"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image:alt" content="Java 内存模型（JMM）"><meta property="article:tag" content="java"><meta property="article:modified_time" content="2022-07-07T15:59:00.000Z"><script>var _hmt = _hmt || [];
      (function() {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?5dd2e8c97962d57b7b8fea1737c01743";
        var s = document.getElementsByTagName("script")[0]; 
        s.parentNode.insertBefore(hm, s);
      })();</script><link rel="stylesheet" href="//at.alicdn.com/t/font_2922463_99aa80ii7cf.css"><title>Java 内存模型（JMM） | Android Guide</title><meta name="description" content="Android 学习 && 面试指南">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/assets/style.c9a516cc.css">
    <link rel="modulepreload" href="/assets/app.2a01fc36.js"><link rel="modulepreload" href="/assets/jmm.html.a4da8e9c.js"><link rel="modulepreload" href="/assets/jmm.html.e422b369.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container has-toc sidebar-open"><!--[--><header class="navbar"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><a href="/" class="home-link"><img class="logo" src="/logo.png" alt="Android Guide"><!----><span class="site-name hide-in-pad">Android Guide</span><!--[--><!----><!--]--></a><nav class="nav-links" style=""><div class="nav-item hide-in-mobile"><a href="/home.html" class="nav-link" arialabel="面试指南"><i class="icon iconfont icon-java"></i>面试指南<!----></a></div><div class="nav-item hide-in-mobile"><a href="/zhuanlan/" class="nav-link" arialabel="优质专栏"><i class="icon iconfont icon-recommend"></i>优质专栏<!----></a></div><div class="nav-item hide-in-mobile"><a href="/open-source-project/" class="nav-link" arialabel="项目精选"><i class="icon iconfont icon-github"></i>项目精选<!----></a></div><div class="nav-item hide-in-mobile"><a href="https://snailclimb.gitee.io/javaguide/#/" rel="noopener noreferrer" target="_blank" arialabel="旧版链接" class="nav-link"><i class="icon iconfont icon-java"></i>旧版链接<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="nav-item hide-in-mobile"><a href="https://javaguide.cn/feed.json" rel="noopener noreferrer" target="_blank" arialabel="RSS订阅" class="nav-link"><i class="icon iconfont icon-rss"></i>RSS订阅<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="nav-item hide-in-mobile"><a href="/about-the-author/" class="nav-link" arialabel="关于作者"><i class="icon iconfont icon-zuozhe"></i>关于作者<!----></a></div></nav><div class="nav-actions-wrapper"><!--[--><!----><!--]--><div class="nav-item"><!----></div><div class="nav-item"><a class="repo-link" href="https://github.com/zengkaiqiang562/JavaGuide" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewbox="0 0 1024 1024" arialabelledby="github" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><title id="github" lang="en">github icon</title><g fill="currentColor"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></g></svg></a></div><div class="nav-item hide-in-mobile"><button id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewbox="0 0 1024 1024" arialabelledby="auto" style="display:block;"><title id="auto" lang="en">auto icon</title><g fill="currentColor"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></g></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewbox="0 0 1024 1024" arialabelledby="dark" style="display:none;"><title id="dark" lang="en">dark icon</title><g fill="currentColor"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></g></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewbox="0 0 1024 1024" arialabelledby="light" style="display:none;"><title id="light" lang="en">light icon</title><g fill="currentColor"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></g></svg></button></div><form class="search-box" role="search"><input type="search" placeholder="搜索" autocomplete="off" spellcheck="false" value><!----></form><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button><!--[--><!----><!--]--></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><a href="/zkq/java/reflect.html" class="nav-link sidebar-link sidebar-page" arialabel="反射机制"><!---->反射机制<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/zkq/java/annotation.html" class="nav-link sidebar-link sidebar-page" arialabel="注解技术"><!---->注解技术<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/zkq/java/genericity.html" class="nav-link sidebar-link sidebar-page" arialabel="泛型编程（TODO）"><!---->泛型编程（TODO）<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/zkq/java/thread.html" class="nav-link sidebar-link sidebar-page" arialabel="线程"><!---->线程<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/zkq/java/threadpool.html" class="nav-link sidebar-link sidebar-page" arialabel="线程池"><!---->线程池<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/zkq/java/jmm.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" arialabel="Java 内存模型（JMM）"><!---->Java 内存模型（JMM）<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#_1-从-java-代码到-cpu-指令" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1. 从 Java 代码到 CPU 指令"><!---->1. 从 Java 代码到 CPU 指令<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#_2-jvm-内存结构-java-内存模型-java-对象模型" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="2. JVM 内存结构 &amp; Java 内存模型 &amp; Java 对象模型"><!---->2. JVM 内存结构 &amp; Java 内存模型 &amp; Java 对象模型<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#_2-1-jvm-内存结构" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="2.1 JVM 内存结构"><!---->2.1 JVM 内存结构<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#_2-2-java-对象模型" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="2.2 Java 对象模型"><!---->2.2 Java 对象模型<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#_3-java-内存模型-jmm" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="3. Java 内存模型（JMM）"><!---->3. Java 内存模型（JMM）<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#_3-1-为什么需要-jmm" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="3.1 为什么需要 JMM"><!---->3.1 为什么需要 JMM<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#_3-2-jmm-是一种规范" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="3.2 JMM 是一种规范"><!---->3.2 JMM 是一种规范<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#_3-3-jmm-是工具类和关键字的原理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="3.3 JMM 是工具类和关键字的原理"><!---->3.3 JMM 是工具类和关键字的原理<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#_3-4-jmm-的三个重要内容-重排序、可见性、原子性" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="3.4 JMM 的三个重要内容（重排序、可见性、原子性）"><!---->3.4 JMM 的三个重要内容（重排序、可见性、原子性）<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#_4-重排序" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="4. 重排序"><!---->4. 重排序<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#_4-1-什么是重排序" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="4.1 什么是重排序"><!---->4.1 什么是重排序<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#_4-2-重排序的好处-提高处理速度" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="4.2 重排序的好处（提高处理速度）"><!---->4.2 重排序的好处（提高处理速度）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#_4-3-重排序的-3-种情况" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="4.3 重排序的 3 种情况"><!---->4.3 重排序的 3 种情况<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#_5-可见性" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="5. 可见性"><!---->5. 可见性<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#_5-1-什么是可见性问题" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="5.1 什么是可见性问题"><!---->5.1 什么是可见性问题<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#用-volatile-解决可见性问题" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="用 volatile 解决可见性问题"><!---->用 volatile 解决可见性问题<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#_5-2-为什么会有可见性问题" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="5.2 为什么会有可见性问题"><!---->5.2 为什么会有可见性问题<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#_5-3-jmm-的抽象-主内存-本地内存" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="5.3 JMM 的抽象：主内存&amp;本地内存"><!---->5.3 JMM 的抽象：主内存&amp;本地内存<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#_5-3-1-什么是主内存和本地内存" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="5.3.1 什么是主内存和本地内存"><!---->5.3.1 什么是主内存和本地内存<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#_5-3-2-主内存和本地内存的关系-导致可见性问题" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="5.3.2 主内存和本地内存的关系（导致可见性问题）"><!---->5.3.2 主内存和本地内存的关系（导致可见性问题）<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#_5-4-happens-before-规则-保证可见性的规则" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="5.4 Happens-Before 规则（保证可见性的规则）"><!---->5.4 Happens-Before 规则（保证可见性的规则）<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#_5-4-1-单线程规则" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="5.4.1 单线程规则"><!---->5.4.1 单线程规则<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#_5-4-2-锁操作-synchronized-和-lock" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="5.4.2 锁操作（synchronized 和 Lock）"><!---->5.4.2 锁操作（synchronized 和 Lock）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#_5-4-3-volatile-变量" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="5.4.3 volatile 变量"><!---->5.4.3 volatile 变量<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#_5-4-4-线程启动" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="5.4.4 线程启动"><!---->5.4.4 线程启动<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#_5-4-5-线程-join" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="5.4.5 线程 join"><!---->5.4.5 线程 join<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#_5-4-6-传递性" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="5.4.6 传递性"><!---->5.4.6 传递性<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#_5-4-7-中断" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="5.4.7 中断"><!---->5.4.7 中断<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#_5-4-8-构造方法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="5.4.8 构造方法"><!---->5.4.8 构造方法<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#_5-4-9-工具类的-happens-before-规则" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="5.4.9 工具类的 Happens-Before 规则"><!---->5.4.9 工具类的 Happens-Before 规则<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#_5-4-10-happens-before-演示案例" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="5.4.10 happens-before 演示案例"><!---->5.4.10 happens-before 演示案例<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#volatile-实现轻量级同步-近朱者赤" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="volatile 实现轻量级同步（近朱者赤）"><!---->volatile 实现轻量级同步（近朱者赤）<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#_5-5-volatile-关键字" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="5.5 volatile 关键字"><!---->5.5 volatile 关键字<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#_5-5-1-volatile-是什么" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="5.5.1 volatile 是什么"><!---->5.5.1 volatile 是什么<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#_5-5-2-volatile-的适用场合" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="5.5.2 volatile 的适用场合"><!---->5.5.2 volatile 的适用场合<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#_5-5-3-volatile-的作用-避免可见性问题、禁止重排序" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="5.5.3 volatile 的作用（避免可见性问题、禁止重排序）"><!---->5.5.3 volatile 的作用（避免可见性问题、禁止重排序）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#_5-5-4-volatile-和-synchronized-的关系" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="5.5.4 volatile 和 synchronized 的关系"><!---->5.5.4 volatile 和 synchronized 的关系<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#_5-5-5-用-volatile-修正重排序问题" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="5.5.5 用  volatile 修正重排序问题"><!---->5.5.5 用  volatile 修正重排序问题<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#_5-5-6-volatile-补充" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="5.5.6 volatile 补充"><!---->5.5.6 volatile 补充<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#_5-6-能保证可见性的措施" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="5.6 能保证可见性的措施"><!---->5.6 能保证可见性的措施<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#_5-7-对-synchronized-可见性的正确理解" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="5.7 对 synchronized 可见性的正确理解"><!---->5.7 对 synchronized 可见性的正确理解<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#_6-原子性" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="6. 原子性"><!---->6. 原子性<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#_6-1-什么是原子性" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="6.1 什么是原子性"><!---->6.1 什么是原子性<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#_6-2-java-中的原子操作有哪些" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="6.2 Java 中的原子操作有哪些"><!---->6.2 Java 中的原子操作有哪些<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#_6-3-long-和-double-的原子性" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="6.3 long 和 double 的原子性"><!---->6.3 long 和 double 的原子性<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#_6-4-原子操作-原子操作-原子操作" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="6.4 原子操作 + 原子操作 != 原子操作"><!---->6.4 原子操作 + 原子操作 != 原子操作<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jmm.html#_7-jmm-的应用-双重检查实现单例" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="7. JMM 的应用（双重检查实现单例）"><!---->7. JMM 的应用（双重检查实现单例）<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">JVM</span><span class="arrow right"></span></button><!--[--><!--[--><!----><!--]--><!----><!--]--></section><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->Java 内存模型（JMM）</h1><div class="article-info"><span class="author-info" arialabel="作者🖊" isoriginal="false" pageview="false" color="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewbox="0 0 1024 1024" arialabelledby="author"><title id="author" lang="en">author icon</title><g fill="currentColor"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></g></svg><span><a class="author-item" href="https://zengkaiqiang562.github.io/" target="_blank" rel="noopener noreferrer">Zenk562</a></span><span property="author" content="Zenk562"></span></span><span class="category-info" arialabel="分类🌈" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewbox="0 0 1024 1024" arialabelledby="category"><title id="category" lang="en">category icon</title><g fill="currentColor"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></g></svg><ul class="categories-wrapper"><li class="category clickable" role="navigation">java</li><meta property="articleSection" content="java"></ul></span><span arialabel="标签🏷" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon tag-icon" viewbox="0 0 1024 1024" arialabelledby="tag"><title id="tag" lang="en">tag icon</title><g fill="currentColor"><path d="M939.902 458.563L910.17 144.567c-1.507-16.272-14.465-29.13-30.737-30.737L565.438 84.098h-.402c-3.215 0-5.726 1.005-7.634 2.913l-470.39 470.39a10.004 10.004 0 000 14.164l365.423 365.424c1.909 1.908 4.42 2.913 7.132 2.913s5.223-1.005 7.132-2.913l470.39-470.39c2.01-2.11 3.014-5.023 2.813-8.036zm-240.067-72.121c-35.458 0-64.286-28.828-64.286-64.286s28.828-64.285 64.286-64.285 64.286 28.828 64.286 64.285-28.829 64.286-64.286 64.286z"></path></g></svg><ul class="tags-wrapper"><li class="tag clickable" role="navigation">java</li></ul><meta property="keywords" content="java"></span><span class="date-info" arialabel="写作日期📅" isoriginal="false" pageview="false" color="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewbox="0 0 1024 1024" arialabelledby="calendar"><title id="calendar" lang="en">calendar icon</title><g fill="currentColor"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></g></svg><span>2022年7月7日</span><meta property="datePublished" content="2022-07-07T15:59:00.000Z"></span><!----><span class="words-info" arialabel="字数🔠" isoriginal="false" pageview="false" color="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon word-icon" viewbox="0 0 1024 1024" arialabelledby="word"><title id="word" lang="en">word icon</title><g fill="currentColor"><path d="M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z"></path><path d="M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z"></path></g></svg><span>约 6077 字</span><meta property="wordCount" content="6077"></span></div><hr></div><div class="toc-place-holder"><aside id="toc-list"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#_1-从-java-代码到-cpu-指令" class="router-link-active router-link-exact-active toc-link level2">1. 从 Java 代码到 CPU 指令</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#_2-jvm-内存结构-java-内存模型-java-对象模型" class="router-link-active router-link-exact-active toc-link level2">2. JVM 内存结构 &amp; Java 内存模型 &amp; Java 对象模型</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#_2-1-jvm-内存结构" class="router-link-active router-link-exact-active toc-link level3">2.1 JVM 内存结构</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#_2-2-java-对象模型" class="router-link-active router-link-exact-active toc-link level3">2.2 Java 对象模型</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#_3-java-内存模型-jmm" class="router-link-active router-link-exact-active toc-link level2">3. Java 内存模型（JMM）</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#_3-1-为什么需要-jmm" class="router-link-active router-link-exact-active toc-link level3">3.1 为什么需要 JMM</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#_3-2-jmm-是一种规范" class="router-link-active router-link-exact-active toc-link level3">3.2 JMM 是一种规范</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#_3-3-jmm-是工具类和关键字的原理" class="router-link-active router-link-exact-active toc-link level3">3.3 JMM 是工具类和关键字的原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#_3-4-jmm-的三个重要内容-重排序、可见性、原子性" class="router-link-active router-link-exact-active toc-link level3">3.4 JMM 的三个重要内容（重排序、可见性、原子性）</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#_4-重排序" class="router-link-active router-link-exact-active toc-link level2">4. 重排序</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#_4-1-什么是重排序" class="router-link-active router-link-exact-active toc-link level3">4.1 什么是重排序</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#_4-2-重排序的好处-提高处理速度" class="router-link-active router-link-exact-active toc-link level3">4.2 重排序的好处（提高处理速度）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#_4-3-重排序的-3-种情况" class="router-link-active router-link-exact-active toc-link level3">4.3 重排序的 3 种情况</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#_5-可见性" class="router-link-active router-link-exact-active toc-link level2">5. 可见性</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#_5-1-什么是可见性问题" class="router-link-active router-link-exact-active toc-link level3">5.1 什么是可见性问题</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#用-volatile-解决可见性问题" class="router-link-active router-link-exact-active toc-link level4">用 volatile 解决可见性问题</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#_5-2-为什么会有可见性问题" class="router-link-active router-link-exact-active toc-link level3">5.2 为什么会有可见性问题</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#_5-3-jmm-的抽象-主内存-本地内存" class="router-link-active router-link-exact-active toc-link level3">5.3 JMM 的抽象：主内存&amp;本地内存</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#_5-3-1-什么是主内存和本地内存" class="router-link-active router-link-exact-active toc-link level4">5.3.1 什么是主内存和本地内存</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#_5-3-2-主内存和本地内存的关系-导致可见性问题" class="router-link-active router-link-exact-active toc-link level4">5.3.2 主内存和本地内存的关系（导致可见性问题）</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#_5-4-happens-before-规则-保证可见性的规则" class="router-link-active router-link-exact-active toc-link level3">5.4 Happens-Before 规则（保证可见性的规则）</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#_5-4-1-单线程规则" class="router-link-active router-link-exact-active toc-link level4">5.4.1 单线程规则</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#_5-4-2-锁操作-synchronized-和-lock" class="router-link-active router-link-exact-active toc-link level4">5.4.2 锁操作（synchronized 和 Lock）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#_5-4-3-volatile-变量" class="router-link-active router-link-exact-active toc-link level4">5.4.3 volatile 变量</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#_5-4-4-线程启动" class="router-link-active router-link-exact-active toc-link level4">5.4.4 线程启动</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#_5-4-5-线程-join" class="router-link-active router-link-exact-active toc-link level4">5.4.5 线程 join</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#_5-4-6-传递性" class="router-link-active router-link-exact-active toc-link level4">5.4.6 传递性</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#_5-4-7-中断" class="router-link-active router-link-exact-active toc-link level4">5.4.7 中断</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#_5-4-8-构造方法" class="router-link-active router-link-exact-active toc-link level4">5.4.8 构造方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#_5-4-9-工具类的-happens-before-规则" class="router-link-active router-link-exact-active toc-link level4">5.4.9 工具类的 Happens-Before 规则</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#_5-4-10-happens-before-演示案例" class="router-link-active router-link-exact-active toc-link level4">5.4.10 happens-before 演示案例</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#volatile-实现轻量级同步-近朱者赤" class="router-link-active router-link-exact-active toc-link level5">volatile 实现轻量级同步（近朱者赤）</a></li><!----><!--]--></ul><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#_5-5-volatile-关键字" class="router-link-active router-link-exact-active toc-link level3">5.5 volatile 关键字</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#_5-5-1-volatile-是什么" class="router-link-active router-link-exact-active toc-link level4">5.5.1 volatile 是什么</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#_5-5-2-volatile-的适用场合" class="router-link-active router-link-exact-active toc-link level4">5.5.2 volatile 的适用场合</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#_5-5-3-volatile-的作用-避免可见性问题、禁止重排序" class="router-link-active router-link-exact-active toc-link level4">5.5.3 volatile 的作用（避免可见性问题、禁止重排序）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#_5-5-4-volatile-和-synchronized-的关系" class="router-link-active router-link-exact-active toc-link level4">5.5.4 volatile 和 synchronized 的关系</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#_5-5-5-用-volatile-修正重排序问题" class="router-link-active router-link-exact-active toc-link level4">5.5.5 用  volatile 修正重排序问题</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#_5-5-6-volatile-补充" class="router-link-active router-link-exact-active toc-link level4">5.5.6 volatile 补充</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#_5-6-能保证可见性的措施" class="router-link-active router-link-exact-active toc-link level3">5.6 能保证可见性的措施</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#_5-7-对-synchronized-可见性的正确理解" class="router-link-active router-link-exact-active toc-link level3">5.7 对 synchronized 可见性的正确理解</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#_6-原子性" class="router-link-active router-link-exact-active toc-link level2">6. 原子性</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#_6-1-什么是原子性" class="router-link-active router-link-exact-active toc-link level3">6.1 什么是原子性</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#_6-2-java-中的原子操作有哪些" class="router-link-active router-link-exact-active toc-link level3">6.2 Java 中的原子操作有哪些</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#_6-3-long-和-double-的原子性" class="router-link-active router-link-exact-active toc-link level3">6.3 long 和 double 的原子性</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#_6-4-原子操作-原子操作-原子操作" class="router-link-active router-link-exact-active toc-link level3">6.4 原子操作 + 原子操作 != 原子操作</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jmm.html#_7-jmm-的应用-双重检查实现单例" class="router-link-active router-link-exact-active toc-link level2">7. JMM 的应用（双重检查实现单例）</a></li><!----><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><!--[--><h2 id="_1-从-java-代码到-cpu-指令" tabindex="-1"><a class="header-anchor" href="#_1-从-java-代码到-cpu-指令" aria-hidden="true">#</a> 1. 从 <code>Java</code> 代码到 <code>CPU</code> 指令</h2><p><img src="/assets/01.049823d4.png" alt="" loading="lazy"></p><p>如上图：</p><ol><li>最开始，我们编写的 <code>Java</code> 代码是 <code>*.java</code> 文件；</li><li>在编译（<code>javac</code> 命令）后，从刚才的 <code>*.java</code> 文件生成一个新的 <code>Java</code> 字节码文件（<code>*.class</code>）；</li><li><code>JVM</code> 会执行刚才生成的字节码文件（<code>*.class</code>），并把字节码文件转换成机器指令；</li><li>机器指令可以直接在 <code>CPU</code> 上运行，也就是最终的程序执行。</li></ol><h2 id="_2-jvm-内存结构-java-内存模型-java-对象模型" tabindex="-1"><a class="header-anchor" href="#_2-jvm-内存结构-java-内存模型-java-对象模型" aria-hidden="true">#</a> 2. <code>JVM</code> 内存结构 &amp; <code>Java</code> 内存模型 &amp; <code>Java</code> 对象模型</h2><p>这是三个截然不同的概念，其中：</p><ol><li><code>JVM</code> 内存结构，和 <code>Java</code> 虚拟机的运行时区域有关。</li><li><code>Java</code> 内存模型，和 <code>Java</code> 的并发编程有关。</li><li><code>Java</code> 对象模型，和 <code>Java</code> 对象在虚拟机中的表现形式有关。</li></ol><h3 id="_2-1-jvm-内存结构" tabindex="-1"><a class="header-anchor" href="#_2-1-jvm-内存结构" aria-hidden="true">#</a> 2.1 <code>JVM</code> 内存结构</h3><p><img src="/assets/02.14bd0e14.png" alt="" loading="lazy"></p><p>如上图，<code>JVM</code> 内存结构包括：</p><ol><li>堆（<code>heap</code>）</li><li>虚拟机栈（<code>VM stack</code>），即图中的 <code>Java</code> 栈</li><li>方法区（<code>method</code>）</li><li>本地方法栈</li><li>程序计数器</li></ol><h3 id="_2-2-java-对象模型" tabindex="-1"><a class="header-anchor" href="#_2-2-java-对象模型" aria-hidden="true">#</a> 2.2 <code>Java</code> 对象模型</h3><p><code>Java</code> 对象模型就是 <code>Java</code> 对象自身的存储模型。</p><p><code>JVM</code> 会给一个类创建一个 <code>instanceKlass</code>，保存在方法区，用来在 <code>JVM</code> 层表示该 <code>Java</code> 类。</p><p>当我们在 <code>Java</code> 代码中使用 <code>new</code> 创建一个对象时，<code>JVM</code> 会创建一个 <code>instanceOopDesc</code> 对象，这个对象中包含了对象头以及实例数据。</p><p><img src="/assets/03.27117c2c.png" alt="" loading="lazy"></p><blockquote><p>参考 《内存分配》 中的 <a href="/zkq/java/jvm/memory-allocate.html#_2-3-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80-%E5%AF%B9%E8%B1%A1%E5%A4%B4%E3%80%81%E5%AE%9E%E4%BE%8B%E6%95%B0%E6%8D%AE%E3%80%81%E5%AF%B9%E9%BD%90%E5%A1%AB%E5%85%85" class="">对象的内存布局</a></p><p>参考 《内存分配》 中的 <a href="/zkq/java/jvm/memory-allocate.html#_2-4-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F-%E4%BD%BF%E7%94%A8%E5%8F%A5%E6%9F%84%E3%80%81%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88" class="">对象的访问方式</a></p></blockquote><h2 id="_3-java-内存模型-jmm" tabindex="-1"><a class="header-anchor" href="#_3-java-内存模型-jmm" aria-hidden="true">#</a> 3. <code>Java</code> 内存模型（<code>JMM</code>）</h2><p><code>JMM</code> 即 <code>Java Memory Model</code></p><h3 id="_3-1-为什么需要-jmm" tabindex="-1"><a class="header-anchor" href="#_3-1-为什么需要-jmm" aria-hidden="true">#</a> 3.1 为什么需要 <code>JMM</code></h3><p><code>C</code> 语言不存在内存模型的概念，因此：</p><ol><li><code>C</code> 语言依赖处理器，不同处理器结果不一样</li><li><code>C</code> 语言无法保证并发安全</li></ol><p><code>Java</code> 程序设计中，需要一个标准，让多线程运行的结果可预期。</p><h3 id="_3-2-jmm-是一种规范" tabindex="-1"><a class="header-anchor" href="#_3-2-jmm-是一种规范" aria-hidden="true">#</a> 3.2 <code>JMM</code> 是一种规范</h3><p><code>JMM</code> 是一组规范，需要各个 <code>JVM</code> 的实现来遵循 <code>JMM</code> 规范，以便于开发者可以利用这些规范，更方便地开发多线程程序。</p><p>如果没有这样的一个 <code>JMM</code> 内存模型来规范，那么很可能经过了不同 <code>JVM</code> 的不同规则的重排序之后，导致不同的虚拟机上运行的结果不一样，那是很大的问题。</p><h3 id="_3-3-jmm-是工具类和关键字的原理" tabindex="-1"><a class="header-anchor" href="#_3-3-jmm-是工具类和关键字的原理" aria-hidden="true">#</a> 3.3 <code>JMM</code> 是工具类和关键字的原理</h3><p><code>volatile</code>、<code>synchronized</code>、<code>Lock</code> 等的原理都是 <code>JMM</code>。</p><p>如果没有 <code>JMM</code>，那就需要我们自己指定什么时候用内存栅栏等，那是相当麻烦的。幸好有了 <code>JMM</code>，让我们只需要用同步工具和关键字就可以开发并发程序。</p><h3 id="_3-4-jmm-的三个重要内容-重排序、可见性、原子性" tabindex="-1"><a class="header-anchor" href="#_3-4-jmm-的三个重要内容-重排序、可见性、原子性" aria-hidden="true">#</a> 3.4 <code>JMM</code> 的三个重要内容（重排序、可见性、原子性）</h3><p><code>JMM</code> 的三个重要内容是：</p><ol><li>重排序</li><li>可见性</li><li>原子性</li></ol><h2 id="_4-重排序" tabindex="-1"><a class="header-anchor" href="#_4-重排序" aria-hidden="true">#</a> 4. 重排序</h2><h3 id="_4-1-什么是重排序" tabindex="-1"><a class="header-anchor" href="#_4-1-什么是重排序" aria-hidden="true">#</a> 4.1 什么是重排序</h3><p><img src="/assets/04.07ab0157.png" alt="" loading="lazy"></p><p><img src="/assets/05.1a3dcf60.png" alt="" loading="lazy"></p><p>如上代码中，演示了重排序的现象，分析如下：</p><div class="language-text ext-text"><pre class="language-text"><code>不考虑重排序，x 和 y 的执行结果只有三种情况：
1. 线程 one 中的 a=1; x=b 先执行完毕，再执行线程 two 中的 b=1; y=a
    此时，由于线程 one 中给 x 赋值的时候线程 two 中还未给 b 赋值，所以 x=0, y=1
2. 线程 two 中的 b=1; y=a 先执行完毕，再执行线程 one 中的 a=1; x=b
    此时，由于线程 two 中给 y 赋值的时候线程 one 中还未给 a 赋值，所以 x=1, y=0
3. 线程 one 中的 a=1 先执行，再执行线程 two 中的 b=1，接着再执行线程 one 中的 x=b，最后再执行线程 two 中的 y=a，此时，x=1, y=1

也就是说，不考虑重排序的情况，是不会出现 x=0, y=0 的情况的。
但是，执行程序，可以发现，经过若干次的 for 循环后，会出现 x=0, y=0 的情况，
这是因为线程 one 或/和 线程 two 发生了重排序。考虑如下 2 个线程都发送重排序的情况：
1. 线程 one 中的 a=1; x=b 重排序后的执行顺序变成了 x=b; a=1
2. 线程 two 中的 b=1; y=a 重排序后的执行顺序变成了 y=a; b=1
于是，当线程 one 中的 x=b 先执行，再执行线程 two 中的 y=a 时，就会出现 x=0, y=0 的情况。
（当然，线程 one 或线程 two 中的仅仅某一个线程发生重排序，也可能会出现 x=0, y=0 的情况）
</code></pre></div><p>分析完上面的代码后，我们可以对重排序进行如下定义：</p><div class="language-text ext-text"><pre class="language-text"><code>什么是重排序？
    在线程 1 内部的两行代码的实际执行顺序和代码在 Java 文件中的顺序不一样，代码指令并不是严格按照代码语句顺序执行的，
    它们的顺序被改变了，这就是重排序。
    如上代码中，被颠倒的可能是 y=a 和 b=1 这两行语句。
</code></pre></div><h3 id="_4-2-重排序的好处-提高处理速度" tabindex="-1"><a class="header-anchor" href="#_4-2-重排序的好处-提高处理速度" aria-hidden="true">#</a> 4.2 重排序的好处（提高处理速度）</h3><p><img src="/assets/06.23118a5c.png" alt="" loading="lazy"></p><p>如上图所示，对比重排序前后的指令优化，重排序明显提高了处理速度。</p><h3 id="_4-3-重排序的-3-种情况" tabindex="-1"><a class="header-anchor" href="#_4-3-重排序的-3-种情况" aria-hidden="true">#</a> 4.3 重排序的 <code>3</code> 种情况</h3><p>如下三种情况下，都可以发生重排序：</p><ol><li>编译器优化：包括 <code>JVM</code>，<code>JIT</code> 编译器等</li><li><code>CPU</code> 指令重排：就算编译器不发生重排，<code>CPU</code> 也可能对指令进行重排</li><li>内存的 “重排序”：线程 <code>A</code> 的修改线程 <code>B</code> 却看不到，从而引出 <strong>可见性问题</strong></li></ol><h2 id="_5-可见性" tabindex="-1"><a class="header-anchor" href="#_5-可见性" aria-hidden="true">#</a> 5. 可见性</h2><h3 id="_5-1-什么是可见性问题" tabindex="-1"><a class="header-anchor" href="#_5-1-什么是可见性问题" aria-hidden="true">#</a> 5.1 什么是可见性问题</h3><p><img src="/assets/07.059357b9.png" alt="" loading="lazy"></p><p>如上代码所示，分析如下三种情况：</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHIAAABICAYAAAAqPKG2AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAOmSURBVHhe7Z0/juIwFIdf9i5E03CA5AagLaaZerqkhp6KPqlJt/UKtMUq3AAOMA2CvUvWDg6QGC8kaxze432SNQ4o//hiv0B+0niFABj0fFN/GeRcFblarVSPwQKPSCKwSCKwSCKwSCKwSCKwSCJYFHmANPQgXqtFxilPNiLXEHseeKqF6UG97pLjBel5sTgaPDyVyHU8BsgLkL8aFvsEYPoJTl2uYyHwE+AjUi/g4QEiqytatrCViNGigMVILQy+w0ewhZ+/mxtQ2w9T0dNZx9W+ZWszqsR25/I62sDkTb2ECOsis7EPu5kaVfkQpn7XKeoP7LYAw7eBWr7NIQ3h17vat2h5lMHYIFxnAJPNAqrrCB3ihDWWy6XqtWFfJAEUUa4WS/IigqBI9lUf5JOWegsSsaZOHpnfu5s8uthGi/3L9SASa+DBYY0cwUKNlFrbTMRYqCNH1jgLIPmhv/dPDimEp2lVtHGm3pDcv3+MOBRZvyM9tcbUJyX6U4BkL2pVO4uQfpYrniWJYX3mvv1j5aEi5V1oFs2UkDtGhLhrvC3R9PWgWVOFuBcakfJkNP6nRspNnlq9YN7AUMOu1Kqyfor3tM2Xta1aT9TmPCmCFnW22m694aiVFkW6Y58EaD5gVziskRZQNzP+dCi+7yH+qvAAcIkcTGBTziIssQkukYwRFkkEFkkEFkkEFkkEFkkEFkkEFkkEiyKPP2Zz+KofnmxE9hu+qsdE+gp/deOpRPYdvpKZoXLfZcthOPXRzDAPEFk9L5QNU/iqyQjeI4CvHY5RaV0k3vBVg0MK8yyCWbuYQn+IE9Z45fDV5cPl4HjgKHBYI3GEry7r5Gzng4ekSDoUiS98NToWyW5Ts2vECWvYmlrLaapNbqfM3FRTsYkqG9SMehynzvPu1FTaeXpW+2lz/D1iXaS8Nk6t1YdgqGHOwlf68WOqkRZFuoPDVzpP9YPATTh8ZQSXSA5fGcElkjHCIonAIonAIonAIonAIolgUSRHPfrkisj+TPQdtSAV9Yi9ueq5p++oBamoRwZb1etK96hHHVPUgqMe19Cn1iBRnW5Yi3p0iFpw1OMC+Sipz6iH1ajFK0c9FjKG+BAcRC046nHBYKI6tnl01IKjHhq9RT1qmKIW1ZN8jnpcYl2kvDZOrdWHoK9vqlEc9dCxKNIdHPXQ0WvkM8NRDyO4RHLUwwgukYwRFkkE/v+RROARSQQWSQQWSQQWSQQWSQQWSQQWSQKAv/gu9ljrrpaeAAAAAElFTkSuQmCC" alt="" loading="lazy"></p><div class="language-text ext-text"><pre class="language-text"><code>1. 当读线程 readThread 先全部执行完毕时，就会打印 b=2; a=1
2. 当写线程 writeThread 先全部执行完毕后，再执行读线程 readThread，就会打印 b=3; a=3
3. 当写线程 writeThread 先执行到 a=3，然后切换到读线程 readThread 执行，此时，读线程 readThread 就会打印 b=2; a=3
</code></pre></div><p><strong>特别地，当出现可见性问题时，就会出现 <code>b=3; a=1</code> 的情况：</strong></p><p><img src="data:image/png;base64,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" alt="" loading="lazy"></p><div class="language-text ext-text"><pre class="language-text"><code>什么是可见性问题？
    如上输出结果，就是写线程 writeThread 中虽然已经执行了 a=3; b=a，
    但是，读线程 readThread 中却无法发现变量 a, b 中的值被修改了，或者只发现其中某个变量的值被修改了。

为什么会发生可见性问题？
    之所以出现可见性问题，是由于主内存和工作内存（也称本地内存）的存在引起的。
    主内存是多线程共享的，工作内存是线程私有的。
    多线程访问的共享变量可以认为是保存在主内存中的，
    但是线程中操作的共享变量，却不是主内存中的共享变量，而是主内存的共享变量的副本拷贝。
    即线程会把共享变量拷贝到自己的工作内存中，操作结束后，再把修改了的共享变量返回给主内存。
    于是，就会出现这样一个问题：
    当写线程 writeThread 修改了工作内存中的变量 a 和 b，且把变量 b 返回给了主内存（还没有将变量 a 返回给主内存），
    此时，切换到读线程 readThread，于是，读线程 readThread 从主内存中访问到的变量 b=3，但变量 a 仍然是 1
</code></pre></div><h4 id="用-volatile-解决可见性问题" tabindex="-1"><a class="header-anchor" href="#用-volatile-解决可见性问题" aria-hidden="true">#</a> 用 <code>volatile</code> 解决可见性问题</h4><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FieldVisibility</span> <span class="token punctuation">{</span>
    <span class="token comment">// int x = 0; // 未使用 volatile 时</span>
    <span class="token keyword">volatile</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">writeThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 假设在写线程中执行</span>
        x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">readThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 假设在读线程中执行</span>
        <span class="token keyword">int</span> r2 <span class="token operator">=</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p><strong>未使用 <code>volatile</code> 时</strong></p><p><img src="/assets/10.e0b10d57.png" alt="" loading="lazy"></p><p><strong>使用 <code>volatile</code> 时</strong></p><p><img src="/assets/11.0f95699c.png" alt="" loading="lazy"></p><h3 id="_5-2-为什么会有可见性问题" tabindex="-1"><a class="header-anchor" href="#_5-2-为什么会有可见性问题" aria-hidden="true">#</a> 5.2 为什么会有可见性问题</h3><p><img src="/assets/12.9736fcb6.png" alt="" loading="lazy"></p><p>出现可见性问题的根本原因就是 <strong><code>CPU</code> 有多级缓存，导致读的数据过期</strong>，具体为：</p><ol><li>高速缓存的容量比主内存小，但是速度仅次于寄存器，所以在 <code>CPU</code> 和主内存之间就多了 <code>Cache</code> 层。</li><li>线程间的对于共享变量的可见性问题不是直接由多核引起的，而是<strong>由多缓存引起的</strong>。</li><li>如果所有的核心都只用一个缓存，那么也就不存在内存可见性问题了。</li><li>每个核心都会将自己需要的数据读到独占缓存中，数据修改后也是写入到缓存中，然后等待刷入到主内存中。所以会导致有些核心读取的值是一个过期的值。</li></ol><h3 id="_5-3-jmm-的抽象-主内存-本地内存" tabindex="-1"><a class="header-anchor" href="#_5-3-jmm-的抽象-主内存-本地内存" aria-hidden="true">#</a> 5.3 <code>JMM</code> 的抽象：主内存&amp;本地内存</h3><h4 id="_5-3-1-什么是主内存和本地内存" tabindex="-1"><a class="header-anchor" href="#_5-3-1-什么是主内存和本地内存" aria-hidden="true">#</a> 5.3.1 什么是主内存和本地内存</h4><p><img src="/assets/13.7ee2add9.png" alt="" loading="lazy"></p><p>如上如的底层细节中：</p><div class="language-text ext-text"><pre class="language-text"><code>core1，core2，core3，core4 看成是一个个的线程（即将核心理解为线程）
registers，L1 cache，L2 cache 看成是工作内存
L3 cache，RAM 看成是主内存
</code></pre></div><p><code>Java</code> 作为高级语言，屏蔽了这些底层细节，用 <code>JMM</code> 定义了一套读写内存数据的规范。虽然我们不再需要关系一级缓存和二级缓存的问题，但是，<code>JMM</code> 抽象了主内存和本地内存的概念。</p><p>这里说的本地内存并不是真的是一块给每个线程分配的内存，而是 <code>JMM</code> 的一个抽象，是对于寄存器、一级缓存、二级缓存等的抽象。</p><p><img src="/assets/14.b8b67d35.png" alt="" loading="lazy"></p><h4 id="_5-3-2-主内存和本地内存的关系-导致可见性问题" tabindex="-1"><a class="header-anchor" href="#_5-3-2-主内存和本地内存的关系-导致可见性问题" aria-hidden="true">#</a> 5.3.2 主内存和本地内存的关系（导致可见性问题）</h4><p><code>JMM</code> 有以下规定：</p><ol><li>所有的变量都存储在主内存中，同时每个线程也有自己独立的工作内存，工作内存中的变量内容是主内存中的拷贝；</li><li>线程不能直接读写主内存中的变量，而是只能操作自己工作内存中的变量 ，然后再同步到主内存中；</li><li>主内存是多个线程共享的，但线程间不共享工作内存，如果线程间需要通信，必须借助主内存中转来完成。</li></ol><p>于是，由于所有的共享变量存在于主内存中，每个线程有自己的本地内存，且线程读写共享数据也是通过本地内存交互的，所以就导致了可见性问题。</p><h3 id="_5-4-happens-before-规则-保证可见性的规则" tabindex="-1"><a class="header-anchor" href="#_5-4-happens-before-规则-保证可见性的规则" aria-hidden="true">#</a> 5.4 <code>Happens-Before</code> 规则（保证可见性的规则）</h3><p><code>Happens-Before</code> 规则就是保证可见性的规则。</p><blockquote><p>即：如果 <code>A happens before B</code>（可记为 <code>hb(A, B)</code>），那么 <code>A</code> 对主内存中变量的修改，对 <code>B</code> 都可见。</p></blockquote><p><code>Happens-Before</code> 规则包括：</p><ol><li>单线程规则</li><li>锁操作（<code>synchronized</code> 和 <code>Lock</code>）</li><li><code>volatile</code> 变量</li><li>线程启动</li><li>线程 <code>join</code></li><li>传递性</li><li>中断</li><li>构造方法</li><li>工具类的 <code>Happens-Before</code> 规则</li></ol><h4 id="_5-4-1-单线程规则" tabindex="-1"><a class="header-anchor" href="#_5-4-1-单线程规则" aria-hidden="true">#</a> 5.4.1 单线程规则</h4><div class="language-text ext-text"><pre class="language-text"><code>单线程规则指明：在同一个线程中，前面语句的执行结果对后面的语句都可见。
即使发生重排序，单线程规则也不会改变。
</code></pre></div><p><img src="/assets/15.6180b717.png" alt="" loading="lazy"></p><p><img src="/assets/16.b8388534.png" alt="" loading="lazy"></p><h4 id="_5-4-2-锁操作-synchronized-和-lock" tabindex="-1"><a class="header-anchor" href="#_5-4-2-锁操作-synchronized-和-lock" aria-hidden="true">#</a> 5.4.2 锁操作（<code>synchronized</code> 和 <code>Lock</code>）</h4><p><img src="/assets/17.dc0f5a33.png" alt="" loading="lazy"></p><p>如上图：</p><div class="language-text ext-text"><pre class="language-text"><code>假设线程 A 先获取到锁 M，而线程 B 在等待锁 M。
那么当线程 A 解锁后，线程 B 获取到锁 M 且继续执行时，
线程 B 加锁后的操作中所访问主内存的变量 x 的值，肯定是线程 A 修改后的值。
即，此时线程 A 修改后的变量 x 的值对获取到锁后的线程 B 来说总是可见的。
</code></pre></div><h4 id="_5-4-3-volatile-变量" tabindex="-1"><a class="header-anchor" href="#_5-4-3-volatile-变量" aria-hidden="true">#</a> 5.4.3 <code>volatile</code> 变量</h4><div class="language-text ext-text"><pre class="language-text"><code>只要线程 A 中已经修改了主内存中的被 volatile 修饰的变量，
那么线程 B 中从主内存中拿到的这个被 volatile 修饰的变量的值就一定是被线程 A 修改后的值，不会出现可见性问题。
也就是说，一个线程中对 volatile 变量所做过的修改，在其他线程访问该 volatile 变量时，总是可见的，
不会由于主内存和工作内存之间的同步不及时而导致可见性问题。
</code></pre></div><p><img src="/assets/18.d68e2183.png" alt="" loading="lazy"></p><h4 id="_5-4-4-线程启动" tabindex="-1"><a class="header-anchor" href="#_5-4-4-线程启动" aria-hidden="true">#</a> 5.4.4 线程启动</h4><div class="language-text ext-text"><pre class="language-text"><code>在线程 A 中启动线程 B 时，在线程 A 中调用线程 B 的 start() 方法之前的所有修改，在线程 B 运行时都是可见的。
</code></pre></div><p><img src="/assets/19.98887597.png" alt="" loading="lazy"></p><h4 id="_5-4-5-线程-join" tabindex="-1"><a class="header-anchor" href="#_5-4-5-线程-join" aria-hidden="true">#</a> 5.4.5 线程 <code>join</code></h4><div class="language-text ext-text"><pre class="language-text"><code>在 Thread A 中执行 threadB.join(); 会保证 Thread B 先执行完毕后，再继续执行 Thread A,
之后，在 Thread A 中执行 statement 1; 时，Thread B 中对主内存中变量的修改，在 Thread A 中都是可见的。
</code></pre></div><p><img src="/assets/20.1daefac4.png" alt="" loading="lazy"></p><h4 id="_5-4-6-传递性" tabindex="-1"><a class="header-anchor" href="#_5-4-6-传递性" aria-hidden="true">#</a> 5.4.6 传递性</h4><p>如果 <code>hb(A, B)</code> 而且 <code>hb(B, C)</code>，那么可以推出 <code>hb(A, C)</code>。</p><div class="language-text ext-text"><pre class="language-text"><code>hb 表示 happens before，
hb(A, B) 表示 A happens before B，即 A 对主内存中变量的修改，对 B 都是可见的。

传递性就是指：
    如果 A 对主内存中变量的修改对 B 都可见，且 B 对主内存中变量的修改对 C 都可见，
    那么 A 对主内存中变量的修改对 C 都可见。
    即：如果 hb(A, B) 且 hb(B, C)，那么 hb(A, C)。
</code></pre></div><h4 id="_5-4-7-中断" tabindex="-1"><a class="header-anchor" href="#_5-4-7-中断" aria-hidden="true">#</a> 5.4.7 中断</h4><div class="language-text ext-text"><pre class="language-text"><code>一个线程被其他线程 interrupt 时，那么检测中断（isInterrupted）或者抛出 InterruptedException 一定能看到。
</code></pre></div><h4 id="_5-4-8-构造方法" tabindex="-1"><a class="header-anchor" href="#_5-4-8-构造方法" aria-hidden="true">#</a> 5.4.8 构造方法</h4><div class="language-text ext-text"><pre class="language-text"><code>对象构造方法的最后一行指令 happens-before 于 finalize() 方法的第一行指令。
</code></pre></div><h4 id="_5-4-9-工具类的-happens-before-规则" tabindex="-1"><a class="header-anchor" href="#_5-4-9-工具类的-happens-before-规则" aria-hidden="true">#</a> 5.4.9 工具类的 <code>Happens-Before</code> 规则</h4><p>包括：</p><ol><li>线程安全的容器 <code>get</code> 一定能看到在此之前的 <code>put</code> 等存入动作</li><li><code>CountDownLatch</code></li><li><code>Semaphore</code></li><li><code>Future</code></li><li>线程池</li><li><code>CyclicBarrier</code></li></ol><h4 id="_5-4-10-happens-before-演示案例" tabindex="-1"><a class="header-anchor" href="#_5-4-10-happens-before-演示案例" aria-hidden="true">#</a> 5.4.10 <code>happens-before</code> 演示案例</h4><p><img src="/assets/21.b31c4ddc.png" alt="" loading="lazy"></p><p>以上代码中，会出现如下几种情况：</p><div class="language-text ext-text"><pre class="language-text"><code>1. a=3, b=2
2. a=1, b=2
3. a=3, b=3

特别地，当没有给 b 加 volatile 时，还有可能出现第 4 种情况：
4. a=1, b=3

这是因为 a 虽然被修改来了，但是其他线程不可见 ，而 b 恰好其他线程可见，从而造成 a=1, b=3。
</code></pre></div><p>以上案例中使用了 <code>happens-before</code> 规则中的 <code>volatile</code> 变量规则避免了由于可见性问题而导致的 <code>a=1, b=3</code> 的结果:</p><div class="language-text ext-text"><pre class="language-text"><code>volatile 变量规则：
    如果 A 是对 volatile 变量的写操作，B 是对同一个变量的读操作，那么 hb(A, B)。
</code></pre></div><h5 id="volatile-实现轻量级同步-近朱者赤" tabindex="-1"><a class="header-anchor" href="#volatile-实现轻量级同步-近朱者赤" aria-hidden="true">#</a> <code>volatile</code> 实现轻量级同步（近朱者赤）</h5><p>如上演示案例中，给 <code>b</code> 加了 <code>volatile</code>，不仅 <code>b</code> 被影响了，也可以实现轻量级同步，即：</p><div class="language-text ext-text"><pre class="language-text"><code>b 之前的写入（即 b=a 之前的 a=3）对读取 b 后的代码（即 print b 后的 print a）都可见，
所以在 writeThread 里对 a 的赋值，一定会对 readThread 里的读取可见，所以这里的 a 即使不加 volatile，
只要 b 读到的是 3，就可以由 happens-before 规则保证读取到的都是 3，而不可能读取到 1。
</code></pre></div><blockquote><p>可以理解成 <code>happens-before</code> 规则中的传递性规则。</p></blockquote><h3 id="_5-5-volatile-关键字" tabindex="-1"><a class="header-anchor" href="#_5-5-volatile-关键字" aria-hidden="true">#</a> 5.5 <code>volatile</code> 关键字</h3><h4 id="_5-5-1-volatile-是什么" tabindex="-1"><a class="header-anchor" href="#_5-5-1-volatile-是什么" aria-hidden="true">#</a> 5.5.1 <code>volatile</code> 是什么</h4><p><code>volatile</code> 是一种同步机制，比 <code>synchronized</code> 或者 <code>Lock</code> 相关类更轻量，因为使用 <code>volatile</code> 并不会发生上下文切换等开销很大的行为。</p><p>如果一个变量被修饰成 <code>volatile</code>，那么 <code>JVM</code> 就知道了这个变量可能会被并发修改。</p><p><code>volatile</code> 的开销小也就意味着了相应的能力也小，虽然说 <code>volatile</code> 是用来同步的，保证线程安全的，但是 <code>volatile</code> 做不到 <code>synchronized</code> 那样的<strong>原子保护</strong>，<code>volatile</code> 仅在很有限的场景下才能发挥作用。</p><h4 id="_5-5-2-volatile-的适用场合" tabindex="-1"><a class="header-anchor" href="#_5-5-2-volatile-的适用场合" aria-hidden="true">#</a> 5.5.2 <code>volatile</code> 的适用场合</h4><p><code>volatile</code> 关键字就是让写线程中对被 <code>volatile</code> 修饰的变量所做的修改实时地刷新到主内存中，让读线程访问被 <code>volatile</code> 修饰的变量时，直接从主内存中读取。</p><p><code>volatile</code> 关键字可以<strong>保证原子操作的线程安全</strong>（即让原子操作的结果对其他线程可见）。但是无法保证非原子操作的线程安全（即无法避免组成非原子操作的各个原子操作之间的线程切换引起的线程安全问题）。</p><div class="language-text ext-text"><pre class="language-text"><code>如 a++ 是非原子操作，可分解为 tmp=a+1 和 a=tmp 两个原子操作。如果在这两个原子操作之间出现了线程切换，那么就会出现线程安全问题。
因此，当用 volatile 修饰变量 a 时，只能保证 a=tmp 赋值后实时地刷新到主内存，
但无法避免 tmp=a+1 和 a=tmp 这两个原子操作之间可能出现的线程切换所引起的线程安全问题。

再如 flag=true 是原子操作，如果 flag 被 volatile 修饰，那么可以保证 flag=true 这条原子操作语句是线程安全的。

又如 flag=!flag 不是原子操作，假设 flag=false，则 flag=!flag 可分解为 tmp=!flag 和 flag=tmp，
因此，即使 flag 被 volatile 修饰，也有可能因在 tmp=!flag 和 flag=tmp 之间出现线程切换引起线程安全问题。
</code></pre></div><p>综上：</p><ol><li><code>volatile</code> <strong>不适用于多线程下的非原子操作</strong>（如 <code>a++</code>，<code>flag=!flag</code>）。</li><li><code>volatile</code> <strong>可适用于多线程下的原子操作</strong>（如 <code>flag=true</code>）。</li></ol><p>另外，<code>volatile</code> 还可以作为刷新之前变量的触发器：</p><p><img src="/assets/22.1dc24cfb.png" alt="" loading="lazy"></p><p>如上代码所示：</p><div class="language-text ext-text"><pre class="language-text"><code>由 happens-before 的单线程规则可知，hb(123, 4)
由 happens-before 的 volatile 变量的规则可知，hb(4, 5)
于是，由 happens-before 的传递性规则可推出，hb(123, 5)

因此，如果在 Thread B 中读取变量 initialized 为 true 时，
就说明了在 Thread A 中的前三条语句中的初始化代码都执行完毕，初始化结果对 Thread B 可见了。
所以，这里就可以将被 volatile 修饰的 initialized 变量看成一个触发器，
即当 Thread B 中发现 initialized 的值为 true 时，表示 Thread A 中的初始化结果可见，
此时就可以结束 while 循环，触发 Thread B 中的 &quot;// use configOptions&quot; 之后的代码继续执行。
</code></pre></div><h4 id="_5-5-3-volatile-的作用-避免可见性问题、禁止重排序" tabindex="-1"><a class="header-anchor" href="#_5-5-3-volatile-的作用-避免可见性问题、禁止重排序" aria-hidden="true">#</a> 5.5.3 <code>volatile</code> 的作用（避免可见性问题、禁止重排序）</h4><p><code>volatile</code> 有两点作用：</p><ol><li><p>避免可见性问题</p><blockquote><p>读取一个 <code>volatile</code> 变量之前，需要先使相应的本地缓存失效 ，这样就必须到主内存读取最新值，写一个 <code>volatile</code> 属性会立即刷入到主内存。</p></blockquote></li><li><p>禁止指令重排序</p><blockquote><p><a href="/zkq/design-pattern/singleton-pattern.html#%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E3%80%90%E6%8E%A8%E8%8D%90%E7%94%A8%E3%80%91" class="">解决单例双重锁乱序问题</a></p></blockquote></li></ol><h4 id="_5-5-4-volatile-和-synchronized-的关系" tabindex="-1"><a class="header-anchor" href="#_5-5-4-volatile-和-synchronized-的关系" aria-hidden="true">#</a> 5.5.4 <code>volatile</code> 和 <code>synchronized</code> 的关系</h4><p><code>synchronized</code> 关键字不但能够保证可见性，还能够将一系列的非原子操作包裹成一个原子操作。</p><blockquote><p>即保证在这一系列的非原子操作之间不发生线程切换，从而避免线程切换引起的线程安全问题。</p></blockquote><p>而 <code>volatile</code> 关键字只能够保证可见性。</p><blockquote><p>即只能够避免因线程私有的工作内存和多线程共有的主内存之间的不及时同步，而导致其他线程访问主内存中的变量值不是被线程修改后的变量值，所引起的线程安全问题。</p></blockquote><p>简而言之：</p><ol><li><code>synchronized</code> 关键字既可以保证可见性，又可以保证原子性；</li><li><code>volatile</code> 关键字只能够保证可见性。</li></ol><p>如下情况中，<code>volatile</code> 可以看做是轻量版的 <code>synchronized</code>：</p><div class="language-text ext-text"><pre class="language-text"><code>如果一个共享变量自始至终只被各个线程赋值，而没有其他的操作，
那么就可以用 volatile 来代替 synchronized 或者代替原子变量。
因为赋值自身是具有原子性的，而 volatile 又保证了可见性，所以就足以保证线程安全。
</code></pre></div><h4 id="_5-5-5-用-volatile-修正重排序问题" tabindex="-1"><a class="header-anchor" href="#_5-5-5-用-volatile-修正重排序问题" aria-hidden="true">#</a> 5.5.5 用 <code>volatile</code> 修正重排序问题</h4><p><img src="/assets/23.a79b1905.png" alt="" loading="lazy"></p><p>相比于<a href="/zkq/project-experiences/project-list/others/java-jmm.html#_4-1-%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8D%E6%8E%92%E5%BA%8F" class="">未修正的代码</a>，这里将变量 <code>a,b,x,y</code> 都用 <code>volatile</code> 修饰了。</p><h4 id="_5-5-6-volatile-补充" tabindex="-1"><a class="header-anchor" href="#_5-5-6-volatile-补充" aria-hidden="true">#</a> 5.5.6 <code>volatile</code> 补充</h4><ol><li><p><code>volatile</code> 属性的读写操作都是<strong>无锁的</strong>，它不能代替 <code>synchronized</code>，因为它没有提供原子性和互斥性。因为无锁，不需要在获取锁和释放锁上花费时间，所以说它是低成本的。</p></li><li><p><code>volatile</code> 可以使得 <code>long</code> 和 <code>double</code> 的赋值是原子的（后面会详细介绍）。</p></li></ol><h3 id="_5-6-能保证可见性的措施" tabindex="-1"><a class="header-anchor" href="#_5-6-能保证可见性的措施" aria-hidden="true">#</a> 5.6 能保证可见性的措施</h3><p>除了 <code>volatile</code> 可以让变量保证可见性外，<code>synchronized</code>、<code>Lock</code>、并发集合、<code>Thread.join()</code> 和 <code>Thread.start()</code> 等都可以保证变量的可见性。</p><blockquote><p>具体看 <code>happens-before</code> 规则的规定。</p></blockquote><h3 id="_5-7-对-synchronized-可见性的正确理解" tabindex="-1"><a class="header-anchor" href="#_5-7-对-synchronized-可见性的正确理解" aria-hidden="true">#</a> 5.7 对 <code>synchronized</code> 可见性的正确理解</h3><ol><li><p><code>synchronized</code> 不仅保证了原子性，还保证了可见性。</p></li><li><p><code>synchronized</code> 不仅让被保护的代码安全，还近朱者赤，如下代码所示：</p><p><img src="/assets/24.1ff7292d.png" alt="" loading="lazy"></p></li></ol><h2 id="_6-原子性" tabindex="-1"><a class="header-anchor" href="#_6-原子性" aria-hidden="true">#</a> 6. 原子性</h2><h3 id="_6-1-什么是原子性" tabindex="-1"><a class="header-anchor" href="#_6-1-什么是原子性" aria-hidden="true">#</a> 6.1 什么是原子性</h3><p>不管是一条语句的操作，还是多条语句的操作，只要操作满足 “要么全部执行成功，要么全部不执行，不会出现只执行一半的情况” 的条件，那么就说这样的操作具体原子性。</p><blockquote><p>即：具备原子性的操作是一个不可分割的 “整体”。</p></blockquote><blockquote><p>现实中，如 “ATM里取钱” 这样的操作是具备原子性的；</p><p>代码中，用 <code>synchronized</code> 包裹的同步代码块组成的操作是具备原子性的</p></blockquote><blockquote><p>注意：<code>i++</code> 操作不具备原子性，该操作可分解为 tmp=a+1 和 a=tmp 两个操作。</p></blockquote><h3 id="_6-2-java-中的原子操作有哪些" tabindex="-1"><a class="header-anchor" href="#_6-2-java-中的原子操作有哪些" aria-hidden="true">#</a> 6.2 <code>Java</code> 中的原子操作有哪些</h3><p>原子操作可以理解为具备原子性的只包含一条语句的操作。</p><blockquote><p>如果想要包含多条语句的操作具备原子性，可以使用 <code>synchronized</code> 关键字。</p></blockquote><p><code>Java</code> 中的原子操作有：</p><ol><li><p>除 <code>long</code> 和 <code>double</code> 之外的基本类型（<code>int</code>、<code>byte</code>、<code>boolean</code>、<code>short</code>、<code>char</code>、<code>float</code>）的赋值操作；</p><blockquote><p>不能是复合赋值操作，且右操作数是变量或常量，不能是表达式或函数。</p></blockquote></li><li><p>所有引用 <code>reference</code> 的赋值操作，不管是 <code>32</code> 位的机器还是 <code>64</code> 位的机器。</p><blockquote><p>不能是复合赋值操作，且右操作数是变量或常量，不能是表达式或函数。</p></blockquote></li><li><p><code>java.concurrent.Atomic.*</code> 包中所有类的原子操作。</p></li></ol><h3 id="_6-3-long-和-double-的原子性" tabindex="-1"><a class="header-anchor" href="#_6-3-long-和-double-的原子性" aria-hidden="true">#</a> 6.3 <code>long</code> 和 <code>double</code> 的原子性</h3><p>官方文档提出：</p><div class="language-text ext-text"><pre class="language-text"><code>对于占 8 字节（64 位）的 long 类型变量和 double 类型变量的赋值操作，
在 32 位操作系统中不具备原子性，在 64 位的操作系统中则具备原子性。

因为 long 或 double 占 64 位，所以在 32 位操作系统中向 long 或 double 类型的变量写入数据时，会分两次写入（每次写 32 位数据）。
为了保证 long 或 double 类型变量的赋值操作具备原子性，应该使用 volatile 修饰 long 或 double 类型的变量。
</code></pre></div><blockquote><p>对于商用的 <code>Java</code> 虚拟机，<code>JVM</code> 内部已经保证了 <code>long</code> 或 <code>double</code> 类型变量的赋值操作具备原子性。因此，实际开发中，不再需要为了保证 <code>long</code> 或 <code>double</code> 类型变量的赋值操作具备原子性，而使用 <code>volatile</code> 关键字修饰它们。</p></blockquote><p><img src="/assets/25.c0ff3526.png" alt="" loading="lazy"></p><h3 id="_6-4-原子操作-原子操作-原子操作" tabindex="-1"><a class="header-anchor" href="#_6-4-原子操作-原子操作-原子操作" aria-hidden="true">#</a> 6.4 原子操作 + 原子操作 != 原子操作</h3><p>简单地把原子操作组合在一起，并不能保证整体依然具有原子性。</p><blockquote><p>比如去 <code>ATM</code> 机两次取钱是两次独立的原子操作，但是期间有可能银行卡被借给女朋友，也就是被其他线程打断并被修改。</p></blockquote><p>另外，全同步的 <code>HashMap</code> 也不完全安全。</p><blockquote><p>即使 <code>HashMap</code> 的写操作具备原子性（如用 <code>synchronized</code> 修饰 <code>put</code> 方法），读操作也具备原子性（如用 <code>synchronized</code> 修饰 <code>get</code> 方法）。但是，由读操作和写操作组成的操作却不具备原子性，即在读操作和写操作之间可能会出现线程切换的情况，从而引起线程安全问题。</p></blockquote><h2 id="_7-jmm-的应用-双重检查实现单例" tabindex="-1"><a class="header-anchor" href="#_7-jmm-的应用-双重检查实现单例" aria-hidden="true">#</a> 7. <code>JMM</code> 的应用（双重检查实现单例）</h2><p><a href="/zkq/design-pattern/singleton-pattern.html#%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E3%80%90%E6%8E%A8%E8%8D%90%E7%94%A8%E3%80%91" class="">参考</a></p><!--]--></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/zengkaiqiang562/JavaGuide/edit/main/docs/zkq/java/jmm.md" rel="noopener noreferrer" target="_blank" arialabel="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewbox="0 0 1024 1024" arialabelledby="edit"><title id="edit" lang="en">edit icon</title><g fill="currentColor"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></g></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item update-time"><span class="label">上次编辑于: </span><span class="info">2022/7/7 23:59:00</span></div><div class="meta-item contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: zengkaiqiang562@163.com">zengk</span><!--]--><!--]--></div></footer><nav class="page-nav"><a href="/zkq/java/threadpool.html" class="nav-link prev" arialabel="线程池"><div class="hint"><span class="arrow left"></span>上一页</div><div class="link"><!---->线程池</div></a><!----></nav><!----><!----></main><!--]--><footer class="footer-wrapper"><div class="footer"></div><div class="copyright">Copyright © 2024 Zenk562</div></footer></div><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app.2a01fc36.js" defer></script>
  </body>
</html>
