<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.38" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://zengkaiqiang562.github.io/zkq/java/jvm/gc.html"><meta property="og:site_name" content="Android Guide"><meta property="og:title" content="垃圾回收"><meta property="og:type" content="article"><meta property="og:image" content="https://zengkaiqiang562.github.io/"><meta property="og:updated_time" content="2022-07-07T15:59:00.000Z"><meta property="og:locale" content="zh-CN"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image:alt" content="垃圾回收"><meta property="article:tag" content="java"><meta property="article:modified_time" content="2022-07-07T15:59:00.000Z"><script>var _hmt = _hmt || [];
      (function() {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?5dd2e8c97962d57b7b8fea1737c01743";
        var s = document.getElementsByTagName("script")[0]; 
        s.parentNode.insertBefore(hm, s);
      })();</script><link rel="stylesheet" href="//at.alicdn.com/t/font_2922463_99aa80ii7cf.css"><title>垃圾回收 | Android Guide</title><meta name="description" content="Android 学习 && 面试指南">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/assets/style.5a38b724.css">
    <link rel="modulepreload" href="/assets/app.625aa393.js"><link rel="modulepreload" href="/assets/gc.html.9db27afc.js"><link rel="modulepreload" href="/assets/gc.html.1406c660.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container has-toc sidebar-open"><!--[--><header class="navbar"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><a href="/" class="home-link"><img class="logo" src="/logo.png" alt="Android Guide"><!----><span class="site-name hide-in-pad">Android Guide</span><!--[--><!----><!--]--></a><nav class="nav-links" style=""><div class="nav-item hide-in-mobile"><a href="/home.html" class="nav-link" arialabel="面试指南"><i class="icon iconfont icon-java"></i>面试指南<!----></a></div><div class="nav-item hide-in-mobile"><a href="/zhuanlan/" class="nav-link" arialabel="优质专栏"><i class="icon iconfont icon-recommend"></i>优质专栏<!----></a></div><div class="nav-item hide-in-mobile"><a href="/open-source-project/" class="nav-link" arialabel="项目精选"><i class="icon iconfont icon-github"></i>项目精选<!----></a></div><div class="nav-item hide-in-mobile"><a href="https://snailclimb.gitee.io/javaguide/#/" rel="noopener noreferrer" target="_blank" arialabel="旧版链接" class="nav-link"><i class="icon iconfont icon-java"></i>旧版链接<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="nav-item hide-in-mobile"><a href="https://javaguide.cn/feed.json" rel="noopener noreferrer" target="_blank" arialabel="RSS订阅" class="nav-link"><i class="icon iconfont icon-rss"></i>RSS订阅<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="nav-item hide-in-mobile"><a href="/about-the-author/" class="nav-link" arialabel="关于作者"><i class="icon iconfont icon-zuozhe"></i>关于作者<!----></a></div></nav><div class="nav-actions-wrapper"><!--[--><!----><!--]--><div class="nav-item"><!----></div><div class="nav-item"><a class="repo-link" href="https://github.com/zengkaiqiang562/JavaGuide" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewbox="0 0 1024 1024" arialabelledby="github" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><title id="github" lang="en">github icon</title><g fill="currentColor"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></g></svg></a></div><div class="nav-item hide-in-mobile"><button id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewbox="0 0 1024 1024" arialabelledby="auto" style="display:block;"><title id="auto" lang="en">auto icon</title><g fill="currentColor"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></g></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewbox="0 0 1024 1024" arialabelledby="dark" style="display:none;"><title id="dark" lang="en">dark icon</title><g fill="currentColor"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></g></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewbox="0 0 1024 1024" arialabelledby="light" style="display:none;"><title id="light" lang="en">light icon</title><g fill="currentColor"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></g></svg></button></div><form class="search-box" role="search"><input type="search" placeholder="搜索" autocomplete="off" spellcheck="false" value><!----></form><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button><!--[--><!----><!--]--></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><a href="/zkq/java/reflect.html" class="nav-link sidebar-link sidebar-page" arialabel="反射机制"><!---->反射机制<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/zkq/java/annotation.html" class="nav-link sidebar-link sidebar-page" arialabel="注解技术"><!---->注解技术<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/zkq/java/genericity.html" class="nav-link sidebar-link sidebar-page" arialabel="泛型编程（TODO）"><!---->泛型编程（TODO）<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/zkq/java/thread.html" class="nav-link sidebar-link sidebar-page" arialabel="线程"><!---->线程<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/zkq/java/threadpool.html" class="nav-link sidebar-link sidebar-page" arialabel="线程池"><!---->线程池<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/zkq/java/jmm.html" class="nav-link sidebar-link sidebar-page" arialabel="Java 内存模型（JMM）"><!---->Java 内存模型（JMM）<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable active"><!----><span class="title">JVM</span><span class="arrow down"></span></button><!--[--><ul class="sidebar-links"><li><!--[--><a href="/zkq/java/jvm/jvm-spec.html" class="nav-link sidebar-link sidebar-page" arialabel="认识 JVM 规范（JVM 概述、字节码指令集、Class文件解析、ASM）"><!---->认识 JVM 规范（JVM 概述、字节码指令集、Class文件解析、ASM）<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/zkq/java/jvm/classloader.html" class="nav-link sidebar-link sidebar-page" arialabel="类加载、连接和初始化"><!---->类加载、连接和初始化<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/zkq/java/jvm/memory-allocate.html" class="nav-link sidebar-link sidebar-page" arialabel="内存分配"><!---->内存分配<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/zkq/java/jvm/class-exe-engine.html" class="nav-link sidebar-link sidebar-page" arialabel="字节码执行引擎"><!---->字节码执行引擎<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/zkq/java/jvm/gc.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" arialabel="垃圾回收"><!---->垃圾回收<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-垃圾回收基础" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1. 垃圾回收基础"><!---->1. 垃圾回收基础<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-1-什么是垃圾" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.1 什么是垃圾"><!---->1.1 什么是垃圾<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-2-如何判定是垃圾" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.2 如何判定是垃圾"><!---->1.2 如何判定是垃圾<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-2-1-引用计数法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.2.1 引用计数法"><!---->1.2.1 引用计数法<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-2-2-根搜索算法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.2.2 根搜索算法"><!---->1.2.2 根搜索算法<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-2-2-1-可作为-gc-roots-的对象" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.2.2.1 可作为 GC Roots 的对象"><!---->1.2.2.1 可作为 GC Roots 的对象<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-2-2-2-hotspot-虚拟机对根搜索算法的优化-oopmap-数据结构" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.2.2.2 HotSpot 虚拟机对根搜索算法的优化（OopMap 数据结构）"><!---->1.2.2.2 HotSpot 虚拟机对根搜索算法的优化（OopMap 数据结构）<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-2-2-2-1-安全点-安全区域" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.2.2.2.1 安全点 &amp; 安全区域"><!---->1.2.2.2.1 安全点 &amp; 安全区域<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-2-3-引用分类" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.2.3 引用分类"><!---->1.2.3 引用分类<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-2-3-1-强引用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.2.3.1 强引用"><!---->1.2.3.1 强引用<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-2-3-2-软引用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.2.3.2 软引用"><!---->1.2.3.2 软引用<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-2-3-3-弱引用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.2.3.3 弱引用"><!---->1.2.3.3 弱引用<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-2-3-4-虚引用-幽灵引用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.2.3.4 虚引用（幽灵引用）"><!---->1.2.3.4 虚引用（幽灵引用）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-2-3-5-示例-gc-对软引用和弱引用的影响-finalize-referencequeue" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.2.3.5 示例：GC 对软引用和弱引用的影响（finalize() &amp; ReferenceQueue）"><!---->1.2.3.5 示例：GC 对软引用和弱引用的影响（finalize() &amp; ReferenceQueue）<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-2-4-跨代引用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.2.4 跨代引用"><!---->1.2.4 跨代引用<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-2-4-1-跨代引用造成的问题" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.2.4.1 跨代引用造成的问题"><!---->1.2.4.1 跨代引用造成的问题<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-2-4-2-记忆集-解决跨代引用造成的问题" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.2.4.2 记忆集（解决跨代引用造成的问题）"><!---->1.2.4.2 记忆集（解决跨代引用造成的问题）<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-2-4-2-1-实现记忆集的三种方式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.2.4.2.1 实现记忆集的三种方式"><!---->1.2.4.2.1 实现记忆集的三种方式<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-2-4-2-2-卡表-card-table-记忆集的具体实现" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.2.4.2.2 卡表（Card Table，记忆集的具体实现）"><!---->1.2.4.2.2 卡表（Card Table，记忆集的具体实现）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-2-4-2-2-卡页-card-page-卡表的组成元素" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.2.4.2.2 卡页（Card Page，卡表的组成元素）"><!---->1.2.4.2.2 卡页（Card Page，卡表的组成元素）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-2-4-2-3-写屏障" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.2.4.2.3 写屏障"><!---->1.2.4.2.3 写屏障<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-2-5-判定是否为垃圾的步骤" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.2.5 判定是否为垃圾的步骤"><!---->1.2.5 判定是否为垃圾的步骤<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-2-5-1-finalize-方法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.2.5.1  finalize() 方法"><!---->1.2.5.1  finalize() 方法<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-2-5-2-示例-通过-finalize-方法实现对象的自救" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.2.5.2  示例：通过 finalize() 方法实现对象的自救"><!---->1.2.5.2  示例：通过 finalize() 方法实现对象的自救<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-3-如何回收垃圾" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.3 如何回收垃圾"><!---->1.3 如何回收垃圾<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-3-1-gc-类型" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.3.1 GC 类型"><!---->1.3.1 GC 类型<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-3-1-1-minorgc-younggc" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.3.1.1 MinorGC（YoungGC）"><!---->1.3.1.1 MinorGC（YoungGC）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-3-1-2-majorgc-oldgc" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.3.1.2 MajorGC（OldGC）"><!---->1.3.1.2 MajorGC（OldGC）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-3-1-3-mixedgc" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.3.1.3 MixedGC"><!---->1.3.1.3 MixedGC<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-3-1-4-fullgc" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.3.1.4 FullGC"><!---->1.3.1.4 FullGC<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-3-2-stw-stop-the-world" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.3.2 STW（Stop-The-World）"><!---->1.3.2 STW（Stop-The-World）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-3-3-判定类无用的条件" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.3.3 判定类无用的条件"><!---->1.3.3 判定类无用的条件<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-3-4-垃圾收集类型" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.3.4 垃圾收集类型"><!---->1.3.4 垃圾收集类型<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-3-4-1-串行收集" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.3.4.1 串行收集"><!---->1.3.4.1 串行收集<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-3-4-2-并行收集" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.3.4.2 并行收集"><!---->1.3.4.2 并行收集<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-3-4-3-并发收集" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.3.4.3 并发收集"><!---->1.3.4.3 并发收集<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-3-5-垃圾回收算法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.3.5 垃圾回收算法"><!---->1.3.5 垃圾回收算法<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-3-5-1-标记清除算法-mark-sweep" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.3.5.1 标记清除算法（Mark-Sweep）"><!---->1.3.5.1 标记清除算法（Mark-Sweep）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-3-5-2-复制算法-copying-一般在新生代中使用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.3.5.2 复制算法（Copying，一般在新生代中使用）"><!---->1.3.5.2 复制算法（Copying，一般在新生代中使用）<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-3-5-2-1-分配担保" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.3.5.2.1 分配担保"><!---->1.3.5.2.1 分配担保<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-3-5-3-标记整理算法-mark-compact-一般在老年代中使用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.3.5.3 标记整理算法（Mark-Compact，一般在老年代中使用）"><!---->1.3.5.3 标记整理算法（Mark-Compact，一般在老年代中使用）<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-垃圾收集器" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="2. 垃圾收集器"><!---->2. 垃圾收集器<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-1-概述" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="2.1 概述"><!---->2.1 概述<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-2-串行收集器-serial-新生代-serial-old-老年代" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="2.2 串行收集器（Serial（新生代）/ Serial old（老年代））"><!---->2.2 串行收集器（Serial（新生代）/ Serial old（老年代））<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-2-1-示例-serial-serial-old-组合的配置-xx-useserialgc" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="2.2.1 示例：Serial + Serial old 组合的配置（-XX:+UseSerialGC）"><!---->2.2.1 示例：Serial + Serial old 组合的配置（-XX:+UseSerialGC）<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-3-并行收集器-parnew-新生代" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="2.3 并行收集器（ParNew（新生代））"><!---->2.3 并行收集器（ParNew（新生代））<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-3-1-示例-parnew-cms-组合的配置-xx-useconcmarksweepgc" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="2.3.1 示例：ParNew + CMS 组合的配置（-XX:+UseConcMarkSweepGC）"><!---->2.3.1 示例：ParNew + CMS 组合的配置（-XX:+UseConcMarkSweepGC）<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-4-并行收集器-parallel-scavenge-新生代-parallel-old-老年代" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="2.4 并行收集器（Parallel Scavenge（新生代）/ Parallel old（老年代））"><!---->2.4 并行收集器（Parallel Scavenge（新生代）/ Parallel old（老年代））<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-4-1-示例-parallel-scavenge-parallel-old-组合的配置-xx-useparallelgc-或-xx-useparalleloldgc" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="2.4.1 示例：Parallel Scavenge + Parallel old 组合的配置（-XX:+UseParallelGC 或 -XX:+UseParallelOldGC）"><!---->2.4.1 示例：Parallel Scavenge + Parallel old 组合的配置（-XX:+UseParallelGC 或 -XX:+UseParallelOldGC）<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-5-并发收集器-cms-concurrent-mark-and-sweep-并发标记清除" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="2.5 并发收集器（CMS，Concurrent Mark and Sweep 并发标记清除）"><!---->2.5 并发收集器（CMS，Concurrent Mark and Sweep 并发标记清除）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-6-g1-收集器-garbage-first" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="2.6 G1 收集器（Garbage-First）"><!---->2.6 G1 收集器（Garbage-First）<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-6-1-g1-收集器的特点" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="2.6.1 G1 收集器的特点"><!---->2.6.1 G1 收集器的特点<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-6-2-g1-收集器定义的五种类型的区域-region" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="2.6.2 G1 收集器定义的五种类型的区域（Region）"><!---->2.6.2 G1 收集器定义的五种类型的区域（Region）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-6-3-g1-收集器的工作过程-四个阶段" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="2.6.3 G1 收集器的工作过程（四个阶段）"><!---->2.6.3 G1 收集器的工作过程（四个阶段）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-6-4-g1-收集器的相关参数配置" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="2.6.4 G1 收集器的相关参数配置"><!---->2.6.4 G1 收集器的相关参数配置<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-6-4-1-xx-useg1gc-使用-g1-收集器" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="2.6.4.1 -XX:+UseG1GC（使用 G1 收集器）"><!---->2.6.4.1 -XX:+UseG1GC（使用 G1 收集器）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-6-4-2-xx-maxgcpausemillis-n-最大-gc-停顿时间" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="2.6.4.2 -XX:MaxGCPauseMillis=&lt;n&gt;（最大 GC 停顿时间）"><!---->2.6.4.2 -XX:MaxGCPauseMillis=&lt;n&gt;（最大 GC 停顿时间）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-6-4-3-xx-initiatingheapoccupancypercent-n" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="2.6.4.3 -XX:InitiatingHeapOccupancyPercent=&lt;n&gt;"><!---->2.6.4.3 -XX:InitiatingHeapOccupancyPercent=&lt;n&gt;<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-6-4-4-xx-newratio-n" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="2.6.4.4 -XX:NewRatio=&lt;n&gt;"><!---->2.6.4.4 -XX:NewRatio=&lt;n&gt;<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-6-4-5-xx-survivorratio-n" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="2.6.4.5 -XX:SurvivorRatio=&lt;n&gt;"><!---->2.6.4.5 -XX:SurvivorRatio=&lt;n&gt;<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-6-4-6-xx-maxtenuringthreshold-n" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="2.6.4.6 -XX:MaxTenuringThreshold=&lt;n&gt;"><!---->2.6.4.6 -XX:MaxTenuringThreshold=&lt;n&gt;<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-6-4-7-xx-parallelgcthreads-n" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="2.6.4.7 -XX:ParallelGCThreads=&lt;n&gt;"><!---->2.6.4.7 -XX:ParallelGCThreads=&lt;n&gt;<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-6-4-8-xx-concgcthreads-n" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="2.6.4.8 -XX:ConcGCThreads=&lt;n&gt;"><!---->2.6.4.8 -XX:ConcGCThreads=&lt;n&gt;<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-6-4-9-xx-g1reservepercent-n" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="2.6.4.9 -XX:G1ReservePercent=&lt;n&gt;"><!---->2.6.4.9 -XX:G1ReservePercent=&lt;n&gt;<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-6-4-10-xx-g1heapregionsize-n" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="2.6.4.10 -XX:G1HeapRegionSize=&lt;n&gt;"><!---->2.6.4.10 -XX:G1HeapRegionSize=&lt;n&gt;<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-7-zgc-收集器" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="2.7 ZGC 收集器"><!---->2.7 ZGC 收集器<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_3-gc-性能指标" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="3. GC 性能指标"><!---->3. GC 性能指标<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_3-1-吞吐量" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="3.1 吞吐量"><!---->3.1 吞吐量<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_3-2-gc-负荷" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="3.2 GC 负荷"><!---->3.2 GC 负荷<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_3-3-暂停时间" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="3.3 暂停时间"><!---->3.3 暂停时间<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_3-4-gc-频率" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="3.4 GC 频率"><!---->3.4 GC 频率<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_3-5-反应速度" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="3.5 反应速度"><!---->3.5 反应速度<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/java/jvm/gc.html#_4-jvm-内存分配原则" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="4. JVM 内存分配原则"><!---->4. JVM 内存分配原则<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><a href="/zkq/java/jvm/concurrence.html" class="nav-link sidebar-link sidebar-page" arialabel="高效并发"><!---->高效并发<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul><!----><!--]--></section><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->垃圾回收</h1><div class="article-info"><span class="author-info" arialabel="作者🖊" isoriginal="false" pageview="false" color="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewbox="0 0 1024 1024" arialabelledby="author"><title id="author" lang="en">author icon</title><g fill="currentColor"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></g></svg><span><a class="author-item" href="https://zengkaiqiang562.github.io/" target="_blank" rel="noopener noreferrer">Zenk562</a></span><span property="author" content="Zenk562"></span></span><span class="category-info" arialabel="分类🌈" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewbox="0 0 1024 1024" arialabelledby="category"><title id="category" lang="en">category icon</title><g fill="currentColor"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></g></svg><ul class="categories-wrapper"><li class="category clickable" role="navigation">java</li><meta property="articleSection" content="java"></ul></span><span arialabel="标签🏷" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon tag-icon" viewbox="0 0 1024 1024" arialabelledby="tag"><title id="tag" lang="en">tag icon</title><g fill="currentColor"><path d="M939.902 458.563L910.17 144.567c-1.507-16.272-14.465-29.13-30.737-30.737L565.438 84.098h-.402c-3.215 0-5.726 1.005-7.634 2.913l-470.39 470.39a10.004 10.004 0 000 14.164l365.423 365.424c1.909 1.908 4.42 2.913 7.132 2.913s5.223-1.005 7.132-2.913l470.39-470.39c2.01-2.11 3.014-5.023 2.813-8.036zm-240.067-72.121c-35.458 0-64.286-28.828-64.286-64.286s28.828-64.285 64.286-64.285 64.286 28.828 64.286 64.285-28.829 64.286-64.286 64.286z"></path></g></svg><ul class="tags-wrapper"><li class="tag clickable" role="navigation">java</li></ul><meta property="keywords" content="java"></span><span class="date-info" arialabel="写作日期📅" isoriginal="false" pageview="false" color="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewbox="0 0 1024 1024" arialabelledby="calendar"><title id="calendar" lang="en">calendar icon</title><g fill="currentColor"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></g></svg><span>2022年7月7日</span><meta property="datePublished" content="2022-07-07T15:59:00.000Z"></span><!----><span class="words-info" arialabel="字数🔠" isoriginal="false" pageview="false" color="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon word-icon" viewbox="0 0 1024 1024" arialabelledby="word"><title id="word" lang="en">word icon</title><g fill="currentColor"><path d="M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z"></path><path d="M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z"></path></g></svg><span>约 7494 字</span><meta property="wordCount" content="7494"></span></div><hr></div><div class="toc-place-holder"><aside id="toc-list"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-垃圾回收基础" class="router-link-active router-link-exact-active toc-link level2">1. 垃圾回收基础</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-1-什么是垃圾" class="router-link-active router-link-exact-active toc-link level3">1.1 什么是垃圾</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-2-如何判定是垃圾" class="router-link-active router-link-exact-active toc-link level3">1.2 如何判定是垃圾</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-2-1-引用计数法" class="router-link-active router-link-exact-active toc-link level4">1.2.1 引用计数法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-2-2-根搜索算法" class="router-link-active router-link-exact-active toc-link level4">1.2.2 根搜索算法</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-2-2-1-可作为-gc-roots-的对象" class="router-link-active router-link-exact-active toc-link level5">1.2.2.1 可作为 GC Roots 的对象</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-2-2-2-hotspot-虚拟机对根搜索算法的优化-oopmap-数据结构" class="router-link-active router-link-exact-active toc-link level5">1.2.2.2 HotSpot 虚拟机对根搜索算法的优化（OopMap 数据结构）</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-2-2-2-1-安全点-安全区域" class="router-link-active router-link-exact-active toc-link level6">1.2.2.2.1 安全点 &amp; 安全区域</a></li><!----><!--]--></ul><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-2-3-引用分类" class="router-link-active router-link-exact-active toc-link level4">1.2.3 引用分类</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-2-3-1-强引用" class="router-link-active router-link-exact-active toc-link level5">1.2.3.1 强引用</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-2-3-2-软引用" class="router-link-active router-link-exact-active toc-link level5">1.2.3.2 软引用</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-2-3-3-弱引用" class="router-link-active router-link-exact-active toc-link level5">1.2.3.3 弱引用</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-2-3-4-虚引用-幽灵引用" class="router-link-active router-link-exact-active toc-link level5">1.2.3.4 虚引用（幽灵引用）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-2-3-5-示例-gc-对软引用和弱引用的影响-finalize-referencequeue" class="router-link-active router-link-exact-active toc-link level5">1.2.3.5 示例：GC 对软引用和弱引用的影响（finalize() &amp; ReferenceQueue）</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-2-4-跨代引用" class="router-link-active router-link-exact-active toc-link level4">1.2.4 跨代引用</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-2-4-1-跨代引用造成的问题" class="router-link-active router-link-exact-active toc-link level5">1.2.4.1 跨代引用造成的问题</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-2-4-2-记忆集-解决跨代引用造成的问题" class="router-link-active router-link-exact-active toc-link level5">1.2.4.2 记忆集（解决跨代引用造成的问题）</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-2-4-2-1-实现记忆集的三种方式" class="router-link-active router-link-exact-active toc-link level6">1.2.4.2.1 实现记忆集的三种方式</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-2-4-2-2-卡表-card-table-记忆集的具体实现" class="router-link-active router-link-exact-active toc-link level6">1.2.4.2.2 卡表（Card Table，记忆集的具体实现）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-2-4-2-2-卡页-card-page-卡表的组成元素" class="router-link-active router-link-exact-active toc-link level6">1.2.4.2.2 卡页（Card Page，卡表的组成元素）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-2-4-2-3-写屏障" class="router-link-active router-link-exact-active toc-link level6">1.2.4.2.3 写屏障</a></li><!----><!--]--></ul><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-2-5-判定是否为垃圾的步骤" class="router-link-active router-link-exact-active toc-link level4">1.2.5 判定是否为垃圾的步骤</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-2-5-1-finalize-方法" class="router-link-active router-link-exact-active toc-link level5">1.2.5.1  finalize() 方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-2-5-2-示例-通过-finalize-方法实现对象的自救" class="router-link-active router-link-exact-active toc-link level5">1.2.5.2  示例：通过 finalize() 方法实现对象的自救</a></li><!----><!--]--></ul><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-3-如何回收垃圾" class="router-link-active router-link-exact-active toc-link level3">1.3 如何回收垃圾</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-3-1-gc-类型" class="router-link-active router-link-exact-active toc-link level4">1.3.1 GC 类型</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-3-1-1-minorgc-younggc" class="router-link-active router-link-exact-active toc-link level5">1.3.1.1 MinorGC（YoungGC）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-3-1-2-majorgc-oldgc" class="router-link-active router-link-exact-active toc-link level5">1.3.1.2 MajorGC（OldGC）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-3-1-3-mixedgc" class="router-link-active router-link-exact-active toc-link level5">1.3.1.3 MixedGC</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-3-1-4-fullgc" class="router-link-active router-link-exact-active toc-link level5">1.3.1.4 FullGC</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-3-2-stw-stop-the-world" class="router-link-active router-link-exact-active toc-link level4">1.3.2 STW（Stop-The-World）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-3-3-判定类无用的条件" class="router-link-active router-link-exact-active toc-link level4">1.3.3 判定类无用的条件</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-3-4-垃圾收集类型" class="router-link-active router-link-exact-active toc-link level4">1.3.4 垃圾收集类型</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-3-4-1-串行收集" class="router-link-active router-link-exact-active toc-link level5">1.3.4.1 串行收集</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-3-4-2-并行收集" class="router-link-active router-link-exact-active toc-link level5">1.3.4.2 并行收集</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-3-4-3-并发收集" class="router-link-active router-link-exact-active toc-link level5">1.3.4.3 并发收集</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-3-5-垃圾回收算法" class="router-link-active router-link-exact-active toc-link level4">1.3.5 垃圾回收算法</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-3-5-1-标记清除算法-mark-sweep" class="router-link-active router-link-exact-active toc-link level5">1.3.5.1 标记清除算法（Mark-Sweep）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-3-5-2-复制算法-copying-一般在新生代中使用" class="router-link-active router-link-exact-active toc-link level5">1.3.5.2 复制算法（Copying，一般在新生代中使用）</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-3-5-2-1-分配担保" class="router-link-active router-link-exact-active toc-link level6">1.3.5.2.1 分配担保</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_1-3-5-3-标记整理算法-mark-compact-一般在老年代中使用" class="router-link-active router-link-exact-active toc-link level5">1.3.5.3 标记整理算法（Mark-Compact，一般在老年代中使用）</a></li><!----><!--]--></ul><!--]--></ul><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-垃圾收集器" class="router-link-active router-link-exact-active toc-link level2">2. 垃圾收集器</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-1-概述" class="router-link-active router-link-exact-active toc-link level3">2.1 概述</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-2-串行收集器-serial-新生代-serial-old-老年代" class="router-link-active router-link-exact-active toc-link level3">2.2 串行收集器（Serial（新生代）/ Serial old（老年代））</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-2-1-示例-serial-serial-old-组合的配置-xx-useserialgc" class="router-link-active router-link-exact-active toc-link level4">2.2.1 示例：Serial + Serial old 组合的配置（-XX:+UseSerialGC）</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-3-并行收集器-parnew-新生代" class="router-link-active router-link-exact-active toc-link level3">2.3 并行收集器（ParNew（新生代））</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-3-1-示例-parnew-cms-组合的配置-xx-useconcmarksweepgc" class="router-link-active router-link-exact-active toc-link level4">2.3.1 示例：ParNew + CMS 组合的配置（-XX:+UseConcMarkSweepGC）</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-4-并行收集器-parallel-scavenge-新生代-parallel-old-老年代" class="router-link-active router-link-exact-active toc-link level3">2.4 并行收集器（Parallel Scavenge（新生代）/ Parallel old（老年代））</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-4-1-示例-parallel-scavenge-parallel-old-组合的配置-xx-useparallelgc-或-xx-useparalleloldgc" class="router-link-active router-link-exact-active toc-link level4">2.4.1 示例：Parallel Scavenge + Parallel old 组合的配置（-XX:+UseParallelGC 或 -XX:+UseParallelOldGC）</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-5-并发收集器-cms-concurrent-mark-and-sweep-并发标记清除" class="router-link-active router-link-exact-active toc-link level3">2.5 并发收集器（CMS，Concurrent Mark and Sweep 并发标记清除）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-6-g1-收集器-garbage-first" class="router-link-active router-link-exact-active toc-link level3">2.6 G1 收集器（Garbage-First）</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-6-1-g1-收集器的特点" class="router-link-active router-link-exact-active toc-link level4">2.6.1 G1 收集器的特点</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-6-2-g1-收集器定义的五种类型的区域-region" class="router-link-active router-link-exact-active toc-link level4">2.6.2 G1 收集器定义的五种类型的区域（Region）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-6-3-g1-收集器的工作过程-四个阶段" class="router-link-active router-link-exact-active toc-link level4">2.6.3 G1 收集器的工作过程（四个阶段）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-6-4-g1-收集器的相关参数配置" class="router-link-active router-link-exact-active toc-link level4">2.6.4 G1 收集器的相关参数配置</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-6-4-1-xx-useg1gc-使用-g1-收集器" class="router-link-active router-link-exact-active toc-link level5">2.6.4.1 -XX:+UseG1GC（使用 G1 收集器）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-6-4-2-xx-maxgcpausemillis-n-最大-gc-停顿时间" class="router-link-active router-link-exact-active toc-link level5">2.6.4.2 -XX:MaxGCPauseMillis=&lt;n&gt;（最大 GC 停顿时间）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-6-4-3-xx-initiatingheapoccupancypercent-n" class="router-link-active router-link-exact-active toc-link level5">2.6.4.3 -XX:InitiatingHeapOccupancyPercent=&lt;n&gt;</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-6-4-4-xx-newratio-n" class="router-link-active router-link-exact-active toc-link level5">2.6.4.4 -XX:NewRatio=&lt;n&gt;</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-6-4-5-xx-survivorratio-n" class="router-link-active router-link-exact-active toc-link level5">2.6.4.5 -XX:SurvivorRatio=&lt;n&gt;</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-6-4-6-xx-maxtenuringthreshold-n" class="router-link-active router-link-exact-active toc-link level5">2.6.4.6 -XX:MaxTenuringThreshold=&lt;n&gt;</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-6-4-7-xx-parallelgcthreads-n" class="router-link-active router-link-exact-active toc-link level5">2.6.4.7 -XX:ParallelGCThreads=&lt;n&gt;</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-6-4-8-xx-concgcthreads-n" class="router-link-active router-link-exact-active toc-link level5">2.6.4.8 -XX:ConcGCThreads=&lt;n&gt;</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-6-4-9-xx-g1reservepercent-n" class="router-link-active router-link-exact-active toc-link level5">2.6.4.9 -XX:G1ReservePercent=&lt;n&gt;</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-6-4-10-xx-g1heapregionsize-n" class="router-link-active router-link-exact-active toc-link level5">2.6.4.10 -XX:G1HeapRegionSize=&lt;n&gt;</a></li><!----><!--]--></ul><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_2-7-zgc-收集器" class="router-link-active router-link-exact-active toc-link level3">2.7 ZGC 收集器</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_3-gc-性能指标" class="router-link-active router-link-exact-active toc-link level2">3. GC 性能指标</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_3-1-吞吐量" class="router-link-active router-link-exact-active toc-link level3">3.1 吞吐量</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_3-2-gc-负荷" class="router-link-active router-link-exact-active toc-link level3">3.2 GC 负荷</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_3-3-暂停时间" class="router-link-active router-link-exact-active toc-link level3">3.3 暂停时间</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_3-4-gc-频率" class="router-link-active router-link-exact-active toc-link level3">3.4 GC 频率</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_3-5-反应速度" class="router-link-active router-link-exact-active toc-link level3">3.5 反应速度</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/java/jvm/gc.html#_4-jvm-内存分配原则" class="router-link-active router-link-exact-active toc-link level2">4. JVM 内存分配原则</a></li><!----><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><!--[--><h2 id="_1-垃圾回收基础" tabindex="-1"><a class="header-anchor" href="#_1-垃圾回收基础" aria-hidden="true">#</a> 1. 垃圾回收基础</h2><h3 id="_1-1-什么是垃圾" tabindex="-1"><a class="header-anchor" href="#_1-1-什么是垃圾" aria-hidden="true">#</a> 1.1 什么是垃圾</h3><p>简单说就是：内存中已经不再被使用到的内存空间就是垃圾。</p><h3 id="_1-2-如何判定是垃圾" tabindex="-1"><a class="header-anchor" href="#_1-2-如何判定是垃圾" aria-hidden="true">#</a> 1.2 如何判定是垃圾</h3><h4 id="_1-2-1-引用计数法" tabindex="-1"><a class="header-anchor" href="#_1-2-1-引用计数法" aria-hidden="true">#</a> 1.2.1 引用计数法</h4><p>引用计数法：给对象添加一个引用计数器，有访问就 <code>+1</code>，引用失效就 <code>-1</code></p><p>引用计数法的优缺点：</p><ol><li><p>优点：实现简单，效率高；</p></li><li><p>缺点：不能解决对象之间的循环引用问题。</p><p><img src="/assets/01.04dc67f4.png" alt="" loading="lazy"></p></li></ol><h4 id="_1-2-2-根搜索算法" tabindex="-1"><a class="header-anchor" href="#_1-2-2-根搜索算法" aria-hidden="true">#</a> 1.2.2 根搜索算法</h4><p>从根（<code>GC Roots</code>）节点向下搜索对象节点，搜素走过的路径称为 <strong>引用链</strong>。当一个对象到根之间没有连通时，则该对象不可用，不可用的对象会被判定为垃圾，对其进行回收。</p><blockquote><p>一个对象可能存在于多条引用链中，即可能不止一个根节点能连通到该对象，所以根节点用复数形式表示：<code>GC Roots</code>。</p></blockquote><p><img src="/assets/02.6e5d96af.png" alt="" loading="lazy"></p><blockquote><p>很多商用虚拟机都是采用根搜索算法来判定一个对象是不是垃圾。</p></blockquote><h5 id="_1-2-2-1-可作为-gc-roots-的对象" tabindex="-1"><a class="header-anchor" href="#_1-2-2-1-可作为-gc-roots-的对象" aria-hidden="true">#</a> 1.2.2.1 可作为 <code>GC Roots</code> 的对象</h5><p>可作为 <code>GC Roots</code> 的对象包括：</p><ol><li>虚拟机栈中（方法参数和局部变量）引用的对象；</li><li>方法区中的类静态成员变量引用的对象；</li><li>方法区中常量引用的对象；</li><li>本地方法栈中 <code>JNI</code> 引用的对象；</li><li>作为同步锁的对象；</li><li>......</li></ol><h5 id="_1-2-2-2-hotspot-虚拟机对根搜索算法的优化-oopmap-数据结构" tabindex="-1"><a class="header-anchor" href="#_1-2-2-2-hotspot-虚拟机对根搜索算法的优化-oopmap-数据结构" aria-hidden="true">#</a> 1.2.2.2 <code>HotSpot</code> 虚拟机对根搜索算法的优化（<code>OopMap</code> 数据结构）</h5><p>按照根搜索算法，为了判定一个对象是否为垃圾，需要从每一个 <code>GC Roots</code> 开始遍历每一条引用链，从而查询某个对象是否在这些引用链中。</p><p>这样做的话，对于代码量很大，引用链很多的项目，判定对象是否为垃圾的效率是很低的。</p><p>为了解决这个问题，<code>HotSpot</code> 虚拟机采用 <code>OopMap</code> 这种数据结构来优化判定对象是否为垃圾的效率：</p><p><code>OopMap</code> 数据结构中，存储了对象之间的引用关系，通过 <code>OopMap</code> 可以加快定位对象的引用位置，而不用从 <code>GC Roots</code> 开始遍历引用链，从而大大提高判定对象是否为垃圾的效率。</p><h6 id="_1-2-2-2-1-安全点-安全区域" tabindex="-1"><a class="header-anchor" href="#_1-2-2-2-1-安全点-安全区域" aria-hidden="true">#</a> 1.2.2.2.1 安全点 &amp; 安全区域</h6><p>在 <code>OopMap</code> 的协助下，<code>JVM</code> 可以很快地完成对 <code>GC Roots</code> 的枚举。但是 <code>JVM</code> 并没有对每一条指令都记录并生成一个 <code>OopMap</code>。</p><p>记录并生成 <code>OopMap</code> 的这些 “特定位置” 被称为 <strong>安全点</strong>。</p><blockquote><p>当用户线程执行到安全点后，才允许暂停用户线程，执行 <code>GC</code> 线程进行 <code>GC</code>。</p></blockquote><p>如果一段代码中，对象引用关系不会发生变化，这段代码区域中任何地方开始 <code>GC</code> 都是安全的，那么这个区域称为 <strong>安全区域</strong>。</p><h4 id="_1-2-3-引用分类" tabindex="-1"><a class="header-anchor" href="#_1-2-3-引用分类" aria-hidden="true">#</a> 1.2.3 引用分类</h4><h5 id="_1-2-3-1-强引用" tabindex="-1"><a class="header-anchor" href="#_1-2-3-1-强引用" aria-hidden="true">#</a> 1.2.3.1 强引用</h5><p>类似于 <code>Foo foo = new Foo()</code> 这样的，称 <code>new</code> 出来的对象被强引用了。</p><p>被强引用的对象，在每次 <code>GC</code> 时都不会被回收。</p><h5 id="_1-2-3-2-软引用" tabindex="-1"><a class="header-anchor" href="#_1-2-3-2-软引用" aria-hidden="true">#</a> 1.2.3.2 软引用</h5><p>类似于 <code>SoftReference&lt;Foo&gt; sRef = new SoftReference&lt;&gt;(new Foo())</code> 这样的，称 <code>new</code> 出来的对象被软引用了。</p><p>被软引用的对象，当 <code>GC</code> 时，在内存不够用的情况下才会被回收。</p><h5 id="_1-2-3-3-弱引用" tabindex="-1"><a class="header-anchor" href="#_1-2-3-3-弱引用" aria-hidden="true">#</a> 1.2.3.3 弱引用</h5><p>类似于 <code>WeakReference&lt;Foo&gt; wRef = new WeakReference&lt;&gt;(new Foo())</code> 这样的，称 <code>new</code> 出来的对象被弱引用了。</p><p>被弱引用的对象，在每次 <code>GC</code> 时都会被回收。</p><h5 id="_1-2-3-4-虚引用-幽灵引用" tabindex="-1"><a class="header-anchor" href="#_1-2-3-4-虚引用-幽灵引用" aria-hidden="true">#</a> 1.2.3.4 虚引用（幽灵引用）</h5><p>类似于 <code>PhantomReference&lt;Foo&gt; wRef = new PhantomReference&lt;&gt;(new Foo(), referenceQueue)</code> 这样的，称 <code>new</code> 出来的对象被虚引用了。</p><p>虚引用也称为幽灵引用或幻影引用，是最弱的引用。</p><p>被虚引用的对象，在每次 <code>GC</code> 时都会被回收。</p><h5 id="_1-2-3-5-示例-gc-对软引用和弱引用的影响-finalize-referencequeue" tabindex="-1"><a class="header-anchor" href="#_1-2-3-5-示例-gc-对软引用和弱引用的影响-finalize-referencequeue" aria-hidden="true">#</a> 1.2.3.5 示例：<code>GC</code> 对软引用和弱引用的影响（<code>finalize()</code> &amp; <code>ReferenceQueue</code>）</h5><ol><li><p><code>GC</code> 对软引用的影响</p><p><img src="/assets/03.1d00c99a.png" alt="" loading="lazy"></p><blockquote><ol><li><p>当垃圾收集器准备回收某个对象时 ，会调用该对象的 <code>finalize()</code> 方法。但是，调用该方法，也并不代表着垃圾收集器一定会回收该对象。</p></li><li><p>当垃圾收集器回收了被软引用的对象后，相关的软引用会放到 <code>ReferenceQueue</code> 队列中。注意：<code>ReferenceQueue</code> 中保存的是 <code>Reference</code> 本身，而不是 <code>Reference</code> 中引用的对象。</p></li></ol></blockquote></li><li><p><code>GC</code> 对弱引用的影响</p><p><img src="/assets/04.a3884136.png" alt="" loading="lazy"></p></li></ol><h4 id="_1-2-4-跨代引用" tabindex="-1"><a class="header-anchor" href="#_1-2-4-跨代引用" aria-hidden="true">#</a> 1.2.4 跨代引用</h4><p>跨代引用：就是一个代中的对象引用了另一个代中的对象。如：</p><ol><li>新生代中的对象引用了老年代中的对象；</li><li>老年代中的对象引用了新生代中的对象。</li></ol><p>跨代引用假说：跨代引用相对于同代引用来说只是极少数的。</p><blockquote><p>隐含推论 ：存在互相引用关系的两个对象，应该是倾向于同时生存或同时消亡的。具体为：</p><ol><li><p>当两个对象处于同一代中时，它们之间的引用就是同代引用，互相同代引用的两个对象，它们之间倾向于同时生存或同时消亡。</p></li><li><p>当两个对象不处于同一代中时，它们之间的引用就是跨代引用。此时，当老年代中的对象引用了新生代中的对象时，新生代中的对象不会被回收，而是会被转存到老年代中。也就是说，互相跨带引用的两个对象，经过多次 <code>GC</code> 后，最终会转为互相同代引用。</p></li></ol></blockquote><h5 id="_1-2-4-1-跨代引用造成的问题" tabindex="-1"><a class="header-anchor" href="#_1-2-4-1-跨代引用造成的问题" aria-hidden="true">#</a> 1.2.4.1 跨代引用造成的问题</h5><p>当进行垃圾回收时，为了查询跨代引用，不仅要扫描新生代中的对象，还要扫描老年代中的对象，这样才能判断存在着多少个新生代中的对象和老年代中的对象之间的跨代引用。</p><p>但是，这样做的话就会极大地影响垃圾回收的性能。为了解决这个问题，引入了新的数据结构：<strong>记忆集</strong>。</p><h5 id="_1-2-4-2-记忆集-解决跨代引用造成的问题" tabindex="-1"><a class="header-anchor" href="#_1-2-4-2-记忆集-解决跨代引用造成的问题" aria-hidden="true">#</a> 1.2.4.2 记忆集（解决跨代引用造成的问题）</h5><p>记忆集（<code>Remembered Set</code>）：一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。</p><blockquote><p>可以理解为，记忆集中记录了存在跨代引用的新生代对象和老年代对象的内存地址，当进行垃圾回收时，只需要判断记忆集中记录的存在跨代引用的对象是否为垃圾即可。</p></blockquote><h6 id="_1-2-4-2-1-实现记忆集的三种方式" tabindex="-1"><a class="header-anchor" href="#_1-2-4-2-1-实现记忆集的三种方式" aria-hidden="true">#</a> 1.2.4.2.1 实现记忆集的三种方式</h6><p>实现记忆集这种数据结构所采用的三种方式：</p><ol><li><p>字长精度：每个记录精确到一个机器字长，该字包含跨代指针。</p></li><li><p>对象精度：每个记录精确到一个对象，该对象里有字段含有跨代指针。</p></li><li><p>卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。</p></li></ol><h6 id="_1-2-4-2-2-卡表-card-table-记忆集的具体实现" tabindex="-1"><a class="header-anchor" href="#_1-2-4-2-2-卡表-card-table-记忆集的具体实现" aria-hidden="true">#</a> 1.2.4.2.2 卡表（<code>Card Table</code>，记忆集的具体实现）</h6><p>卡表是记忆集的一种具体实现，定义了记忆集的记录精度与堆内存的映射关系。</p><blockquote><p>卡表采用了卡精度实现记忆集这种数据结构。</p></blockquote><h6 id="_1-2-4-2-2-卡页-card-page-卡表的组成元素" tabindex="-1"><a class="header-anchor" href="#_1-2-4-2-2-卡页-card-page-卡表的组成元素" aria-hidden="true">#</a> 1.2.4.2.2 卡页（<code>Card Page</code>，卡表的组成元素）</h6><p>卡表的每个元素都对应着其标识的内存区域中的一块特定大小的内存块。这个内存块称为卡页。</p><blockquote><p>也就是说，卡表由卡页组成，每个卡页中保存了多个对象。</p></blockquote><p>当某个卡页中的对象存在跨代引用时，就会记录下来。当进行垃圾回收时，会将这些记录了的对象筛选出来，通过根搜索算法来判定它们是否为垃圾。</p><h6 id="_1-2-4-2-3-写屏障" tabindex="-1"><a class="header-anchor" href="#_1-2-4-2-3-写屏障" aria-hidden="true">#</a> 1.2.4.2.3 写屏障</h6><p>卡表中记录了对象间的引用关系，那么当对象间的引用关系发生变化时，卡表中的数据记录状态也应该随着改变。那么由谁来维护卡表的数据记录状态？什么时候来改变卡表中的数据记录状态？答：在 <code>HotSpot</code> 虚拟机中，是通过 <strong>写屏障</strong> 这种技术来维护卡表中的数据记录状态的。</p><p>写屏障可以看成是 <code>JVM</code> 对 “引用类型字段赋值” 这个动作的 <code>AOP</code>。</p><blockquote><p>所谓的对 “引用类型字段赋值” 这个动作的 <code>AOP</code>，就是说，<code>JVM</code> 会在 “引用类型字段赋值” 前后额外地添加一些程序，达到维护卡表的目的。其中：</p><ol><li><p><code>JVM</code> 在 “引用类型字段赋值” 这个动作之前添加程序，称为 <strong>写前屏障</strong>。</p></li><li><p><code>JVM</code> 在 “引用类型字段赋值” 这个动作之后添加程序，称为 <strong>写后屏障</strong>。</p></li></ol></blockquote><h4 id="_1-2-5-判定是否为垃圾的步骤" tabindex="-1"><a class="header-anchor" href="#_1-2-5-判定是否为垃圾的步骤" aria-hidden="true">#</a> 1.2.5 判定是否为垃圾的步骤</h4><p>判定是否为垃圾的步骤为：</p><ol><li><p>先通过根搜索算法判定对象是否可用；</p></li><li><p>对于不可用的对象，再看是否有必要执行 <code>finalize()</code> 方法；</p></li><li><p>以上两步执行完后，如果对象仍然没有被使用，那么该对象就属于垃圾。</p><blockquote><p>通过第 <code>1</code>、<code>2</code> 步判定对象是否为垃圾时，存在两种情况：</p><ol><li><p>通过根搜索算法判定对象不在任何一条引用链上；且没必要执行 <code>finalize()</code> 方法；</p></li><li><p>通过根搜索方法判定对象不在任何一条引用链上；且执行 <code>finalize()</code> 方法时，没有进行对象的自救。</p></li></ol><p>如果执行完第 <code>1</code>、<code>2</code> 步，且满足以上两种情况，同时对象仍然没有被使用，那么该对象就是垃圾。</p></blockquote></li></ol><h5 id="_1-2-5-1-finalize-方法" tabindex="-1"><a class="header-anchor" href="#_1-2-5-1-finalize-方法" aria-hidden="true">#</a> 1.2.5.1 <code>finalize()</code> 方法</h5><p><code>finalize()</code> 方法会在对象 <strong>第一次</strong> 进行垃圾回收时调用。</p><blockquote><p>但是，如果对象没有重写 <code>finalize()</code> 方法，或者 <code>JVM</code> 已经调用过 <code>finalize()</code> 方法了，那么就没必要在第一次回收时再调用 <code>finalize()</code> 方法了。</p></blockquote><p>如果 <code>finalize()</code> 方法在第一次回收时调用了，那么我们可以在对象的 <code>finalize()</code> 方法中进行 <strong>对象的自救</strong>。</p><blockquote><p>注意：<code>finalize()</code> 方法并不靠谱，<code>Java</code> 中不建议使用 <code>finalize()</code> 方法。</p></blockquote><h5 id="_1-2-5-2-示例-通过-finalize-方法实现对象的自救" tabindex="-1"><a class="header-anchor" href="#_1-2-5-2-示例-通过-finalize-方法实现对象的自救" aria-hidden="true">#</a> 1.2.5.2 示例：通过 <code>finalize()</code> 方法实现对象的自救</h5><p><img src="/assets/05.404738cc.png" alt="" loading="lazy"></p><h3 id="_1-3-如何回收垃圾" tabindex="-1"><a class="header-anchor" href="#_1-3-如何回收垃圾" aria-hidden="true">#</a> 1.3 如何回收垃圾</h3><h4 id="_1-3-1-gc-类型" tabindex="-1"><a class="header-anchor" href="#_1-3-1-gc-类型" aria-hidden="true">#</a> 1.3.1 <code>GC</code> 类型</h4><h5 id="_1-3-1-1-minorgc-younggc" tabindex="-1"><a class="header-anchor" href="#_1-3-1-1-minorgc-younggc" aria-hidden="true">#</a> 1.3.1.1 <code>MinorGC</code>（<code>YoungGC</code>）</h5><p>发生在新生代的收集动作（<code>GC</code>）。</p><h5 id="_1-3-1-2-majorgc-oldgc" tabindex="-1"><a class="header-anchor" href="#_1-3-1-2-majorgc-oldgc" aria-hidden="true">#</a> 1.3.1.2 <code>MajorGC</code>（<code>OldGC</code>）</h5><p>发生在老年代的 <code>GC</code>。</p><blockquote><p>目前只有 <code>CMS</code> 收集器会有单独收集老年代的行为。</p></blockquote><h5 id="_1-3-1-3-mixedgc" tabindex="-1"><a class="header-anchor" href="#_1-3-1-3-mixedgc" aria-hidden="true">#</a> 1.3.1.3 <code>MixedGC</code></h5><p>收集整个新生代以及部分老年代。</p><blockquote><p>目前只有 <code>G1</code> 收集器会有这种行为。</p></blockquote><h5 id="_1-3-1-4-fullgc" tabindex="-1"><a class="header-anchor" href="#_1-3-1-4-fullgc" aria-hidden="true">#</a> 1.3.1.4 <code>FullGC</code></h5><p>收集整个 <code>Java</code> 堆和方法区的 <code>GC</code>。</p><blockquote><p>注意：方法区中也可以进行垃圾回收。</p></blockquote><h4 id="_1-3-2-stw-stop-the-world" tabindex="-1"><a class="header-anchor" href="#_1-3-2-stw-stop-the-world" aria-hidden="true">#</a> 1.3.2 <code>STW</code>（<code>Stop-The-World</code>）</h4><p><code>STW</code> 是 <code>Java</code> 中的一种全局暂停的现象，多半是由 <code>GC</code> 引起的。</p><blockquote><p>所谓全局暂停就是 <code>Java</code> 代码停止运行。不过 <code>native</code> 代码可以执行，但不能和 <code>JVM</code> 交互。</p></blockquote><p><code>STW</code> 的危害是长时间服务停止，没有响应。对于 <code>HA</code> 系统，可能引起主备切换，严重危害生产环境。</p><blockquote><p>对虚拟机的优化，应该要尽量避免 <code>STW</code>，或者尽量缩减 <code>STW</code> 的耗时时长。</p></blockquote><h4 id="_1-3-3-判定类无用的条件" tabindex="-1"><a class="header-anchor" href="#_1-3-3-判定类无用的条件" aria-hidden="true">#</a> 1.3.3 判定类无用的条件</h4><p>判定类无用的条件有：</p><ol><li><code>JVM</code> 中该类的所有实例都已经被回收；</li><li>加载该类的 <code>ClassLoader</code> 已经被回收；</li><li>没有任何地方引用该类的 <code>Class</code> 对象；</li><li>无法在任何地方通过反射访问这个类。</li></ol><h4 id="_1-3-4-垃圾收集类型" tabindex="-1"><a class="header-anchor" href="#_1-3-4-垃圾收集类型" aria-hidden="true">#</a> 1.3.4 垃圾收集类型</h4><h5 id="_1-3-4-1-串行收集" tabindex="-1"><a class="header-anchor" href="#_1-3-4-1-串行收集" aria-hidden="true">#</a> 1.3.4.1 串行收集</h5><p>单个 <code>GC</code> 线程进行内存回收，会暂停所有的用户线程。</p><blockquote><p>如：<code>Serial</code>。</p></blockquote><h5 id="_1-3-4-2-并行收集" tabindex="-1"><a class="header-anchor" href="#_1-3-4-2-并行收集" aria-hidden="true">#</a> 1.3.4.2 并行收集</h5><p>多个 <code>GC</code> 线程进行内存回收，会暂停所有的用户线程。</p><blockquote><p>如：<code>Parallel</code></p></blockquote><h5 id="_1-3-4-3-并发收集" tabindex="-1"><a class="header-anchor" href="#_1-3-4-3-并发收集" aria-hidden="true">#</a> 1.3.4.3 并发收集</h5><p><code>GC</code> 线程和用户线程同时执行（不一定是并行，可以是交替执行），不需要暂停用户线程。</p><blockquote><p>如：<code>CMS</code>。</p></blockquote><h4 id="_1-3-5-垃圾回收算法" tabindex="-1"><a class="header-anchor" href="#_1-3-5-垃圾回收算法" aria-hidden="true">#</a> 1.3.5 垃圾回收算法</h4><h5 id="_1-3-5-1-标记清除算法-mark-sweep" tabindex="-1"><a class="header-anchor" href="#_1-3-5-1-标记清除算法-mark-sweep" aria-hidden="true">#</a> 1.3.5.1 标记清除算法（<code>Mark-Sweep</code>）</h5><p>标记清除算法分为标记和清除两个阶段：</p><ol><li>先标记出要回收的对象；</li><li>然后统一回收这些对象。</li></ol><p><img src="/assets/06.f20ca60b.png" alt="" loading="lazy"></p><p>标记清除算法的优缺点：</p><ol><li><p>优点：简单。</p></li><li><p>缺点：</p><ol><li><p>效率不高，标记和清除的效率都不高；</p></li><li><p>标记清除后会产生大量不连续的内存碎片，从而导致在分配大对象时触发 <code>GC</code>。</p><blockquote><p>被标记的对象可能存放在各个不连续的内存空间中，那么清除这些内存空间后，就会产生多个不连续的未使用的内存空间（即 <strong>内存碎片</strong>）。由于未使用的内存空间是不连续的，因此无法存放下需要连续内存空间的大对象，从而导致在分配大对象时仍然会触发 <code>GC</code>。</p></blockquote></li></ol></li></ol><h5 id="_1-3-5-2-复制算法-copying-一般在新生代中使用" tabindex="-1"><a class="header-anchor" href="#_1-3-5-2-复制算法-copying-一般在新生代中使用" aria-hidden="true">#</a> 1.3.5.2 复制算法（<code>Copying</code>，一般在新生代中使用）</h5><p>复制算法：把内存分成两块完全相同的区域，每次使用其中一块。当一块使用完了，就把这块上还存活的对象拷贝到另一块中，然后把这块清除掉。</p><blockquote><p>新生代中，存活区内的 <code>from space</code> 和 <code>to space</code> 就是采用了复制算法。</p></blockquote><p><img src="/assets/07.e6e9c2c8.png" alt="" loading="lazy"></p><p>复制算法的优缺点：</p><ol><li><p>优点：实现简单，运行高效，避免了内存碎片的产生。</p></li><li><p>缺点：由于复制算法中，有一半的内存区域是保留的，所以造成了内存浪费。</p></li></ol><p><code>JVM</code> 实际实现中，是将内存分为一块较大的 <code>Eden</code> 区，和两块较小的 <code>Survivor</code> 区（<code>from</code> 和 <code>to</code>）。每次使用 <code>Eden</code> 和一块 <code>Survivor</code>。在回收时，把存活的对象复制到另一块 <code>Survivor</code> 中。</p><blockquote><p><code>HotSpot</code> 虚拟机默认的 <code>Eden</code> 和 <code>Survivor</code> 的比值是 <code>8:1</code>，也就是每次能用 <code>90%</code> 的新生代空间。</p><div class="language-text ext-text"><pre class="language-text"><code>Eden:Survivor = 8:1，即 Eden:from:to = 8:1:1，
于是，可使用的新生代空间为：(Eden+from)/(Eden+from+to) = 9/10 = 90%
</code></pre></div></blockquote><p>在回收时，把存活的对象复制到另一块 <code>Survivor</code> 时，如果发现另一块 <code>Survivor</code> 空间不够，就要依赖老年代进行 <strong>分配担保</strong>，让放不下的对象直接进入老年代。</p><h6 id="_1-3-5-2-1-分配担保" tabindex="-1"><a class="header-anchor" href="#_1-3-5-2-1-分配担保" aria-hidden="true">#</a> 1.3.5.2.1 分配担保</h6><p>分配担保就是指：当新生代进行垃圾回收后，新生代的存活区放置不下，那么需要把这些对象放置到老年代中，此时，就需要担保老年代中有足够的内存空间来放置这些对象。</p><blockquote><p>“新生代的存活区放置不下这些对象” 有两种情况：</p><ol><li><p><code>eden</code> 区 + 一个 <code>Survivor</code> 区（<code>from space</code>），对这两个区进行回收后，其中存活下来的对象过多，无法全部放到另一个 <code>Survivor</code> 区（<code>to space</code>）中；</p></li><li><p><code>eden</code> 区 + 一个 <code>Survivor</code> 区（<code>from space</code>），对这两个区进行回收后，当新生代为新的对象分配内存空间时，无法在新生代中找到足够大的空间来存放这个较大的新对象。</p></li></ol><p>以上两种情况中，无法放置到新生代中的这些对象，都需要将它们放置到老年代中去。</p></blockquote><p>分配担保是一种策略，其过程如下：</p><ol><li><p>在发生 <code>MinorGC</code> 前，<code>JVM</code> 会检查老年代的最大可用连续空间是否大于新生代中所有对象的总空间：</p><ol><li><p>如果大于，那么可以确保 <code>MinorGC</code> 是安全的；</p></li><li><p>如果小于，那么 <code>JVM</code> 会继续检查是否设置了允许担保失败：</p><ol><li><p>如果允许担保失败，那么继续检查老年代的最大可用连续空间是否大于历次放置到老年代中的对象的平均大小：</p><ol><li><p>如果大于，那么尝试进行一次 <code>MinorGC</code>；</p></li><li><p>如果不大于，那么改做一次 <code>Full GC</code>。</p></li></ol></li></ol></li></ol></li></ol><h5 id="_1-3-5-3-标记整理算法-mark-compact-一般在老年代中使用" tabindex="-1"><a class="header-anchor" href="#_1-3-5-3-标记整理算法-mark-compact-一般在老年代中使用" aria-hidden="true">#</a> 1.3.5.3 标记整理算法（<code>Mark-Compact</code>，一般在老年代中使用）</h5><p>由于复制算法在存活对象比较多的时候，效率较低、且有空间浪费，因此老年代一般不会选用复制算法，而是多选用标记整理算法。</p><p>标记整理算法的标记过程跟标记清除算法的标记过程一样，但标记整理算法的后续不是直接清除可回收的对象，而是让所有存活的对象都向一端移动，于是，端边界以外的内存中只留下了可回收的对象，此时直接清除端边界以外的内存即可。</p><p><img src="/assets/08.74a12699.png" alt="" loading="lazy"></p><h2 id="_2-垃圾收集器" tabindex="-1"><a class="header-anchor" href="#_2-垃圾收集器" aria-hidden="true">#</a> 2. 垃圾收集器</h2><h3 id="_2-1-概述" tabindex="-1"><a class="header-anchor" href="#_2-1-概述" aria-hidden="true">#</a> 2.1 概述</h3><p>垃圾收集算法是内存回收所采用的方法。而垃圾收集器则是垃圾收集算法的具体实现，通过垃圾收集器实现对内存的回收。</p><p>不同厂商、不同虚拟机版本中，垃圾收集器的实现有很大差别。</p><p><code>HotSpot</code> 虚拟机中包含的垃圾收集器如下图所示：</p><p><img src="/assets/09.aa05314a.png" alt="" loading="lazy"></p><p>其中：</p><ol><li><p><code>Serial</code> 和 <code>Serial old</code> 都是串行收集器；</p></li><li><p><code>ParNew</code> 和 <code>Parallel old</code> 都是并行收集器；</p></li><li><p><code>G1</code> 是新生代和老年代都可以使用的收集器；</p></li><li><p>新生代中的 <code>Serial</code> 收集器可以和老年代中的 <code>Serial old</code> 收集器组合使用；</p></li><li><p>新生代中的 <code>ParNew</code> 收集器可以和老年代中的 <code>CMS</code> 收集器组合使用；</p></li><li><p>新生代中的 <code>Parallel Scavenge</code> 收集器可以和老年代中的 <code>Serial old</code> 或 <code>Parallel old</code> 收集器组合使用；</p></li><li><p>老年代中的 <code>CMS</code> 收集器可以和 <code>Serial old</code> 收集器配合使用。</p><blockquote><p>如：当 <code>CMS</code> 收集器无法正常使用时，使用 <code>Serial old</code> 收集器接替工作。</p></blockquote></li><li><p><code>G1</code> 收集器既可以处理新生代的垃圾回收，又可以处理老年代的垃圾回收。</p><blockquote><p>所以 <code>G1</code> 收集器不需要和其他收集器组合使用。</p></blockquote></li></ol><h3 id="_2-2-串行收集器-serial-新生代-serial-old-老年代" tabindex="-1"><a class="header-anchor" href="#_2-2-串行收集器-serial-新生代-serial-old-老年代" aria-hidden="true">#</a> 2.2 串行收集器（<code>Serial</code>（新生代）/ <code>Serial old</code>（老年代））</h3><p><img src="/assets/10.5c3c1298.png" alt="" loading="lazy"></p><p>串行收集器的说明：</p><ol><li><p>新生代中的 <code>Serial</code> 收集器和老年代中的 <code>Serial old</code> 收集器都是串行收集器，串行收集器就是单线程的收集器；</p></li><li><p>在垃圾回收时，串行收集器会 <code>STW</code>（<code>Stop-the-World</code>）。</p></li><li><p>串行收集器的优点是简单，对于单 <code>CPU</code> 来说，由于没有多线程的交互开销，可能更高效。</p></li><li><p><code>Serial</code> 收集器是默认的 <code>Client</code> 模式下的新生代收集器。</p></li><li><p>通过设置参数 <code>-XX:+UseSerialGC</code> 开启串行收集器，此时，会采用 <code>Serial</code> + <code>Serial old</code> 的收集器组合。</p></li><li><p>新生代中的串行收集器 <code>Serial</code> 采用复制算法；老年代中的串行收集器 <code>Serial old</code> 采用标记整理算法。</p></li></ol><h4 id="_2-2-1-示例-serial-serial-old-组合的配置-xx-useserialgc" tabindex="-1"><a class="header-anchor" href="#_2-2-1-示例-serial-serial-old-组合的配置-xx-useserialgc" aria-hidden="true">#</a> 2.2.1 示例：<code>Serial</code> + <code>Serial old</code> 组合的配置（<code>-XX:+UseSerialGC</code>）</h4><p><img src="/assets/11.1788aed2.png" alt="" loading="lazy"></p><h3 id="_2-3-并行收集器-parnew-新生代" tabindex="-1"><a class="header-anchor" href="#_2-3-并行收集器-parnew-新生代" aria-hidden="true">#</a> 2.3 并行收集器（<code>ParNew</code>（新生代））</h3><p><img src="/assets/12.da4c19dd.png" alt="" loading="lazy"></p><p>并行收集器 <code>ParNew</code> 的说明：</p><ol><li><p><code>ParNew</code> 收集器是新生代中的并行收集器，与 <code>Serial</code> 收集器的最大区别是：<code>ParNew</code> 收集器会使用多个 <code>GC</code> 线程进行新生代中的垃圾回收；</p></li><li><p><code>ParNew</code> 收集器在垃圾回收时会 <code>STW</code>（<code>Stop-the-World</code>）。</p></li><li><p>在并发能力好的 <code>CPU</code> 环境中，<code>ParNew</code> 并行收集器的停顿时间要比 <code>Serial</code> 串行收集器短；但对于单 <code>CPU</code> 或并发能力较弱的 <code>CPU</code>，由于多线程的交互开销，<code>ParNew</code> 并行收集器可能比 <code>Serial</code> 串行收集器更差。</p></li><li><p>并行收集器 <code>ParNew</code> 是 <code>Server</code> 模式下首选的新生代收集器；</p></li><li><p><strong>新生代中的并行收集器 <code>ParNew</code> 通常与老年代中的 <code>CMS</code> 收集器组合使用</strong>。</p><blockquote><p>当设置参数 <code>-XX:+UseConcMarkSweepGC</code>，指定老年代使用 <code>CMS</code> 收集器时，新生代就会使用 <code>ParNew</code> 收集器。</p><p>（不再使用参数 <code>-XX:+UseParNewGC</code> 来单独开启 <code>ParNew</code> 收集器）</p></blockquote></li><li><p>通过设置参数 <code>-XX:ParallelGCThreads</code>，指定并行收集器 <code>ParNew</code> 的 <code>GC</code> 线程数。（最好与 <code>CPU</code> 数量一致）</p></li><li><p>并行收集器 <code>ParNew</code> 只在新生代中使用，采用复制算法。</p></li></ol><h4 id="_2-3-1-示例-parnew-cms-组合的配置-xx-useconcmarksweepgc" tabindex="-1"><a class="header-anchor" href="#_2-3-1-示例-parnew-cms-组合的配置-xx-useconcmarksweepgc" aria-hidden="true">#</a> 2.3.1 示例：<code>ParNew</code> + <code>CMS</code> 组合的配置（<code>-XX:+UseConcMarkSweepGC</code>）</h4><p><img src="/assets/13.1232deec.png" alt="" loading="lazy"></p><h3 id="_2-4-并行收集器-parallel-scavenge-新生代-parallel-old-老年代" tabindex="-1"><a class="header-anchor" href="#_2-4-并行收集器-parallel-scavenge-新生代-parallel-old-老年代" aria-hidden="true">#</a> 2.4 并行收集器（<code>Parallel Scavenge</code>（新生代）/ <code>Parallel old</code>（老年代））</h3><p><img src="/assets/14.eb3e45da.png" alt="" loading="lazy"></p><p>说明：</p><ol><li><p>并行收集器 <code>Parallel Scavenge</code> 只在新生代中使用，采用复制算法；并行收集器 <code>Parallel old</code> 只在老年代中使用，采用标记整理算法。</p></li><li><p>新生代中的 <code>Parallel Scavenge</code> 并行收集器跟 <code>ParNew</code> 很类型，但 <code>Parallel Scavenge</code> 更关注吞吐量，能最高效率的利用 <code>CPU</code>，适合运行后台应用。</p></li><li><p>通过设置参数 <code>-XX:+UseParallelGC</code>，或者设置参数 <code>-XX:+UseParallelOldGC</code>，都会使用 <code>Parallel Scavenge</code> + <code>Parallel old</code> 的收集器组合。</p></li><li><p>通过设置参数 <code>-XX:MaxGCPauseMillis</code>，配置 <code>GC</code> 的最大停顿时间。</p></li></ol><h4 id="_2-4-1-示例-parallel-scavenge-parallel-old-组合的配置-xx-useparallelgc-或-xx-useparalleloldgc" tabindex="-1"><a class="header-anchor" href="#_2-4-1-示例-parallel-scavenge-parallel-old-组合的配置-xx-useparallelgc-或-xx-useparalleloldgc" aria-hidden="true">#</a> 2.4.1 示例：<code>Parallel Scavenge</code> + <code>Parallel old</code> 组合的配置（<code>-XX:+UseParallelGC</code> 或 <code>-XX:+UseParallelOldGC</code>）</h4><p><img src="/assets/15.77dd81b3.png" alt="" loading="lazy"></p><p><img src="/assets/16.f0809ca6.png" alt="" loading="lazy"></p><h3 id="_2-5-并发收集器-cms-concurrent-mark-and-sweep-并发标记清除" tabindex="-1"><a class="header-anchor" href="#_2-5-并发收集器-cms-concurrent-mark-and-sweep-并发标记清除" aria-hidden="true">#</a> 2.5 并发收集器（<code>CMS</code>，<code>Concurrent Mark and Sweep</code> 并发标记清除）</h3><p>前面介绍的收集器（<code>Serial</code>、<code>Serial old</code>、<code>ParNew</code>、<code>Parallel Scavenge</code>、<code>Parallel old</code>）都是串行收集器或并行收集器，而这里介绍的老年代中的 <code>CMS</code> 收集器则是 <strong>并发</strong> 收集器。其中：</p><ol><li><p>所谓串行，就是指垃圾回收时，暂停用户线程，只开启一个 <code>GC</code> 线程进行垃圾回收；</p></li><li><p>所谓并行，就是指垃圾回收时，暂停用户线程，开启多个 <code>GC</code> 线程进行垃圾回收。</p></li><li><p>所谓并发，就是指垃圾回收时，不暂停 用户线程，可以开启多个 <code>GC</code> 线程进行垃圾回收。</p><blockquote><p>也就是说，“并发” 就意味着用户线程和 <code>GC</code> 线程可以同时运行。</p></blockquote></li></ol><p>另外，前面介绍的老年代中的 <code>Serial old</code> 和 <code>Parallel old</code> 收集器都是采用标记整理算法，而老年代中的 <code>CMS</code> 收集器则是采用 <strong>标记清除算法</strong>。</p><p><code>CMS</code> 收集器的工作过程可划分为四个阶段：</p><ol><li><p>初始标记阶段：只标记 <code>GC Roots</code> 能直接关联到的对象。</p></li><li><p>并发标记阶段：进行 <code>GC Roots Tracing</code> 的过程。</p></li><li><p>重新标记阶段：修正并发标记期间，因程序运行导致标记发生变化的那一部分对象。</p></li><li><p>并发清除阶段：并发回收垃圾对象。</p></li></ol><p><img src="/assets/17.a3515d03.png" alt="" loading="lazy"></p><p>注意：</p><ol><li><p>在 <code>CMS</code> 的工作过程中，只有并发标记阶段和并发清除阶段中的线程是与用户线程同时运行的。在初始标记阶段和重新标记阶段中还是会暂停用户线程，即这两个阶段中可能会发生 <code>STW</code>（<code>Stop-the-World</code>）。</p></li><li><p>运行示意图中，最后的重置线程，指的是清空跟收集相关的数据并重置，为下一次收集做准备。</p></li></ol><p><code>CMS</code> 收集器的优缺点：</p><ol><li><p>优点：低停顿、并发执行。</p></li><li><p>缺点：</p><ol><li>并发执行，对 <code>CPU</code> 资源压力大；</li><li>无法处理在处理过程中产生的垃圾，可能导致 <code>FullGC</code>；</li><li>采用的标记清除算法会导致大量的内存碎片，从而在分配大对象时可能触发 <code>FullGC</code>。</li></ol></li></ol><p><code>CMS</code> 收集器的相关参数配置：</p><ol><li><p><code>-XX:+UseConcMarkSweepGC</code>：使用 <code>ParNew</code> + <code>CMS</code> + <code>Serial old</code> 的收集器组合。</p><blockquote><p>其中，<code>Serial old</code> 收集器将作为 <code>CMS</code> 出错时的后备收集器。</p></blockquote></li><li><p><code>-XX:CMSInitiatingOccupancyFraction</code>：设置在老年代的内存空间被使用多少后触发 <code>CMS</code> 收集器进行垃圾回收。</p><blockquote><p>默认是 <code>80%</code>。</p></blockquote></li></ol><h3 id="_2-6-g1-收集器-garbage-first" tabindex="-1"><a class="header-anchor" href="#_2-6-g1-收集器-garbage-first" aria-hidden="true">#</a> 2.6 <code>G1</code> 收集器（<code>Garbage-First</code>）</h3><h4 id="_2-6-1-g1-收集器的特点" tabindex="-1"><a class="header-anchor" href="#_2-6-1-g1-收集器的特点" aria-hidden="true">#</a> 2.6.1 <code>G1</code> 收集器的特点</h4><p><code>G1</code> 收集器是一款面向服务端应用的收集器，与其他收集器相比，具有如下特点：</p><ol><li><p><code>G1</code> 收集器把内存划分为多个独立的区域（<code>Region</code>）。</p></li><li><p><code>G1</code> 收集器仍采用分代思想，保留了新生代和老年代，但它们不再是物理隔离的，而是一部分 <code>Region</code> 的集合。且不需要 <code>Region</code> 是连续的。</p><blockquote><p>前面介绍的垃圾收集器都是采用分代思想，且在内存的物理结构上，将内存 划分为新生代和老年代。</p></blockquote></li><li><p><code>G1</code> 收集器能充分利用多 <code>CPU</code>、多核环境硬件优势，尽量缩短 <code>STW</code>。</p></li><li><p><code>G1</code> 收集器整体上采用标记整理算法，局部采用复制算法，不会产生内存碎片。</p></li><li><p><code>GC</code> 收集器的停顿可预测，能明确地指定：在一个时间段内，消耗在垃圾收集上的时间不能超过多长时间。</p></li><li><p><code>G1</code> 收集器跟踪各个 <code>Region</code> 里面垃圾堆的价值大小，在后台维护一个优先列表，每次根据允许的时间来回收价值最大的区域，从而保证在有限时间内的高效收集。</p><blockquote><p>所谓 “回收价值最大” 的区域，就是指垃圾对象存放最多的区域。因为回收这样的区域中的垃圾对象，释放后得到的可用内存空间最多。</p></blockquote></li><li><p><code>G1</code> 收集器一般不会进行 <code>FullGC</code>。通常是进行整个新生代区域的回收，以及部分回收价值最大的老年代区域的回收。也就是进行 <code>Mixed GC</code>。</p></li></ol><h4 id="_2-6-2-g1-收集器定义的五种类型的区域-region" tabindex="-1"><a class="header-anchor" href="#_2-6-2-g1-收集器定义的五种类型的区域-region" aria-hidden="true">#</a> 2.6.2 <code>G1</code> 收集器定义的五种类型的区域（<code>Region</code>）</h4><p><code>G1</code> 收集器把内存划分为多个独立的区域（<code>Region</code>），并定义了五种不同类型的 <code>Region</code>：</p><ol><li><p><code>Eden regions</code>：新生代的 <code>Eden</code> 区。</p></li><li><p><code>Survivor regions</code>：新生代的 <code>Survivor</code> 区。</p></li><li><p><code>Old regions</code>：老年代。</p></li><li><p><code>Humongous regions</code>：巨型对象区域，专门用来存储大对象。通常也被认为是老年代的一部分。</p><blockquote><p><code>G1</code> 收集器认为只要对象的大小超过了一个 <code>Region</code> 容量的 <code>1/2</code>，即可判定为大对象。</p></blockquote></li></ol><p><img src="/assets/18.69c2455e.png" alt="" loading="lazy"></p><h4 id="_2-6-3-g1-收集器的工作过程-四个阶段" tabindex="-1"><a class="header-anchor" href="#_2-6-3-g1-收集器的工作过程-四个阶段" aria-hidden="true">#</a> 2.6.3 <code>G1</code> 收集器的工作过程（四个阶段）</h4><p>跟 <code>CMS</code> 类似，<code>G1</code> 收集器的工作过程可划分为四个阶段：</p><ol><li><p>初始标记阶段：只标记 <code>GC Roots</code> 能直接关联到的对象。</p></li><li><p>并发标记阶段：进行 <code>GC Roots Tracing</code> 的过程。</p></li><li><p>最终标记阶段：修正并发标记期间，因程序运行导致标记发生变化的那一部分对象。</p></li><li><p>筛选回收阶段：根据时间来进行价值最大化的回收。</p></li></ol><p><img src="/assets/19.fefacffe.png" alt="" loading="lazy"></p><h4 id="_2-6-4-g1-收集器的相关参数配置" tabindex="-1"><a class="header-anchor" href="#_2-6-4-g1-收集器的相关参数配置" aria-hidden="true">#</a> 2.6.4 <code>G1</code> 收集器的相关参数配置</h4><h5 id="_2-6-4-1-xx-useg1gc-使用-g1-收集器" tabindex="-1"><a class="header-anchor" href="#_2-6-4-1-xx-useg1gc-使用-g1-收集器" aria-hidden="true">#</a> 2.6.4.1 <code>-XX:+UseG1GC</code>（使用 <code>G1</code> 收集器）</h5><p>开启并使用 <code>G1</code> 收集器。</p><blockquote><p><code>JDK 13</code> 中默认使用 <code>G1</code> 收集器。</p></blockquote><h5 id="_2-6-4-2-xx-maxgcpausemillis-n-最大-gc-停顿时间" tabindex="-1"><a class="header-anchor" href="#_2-6-4-2-xx-maxgcpausemillis-n-最大-gc-停顿时间" aria-hidden="true">#</a> 2.6.4.2 <code>-XX:MaxGCPauseMillis=&lt;n&gt;</code>（最大 <code>GC</code> 停顿时间）</h5><p>这里设置的最大 <code>GC</code> 停顿时间只是软件的目标，<code>JVM</code> 将尽可能让（但不保证）停顿小于这个时间。</p><h5 id="_2-6-4-3-xx-initiatingheapoccupancypercent-n" tabindex="-1"><a class="header-anchor" href="#_2-6-4-3-xx-initiatingheapoccupancypercent-n" aria-hidden="true">#</a> 2.6.4.3 <code>-XX:InitiatingHeapOccupancyPercent=&lt;n&gt;</code></h5><p>占用了多少 <code>Java</code> 堆内存时触发 <code>GC</code>，默认为 <code>45</code>。</p><h5 id="_2-6-4-4-xx-newratio-n" tabindex="-1"><a class="header-anchor" href="#_2-6-4-4-xx-newratio-n" aria-hidden="true">#</a> 2.6.4.4 <code>-XX:NewRatio=&lt;n&gt;</code></h5><p>默认为 <code>2</code>。</p><h5 id="_2-6-4-5-xx-survivorratio-n" tabindex="-1"><a class="header-anchor" href="#_2-6-4-5-xx-survivorratio-n" aria-hidden="true">#</a> 2.6.4.5 <code>-XX:SurvivorRatio=&lt;n&gt;</code></h5><p>默认为 <code>8</code>。</p><h5 id="_2-6-4-6-xx-maxtenuringthreshold-n" tabindex="-1"><a class="header-anchor" href="#_2-6-4-6-xx-maxtenuringthreshold-n" aria-hidden="true">#</a> 2.6.4.6 <code>-XX:MaxTenuringThreshold=&lt;n&gt;</code></h5><p>新生代到老年代的岁数。默认是 <code>15</code>。</p><blockquote><p><code>15</code> 表示新生代中的某个对象在经历了 <code>15</code> 次 <code>GC</code> 后，仍然保留在新生代的存活区中，那么就会将该对象放到老年代中保存。</p></blockquote><h5 id="_2-6-4-7-xx-parallelgcthreads-n" tabindex="-1"><a class="header-anchor" href="#_2-6-4-7-xx-parallelgcthreads-n" aria-hidden="true">#</a> 2.6.4.7 <code>-XX:ParallelGCThreads=&lt;n&gt;</code></h5><p>并行 <code>GC</code> 的线程数。默认值会根据平台不同而不同。</p><h5 id="_2-6-4-8-xx-concgcthreads-n" tabindex="-1"><a class="header-anchor" href="#_2-6-4-8-xx-concgcthreads-n" aria-hidden="true">#</a> 2.6.4.8 <code>-XX:ConcGCThreads=&lt;n&gt;</code></h5><p>并发 <code>GC</code> 使用的线程数。</p><h5 id="_2-6-4-9-xx-g1reservepercent-n" tabindex="-1"><a class="header-anchor" href="#_2-6-4-9-xx-g1reservepercent-n" aria-hidden="true">#</a> 2.6.4.9 <code>-XX:G1ReservePercent=&lt;n&gt;</code></h5><p>设置作为空闲空间的预留内存百分比，以降低目标空间溢出的风险。默认值是 <code>10%</code>。</p><h5 id="_2-6-4-10-xx-g1heapregionsize-n" tabindex="-1"><a class="header-anchor" href="#_2-6-4-10-xx-g1heapregionsize-n" aria-hidden="true">#</a> 2.6.4.10 <code>-XX:G1HeapRegionSize=&lt;n&gt;</code></h5><p>设置 <code>G1</code> 区域的大小。值是 <code>2</code> 的幂，范围是 <code>1MB</code> 到 <code>32MB</code>。</p><p>目标是根据最小的 <code>Java</code> 堆大小划分出约 <code>2048</code> 个区域。</p><h3 id="_2-7-zgc-收集器" tabindex="-1"><a class="header-anchor" href="#_2-7-zgc-收集器" aria-hidden="true">#</a> 2.7 <code>ZGC</code> 收集器</h3><p><code>ZGC</code> 收集器是 <code>JDK 11</code> 加入的低延迟收集器（处于试验阶段）。</p><p><code>ZGC</code> 收集器的设计目标是：</p><ol><li>支持 <code>TB</code> 级内存容量；</li><li>暂停时间低（<code>&lt;10ms</code>）；</li><li>对整个程序吞吐量的影响小于 <code>15%</code>。</li></ol><p><code>ZGC</code> 收集器中的新技术：</p><ol><li>着色技术：</li><li>读屏障。</li></ol><h2 id="_3-gc-性能指标" tabindex="-1"><a class="header-anchor" href="#_3-gc-性能指标" aria-hidden="true">#</a> 3. <code>GC</code> 性能指标</h2><p>一款优秀的 <code>GC</code> 收集器，应该使得：</p><ol><li>吞吐量很大；</li><li><code>GC</code> 负荷很小；</li><li>暂停时间几乎没有。</li></ol><blockquote><p>交互式应用通常希望暂停时间越少越好。</p></blockquote><h3 id="_3-1-吞吐量" tabindex="-1"><a class="header-anchor" href="#_3-1-吞吐量" aria-hidden="true">#</a> 3.1 吞吐量</h3><p>吞吐量 = 应用代码执行的时间 / 运行的总时间</p><blockquote><p>其中，运行的总时间 = 应用代码执行时间 + <code>GC</code> 时间。</p></blockquote><h3 id="_3-2-gc-负荷" tabindex="-1"><a class="header-anchor" href="#_3-2-gc-负荷" aria-hidden="true">#</a> 3.2 <code>GC</code> 负荷</h3><p>与吞吐量相反，<code>GC</code> 负荷 = <code>GC</code> 时间 / 运行的总时间</p><h3 id="_3-3-暂停时间" tabindex="-1"><a class="header-anchor" href="#_3-3-暂停时间" aria-hidden="true">#</a> 3.3 暂停时间</h3><p>暂停时间就是发生 <code>STW</code>（<code>Stop-the-World</code>）的总时间。</p><h3 id="_3-4-gc-频率" tabindex="-1"><a class="header-anchor" href="#_3-4-gc-频率" aria-hidden="true">#</a> 3.4 <code>GC</code> 频率</h3><p><code>GC</code> 频率就是 <code>GC</code> 在一个时间段内发生的次数。</p><h3 id="_3-5-反应速度" tabindex="-1"><a class="header-anchor" href="#_3-5-反应速度" aria-hidden="true">#</a> 3.5 反应速度</h3><p>反应速度就是从对象成为垃圾到被回收的时间。</p><blockquote><p>并不是说反应速度越快越好。有时，反应速度快，可能意味着频繁的 <code>GC</code>。</p></blockquote><h2 id="_4-jvm-内存分配原则" tabindex="-1"><a class="header-anchor" href="#_4-jvm-内存分配原则" aria-hidden="true">#</a> 4. <code>JVM</code> 内存分配原则</h2><p><code>JVM</code> 内存分配原则如下：</p><ol><li><p>新生代尽可能设置得大点，如果太小会导致：</p><ol><li><code>YGC</code>（新生代的垃圾回收）次数更加频繁；</li><li>可能导致 <code>YGC</code> 后的对象进入老年代，如果此时老年代满了，会触发 <code>FGC</code>（即 <code>FullGC</code>）。</li></ol></li><li><p>对老年代，针对响应时间优先的应用：由于老年代通常采用并发收集器，因此老年代的大小要综合考虑并发量和并发持续时间等参数：</p><ol><li>如果老年代的大小设置小了，可能会造成内存碎片，高回收频率会导致应用暂停；</li><li>如果老年代的大小设置大了，会需要较长的回收时间。</li></ol></li><li><p>对老年代，针对吞吐量优先的应用：通常设置较大的新生代和较小的老年代。</p><blockquote><p>这样可以尽可能回收大部分短期对象，减少中期对象，而老年代尽量存放长期存活的对象。</p></blockquote></li><li><p>依据对象的存活周期进行分类，对象优先分配在新生代中，长时间存活的对象则分配在老年代中。</p></li><li><p>根据不同代的特点，选取合适的收集算法：</p><ol><li>少量对象存活，适合复制算法；</li><li>大量对象存活，适合标记清除算法，或标记整理算法。</li></ol></li></ol><!--]--></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/zengkaiqiang562/JavaGuide/edit/main/docs/zkq/java/jvm/gc.md" rel="noopener noreferrer" target="_blank" arialabel="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewbox="0 0 1024 1024" arialabelledby="edit"><title id="edit" lang="en">edit icon</title><g fill="currentColor"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></g></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item update-time"><span class="label">上次编辑于: </span><span class="info">2022/7/7 23:59:00</span></div><div class="meta-item contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: zengkaiqiang562@163.com">zengk</span><!--]--><!--]--></div></footer><nav class="page-nav"><a href="/zkq/java/jvm/class-exe-engine.html" class="nav-link prev" arialabel="字节码执行引擎"><div class="hint"><span class="arrow left"></span>上一页</div><div class="link"><!---->字节码执行引擎</div></a><a href="/zkq/java/jvm/concurrence.html" class="nav-link next" arialabel="高效并发"><div class="hint">下一页<span class="arrow right"></span></div><div class="link">高效并发<!----></div></a></nav><!----><!----></main><!--]--><footer class="footer-wrapper"><div class="footer"></div><div class="copyright">Copyright © 2023 Zenk562</div></footer></div><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app.625aa393.js" defer></script>
  </body>
</html>
