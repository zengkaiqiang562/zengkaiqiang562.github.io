<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.38" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://zengkaiqiang562.github.io/zkq/project-experiences/skill-keypoint.html"><meta property="og:site_name" content="Android Guide"><meta property="og:title" content="技能要点"><meta property="og:type" content="article"><meta property="og:image" content="https://zengkaiqiang562.github.io/"><meta property="og:updated_time" content="2022-07-10T14:36:08.000Z"><meta property="og:locale" content="zh-CN"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image:alt" content="技能要点"><meta property="article:tag" content="项目经历"><meta property="article:modified_time" content="2022-07-10T14:36:08.000Z"><script>var _hmt = _hmt || [];
      (function() {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?5dd2e8c97962d57b7b8fea1737c01743";
        var s = document.getElementsByTagName("script")[0]; 
        s.parentNode.insertBefore(hm, s);
      })();</script><link rel="stylesheet" href="//at.alicdn.com/t/font_2922463_99aa80ii7cf.css"><title>技能要点 | Android Guide</title><meta name="description" content="Android 学习 && 面试指南">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/assets/style.5a38b724.css">
    <link rel="modulepreload" href="/assets/app.625aa393.js"><link rel="modulepreload" href="/assets/skill-keypoint.html.f6bdb53f.js"><link rel="modulepreload" href="/assets/skill-keypoint.html.855959a3.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container has-toc sidebar-open"><!--[--><header class="navbar"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><a href="/" class="home-link"><img class="logo" src="/logo.png" alt="Android Guide"><!----><span class="site-name hide-in-pad">Android Guide</span><!--[--><!----><!--]--></a><nav class="nav-links" style=""><div class="nav-item hide-in-mobile"><a href="/home.html" class="nav-link" arialabel="面试指南"><i class="icon iconfont icon-java"></i>面试指南<!----></a></div><div class="nav-item hide-in-mobile"><a href="/zhuanlan/" class="nav-link" arialabel="优质专栏"><i class="icon iconfont icon-recommend"></i>优质专栏<!----></a></div><div class="nav-item hide-in-mobile"><a href="/open-source-project/" class="nav-link" arialabel="项目精选"><i class="icon iconfont icon-github"></i>项目精选<!----></a></div><div class="nav-item hide-in-mobile"><a href="https://snailclimb.gitee.io/javaguide/#/" rel="noopener noreferrer" target="_blank" arialabel="旧版链接" class="nav-link"><i class="icon iconfont icon-java"></i>旧版链接<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="nav-item hide-in-mobile"><a href="https://javaguide.cn/feed.json" rel="noopener noreferrer" target="_blank" arialabel="RSS订阅" class="nav-link"><i class="icon iconfont icon-rss"></i>RSS订阅<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="nav-item hide-in-mobile"><a href="/about-the-author/" class="nav-link" arialabel="关于作者"><i class="icon iconfont icon-zuozhe"></i>关于作者<!----></a></div></nav><div class="nav-actions-wrapper"><!--[--><!----><!--]--><div class="nav-item"><!----></div><div class="nav-item"><a class="repo-link" href="https://github.com/zengkaiqiang562/JavaGuide" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewbox="0 0 1024 1024" arialabelledby="github" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><title id="github" lang="en">github icon</title><g fill="currentColor"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></g></svg></a></div><div class="nav-item hide-in-mobile"><button id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewbox="0 0 1024 1024" arialabelledby="auto" style="display:block;"><title id="auto" lang="en">auto icon</title><g fill="currentColor"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></g></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewbox="0 0 1024 1024" arialabelledby="dark" style="display:none;"><title id="dark" lang="en">dark icon</title><g fill="currentColor"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></g></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewbox="0 0 1024 1024" arialabelledby="light" style="display:none;"><title id="light" lang="en">light icon</title><g fill="currentColor"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></g></svg></button></div><form class="search-box" role="search"><input type="search" placeholder="搜索" autocomplete="off" spellcheck="false" value><!----></form><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button><!--[--><!----><!--]--></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" arialabel="技能要点"><!---->技能要点<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_1-jni-和-ndk-开发" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1. JNI 和 NDK 开发"><!---->1. JNI 和 NDK 开发<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_2-ipc-和-binder-机制" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="2. IPC 和 Binder 机制"><!---->2. IPC 和 Binder 机制<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_2-1-linux-和-android-中的-ipc-机制" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="2.1 Linux 和 Android 中的 IPC 机制"><!---->2.1 Linux 和 Android 中的 IPC 机制<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_2-2-binder-机制" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="2.2 Binder 机制"><!---->2.2 Binder 机制<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_2-2-1-native-binder" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="2.2.1 Native Binder"><!---->2.2.1 Native Binder<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_2-2-2-java-binder" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="2.2.2 Java Binder"><!---->2.2.2 Java Binder<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_3-android-系统启动流程" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="3. Android 系统启动流程"><!---->3. Android 系统启动流程<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_4-四大组件工作过程" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="4. 四大组件工作过程"><!---->4. 四大组件工作过程<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_5-网络分层模型" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="5. 网络分层模型"><!---->5. 网络分层模型<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_5-tcp-三次握手和四次挥手" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="5. TCP 三次握手和四次挥手"><!---->5. TCP 三次握手和四次挥手<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_6-http-和-https-协议" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="6. HTTP 和 HTTPS 协议"><!---->6. HTTP 和 HTTPS 协议<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_7-realm-数据库" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="7. Realm 数据库"><!---->7. Realm 数据库<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_8-插件化动态换肤" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="8. 插件化动态换肤"><!---->8. 插件化动态换肤<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_8-1-activity-插件化" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="8.1 Activity 插件化"><!---->8.1 Activity 插件化<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_9-热修复和-sophix-热更新框架" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="9. 热修复和 Sophix 热更新框架"><!---->9. 热修复和 Sophix 热更新框架<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_9-1-资源修复" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="9.1 资源修复"><!---->9.1 资源修复<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_9-1-1-instant-run" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="9.1.1 Instant Run"><!---->9.1.1 Instant Run<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_9-1-2-instant-run-的资源修复" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="9.1.2 Instant Run 的资源修复"><!---->9.1.2 Instant Run 的资源修复<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_9-2-代码修复" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="9.2 代码修复"><!---->9.2 代码修复<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_9-2-1-类加载方案" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="9.2.1 类加载方案"><!---->9.2.1 类加载方案<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_9-2-2-底层替换方案" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="9.2.2 底层替换方案"><!---->9.2.2 底层替换方案<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_10-mvc-mvp-mvvm-模式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="10. MVC/MVP/MVVM 模式"><!---->10. MVC/MVP/MVVM 模式<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_10-3-mvvm-架构" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="10.3 MVVM 架构"><!---->10.3 MVVM 架构<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_11-事件分发和滑动冲突" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="11. 事件分发和滑动冲突"><!---->11. 事件分发和滑动冲突<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_12-嵌套滑动" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="12. 嵌套滑动"><!---->12. 嵌套滑动<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_13-常见设计模式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="13. 常见设计模式"><!---->13. 常见设计模式<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_13-1-单例模式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="13.1 单例模式"><!---->13.1 单例模式<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_13-1-1-双重检查" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="13.1.1 双重检查"><!---->13.1.1 双重检查<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_13-1-2-静态内部类" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="13.1.2 静态内部类"><!---->13.1.2 静态内部类<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_13-2-外观模式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="13.2 外观模式"><!---->13.2 外观模式<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_13-3-享元模式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="13.3 享元模式"><!---->13.3 享元模式<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_13-4-工厂模式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="13.4 工厂模式"><!---->13.4 工厂模式<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_13-5-建造者模式-builder-模式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="13.5 建造者模式（Builder 模式）"><!---->13.5 建造者模式（Builder 模式）<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_14-常见算法题" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="14. 常见算法题"><!---->14. 常见算法题<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_14-1-生产者消费者" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="14.1 生产者消费者"><!---->14.1 生产者消费者<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_14-2-交替打印-0-100" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="14.2 交替打印 0-100"><!---->14.2 交替打印 0-100<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_14-2-死锁" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="14.2 死锁"><!---->14.2 死锁<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_14-3-冒泡排序和选择排序" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="14.3 冒泡排序和选择排序"><!---->14.3 冒泡排序和选择排序<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_14-4-字符串反转" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="14.4 字符串反转"><!---->14.4 字符串反转<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_15-sql-语句" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="15. SQL 语句"><!---->15. SQL 语句<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_15-1-创建表" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="15.1 创建表"><!---->15.1 创建表<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_15-2-insert-语句" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="15.2 insert 语句"><!---->15.2 insert 语句<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_15-3-update-语句" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="15.3 update 语句"><!---->15.3 update 语句<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_15-4-delete-语句" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="15.4 delete 语句"><!---->15.4 delete 语句<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_15-5-select-语句" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="15.5 select 语句"><!---->15.5 select 语句<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_16-项目中遇到的难点" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="16. 项目中遇到的难点"><!---->16. 项目中遇到的难点<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_16-1-直播界面退出后延迟-10s-左右才回调-ondestroy" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="16.1 直播界面退出后延迟 10s 左右才回调 onDestroy"><!---->16.1 直播界面退出后延迟 10s 左右才回调 onDestroy<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_16-2-健康检测中的人脸识别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="16.2 健康检测中的人脸识别"><!---->16.2 健康检测中的人脸识别<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_16-3-上下切换直播间和上下滑动聊天记录的滑动冲突" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="16.3 上下切换直播间和上下滑动聊天记录的滑动冲突"><!---->16.3 上下切换直播间和上下滑动聊天记录的滑动冲突<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_17-hashmap-中的哈希冲突-也称哈希碰撞" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="17. HashMap 中的哈希冲突（也称哈希碰撞）"><!---->17. HashMap 中的哈希冲突（也称哈希碰撞）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_18-android-新特性" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="18. Android 新特性"><!---->18. Android 新特性<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_19-recyclerview-的回收复用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="19. RecyclerView 的回收复用"><!---->19. RecyclerView 的回收复用<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_20-recyclerview-实现无限轮播" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="20. RecyclerView 实现无限轮播"><!---->20. RecyclerView 实现无限轮播<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_21-kotlin-协程" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="21. Kotlin 协程"><!---->21. Kotlin 协程<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><!----><span class="title">项目列表</span><!----></p><!--[--><ul class="sidebar-links"><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">VCAT+重构</span><span class="arrow right"></span></button><!--[--><!----><!----><!--]--></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">VCAT+</span><span class="arrow right"></span></button><!--[--><!----><!----><!--]--></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">即时猫</span><span class="arrow right"></span></button><!--[--><!----><!----><!--]--></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">党建展厅</span><span class="arrow right"></span></button><!--[--><!----><!----><!--]--></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">车载音乐</span><span class="arrow right"></span></button><!--[--><!----><!----><!--]--></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">车载控制系统</span><span class="arrow right"></span></button><!--[--><!----><!----><!--]--></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">车载收音机</span><span class="arrow right"></span></button><!--[--><!----><!----><!--]--></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">远东支付</span><span class="arrow right"></span></button><!--[--><!----><!----><!--]--></section><!--]--></li></ul><!----><!--]--></section><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->技能要点</h1><div class="article-info"><span class="author-info" arialabel="作者🖊" isoriginal="false" pageview="false" color="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewbox="0 0 1024 1024" arialabelledby="author"><title id="author" lang="en">author icon</title><g fill="currentColor"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></g></svg><span><a class="author-item" href="https://zengkaiqiang562.github.io/" target="_blank" rel="noopener noreferrer">Zenk562</a></span><span property="author" content="Zenk562"></span></span><span class="category-info" arialabel="分类🌈" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewbox="0 0 1024 1024" arialabelledby="category"><title id="category" lang="en">category icon</title><g fill="currentColor"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></g></svg><ul class="categories-wrapper"><li class="category clickable" role="navigation">项目经历</li><meta property="articleSection" content="项目经历"></ul></span><span arialabel="标签🏷" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon tag-icon" viewbox="0 0 1024 1024" arialabelledby="tag"><title id="tag" lang="en">tag icon</title><g fill="currentColor"><path d="M939.902 458.563L910.17 144.567c-1.507-16.272-14.465-29.13-30.737-30.737L565.438 84.098h-.402c-3.215 0-5.726 1.005-7.634 2.913l-470.39 470.39a10.004 10.004 0 000 14.164l365.423 365.424c1.909 1.908 4.42 2.913 7.132 2.913s5.223-1.005 7.132-2.913l470.39-470.39c2.01-2.11 3.014-5.023 2.813-8.036zm-240.067-72.121c-35.458 0-64.286-28.828-64.286-64.286s28.828-64.285 64.286-64.285 64.286 28.828 64.286 64.285-28.829 64.286-64.286 64.286z"></path></g></svg><ul class="tags-wrapper"><li class="tag clickable" role="navigation">项目经历</li></ul><meta property="keywords" content="项目经历"></span><span class="date-info" arialabel="写作日期📅" isoriginal="false" pageview="false" color="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewbox="0 0 1024 1024" arialabelledby="calendar"><title id="calendar" lang="en">calendar icon</title><g fill="currentColor"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></g></svg><span>2022年7月6日</span><meta property="datePublished" content="2022-07-06T10:07:29.000Z"></span><!----><span class="words-info" arialabel="字数🔠" isoriginal="false" pageview="false" color="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon word-icon" viewbox="0 0 1024 1024" arialabelledby="word"><title id="word" lang="en">word icon</title><g fill="currentColor"><path d="M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z"></path><path d="M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z"></path></g></svg><span>约 12498 字</span><meta property="wordCount" content="12498"></span></div><hr></div><div class="toc-place-holder"><aside id="toc-list"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_1-jni-和-ndk-开发" class="router-link-active router-link-exact-active toc-link level2">1. JNI 和 NDK 开发</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_2-ipc-和-binder-机制" class="router-link-active router-link-exact-active toc-link level2">2. IPC 和 Binder 机制</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_2-1-linux-和-android-中的-ipc-机制" class="router-link-active router-link-exact-active toc-link level3">2.1 Linux 和 Android 中的 IPC 机制</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_2-2-binder-机制" class="router-link-active router-link-exact-active toc-link level3">2.2 Binder 机制</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_2-2-1-native-binder" class="router-link-active router-link-exact-active toc-link level4">2.2.1 Native Binder</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_2-2-2-java-binder" class="router-link-active router-link-exact-active toc-link level4">2.2.2 Java Binder</a></li><!----><!--]--></ul><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_3-android-系统启动流程" class="router-link-active router-link-exact-active toc-link level2">3. Android 系统启动流程</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_4-四大组件工作过程" class="router-link-active router-link-exact-active toc-link level2">4. 四大组件工作过程</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_5-网络分层模型" class="router-link-active router-link-exact-active toc-link level2">5. 网络分层模型</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_5-tcp-三次握手和四次挥手" class="router-link-active router-link-exact-active toc-link level2">5. TCP 三次握手和四次挥手</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_6-http-和-https-协议" class="router-link-active router-link-exact-active toc-link level2">6. HTTP 和 HTTPS 协议</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_7-realm-数据库" class="router-link-active router-link-exact-active toc-link level2">7. Realm 数据库</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_8-插件化动态换肤" class="router-link-active router-link-exact-active toc-link level2">8. 插件化动态换肤</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_8-1-activity-插件化" class="router-link-active router-link-exact-active toc-link level3">8.1 Activity 插件化</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_9-热修复和-sophix-热更新框架" class="router-link-active router-link-exact-active toc-link level2">9. 热修复和 Sophix 热更新框架</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_9-1-资源修复" class="router-link-active router-link-exact-active toc-link level3">9.1 资源修复</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_9-1-1-instant-run" class="router-link-active router-link-exact-active toc-link level4">9.1.1 Instant Run</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_9-1-2-instant-run-的资源修复" class="router-link-active router-link-exact-active toc-link level4">9.1.2 Instant Run 的资源修复</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_9-2-代码修复" class="router-link-active router-link-exact-active toc-link level3">9.2 代码修复</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_9-2-1-类加载方案" class="router-link-active router-link-exact-active toc-link level4">9.2.1 类加载方案</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_9-2-2-底层替换方案" class="router-link-active router-link-exact-active toc-link level4">9.2.2 底层替换方案</a></li><!----><!--]--></ul><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_10-mvc-mvp-mvvm-模式" class="router-link-active router-link-exact-active toc-link level2">10. MVC/MVP/MVVM 模式</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_10-3-mvvm-架构" class="router-link-active router-link-exact-active toc-link level3">10.3 MVVM 架构</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_11-事件分发和滑动冲突" class="router-link-active router-link-exact-active toc-link level2">11. 事件分发和滑动冲突</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_12-嵌套滑动" class="router-link-active router-link-exact-active toc-link level2">12. 嵌套滑动</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_13-常见设计模式" class="router-link-active router-link-exact-active toc-link level2">13. 常见设计模式</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_13-1-单例模式" class="router-link-active router-link-exact-active toc-link level3">13.1 单例模式</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_13-1-1-双重检查" class="router-link-active router-link-exact-active toc-link level4">13.1.1 双重检查</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_13-1-2-静态内部类" class="router-link-active router-link-exact-active toc-link level4">13.1.2 静态内部类</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_13-2-外观模式" class="router-link-active router-link-exact-active toc-link level3">13.2 外观模式</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_13-3-享元模式" class="router-link-active router-link-exact-active toc-link level3">13.3 享元模式</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_13-4-工厂模式" class="router-link-active router-link-exact-active toc-link level3">13.4 工厂模式</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_13-5-建造者模式-builder-模式" class="router-link-active router-link-exact-active toc-link level3">13.5 建造者模式（Builder 模式）</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_14-常见算法题" class="router-link-active router-link-exact-active toc-link level2">14. 常见算法题</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_14-1-生产者消费者" class="router-link-active router-link-exact-active toc-link level3">14.1 生产者消费者</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_14-2-交替打印-0-100" class="router-link-active router-link-exact-active toc-link level3">14.2 交替打印 0-100</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_14-2-死锁" class="router-link-active router-link-exact-active toc-link level3">14.2 死锁</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_14-3-冒泡排序和选择排序" class="router-link-active router-link-exact-active toc-link level3">14.3 冒泡排序和选择排序</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_14-4-字符串反转" class="router-link-active router-link-exact-active toc-link level3">14.4 字符串反转</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_15-sql-语句" class="router-link-active router-link-exact-active toc-link level2">15. SQL 语句</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_15-1-创建表" class="router-link-active router-link-exact-active toc-link level3">15.1 创建表</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_15-2-insert-语句" class="router-link-active router-link-exact-active toc-link level3">15.2 insert 语句</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_15-3-update-语句" class="router-link-active router-link-exact-active toc-link level3">15.3 update 语句</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_15-4-delete-语句" class="router-link-active router-link-exact-active toc-link level3">15.4 delete 语句</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_15-5-select-语句" class="router-link-active router-link-exact-active toc-link level3">15.5 select 语句</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_16-项目中遇到的难点" class="router-link-active router-link-exact-active toc-link level2">16. 项目中遇到的难点</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_16-1-直播界面退出后延迟-10s-左右才回调-ondestroy" class="router-link-active router-link-exact-active toc-link level3">16.1 直播界面退出后延迟 10s 左右才回调 onDestroy</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_16-2-健康检测中的人脸识别" class="router-link-active router-link-exact-active toc-link level3">16.2 健康检测中的人脸识别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_16-3-上下切换直播间和上下滑动聊天记录的滑动冲突" class="router-link-active router-link-exact-active toc-link level3">16.3 上下切换直播间和上下滑动聊天记录的滑动冲突</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_17-hashmap-中的哈希冲突-也称哈希碰撞" class="router-link-active router-link-exact-active toc-link level2">17. HashMap 中的哈希冲突（也称哈希碰撞）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_18-android-新特性" class="router-link-active router-link-exact-active toc-link level2">18. Android 新特性</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_19-recyclerview-的回收复用" class="router-link-active router-link-exact-active toc-link level2">19. RecyclerView 的回收复用</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_20-recyclerview-实现无限轮播" class="router-link-active router-link-exact-active toc-link level2">20. RecyclerView 实现无限轮播</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zkq/project-experiences/skill-keypoint.html#_21-kotlin-协程" class="router-link-active router-link-exact-active toc-link level2">21. Kotlin 协程</a></li><!----><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><!--[--><h2 id="_1-jni-和-ndk-开发" tabindex="-1"><a class="header-anchor" href="#_1-jni-和-ndk-开发" aria-hidden="true">#</a> 1. <code>JNI</code> 和 <code>NDK</code> 开发</h2><p>参考：<a href="/zkq/android/ndk/jni.html#_1-jni-%E5%92%8C-ndk-%E5%BC%80%E5%8F%91" class="">JNI 和 NDK 开发</a></p><h2 id="_2-ipc-和-binder-机制" tabindex="-1"><a class="header-anchor" href="#_2-ipc-和-binder-机制" aria-hidden="true">#</a> 2. <code>IPC</code> 和 <code>Binder</code> 机制</h2><h3 id="_2-1-linux-和-android-中的-ipc-机制" tabindex="-1"><a class="header-anchor" href="#_2-1-linux-和-android-中的-ipc-机制" aria-hidden="true">#</a> 2.1 <code>Linux</code> 和 Android 中的 <code>IPC</code> 机制</h3><p><code>Linux</code> 提供的 <code>IPC</code> 机制有：</p><ol><li><p>管道（<code>Pipe</code>）</p><div class="language-text ext-text"><pre class="language-text"><code>管道的主要思想是在内存中创建一个存在于内存中的共享文件，使得进程双方通过这个共享文件来传递信息。

管道采用半双工通信的方式，即数据只能在一个方向上流动。
</code></pre></div></li><li><p>信号（<code>Signal</code>）</p><div class="language-text ext-text"><pre class="language-text"><code>信号是通过软件对中断机制的模拟。
信号可以在用户空间和内核空间之间直接交互。内核可以利用信号通知用户空间的进程发生了哪些系统事件。
信号不适用于信息交换。比较适用于进程中断控制。
</code></pre></div></li><li><p>信号量（<code>Semaphore</code>）</p><div class="language-text ext-text"><pre class="language-text"><code>信号量是一个计数器，用来控制多个进程对共享资源的访问。
信号量常作为一种锁机制，防止多个进程同时访问共享资源。即信号量主要作为一种同步手段。
</code></pre></div></li><li><p>共享内存（<code>Share Memory</code>）</p><div class="language-text ext-text"><pre class="language-text"><code>共享内存就是在内核空间中分配一块内存区，多个进程都可以访问这块内存区。
且进程可以直接将这块内存区映射到自己的私有地址空间，从而可以直接读取这块内存区，而不用进行数据复制，提高了效率。
</code></pre></div></li><li><p>套接字（<code>Socket</code>）</p><div class="language-text ext-text"><pre class="language-text"><code>套接字不仅可以用于同一机器中不同进程间的通信，还可以用于不同机器之间的进程间通信。
</code></pre></div></li></ol><p><code>Android</code> 系统是基于 <code>Linux</code> 内核的，除了可以使用 <code>Linux</code> 中的 <code>IPC</code> 机制外，<code>Android</code> 还提供了如下的 <code>IPC</code> 机制有：</p><ol><li><p>文件共享</p><div class="language-text ext-text"><pre class="language-text"><code>文件共享就是多个进程通过读写同一个文件进行数据共享。共享的文件可以是 txt、xml、json 文件
文件共享适用于对数据同步要求不高的进程间通信
</code></pre></div></li><li><p><code>Messenger</code></p><div class="language-text ext-text"><pre class="language-text"><code>Messenger 就是采用 AIDL 的方式通过 Binder 实现了进程间通信。
也就是说，Messenger 内部还是通过 Binder 进行进程间通信的。
只不过 Messenger 主要用来在进程间传递 Message 消息对象的。即通过 Messenger 进行的进程间通信，数据都封装在 Message 对象中。
Messenger 的缺点是：只能跨进程传递数据，不能跨进程调用方法。
</code></pre></div></li><li><p><code>ContentProvider</code></p><div class="language-text ext-text"><pre class="language-text"><code>ContentProvider 内部也是通过 Binder 进行进程间通信的。
ContentProvider 的主要作用就是为不同的进程提供了统一的接口来访问共享数据。
</code></pre></div></li><li><p><code>AIDL</code></p><div class="language-text ext-text"><pre class="language-text"><code>AIDL 就是 Android 接口定义语言（`Android Interface Definition Language`）
AIDL 是一种语法规范，通过编写 aidl 接口文件，可以自动生成 Binder 通信时客户端和服务端所需要的部分 Java 代码，如：
    1. 自动生成服务端的服务类所需要继承的 Binder 的抽象子类 IXxx.Stub
    2. 自动生成客户端的 Binder 代理类 Ixxx.Stub.Proxy
也就是说，通过 AIDL 规范可以更方便地使用 Binder 机制进行进程间通信
并且，当我们需要跨进程调用方法时，也只能通过 AIDL 的方式实现（或者自己手动的编程客户端和服务端的所有代码）
</code></pre></div></li></ol><blockquote><p>其中 <code>Messenger</code>、<code>ContentProvider</code>、<code>AIDL</code> 其实都是通过 <code>Binder</code> 实现的。</p></blockquote><p>在通过 <code>Binder</code> 进行跨进程通信时，传递的数据都必须是可序列化的，即封装数据的类必须实现 <code>Serializable</code> 或 <code>Parcelable</code> 接口。</p><blockquote><p>其中 <code>Parcelable</code> 接口是 <code>Android</code> 提供的序列化方式，在 <code>Android</code> 平台上效率更高。</p><p>在 <code>Android</code> 中通过 <code>Intent</code> 进行数据传递时，所使用的 <code>Bundle</code> 就实现了 <code>Parcelable</code> 接口。</p></blockquote><h3 id="_2-2-binder-机制" tabindex="-1"><a class="header-anchor" href="#_2-2-binder-机制" aria-hidden="true">#</a> 2.2 <code>Binder</code> 机制</h3><p>虽然通过 <code>Linux</code> 提供的共享内存的方式进行进程间通信的效率不比 <code>Android</code> 提供的 <code>Binder</code> 机制的效率低。</p><blockquote><p>因为采用共享内存的方式，不同进程的用户空间都可以和内核空间中的同一块内存区进行内存映射（<code>mmap</code>），从而不需要对共享数据进行复制。</p></blockquote><p>但是，共享内存的方式是不安全的，当多进程同步访问共享数据时容易出现线程同步问题，甚至发生死锁。</p><p>而 <code>Binder</code> 机制是基于 <code>C/S</code> 架构的，采用 <code>Binder</code> 机制进行进程间通信时，只需要客户端进程的用户空间与内核空间的内存区进行一次数据的复制。服务端进程的用户空间则与内核空间的内存区进行内存映射，从而不需要复制数据。即：使用 <code>Binder</code>，在一次进程间通信中，只需要复制一次数据。</p><blockquote><p>虽然 <code>Binder</code> 机制没有共享内存的方式的效率高，但 <code>Binder</code> 机制在进程间通信时更稳定、更安全。</p></blockquote><p>根据 Android 系统的分层，Binder 机制也可分为：</p><ol><li><p><code>Java Binder</code>：即 <code>Framework</code> 层中通过 <code>Java</code> 代码为 <code>Binder</code> 提供的 <code>API</code></p></li><li><p><code>Native Binder</code>：即 <code>Native</code> 层中通过 <code>C/C++</code> 代码为 <code>Binder</code> 提供的 <code>API</code></p></li><li><p><code>Kernel Binder</code>：即 <code>Linux</code> 内核层中 <code>Binder</code> 驱动相关的 <code>API</code></p></li></ol><h4 id="_2-2-1-native-binder" tabindex="-1"><a class="header-anchor" href="#_2-2-1-native-binder" aria-hidden="true">#</a> 2.2.1 <code>Native Binder</code></h4><p>在 <code>Native Binder</code> 中，客户端进程中的 <code>Binder</code> 使用流程（以系统服务 <code>mediaserver</code> 所在的 <code>media</code> 进程为例）：</p><ol><li><p>在客户端进程的入口函数 <code>main</code> 执行时：</p><div class="language-text ext-text"><pre class="language-text"><code>1. 创建表示当前进程的 ProceessState 实例

    在创建表示客户端进程的 ProceessState 实例时，会做几件事：
        1. 调用 ProcessState::open_driver 函数打开名为 &quot;/dev/binder&quot; 的 Binder 驱动设备，在 open_driver 函数中：
            1. 通过调用系统函数 open 打开 Binder 驱动设备（注意：调用系统函数是用户空间访问内核空间的唯一方式）
            2. 通过调用系统函数 ioctl 设置 Binder 最大支持的线程数为 15（DEFAULT_MAX_BINDER_THREADS）
        2. 调用系统函数 mmap 实现 mediaserver 进程的用户空间与内核空间的内存映射。
            注意：当将 mediaserver 进程中的系统服务注册到 servicemanager 进程的过程中会进行 Binder 通信，此时，
                  mediaserver 进程是本次 Binder 通信的客户端，servicemanager 进程是本次 Binder 通信的服务端
                  当 app 进程访问 mediaserver 进程中的系统服务的过程中也会进行 Binder 通信，此时，
                  app 进程是本次 Binder 通信的客户端，mediaserver 进程是本次 Binder 通信的服务端。
                  而在 mediaserver 进程的用户空间中进行了内存映射的这块内存区，
                  是在 mediaserver 作为 Binder 通信的服务端时才用到的。

2. 获取作为服务端的 servicemanager 进程在客户端中的 Binder 代理对象 IServiceManager

    IServiceManager 作为服务端进程 servicemanager 在客户端进程 mediaserver 中的代理，
    IServiceManager 内部封装了一个 BpBinder 对象，表示 Binder 通信时服务端在客户端中的 Binder 代理。
    代理对象 BpBinder 只是持有了服务端在 Binder 中保存的一个 handle 值。
    （如 servicemanager 进程在 Binder 中保存的 handle 值为 0）
    Binder 会根据 handle 值找到服务端中对应的被代理对象 BBinder，通过 BBinder 就能访问到服务端进程中的服务
    即：
        Client &lt;-&gt; BpBinder &lt;---handle---&gt; BBinder &lt;-&gt; Server

3. 将作为客户端的 mediaserver 进程中的系统服务对象 MediaPlayerService 注册到作为服务端的 servicemanager 进程中

    1. 在注册系统服务时，mediaserver 作为客户端进程，调用服务端进程 servicemanager 提供
    的代理类 IServiceManager 的 addService 方法进行系统服务的注册。调用 addService 方法时：
       1. 需要传入 mediaserver 中所要注册的系统服务的名称，其他进程会根据此名称从 servicemanager 中查询注册的系统服务
       2. 需要传入 mediaserver 中所要注册的系统服务对象，如 MediaPlayerService。注意：系统服务类需要继承自 Binder。

    1. 在 IServiceManager.addService 函数中，
       1. 会将需要传递的数据（如注册的服务名称，注册的服务对象）封装在 Parcel 对象 data 中，
       2. 然后再调用 BpBinder.transact(code, data, replay, flags) 函数，其中
          1. 参数 code 表示本次 Binder 通信所进行的操作的指令码，如 ADD_SERVICE_TRANSACTION 表示操作为注册系统服务
          2. 参数 data 表示本次 Binder 通信时客户端传给服务端的数据
          3. 参数 replay 表示本次 Binder 通信时服务端返回给客户端的数据
    
    2. BpBinder.transact 函数中，又会调用当前 Binder 线程的 transact 函数，即调用 IPCThreadState::transact 函数
         status_t IPCThreadState::transact(
                            int32_t handle, // BpBinder 代理对象中所持有的服务端保存在 Binder 中的 handle 值
                            uint32_t code, 
                            const Parcel&amp; data,
                            Parcel* reply, 
                            uint32_t flags)
        调用 IServiceManager.addService 函数时，这里传入的 handle 值就是 0

    3. 在 IPCThreadState::transact(handle, code, data, reply, flags) 函数中：
        1. 先调用 IPCThreadState::writeTransactionData 函数：
              writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL) 
          在 writeTransactionData 函数中将需要发送给服务端的参数封装在 Parcel 对象 mOut 中
        2. 再调用 IPCThreadState::waitForResponse(replay) 函数。在 waitForResponse 函数中：
           1. 调用 IPCThreadState::talkWithDriver() 函数向服务端发起 Binder 通信，在 talkWithDriver 函数中：
              1. 先将 Parcel 对象 mOut 中要发送给服务端的数据封装在 binder_write_read 结构体对象 bwr 中，
              2. 通过调用系统函数 ioctl 将数据从用户空间传递到内核空间的 Binder 驱动中。
              3. 如果调用 waitForResponse 函数时传入的参数 reply 不为 NULL，那么会等待服务端返回响应数据。

    综上，客户端向服务端发起 Binder 通信的流程为：
        BpBinder::transact -&gt; IPCThreadState::transact 
                           -&gt; IPCThreadState::writeTransactionData
                           -&gt; IPCThreadState::waitForResponse
                           -&gt; IPCThreadState::talkWithDriver
                           -&gt; ioctl
        当服务端收到数据时，会执行 BBinder::onTransact 函数

4. 启动 Binder 线程池。（当 mediaserver 进程作为 Binder 通信的服务端时会用到）

    调用 ProcessState::self()-&gt;startThreadPool() 函数启动 Binder 线程池，
    在 startThreadPool 函数中会调用 ProcessState::spawnPooledThread(true) 函数为创建的 Binder 线程池添加主线程。

5. 将调用 main 函数的当前线程加入到 Binder 线程池中。

    调用 IPCThreadState::self()-&gt;joinThreadPool(); 函数将当前线程添加到 Binder 线程池中。
</code></pre></div></li></ol><p><code>servicemanager</code> 进程的启动过程：</p><ol><li><p><code>init</code> 进程通过解析 <code>servicemanager.rc</code> 文件创建 <code>servicemanager</code> 进程，并执行 <code>servicemanager</code> 进程的入口函数 <code>main</code></p><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* frameworks/native/cmds/servicemanager/service_manager.c */</span>
<span class="token comment">/*
    在 servicemanager 进程的入口 main 函数中主要做了三件事：
    1. 调用 binder_open 函数打开 binder 驱动
    2. 调用 binder_become_context_manager 将 servicemanager 进程注册为 Binder 机制的上下文管理者
    3. 调用 binder_loop 函数，循环等待客户端发过来的请求，并通过 svcmgr_handler 函数进行处理
*/</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">binder_state</span> <span class="token operator">*</span>bs<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    bs <span class="token operator">=</span> <span class="token function">binder_open</span><span class="token punctuation">(</span>driver<span class="token punctuation">,</span> <span class="token number">128</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">binder_become_context_manager</span><span class="token punctuation">(</span>bs<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">ALOGE</span><span class="token punctuation">(</span><span class="token string">&quot;cannot become context manager (%s)\n&quot;</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">binder_loop</span><span class="token punctuation">(</span>bs<span class="token punctuation">,</span> svcmgr_handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ol><p>在 <code>Binder</code> 机制中，客户端进程和服务端进程之间通信其实就是以发送和解析命令协议的方式进行的，如：</p><ol><li><p>客户端进程向 <code>Binder</code> 驱动发送 <code>BC_TRANSACTION</code> 命令，并携带请求数据；</p></li><li><p><code>Binder</code> 驱动接收到客户端进程的请求后，向服务端进程发送 <code>BR_TRANSACTION</code> 命令，并携带请求数据；</p><blockquote><p>其中，&quot;<code>BR</code>&quot; 中的 <code>R</code> 不是理解为 <code>Reply</code>，而应该理解为 <code>Remote</code>，即来自远端的请求。</p></blockquote></li><li><p>服务端进程接收到 <code>BR_TRANSACTION</code> 命令后，解析并处理传过来的请求数据，然后向 <code>Binder</code> 驱动发送 <code>BC_REPLY</code> 命令，</p><blockquote><p>如果本次请求需要返回响应数据，则服务端进程向 <code>Binder</code> 驱动发送 <code>BC_REPLY</code> 命令时，还会携带响应数据。</p></blockquote></li><li><p><code>Binder</code> 驱动接收到服务端进程的响应后，向客户端进程发送 <code>BR_REPLY</code> 命令。（如果存在响应数据，也一并发送给客户端进程）</p><blockquote><p>其中，&quot;<code>BR</code>&quot; 中的 <code>R</code> 不是理解为 <code>Reply</code>，而应该理解为 <code>Remote</code>，即来自远端的响应。</p></blockquote></li></ol><p><code>servicemanager</code> 进程中接收并处理客户端进程发起的请求：</p><ol><li><p><code>servicemanager</code> 进程在 <code>main</code> 函数中会调用 <code>binder_loop</code> 函数循环等待客户端的请求</p><div class="language-text ext-text"><pre class="language-text"><code>在 binder_loop 函数中:
1. 首先调用系统函数 ioctl 读取 Binder 驱动中的客户端请求
2. 然后调用 binder_parse 函数解析读取到的客户端请求
   1. 当在 binder_parse 函数中解析到 BR_TRANSACTION 命令时，就表示接收到客户端的请求了。
      此时，调用通过 binder_loop 函数传入的函数 svcmgr_handler 来处理客户端请求

在 svcmgr_handler 中处理客户端请求时：
1. 如果客户端传过来的 code 是 CHECK_SERVICE_TRANSACTION，那么 svcmgr_handler 函数中解析出的就是 SVC_MGR_CHECK_SERVICE
   如果客户端传过来的 code 是 ADD_SERVICE_TRANSACTION ，那么 svcmgr_handler 函数中解析出的就是 SVC_MGR_ADD_SERVICE

2. 如果客户端请求注册服务，那么解析出 SVC_MGR_ADD_SERVICE，此时调用 do_add_service 函数，
   将注册的服务名称和服务对应的 handle 值保存在结构体 svcinfo 中，并将该 svcinfo 对象存入到 svclist 容器中。

3. 如果客户端请求获取已注册了的服务，那么解析出 SVC_MGR_CHECK_SERVICE，此时调用 do_find_service 函数，
   从 svclist 容器中查询与服务名称对应的 svcinfo 结构体对象，并将查询到的 svcinfo 中保存的 handle 值返回给 Binder 驱动
</code></pre></div></li></ol><h4 id="_2-2-2-java-binder" tabindex="-1"><a class="header-anchor" href="#_2-2-2-java-binder" aria-hidden="true">#</a> 2.2.2 <code>Java Binder</code></h4><p>在 <code>Zygote</code> 进程启动过程中，会执行 <code>AndroidRuntime::startReg(JNIEnv*)</code> 函数，其中，会对很多的 <code>Java</code> 类中的 <code>native</code> 方法进行动态注册。</p><p>其中，就包括对 <code>Binder</code>、<code>BinderInternal</code>、<code>BinderProxy</code> 这三个 <code>Java</code> 类中的 <code>native</code> 方法的动态注册。</p><blockquote><p><code>Binder</code> 和 <code>BinderProxy</code> 都定义在 <code>Binder.java</code> 中</p></blockquote><ol><li><p><code>BinderInternal</code> 提供了静态的 <code>native</code> 方法 <code>getContextObject()</code>，该方法会返回 <code>BinderProxy</code> 对象，<code>BinderProxy</code> 对象的成员变量 <code>mObject</code> 保存 <code>Native</code> 层中的 <code>handle</code> 值为 <code>0</code> 的 <code>BpBinder</code> 对象的地址。</p></li><li><p>在 <code>Java</code> 层中，当将继承自 <code>Binder</code> 的系统服务注册到 <code>servicemanager</code> 进程时。在 <code>Native</code> 层会创建一个 <code>JavaBBinder</code> 对象，通过 <code>JavaBBinder</code> 的成员变量 <code>mObject</code> 指向 <code>Java</code> 层中的继承自 <code>Binder</code> 的系统服务。</p></li><li><p>当系统服务所在的进程作为服务端与作为客户端的 <code>App</code> 进程进行 <code>Binder</code> 通信时，<code>Binder</code> 驱动会将接收到的客户端请求通过调用 <code>JavaBBinder</code> 的 <code>onTransact</code> 函数发送给服务端进程中的系统服务。</p><blockquote><p>在 <code>JavaBBinder</code> 的 <code>onTransact</code> 函数中通过指向 <code>Java</code> 层系统服务的成员变量 <code>mObject</code> 调用继承自 <code>Binder</code> 的系统服务类的 <code>execTransact</code> 函数。</p></blockquote></li></ol><h2 id="_3-android-系统启动流程" tabindex="-1"><a class="header-anchor" href="#_3-android-系统启动流程" aria-hidden="true">#</a> 3. <code>Android</code> 系统启动流程</h2><p><code>Android</code> 系统的启动流程大致为：</p><ol><li><p>启动电源后，先加载并执行引导程序 <code>BootLoader</code>。</p><blockquote><p>引导程序 <code>BootLoader</code> 的作用就是引导 <code>Android</code> 系统开始运行起来。</p></blockquote></li><li><p><code>Android</code> 系统开始运行时，首先启动的是 <code>Linux</code> 内核。<code>Linux</code> 内核启动后会先进行一系列的系统设置，如设置缓存，加载驱动等。当 <code>Linux</code> 内核中的系统设置完成后，<code>Linux</code> 内核会在系统文件中寻找 <code>init.rc</code> 文件，并启动 <code>init</code> 进程。</p></li><li><p><code>init</code> 进程启动后，会初始化和启动属性服务，并通过解析 <code>init.rc</code> 文件，从导入该文件的 <code>init.zygote.rc</code> 文件中解析并启动 <code>Zygote</code> 进程。</p></li><li><p><code>Zygote</code> 进程启动后会：</p><ol><li>创建 <code>Java</code> 虚拟机，</li><li>并为虚拟机注册 <code>JNI</code> 方法（即对某些 <code>Java</code> 类中的 <code>native</code> 方法进行动态注册）</li><li>创建 <code>Socket</code> 通信中作为服务端的 <code>Socket</code></li><li>启动 <code>SystemServer</code> 进程</li><li>等待系统服务（如 <code>AMS</code>）发起 <code>Socket</code> 通信。</li></ol></li><li><p><code>SystemServer</code> 进程启动后会：</p><ol><li>启动 <code>Binder</code> 线程池。（因为 <code>SystemServer</code> 进程中提供了各种系统服务用于 <code>Binder</code> 通信）</li><li>创建 <code>SystemServiceManager</code>。（<code>SystemServiceManager</code> 会对系统服务进行创建、启动和生命周期管理）</li><li>启动各种系统服务（如 <code>AMS</code>、<code>PMS</code>、<code>WMS</code> 等）</li></ol></li><li><p>系统服务 <code>AMS</code> 在 <code>SystemServer</code> 进程中启动后，<code>AMS</code> 会去启动 <code>Launcher</code> 桌面应用</p></li><li><p><code>Launcher</code> 启动后，会将已安装的应用程序的入口图标显示在屏幕上。</p></li></ol><h2 id="_4-四大组件工作过程" tabindex="-1"><a class="header-anchor" href="#_4-四大组件工作过程" aria-hidden="true">#</a> 4. 四大组件工作过程</h2><h2 id="_5-网络分层模型" tabindex="-1"><a class="header-anchor" href="#_5-网络分层模型" aria-hidden="true">#</a> 5. 网络分层模型</h2><p>OSI 七层模型 是国际标准化组织提出一个网络分层模型，其大体结构以及每一层提供的功能如下图所示：</p><p><img src="/assets/03.b7ad4da3.png" alt="" loading="lazy"></p><p>TCP/IP 四层模型 是目前被广泛采用的一种模型。由以下 4 层组成：</p><ol><li>应用层</li><li>传输层</li><li>网络层</li><li>网络接口层（有的也称数据链路层，或链路层）</li></ol><p>我们可以将 TCP/IP 模型看作是 OSI 七层模型的精简版本，如下图所示：</p><p><img src="/assets/04.dbbd9864.png" alt="" loading="lazy"></p><h2 id="_5-tcp-三次握手和四次挥手" tabindex="-1"><a class="header-anchor" href="#_5-tcp-三次握手和四次挥手" aria-hidden="true">#</a> 5. <code>TCP</code> 三次握手和四次挥手</h2><blockquote><p>参考：<a href="/cs-basics/network/other-network-questions.html#tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B-%E9%9D%A2%E8%AF%95%E5%B8%B8%E5%AE%A2" class=""><code>tcp</code>-三次握手和四次挥手-面试常客</a></p><p>参考：<a href="https://blog.csdn.net/jdsjlzx/article/details/123980560" target="_blank" rel="noopener noreferrer">动画图解TCP三次握手过程<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>参考：<a href="https://blog.csdn.net/jdsjlzx/article/details/123881766" target="_blank" rel="noopener noreferrer">图解TCP三次握手和TCP四次挥手<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>参考：<a href="https://blog.csdn.net/jdsjlzx/article/details/123877320" target="_blank" rel="noopener noreferrer">深入浅出之 TCP协议（三次握手与四次挥手、超时重发、流量控制、拥塞控制、与UDP区别）<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></blockquote><p>为什么要三次握手？</p><p><img src="/assets/01.ae413e28.png" alt="" loading="lazy"></p><p>三次握手的目的是建立可靠的通信信道。简单来说就是让数据的发送与接收更可靠，因此，<strong>三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的</strong>。</p><p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</p><p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</p><p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</p><p>所以三次握手就能确认双方收发功能都正常，缺一不可。</p><p>为什么要四次挥手？</p><p><img src="/assets/02.b1487002.png" alt="" loading="lazy"></p><p>断开一个 TCP 连接则需要“四次挥手”：</p><ol><li>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送</li><li>服务器-收到这个 FIN，它发回一个 ACK，确认序号为收到的序号加 1 。和 SYN 一样，一个 FIN 将占用一个序号</li><li>服务器-关闭与客户端的连接，发送一个 FIN 给客户端</li><li>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加 1</li></ol><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p><p>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p><h2 id="_6-http-和-https-协议" tabindex="-1"><a class="header-anchor" href="#_6-http-和-https-协议" aria-hidden="true">#</a> 6. <code>HTTP</code> 和 <code>HTTPS</code> 协议</h2><p>HTTP 协议，全称超文本传输协议（Hypertext Transfer Protocol）</p><p>HTTP 是一个无状态（stateless）协议，也就是说服务器不维护客户端已发送过来的历史请求。</p><p>HTTP 是应用层协议，它以 TCP（传输层）作为底层协议，默认端口为 80.</p><p>HTTPS 是基于 HTTP 的，也是用 TCP 作为底层协议，并额外使用 SSL/TLS 协议用作加密和安全认证。默认端口号是 443.</p><p>HTTPS 之所以能达到较高的安全性要求，就是结合了 SSL/TLS 和 TCP 协议，对通信数据进行加密，解决了 HTTP 数据透明的问题</p><blockquote><p>SSL 指安全套接字协议（Secure Sockets Layer）</p><p>SSL 2.0 则具有较大的缺陷（DROWN 缺陷——Decrypting RSA with Obsolete and Weakened eNcryption）。</p><p>很快，在 1999 年，SSL 3.0 进一步升级，新版本被命名为 <strong>TLS 1.0</strong>。</p><p>因此，TLS 是基于 SSL 之上的，但由于习惯叫法，通常把 HTTPS 中的核心加密协议混成为 SSL/TLS。</p></blockquote><p>SSL/TLS 的核心要素是 <strong>非对称加密</strong>。非对称加密采用两个密钥：一个公钥，一个私钥。</p><blockquote><p>在通信时，私钥仅由解密者保存，公钥由任何一个想与解密者通信的发送者（加密者）所持有。</p></blockquote><p>使用 SSL/TLS 进行通信的双方需要使用非对称加密方案来通信，但是非对称加密设计了较为复杂的数学算法，在实际通信过程中，计算的代价较高，效率太低，因此，SSL/TLS 实际 <strong>对消息的加密使用的是对称加密</strong>。</p><p>为什么 SSL/TLS 还需要使用非对称加密呢？因为 <strong>对称加密的保密性完全依赖于密钥的保密性</strong>。因此，<strong>使用非对称加密，对对称加密的密钥进行加密</strong>，保护该密钥不在网络信道中被窃听。</p><p>总结：HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</p><h2 id="_7-realm-数据库" tabindex="-1"><a class="header-anchor" href="#_7-realm-数据库" aria-hidden="true">#</a> 7. <code>Realm</code> 数据库</h2><p><code>Realm</code> 和 <code>GreenDao</code> 都是 <code>ORM</code> （对象关系映射）框架。</p><p><code>GreenDao</code> 是基于 <code>SQLite</code> 的，而 <code>Realm</code> 有自己的数据库引擎。</p><p><code>ORM</code> 框架就是将 <code>Java</code> 类看成一张表；类中的成员变量看成一个字段；一个类对象看成一条记录</p><p>需要通过 <code>Realm</code> 保存到数据库中的类需要继承 <code>RealmObject</code>，通过 <code>APT</code> 技术，会根据继承了 <code>RealmObject</code> 的类自动生成创建对应表的代码。</p><h2 id="_8-插件化动态换肤" tabindex="-1"><a class="header-anchor" href="#_8-插件化动态换肤" aria-hidden="true">#</a> 8. 插件化动态换肤</h2><p>采用了插件化的 <code>App</code> 由宿主和插件两个部分组成：</p><ol><li>宿主是指已安装在手机中的 <code>apk</code>；</li><li>插件一般是指经过处理的 <code>apk</code>、<code>so</code>、<code>dex</code> 等文件。</li></ol><p>通过将插件加载到宿主中，可以让宿主接入更多的业务模块，同时也减小了宿主 <code>apk</code> 的体积、降低了各业务模块之间的耦合度。并且插件是可以自由地进行插拔的，这也就提高了 <code>app</code> 的可扩展性。</p><p>插件化一般可分为 <code>Activity</code> 插件化、<code>Service</code> 插件化、广播插件化、<code>ContentProvider</code> 插件化、资源插件化、<code>so</code> 动态库的插件化。</p><h3 id="_8-1-activity-插件化" tabindex="-1"><a class="header-anchor" href="#_8-1-activity-插件化" aria-hidden="true">#</a> 8.1 <code>Activity</code> 插件化</h3><p><code>Activity</code> 插件化主要有 <code>3</code> 种实现方式：</p><ol><li>反射实现：反射实现会对性能有影响，主流的插件化框架没有采用此方式</li><li>接口实现：接口实现的方式可以参考 <code>dynamic-load-apk</code> 的源码</li><li><code>Hook</code> 技术实现：<code>Hook</code> 技术实现是主流。</li></ol><p><code>Hook</code> 技术实现主要有两种解决方案：</p><ol><li><p>通过 <code>Hook</code> <code>IActivityManager</code> 实现</p><div class="language-text ext-text"><pre class="language-text"><code>此方式需要预先在 AndroidManifest.xml 中注册一个用来占坑的 Activity，以通过 AMS 的校验。
然后用插件 Activity 代替占坑 Activity。具体为：
1. 首先在宿主 apk 的 AndroidManifest.xml 中注册占坑 Activity。（插件 Activity 不在宿主 apk 中，所以无法注册）
2. 由于插件 Activity 没有注册，所以启动插件 Activity 时无法通过 AMS 校验。
   此时，需要通过反射获取到单例的原 IActivityManager，然后再使用动态代理生成一个代理 IActivityManager。 
   代理原 IActivityManager 的 startActivity 方法，
   在 startActivity 方法中将启动的未注册的插件 Activity 替换成占坑 Activity，以通过 AMS 的校验
3. 当 AMS 通知 app 启动占坑 Activity 时，在 app 的 ActivityThread 中会通过 H 类发送 LAUNCH_ACTIVITY 消息。
   由于 Handler 在处理消息时优先调用 mCallback 的 handleMessage 方法，
   所以可以通过反射获取到 ActivityThread.H，为其设置我们自定义的 Callback，
   在 Callback 的 handleMessage 中就可以 Hook 到 LAUNCH_ACTIVITY 消息，
   然后将 AMS 要求我们启动的占坑 Activity 再还原成插件 Activity。
于是，实现了插件 Activity 的启动。
</code></pre></div></li><li><p>通过 <code>Hook</code> <code>Instrumentation</code> 实现</p><div class="language-text ext-text"><pre class="language-text"><code>Hook Instrumentation 与 Hook IActivityManager 区别只是替换插件 Activity 和还原插件 Activity 的地方不同：
1. 在 Instrumentation 的 execStartActivity 方法中将启动的插件 Activity 替换成占坑 Activity，以通过 AMS 校验
2. 在 Instrumentation 的 newActivity 方法中还原插件 Activity
</code></pre></div></li></ol><h2 id="_9-热修复和-sophix-热更新框架" tabindex="-1"><a class="header-anchor" href="#_9-热修复和-sophix-热更新框架" aria-hidden="true">#</a> 9. 热修复和 <code>Sophix</code> 热更新框架</h2><p>热修复框架的核心技术分三类：</p><ol><li>代码修复</li><li>资源修复</li><li>动态链接库修复</li></ol><h3 id="_9-1-资源修复" tabindex="-1"><a class="header-anchor" href="#_9-1-资源修复" aria-hidden="true">#</a> 9.1 资源修复</h3><h4 id="_9-1-1-instant-run" tabindex="-1"><a class="header-anchor" href="#_9-1-1-instant-run" aria-hidden="true">#</a> 9.1.1 <code>Instant Run</code></h4><p>传统的编译部署需要重新安装 <code>App</code> 和重启 <code>App</code>。</p><p>而采用 <code>Instant Run</code> 可以避免这一情况。<code>Instant Run</code> 的构建和部署是基于更改的部分的。</p><p><code>Instant Run</code> 的部署有三种方式：</p><ol><li><p><code>Hot Swap</code></p><div class="language-text ext-text"><pre class="language-text"><code>该方式不需要重启 App，也不需要重启当前的 Activity
使用场景：修改一个现有的方法中的代码
</code></pre></div></li><li><p><code>Warm Swap</code></p><div class="language-text ext-text"><pre class="language-text"><code>该方式不需要重启 App，但需要重启当前的 Activity
使用场景：修改或删除一个现有的资源文件
</code></pre></div></li><li><p><code>Cold Swap</code></p><div class="language-text ext-text"><pre class="language-text"><code>该方式需要重启 App，但不需要重新安装 App
使用场景：添加、删除、修改一个字段或方法；添加一个类等。
</code></pre></div></li></ol><blockquote><p>无论采用哪种方式，<code>Instant Run</code> 都不需要重新安装 <code>App</code></p></blockquote><h4 id="_9-1-2-instant-run-的资源修复" tabindex="-1"><a class="header-anchor" href="#_9-1-2-instant-run-的资源修复" aria-hidden="true">#</a> 9.1.2 <code>Instant Run</code> 的资源修复</h4><p><code>Instant Run</code> 的资源热修复原理就是：</p><ol><li>通过反射创建一个新的 <code>AssetManager</code> 对象 <code>newAssetManager</code></li><li>通过反射调用 <code>newAssetManager</code> 对象中的 <code>addAssetPath</code> 方法，并传入修复后的资源路径</li><li>通过反射获取 <code>ResourcesImpl</code> 对象中的成员变量 <code>mAssets</code></li><li>通过反射将 <code>mAssets</code> 设置成传入了修复后的资源路径的 <code>newAssetManager</code> 对象。</li></ol><h3 id="_9-2-代码修复" tabindex="-1"><a class="header-anchor" href="#_9-2-代码修复" aria-hidden="true">#</a> 9.2 代码修复</h3><p>代码修复有三个方案：</p><ol><li>底层替换方案</li><li>类加载方案</li><li><code>Instant Run</code> 方案</li></ol><h4 id="_9-2-1-类加载方案" tabindex="-1"><a class="header-anchor" href="#_9-2-1-类加载方案" aria-hidden="true">#</a> 9.2.1 类加载方案</h4><p>类加载方案是基于 <code>Dex</code> 分包方案的。</p><p><code>Dex</code> 分包方案主要做的是：</p><ol><li>在打包时将应用代码分成多个 <code>dex</code> 文件</li><li>将应用启动时必须用到的类和这些类的直接引用类放到主 <code>dex</code> 文件中</li><li>将其他代码放到次 <code>dex</code> 文件中</li><li>当应用启动时先加载主 <code>dex</code> 文件，等到应用启动后再动态地加载次 <code>dex</code> 文件。</li></ol><p>在 <code>ClassLoader</code> 的类加载过程中，会调用到 <code>DexPathList</code> 的 <code>findClass</code> 方法：</p><div class="language-java ext-java"><pre class="language-java"><code><span class="token comment">/* libcore/dalvik/src/main/java/dalvik/system/DexPathList.java */</span>

<span class="token comment">/*
    其中 dexElements 数组表示 dex 文件的数组，即一个 Element 表示一个 dex 文件
    类加载方案进行代码修复的原理就是：
    将修复后的 class 文件打包到 Patch.dex 中，将 Patch.dex 放在 dexElements 数组的第一个 Element 元素中。
    使得在调用 findClass 方法时，优先从 Patch.dex 中获取修复后的 class。

    类加载方案的缺点是：需要重启 App 才能生效。因为只有重启 App 才能重新进行类加载过程。
*/</span>
<span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">DexPathList</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">private</span> <span class="token class-name">Element</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dexElements<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">public</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">findClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Throwable</span><span class="token punctuation">&gt;</span></span> suppressed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Element</span> element <span class="token operator">:</span> dexElements<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> clazz <span class="token operator">=</span> element<span class="token punctuation">.</span><span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> definingContext<span class="token punctuation">,</span> suppressed<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>clazz <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> clazz<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="_9-2-2-底层替换方案" tabindex="-1"><a class="header-anchor" href="#_9-2-2-底层替换方案" aria-hidden="true">#</a> 9.2.2 底层替换方案</h4><p>底层替换方案不会加载新的 <code>class</code> 文件，而是直接在 <code>Native</code> 层中修改原有类。</p><p>在 <code>Native</code> 层对原有类进行修改的限制比较多，如：不能增减原有类的方法和字段，否则已建立好的索引会失效，导致方法和字段无法正常访问。</p><div class="language-java ext-java"><pre class="language-java"><code><span class="token comment">/* libcore/ojluni/src/main/java/java/lang/reflect/Method.java */</span>
<span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> 
        <span class="token keyword">throws</span> <span class="token class-name">IllegalAccessException</span><span class="token punctuation">,</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">,</span> <span class="token class-name">InvocationTargetException</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* art/runtime/native/java_lang_reflect_Method.cc */</span>
<span class="token keyword">static</span> jobject <span class="token function">Method_invoke</span><span class="token punctuation">(</span>JNIEnv<span class="token operator">*</span> env<span class="token punctuation">,</span> jobject javaMethod<span class="token punctuation">,</span> jobject javaReceiver<span class="token punctuation">,</span> jobject javaArgs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ScopedFastNativeObjectAccess <span class="token function">soa</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">InvokeMethod</span><span class="token punctuation">(</span>soa<span class="token punctuation">,</span> javaMethod<span class="token punctuation">,</span> javaReceiver<span class="token punctuation">,</span> javaArgs<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token comment">/* art/runtime/reflection.cc */</span>
jobject <span class="token function">InvokeMethod</span><span class="token punctuation">(</span><span class="token keyword">const</span> ScopedObjectAccessAlreadyRunnable<span class="token operator">&amp;</span> soa<span class="token punctuation">,</span> jobject javaMethod<span class="token punctuation">,</span> 
        jobject javaReceiver<span class="token punctuation">,</span> jobject javaArgs<span class="token punctuation">,</span> size_t num_frames<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    ObjPtr<span class="token operator">&lt;</span>mirror<span class="token double-colon punctuation">::</span>Executable<span class="token operator">&gt;</span> executable <span class="token operator">=</span> soa<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">Decode</span><span class="token generic class-name"><span class="token operator">&lt;</span>mirror<span class="token double-colon punctuation">::</span>Executable<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>javaMethod<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">bool</span> accessible <span class="token operator">=</span> executable<span class="token operator">-&gt;</span><span class="token function">IsAccessible</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ArtMethod<span class="token operator">*</span> m <span class="token operator">=</span> executable<span class="token operator">-&gt;</span><span class="token function">GetArtMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-cpp ext-cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">ArtMethod</span> FINAL <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    GcRoot<span class="token operator">&lt;</span>mirror<span class="token double-colon punctuation">::</span>Class<span class="token operator">&gt;</span> declaring_class_<span class="token punctuation">;</span>

    std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span><span class="token keyword">uint32_t</span><span class="token operator">&gt;</span> access_flags_<span class="token punctuation">;</span>

    <span class="token keyword">uint32_t</span> dex_code_item_offset_<span class="token punctuation">;</span>

    <span class="token keyword">uint32_t</span> dex_method_index_<span class="token punctuation">;</span>

    <span class="token keyword">uint16_t</span> method_index_<span class="token punctuation">;</span>

    <span class="token keyword">uint16_t</span> hotness_count_<span class="token punctuation">;</span>

    <span class="token keyword">struct</span> <span class="token class-name">PtrSizedFields</span> <span class="token punctuation">{</span>
        ArtMethod<span class="token operator">*</span><span class="token operator">*</span> dex_cache_resolved_methods_<span class="token punctuation">;</span>
        <span class="token keyword">void</span><span class="token operator">*</span> data_<span class="token punctuation">;</span>
        <span class="token keyword">void</span><span class="token operator">*</span> entry_point_from_quick_compiled_code_<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> ptr_sized_fields_<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><p>底层替换方案和反射的原理有关联。</p><p>以反射调用方法为例：</p><ol><li>通过反射调用方法时会使用到如上的 <code>Method.java</code> 中的 <code>native</code> 方法 <code>invoke</code></li><li><code>invoke</code> 方法在 <code>Native</code> 层中的实现跟 <code>ArtMethod</code> 类有关</li><li><code>ArtMethod</code> 类中的结构体 <code>PtrSizedFields</code> 封装了 <code>invoke</code> 所要反射调用的方法的执行入口</li></ol><p>底层替换原理就是通过修改 <code>ArtMethod</code> 对象，让其中的结构体成员 <code>PtrSizedFields</code> 保存修复后的方法的执行入口。</p><p>阿里提供的 <code>AndFix</code>、<code>Sophix</code> 热修复框架就是采用了底层替换方案。</p><h2 id="_10-mvc-mvp-mvvm-模式" tabindex="-1"><a class="header-anchor" href="#_10-mvc-mvp-mvvm-模式" aria-hidden="true">#</a> 10. <code>MVC</code>/<code>MVP</code>/<code>MVVM</code> 模式</h2><h3 id="_10-3-mvvm-架构" tabindex="-1"><a class="header-anchor" href="#_10-3-mvvm-架构" aria-hidden="true">#</a> 10.3 MVVM 架构</h3><p>MVVM 是 Model-View-ViewModel 的缩写</p><p>MVVM 架构需要用到：</p><ol><li><p>ViewModel：ViewModel 负责保存数据（Model），并处理数据和界面（View）之间的业务逻辑。对 UI 界面所需的数据负责，让视图和数据进行分离。</p></li><li><p>DataBinding：使用 DataBinding 可以省去 findViewById，并让布局文件中的控件直接与数据绑定，即使得部分与 UI 控件相关的代码可以在布局文件中完成。</p></li><li><p>LiveData：LiveData 基于观察者模式，使用 LiveData + ViewModel 可以更好的实现数据（Model）和界面（View）之间的解耦</p></li><li><p>Room：一个 ORM（对象关系映射） 数据库，可以搭配 LiveData 使用。</p></li></ol><h2 id="_11-事件分发和滑动冲突" tabindex="-1"><a class="header-anchor" href="#_11-事件分发和滑动冲突" aria-hidden="true">#</a> 11. 事件分发和滑动冲突</h2><p>传递 <code>ACTION_DOWN</code> 事件就相当于在传递锚点，即 <code>ACTION_DOWN</code> 事件能传到哪个子控件，后续的 <code>MOVE</code>、<code>UP</code> 事件默认就能传到哪个子控件。</p><p>但可以通过调用 <code>dispatchTouchEvent</code> 方法阻止事件向下传递，也可以通过调用 <code>onInterceptTouchEvent</code> 方法阻止事件向下传递，</p><p>不过 <code>onInterceptTouchEvent</code> 方法阻止事件向下传递后，当前控件的 <code>onTouchEvent</code> 还能收到事件。而 <code>dispatchTouchEvent</code> 方法阻止事件向下传递后，当前控件的 <code>onTouchEvent</code> 就无法收到了。</p><blockquote><p>如果仅仅要阻止 <code>DOWN</code> 事件向上回传，那么在 <code>onTouchEvent</code> 中返回 <code>true</code>，消费掉事件即可。</p></blockquote><p>在 <code>onInterceptTouchEvent</code> 中拦截 <code>MOVE</code> 事件，可以让 <code>MOVE</code> 事件到不了 <code>ACTION_DOWN</code> 事件所锚定的那个子控件中。 但拦截 <code>MOVE</code> 事件的当前父控件却可以一直接收到后续的 <code>MOVE</code> 事件。</p><p>不过，也可以在子控件中调用父控件对象的 <code>requestDisallowInterceptTouchEvent(true)</code> 方法，请求父控件不要拦截 <code>MOVE</code> 事件。 从而让 <code>MOVE</code> 事件还是继续向下传到子控件中</p><blockquote><p>注意：只有 <code>DOWN</code> 事件才可以通过 <code>onTouchEvent</code> 向上回传，传递到消费掉 <code>DOWN</code> 事件的控件为止（或直接回传到 <code>DecorView</code>）</p><p>谁消费掉 <code>DOWN</code> 事件，谁就是锚点控件，于是 <code>MOVE</code> 事件就能向下传到锚点控件。但是：<code>MOVE</code> 事件是不会向上通过 <code>onTouchEvent</code> 回传的。即只有那个消费了 <code>DOWN</code> 事件的控件才有可能在执行 <code>onTouchEvent</code> 时收到 <code>MOVE</code> 事件。</p><p>如果 <code>MOVE</code> 事件被拦截了，那么后续的 <code>MOVE</code> 事件只会在当前执行拦截的控件中的 <code>onTouchEvent</code> 中收到</p></blockquote><p>处理滑动冲突时，主要用到两个方法：</p><ol><li><p>重写父控件的 <code>onInterceptTouchEvent</code> 方法，拦截会产生冲突的事件向下传给子控件，于是在一次事件序列中的事件都不会传给子控件了。</p></li><li><p>在子控件中调用 <code>requestDisallowInterceptTouchEvent(true)</code> 方法，请求父控件不要拦截事件，于是在一次事件序列中的事件都会传给子控件。</p><div class="language-text ext-text"><pre class="language-text"><code>子控件中调用父控件的 requestDisallowInterceptTouchEvent(true) 方法，请求父控件不要拦截 MOVE 事件时，需要满足以下条件：
1. 子控件必须得先接收并消费掉 DOWN 事件。
2. 父控件只能在重写的 onInterceptTouchEvent 方法中拦截 MOVE 事件
3. requestDisallowInterceptTouchEvent(true) 生效时，父控件的 onInterceptTouchEvent 方法就不会执行了。
   （于是，在父控件的 onInterceptTouchEvent 方法中拦截 MOVE 事件的代码就无效了） 
</code></pre></div></li></ol><blockquote><p>注意：在一次事件序列中，只要父控件把 <code>MOVE</code> 事件给拦截了，那么子控件在 <strong>本次事件序列中</strong> 就再也无法收到后续的 <code>MOVE</code> 事件了。</p></blockquote><p>常见的滑动冲突场景有：</p><ol><li><p>外层与内层的滑动方向不一致</p><div class="language-text ext-text"><pre class="language-text"><code>如外层 ViewPager 左右滑动；内层 RecyclerView 上下滑动

思路：判断滑动方向以决定事件交给谁处理
    对滑动前后两个点的连线分解成水平分量 dx 和垂直分量 dy，
    若 dx &gt; dy 则为左右滑动，此时交给外层 ViewPager 处理
    若 dx &lt; dy 则为上下滑动，此时交给内层 RecyclerView 处理
</code></pre></div></li><li><p>外层与内层的滑动方向一致</p><div class="language-text ext-text"><pre class="language-text"><code>如外层 ViewPager 左右滑动；内层 RecyclerView 左右滑动
思路：根据业务需求，对外层 ViewPager 重写 onInterceptTouchEvent，
    对内层 RecyclerView 调用父控件 ViewPager 的 requestDisallowInterceptTouchEvent(true)，
    即在适当的时候通过父控件拦截事件，以及子控件请求父控件不要拦截事件，以决定滑动哪个控件
</code></pre></div></li></ol><p>滑动冲突的解决方法：</p><ol><li><p>外部拦截法</p><div class="language-text ext-text"><pre class="language-text"><code>就是重写父控件的 onInterceptTouchEvent 方法，由父控件决定什么情况下拦截事件，什么情况下才可以将事件向下传递子控件。
通常 DOWN 事件需要传给子控件，不能拦截，否则一次事件序列中的后续事件子控件都无法接收到。并且 UP、CANCEL 事件也不会拦截。
重写 onInterceptTouchEvent 方法，主要就是对 MOVE 事件进行拦截以解决滑动冲突
</code></pre></div></li><li><p>内部拦截法</p><div class="language-text ext-text"><pre class="language-text"><code>内部拦截法就是不需要考虑父控件在重写的 onInterceptTouchEvent 方法中什么时候会拦截事件。
而是通过在子控件中调用父控件的 requestDisallowInterceptTouchEvent(true) 方法，
由子控件自己决定在什么时候向父控件请求不要拦截事件，
只要子控件请求了不拦截事件，那么父控件就不会调用 onInterceptTouchEvent 方法来拦截事件了。
</code></pre></div></li></ol><h2 id="_12-嵌套滑动" tabindex="-1"><a class="header-anchor" href="#_12-嵌套滑动" aria-hidden="true">#</a> 12. 嵌套滑动</h2><h2 id="_13-常见设计模式" tabindex="-1"><a class="header-anchor" href="#_13-常见设计模式" aria-hidden="true">#</a> 13. 常见设计模式</h2><h3 id="_13-1-单例模式" tabindex="-1"><a class="header-anchor" href="#_13-1-单例模式" aria-hidden="true">#</a> 13.1 单例模式</h3><h4 id="_13-1-1-双重检查" tabindex="-1"><a class="header-anchor" href="#_13-1-1-双重检查" aria-hidden="true">#</a> 13.1.1 双重检查</h4><div class="language-java ext-java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token comment">/*
        volatile 的作用：
        1. 禁止重排序
        2. 保证可见性
    */</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token comment">/*
        外层if是为了提高效率，即当 instance != null 时，直接返回
        内层if是为了保证线程安全，即当多个线程都进入了外层if时，那么由于synchronized关键字的存在，保证了内层if语句的原子性
    */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="_13-1-2-静态内部类" tabindex="-1"><a class="header-anchor" href="#_13-1-2-静态内部类" aria-hidden="true">#</a> 13.1.2 静态内部类</h4><div class="language-java ext-java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton7</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token class-name">Singleton7</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonInstance</span> <span class="token punctuation">{</span>

        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Singleton7</span> <span class="token constant">INSTANCE</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton7</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton7</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">SingletonInstance</span><span class="token punctuation">.</span><span class="token constant">INSTANCE</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_13-2-外观模式" tabindex="-1"><a class="header-anchor" href="#_13-2-外观模式" aria-hidden="true">#</a> 13.2 外观模式</h3><p>外观模式就是统一接口封装。将子系统（如可以将第三方 SDK 作为一个子系统）的逻辑、交互隐藏起来，为用户提供一个高层次的接口，使得子系统的更加易用。</p><p>同时也对外隐藏了具体实现，这样即使子系统发生了变化，使用高层次接口的用户也不会感知到。</p><h3 id="_13-3-享元模式" tabindex="-1"><a class="header-anchor" href="#_13-3-享元模式" aria-hidden="true">#</a> 13.3 享元模式</h3><p>享元模式用来尽可能减少内存的使用量。享元模式适用于可能存在大量重复对象的场景。</p><p>享元模式就是指对可共享的对象进行缓存，达到对象共享、避免创建过多对象的效果。从而提升性能，避免内存溢出。</p><p>对象池的实现就是采用了享元模式。（如 <code>Handler</code> 消息机制中的 <code>Message</code> 就使用了对象池）</p><h3 id="_13-4-工厂模式" tabindex="-1"><a class="header-anchor" href="#_13-4-工厂模式" aria-hidden="true">#</a> 13.4 工厂模式</h3><p>工厂模式可分为：工厂方法模式、抽象工厂模式。</p><p>工厂方法模式就是定义一个用于创建对象的工厂接口，由工厂接口的具体实现来决定创建哪个类的对象。</p><p>如果工厂接口的具体实现有多个，就称为 <strong>多工厂方法模式</strong> （或 <strong>工厂方法模式</strong>）。</p><blockquote><p>一般地，工厂方法模式下，一个具体的工厂只为一个类创建对象</p></blockquote><p>如果工厂接口的具体实现只有一个，就称为 <strong>简单工厂模式</strong>（或 <strong>静态工厂模式</strong>）</p><blockquote><p>一般地，简单工厂模式下，一个具体的工厂可以为不同的类创建对象</p><p>工厂接口的具体实现只有一个，并不代表这个具体实现只能为一个类创建对象。</p><p>可以将不同类的 <code>Class</code> 对象传给这个具体实现，于是具体实现就可以根据不同的 <code>Class</code> 对象通过反射创建出不同类的对象。</p></blockquote><p>工厂方法模式就是一个工厂接口只提供一个接口方法用于创建一个对象。</p><p><strong>抽象工厂模式</strong> 就是一个工厂接口提供多个接口方法用于创建多个对象。</p><blockquote><p>一般地，由一个工厂接口提供多个接口方法所创建的多个对象应该是一组相关的对象。</p><p>如一个生产汽车的工厂接口，提供多个接口方法用于创建轮胎、发动机、制动系统等一组与汽车相关的对象。</p></blockquote><h3 id="_13-5-建造者模式-builder-模式" tabindex="-1"><a class="header-anchor" href="#_13-5-建造者模式-builder-模式" aria-hidden="true">#</a> 13.5 建造者模式（<code>Builder</code> 模式）</h3><p>通过建造者模式，可以一步一步地创建出一个复杂对象。</p><p>当初始化一个对象特别复杂，需要的参数特别多，且很多参数都具有默认值时，可以考虑使用建造者模式。</p><p>通过建造者模式可以将参数的设置和对象的初始化过程分离开来。</p><p>并且，通过建造者模式来设置参数时可以采用调用链的形式实现，使得代码更简洁易懂。</p><h2 id="_14-常见算法题" tabindex="-1"><a class="header-anchor" href="#_14-常见算法题" aria-hidden="true">#</a> 14. 常见算法题</h2><h3 id="_14-1-生产者消费者" tabindex="-1"><a class="header-anchor" href="#_14-1-生产者消费者" aria-hidden="true">#</a> 14.1 生产者消费者</h3><h3 id="_14-2-交替打印-0-100" tabindex="-1"><a class="header-anchor" href="#_14-2-交替打印-0-100" aria-hidden="true">#</a> 14.2 交替打印 <code>0-100</code></h3><p>通过 <code>wait</code> 和 <code>notify</code> 实现</p><div class="language-java ext-java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Print</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PrintTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;偶数&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 保证偶数 0 先打印</span>

        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PrintTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;奇数&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">PrintTask</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span> 
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>count <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">synchronized</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>

                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currrentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;:&quot;</span> <span class="token operator">+</span> count<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                    lock<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                    <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 打印完最后一个数 100 后就不需要等待了</span>
                        <span class="token keyword">try</span> <span class="token punctuation">{</span>
                            lock<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
                        <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><h3 id="_14-2-死锁" tabindex="-1"><a class="header-anchor" href="#_14-2-死锁" aria-hidden="true">#</a> 14.2 死锁</h3><h3 id="_14-3-冒泡排序和选择排序" tabindex="-1"><a class="header-anchor" href="#_14-3-冒泡排序和选择排序" aria-hidden="true">#</a> 14.3 冒泡排序和选择排序</h3><p>当从小到大排列时，冒泡排序就是先将最大的排在后面。</p><div class="language-java ext-java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>

    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 控制比较轮次，一共 n-1 趟</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//控制两个挨着的元素进行比较</span>
        
            <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当从小到大排列时，选择排序就是先选择最小的排在前面</p><div class="language-java ext-java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>

    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 控制比较轮次，一共 n-1 趟</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//控制两个挨着的元素进行比较</span>
        
            <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_14-4-字符串反转" tabindex="-1"><a class="header-anchor" href="#_14-4-字符串反转" aria-hidden="true">#</a> 14.4 字符串反转</h3><div class="language-java ext-java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reverseString</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">;</span> <span class="token operator">++</span>left<span class="token punctuation">,</span> <span class="token operator">--</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">char</span> tmp <span class="token operator">=</span> s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>
            s<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>
            s<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_15-sql-语句" tabindex="-1"><a class="header-anchor" href="#_15-sql-语句" aria-hidden="true">#</a> 15. <code>SQL</code> 语句</h2><h3 id="_15-1-创建表" tabindex="-1"><a class="header-anchor" href="#_15-1-创建表" aria-hidden="true">#</a> 15.1 创建表</h3><div class="language-sql ext-sql"><pre class="language-sql"><code><span class="token keyword">create</span> <span class="token keyword">table</span> exams<span class="token punctuation">(</span>
    id <span class="token keyword">int</span> <span class="token keyword">primary</span> <span class="token keyword">key</span> <span class="token keyword">auto_increment</span><span class="token punctuation">,</span>
    name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    chinese <span class="token keyword">double</span><span class="token punctuation">,</span>
    math <span class="token keyword">double</span><span class="token punctuation">,</span>
    english <span class="token keyword">double</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="_15-2-insert-语句" tabindex="-1"><a class="header-anchor" href="#_15-2-insert-语句" aria-hidden="true">#</a> 15.2 <code>insert</code> 语句</h3><div class="language-sql ext-sql"><pre class="language-sql"><code><span class="token comment">-- 只写部分字段</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> exams<span class="token punctuation">(</span>id<span class="token punctuation">,</span> name<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">&#39;jack&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">-- 所有字段都要写</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> exams <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">&#39;john&#39;</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">,</span> <span class="token number">70</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="_15-3-update-语句" tabindex="-1"><a class="header-anchor" href="#_15-3-update-语句" aria-hidden="true">#</a> 15.3 <code>update</code> 语句</h3><div class="language-sql ext-sql"><pre class="language-sql"><code><span class="token comment">-- 将 exams 表中所有记录的 chinese 字段的值都修改为 100</span>
<span class="token keyword">update</span> exams <span class="token keyword">set</span> chinese<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span>

<span class="token comment">-- 更新 where 从句指定的某些记录的某些字段</span>
<span class="token keyword">update</span> exams <span class="token keyword">set</span> chinese<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">,</span> math<span class="token operator">=</span><span class="token string">&#39;100&#39;</span> <span class="token keyword">where</span> name<span class="token operator">=</span><span class="token string">&#39;jack&#39;</span><span class="token punctuation">;</span>

<span class="token comment">-- 在原字段值的基础上更新</span>
<span class="token keyword">update</span> exams <span class="token keyword">set</span> chinese<span class="token operator">=</span>chinese<span class="token operator">+</span><span class="token number">20</span> <span class="token keyword">where</span> name<span class="token operator">=</span><span class="token string">&#39;jack&#39;</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="_15-4-delete-语句" tabindex="-1"><a class="header-anchor" href="#_15-4-delete-语句" aria-hidden="true">#</a> 15.4 <code>delete</code> 语句</h3><div class="language-sql ext-sql"><pre class="language-sql"><code><span class="token comment">-- 删除表中的所有记录</span>
<span class="token keyword">delete</span> <span class="token keyword">from</span> exams<span class="token punctuation">;</span>

<span class="token comment">-- 删除 where 从句指定的某条/某些记录</span>
<span class="token keyword">delete</span> <span class="token keyword">from</span> exams <span class="token keyword">where</span> name<span class="token operator">=</span><span class="token string">&#39;jack&#39;</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="_15-5-select-语句" tabindex="-1"><a class="header-anchor" href="#_15-5-select-语句" aria-hidden="true">#</a> 15.5 <code>select</code> 语句</h3><div class="language-sql ext-sql"><pre class="language-sql"><code><span class="token comment">-- 查询表中所有记录的所有字段</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> exams<span class="token punctuation">;</span>

<span class="token comment">-- 查询表中所有记录的 id 和 name 字段</span>
<span class="token keyword">select</span> id<span class="token punctuation">,</span> name <span class="token keyword">from</span> exams<span class="token punctuation">;</span>

<span class="token comment">-- 去除某个字段值相同的重复记录</span>
<span class="token keyword">select</span> <span class="token keyword">distinct</span> chinese <span class="token keyword">from</span> exams<span class="token punctuation">;</span>

<span class="token comment">-- as 起别名</span>
<span class="token keyword">select</span> name<span class="token punctuation">,</span> chinese<span class="token operator">+</span>math<span class="token operator">+</span>english <span class="token keyword">from</span> exams<span class="token punctuation">;</span>
<span class="token keyword">select</span> name<span class="token punctuation">,</span> chinese<span class="token operator">+</span>math<span class="token operator">+</span>english <span class="token keyword">as</span> 总分 <span class="token keyword">from</span> exams<span class="token punctuation">;</span>

<span class="token comment">-- where 从句进行过滤查询</span>

<span class="token comment">-- 只查询字段 name 的值为 jack 的这些记录的所有字段</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> exams <span class="token keyword">where</span> name<span class="token operator">=</span><span class="token string">&#39;jack&#39;</span><span class="token punctuation">;</span>

<span class="token comment">-- 只查询字段 english 的值大于 90 的这些记录的所有字段</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> exams <span class="token keyword">where</span> english<span class="token operator">&gt;</span><span class="token number">90</span><span class="token punctuation">;</span>

<span class="token comment">-- 只查询字段 english 的值大于等于80，且小于等于 90 的这些记录的所有字段</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> exams <span class="token keyword">where</span> english<span class="token operator">&gt;=</span><span class="token number">80</span> <span class="token operator">and</span> english<span class="token operator">&lt;=</span><span class="token number">90</span><span class="token punctuation">;</span>

<span class="token comment">-- 只查询字段 english 的值为 60 或 90 或 100 的这些记录的所有字段</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> exams <span class="token keyword">where</span> english <span class="token operator">in</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">-- 只查询字段 name 的值为 j 开头的这些记录的所有字段。（&#39;%&#39; 匹配多个字符；&#39;_&#39; 匹配一个字符）</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> exams <span class="token keyword">where</span> name <span class="token operator">like</span> <span class="token string">&#39;j%&#39;</span><span class="token punctuation">;</span>

<span class="token comment">-- 查询字段 name 的值为 j 开头的这些记录的所有字段，并将查询到的记录按总成绩降序排列。（desc 降序，asc 升序）</span>
<span class="token comment">-- 注意：order by 子句总是在 select 语句最后。</span>
selct <span class="token operator">*</span> <span class="token keyword">from</span> exams <span class="token keyword">where</span> name <span class="token operator">like</span> <span class="token string">&#39;j%&#39;</span> <span class="token keyword">order</span> <span class="token keyword">by</span> chinese<span class="token operator">+</span>math<span class="token operator">+</span>english <span class="token keyword">desc</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="_16-项目中遇到的难点" tabindex="-1"><a class="header-anchor" href="#_16-项目中遇到的难点" aria-hidden="true">#</a> 16. 项目中遇到的难点</h2><h3 id="_16-1-直播界面退出后延迟-10s-左右才回调-ondestroy" tabindex="-1"><a class="header-anchor" href="#_16-1-直播界面退出后延迟-10s-左右才回调-ondestroy" aria-hidden="true">#</a> 16.1 直播界面退出后延迟 <code>10s</code> 左右才回调 <code>onDestroy</code></h3><p>这个问题所引发的现象是：在当前直播间中的聊天室内可以看到之前进入过的直播间中的聊天内容。</p><p>导致这个问题的直接原因是：在进入当前直播间时，上一个直播间的聊天室还未销毁掉，也就是上一个直播间界面的 Activity 的 onDestroy 方法还未执行。</p><p>其根本原因是在退出上一个直播间进入直播首页时，直播首页在 onResume 时就立即开始了不停地绘制表示正在直播的动画，导致 UI 线程无法空闲下来，app 进程没有机会通知 AMS 执行上一个界面的 onDestroy 方法。</p><p>而 AMS 为了避免 app 进程不通知自己去销毁上一个界面，会设置一个 10s 的超时时间，于是 10s 后即使 app 进程没有发通知过来，AMS 也会主动到告诉 app 进程去销毁上一个 Activity 界面。</p><p>解决这个问题的办法就是将刷新动画的 invalidate() 方法替换成 postInvalidateDelayed(10) 方法，即每间隔 10ms 刷新一次动画。让 app 进程可以空闲下来接收 AMS 的通知。</p><h3 id="_16-2-健康检测中的人脸识别" tabindex="-1"><a class="header-anchor" href="#_16-2-健康检测中的人脸识别" aria-hidden="true">#</a> 16.2 健康检测中的人脸识别</h3><p>健康检测中需要给集成的 SDK 提供一张包含人脸的图片，但由于手机拍出的照片很大，所以需要对照片进行裁剪。</p><p>裁剪时为保证能够将包含人脸的区域裁剪出来，所以需要在拍照的时候实时地检测人脸是否在裁剪区域内。</p><p>Android 系统提供的 Camera2 相关的 API 是支持人脸识别功能的：</p><ol><li><p>首先需要获取 CameraCharacteristics，查询摄像头特质中支持的人脸检测模式。如果摄像头不支持人脸识别那么就查询不到任何人脸检测模式</p></li><li><p>当获取到了人脸检测模式后，在调用 CameraDevice.createCaptureSession 方法开启预览时将支持的人脸检测模式设置到 CaptureRequest 中</p></li><li><p>在预览过程中就会不断地回调 CameraCaptureSession.CaptureCallback 中的 onCaptureCompleted 方法。通过该方法传入的参数 TotalCaptureResult 就能获取到在预览过程中人脸所在区域的实时范围。</p></li></ol><h3 id="_16-3-上下切换直播间和上下滑动聊天记录的滑动冲突" tabindex="-1"><a class="header-anchor" href="#_16-3-上下切换直播间和上下滑动聊天记录的滑动冲突" aria-hidden="true">#</a> 16.3 上下切换直播间和上下滑动聊天记录的滑动冲突</h3><p>在一个 Activity 界面中通过 RecyclerView 实现了直播间的上下切换，一个直播间就是一个 RecyclerView 列表中的 item 视图。</p><p>在一个直播间中的又通过 RecyclerView 来显示聊天记录。</p><p>由于内外两个 RecyclerView 都是同方向滑动，所以在内层 RecyclerView 的区域内的上下滑动事件会被外层的 RecyclerView 拦截。</p><p>解决办法是调用外层 RecyclerView 的 addOnItemTouchListener 方法，重写 OnItemTouchListener 的 onInterceptTouchEvent 方法</p><p>在 onInterceptTouchEvent 中判断 MOVE 事件是否发生在内层 RecyclerView 的区域内。</p><p>如果事件在内层 RecyclerView 的区域内，就调用内层 RecyclerView 的 requestDisallowInterceptTouchEvent(true) 方法请求外层 RecyclerView 不要拦截事件。</p><blockquote><p>注意：requestDisallowInterceptTouchEvent(true) 方法设置的标记会向上传递给父控件。</p></blockquote><blockquote><p>注意：如果子控件消费掉了 DOWN 事件，那么后续的事件才会传递的到子控件中，而传递事件时是需要经过父控件的。</p><p>这就意味着只要父控件中有子控件消费掉了 DOWN 事件，那么这一次事件序列中的所有事件都会经过父控件，即父控件也可以接收到事件。（并且还能控制是否对后续的 MOVE 事件进行拦截，不让子控件接收到）&gt;</p></blockquote><h2 id="_17-hashmap-中的哈希冲突-也称哈希碰撞" tabindex="-1"><a class="header-anchor" href="#_17-hashmap-中的哈希冲突-也称哈希碰撞" aria-hidden="true">#</a> 17. <code>HashMap</code> 中的哈希冲突（也称哈希碰撞）</h2><p>当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的哈希冲突，也叫哈希碰撞。</p><p>哈希函数的设计至关重要，好的哈希函数会尽可能地保证计算简单和散列地址分布均匀,但是，我们需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。</p><p>那么哈希冲突如何解决呢？哈希冲突的解决方案有多种:</p><ol><li>开放地址法（发生冲突，继续寻找下一块未被占用的存储地址），</li><li>再散列函数法，</li><li>拉链法（链地址法），</li></ol><p>HashMap 即是采用了拉链法（链地址法），也就是数组+链表的方式，</p><p>简单来说，HashMap 由数组+链表组成的，数组是 HashMap 的主体，<strong>链表则是主要为了解决哈希冲突而存在的</strong>。</p><p>如果定位到的数组位置不含链表（当前 entry 的 next 指向 null）,那么对于查找，添加等操作很快，仅需一次寻址即可；</p><p>如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过 key 对象的 equals 方法逐一比对查找。所以，性能考虑，HashMap 中的链表出现越少，性能才会越好。</p><hr><p><strong><code>HashMap</code> 的数据结构</strong>：</p><p>数据结构中有数组和链表来实现对数据的存储，但这两者基本上是两个极端：</p><ol><li><p>数组的特点是：寻址容易，插入和删除困难；</p></li><li><p>链表的特点是：寻址困难，插入和删除容易。</p></li></ol><p>那么我们能不能综合两者的特性，做出一种 <strong>寻址容易，插入删除也容易</strong> 的数据结构？</p><p>答案是肯定的，这就是我们要提起的 <strong>哈希表（<code>Hash Table</code>）</strong>。</p><p>哈希表有多种不同的实现方法，我接下来解释的是最常用的一种方法：拉链法（链地址法）。</p><blockquote><p>拉链法（链地址法）可以理解为 “链表的数组”</p><p>即采用拉链法的哈希表是由数组+链表组成的</p></blockquote><p><img src="/assets/05.a83eea1a.png" alt="" loading="lazy"></p><blockquote><p>从上图我们可以发现哈希表是由数组+链表组成的，一个长度为16的数组中，<strong>每个元素存储的是一个链表的头结点</strong>。</p><p>那么这些元素是按照什么样的规则存储到数组中呢。一般情况是通过 <code>hash(key) % len</code> 获得，也就是数组元素的key的哈希值对数组长度取模，取模的结果就是元素在长度为 len 的数组中的索引。</p><p>也就是说对元素的 key 取哈希值（<code>hash(key)</code>）相同的元素都存放在同一个链表中</p><p>注意：在 JDK 1.8 中，当链表长度超过阈值（8）时，会将链表转换为红黑树</p></blockquote><p>HashMap 其实也是一个线性的数组实现的,所以可以理解为其存储数据的容器就是一个线性数组。这可能让我们很不解，一个线性的数组怎么实现按键值对来存取数据呢？这里 HashMap 有做一些处理：</p><div class="language-text ext-text"><pre class="language-text"><code>首先 HashMap 里面实现一个静态内部类Entry，其重要的属性有 key , value, next，
从属性 key,value 我们就能很明显的看出来 Entry 就是 HashMap 键值对实现的一个基础bean，
我们上面说到 HashMap 的基础就是一个线性数组，这个数组就是 Entry[]，Map 里面的内容都保存在 Entry[] 里面。
</code></pre></div><p>个人理解：</p><div class="language-text ext-text"><pre class="language-text"><code>Java 中的 HashMap 底层原理是采用哈希表的，哈希表就是数组 + 链表组成。
其中数组中存放链表的头结点，链表中存放对 key 取哈希值相同的元素。
链表的存在就是为了解决哈希冲突（也称哈希碰撞）。
哈希冲突就是对于一个固定大小的数组，对 key 取哈希值再与数组长度取模，以取模结果作为元素的索引时，
即使 key 不同，取模的结果也可能会相同，从而导致一个索引可能对应多个元素。
为了解决这个问题，在数组的一个索引处存放链表的头结点，将 hash(key) % len 结果相同的元素放在同一个链表中。
当根据 key 取 value 时，先根据 hash(key) % len 得到索引找到存放元素的链表，
再在链表中查找 hash(key) 和 key 相同的元素，然后从元素中取出 value。
</code></pre></div><h2 id="_18-android-新特性" tabindex="-1"><a class="header-anchor" href="#_18-android-新特性" aria-hidden="true">#</a> 18. Android 新特性</h2><blockquote><p>参考：<a href="/zkq/android/others/version-new-feature.html" class="">Android 版本新特性</a></p></blockquote><h2 id="_19-recyclerview-的回收复用" tabindex="-1"><a class="header-anchor" href="#_19-recyclerview-的回收复用" aria-hidden="true">#</a> 19. RecyclerView 的回收复用</h2><h2 id="_20-recyclerview-实现无限轮播" tabindex="-1"><a class="header-anchor" href="#_20-recyclerview-实现无限轮播" aria-hidden="true">#</a> 20. RecyclerView 实现无限轮播</h2><h2 id="_21-kotlin-协程" tabindex="-1"><a class="header-anchor" href="#_21-kotlin-协程" aria-hidden="true">#</a> 21. Kotlin 协程</h2><!--]--></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/zengkaiqiang562/JavaGuide/edit/main/docs/zkq/project-experiences/skill-keypoint.md" rel="noopener noreferrer" target="_blank" arialabel="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewbox="0 0 1024 1024" arialabelledby="edit"><title id="edit" lang="en">edit icon</title><g fill="currentColor"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></g></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item update-time"><span class="label">上次编辑于: </span><span class="info">2022/7/10 22:36:08</span></div><div class="meta-item contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: zengkaiqiang562@163.com">zengk</span><!--]--><!--]--></div></footer><!----><!----><!----></main><!--]--><footer class="footer-wrapper"><div class="footer"></div><div class="copyright">Copyright © 2023 Zenk562</div></footer></div><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app.625aa393.js" defer></script>
  </body>
</html>
